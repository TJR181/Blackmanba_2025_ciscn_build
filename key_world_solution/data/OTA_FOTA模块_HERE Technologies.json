[
  {
    "设备品牌": "",
    "设备类型": "OTA",
    "产品型号": "",
    "CVE编号": "CVE-2025-6087",
    "漏洞描述": "A Server-Side Request Forgery (SSRF) vulnerability was identified in the @opennextjs/cloudflare package. The vulnerability stems from an unimplemented feature in the Cloudflare adapter for Open Next, which allowed unauthenticated users to proxy arbitrary remote content via the /_next/image endpoint.\n\nThis issue allowed attackers to load remote resources from arbitrary hosts under the victim site’s domain for any site deployed using the Cloudflare adapter for Open Next. \n\n\n\n\nFor example:\n\n https://victim-site.com/_next/image?url=https://attacker.com \n\nIn this example, attacker-controlled content from attacker.com is served through the victim site’s domain (victim-site.com), violating the same-origin policy and potentially misleading users or other services.\n\n\n\n\nImpact:\n\n  *  SSRF via unrestricted remote URL loading\n\n\n\n\n  *  Arbitrary remote content loading\n\n\n\n\n  *  Potential internal service exposure or phishing risks through domain abuse\n\n\n\n\n\n\n\nMitigation:\n\nThe following mitigations have been put in place:\n\n  *  Server side updates to Cloudflare’s platform to restrict the content loaded via the /_next/image endpoint to images. The update automatically mitigates the issue for all existing and any future sites deployed to Cloudflare using the affected version of the Cloudflare adapter for Open Next\n\n\n\n\n  *   Root cause fix https://github.com/opennextjs/opennextjs-cloudflare/pull/727  to the Cloudflare adapter for Open Next. The patched version of the adapter is found here  @opennextjs/cloudflare@1.3.0 https://www.npmjs.com/package/@opennextjs/cloudflare/v/1.3.0 \n\n\n  *   Package dependency update https://github.com/cloudflare/workers-sdk/pull/9608  to create-cloudflare (c3) to use the fixed version of the Cloudflare adapter for Open Next. The patched version of create-cloudflare is found here:  create-cloudflare@2.49.3 https://www.npmjs.com/package/create-cloudflare/v/2.49.3 \n\n\n\n\nIn addition to the automatic mitigation deployed on Cloudflare’s platform, we encourage affected  users to upgrade to @opennext/cloudflare v1.3.0 and use the  remotePatterns  https://nextjs.org/docs/pages/api-reference/components/image#remotepatterns  filter in Next config https://nextjs.org/docs/pages/api-reference/components/image#remotepatterns  if they need to allow-list external urls with images assets.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/opennextjs/opennextjs-cloudflare"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2025年06月16日"
  },
  {
    "设备品牌": "TP-LINK Technologies",
    "设备类型": "OTA",
    "产品型号": "TL-IPC544EP-W4",
    "CVE编号": "CVE-2025-5875",
    "漏洞描述": "A vulnerability classified as critical has been found in TP-LINK Technologies TL-IPC544EP-W4 1.0.9 Build 240428 Rel 69493n. Affected is the function sub_69064 of the file /bin/main. The manipulation of the argument text leads to buffer overflow. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://locrian-lightning-dc7.notion.site/TL-IPC544EP-W4-1f98e5e2b1a280ae9862d49391d95651",
      "https://www.tp-link.cn/"
    ],
    "受影响版本": [
      "1.0.9 Build 240428 Rel 69493n"
    ],
    "公开日期": "2025年06月09日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "SecCenter SMP-E1114P02",
    "CVE编号": "CVE-2025-5162",
    "漏洞描述": "A vulnerability, which was classified as critical, has been found in H3C SecCenter SMP-E1114P02 up to 20250513. Affected by this issue is some unknown functionality of the file /safeEvent/importFile/. The manipulation of the argument logGeneralFile/logGeneralFile_2 leads to unrestricted upload. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://flowus.cn/share/ce6c4094-8d97-466c-8fcc-df3f3d6f314e?code=G8A6P3",
      "https://flowus.cn/share/d6c310ac-a179-499f-9e9a-5c0de80b19be?code=G8A6P3"
    ],
    "受影响版本": [
      "20250513"
    ],
    "公开日期": "2025年05月26日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "SecCenter SMP-E1114P02",
    "CVE编号": "CVE-2025-5161",
    "漏洞描述": "A vulnerability classified as problematic was found in H3C SecCenter SMP-E1114P02 up to 20250513. Affected by this vulnerability is the function operationDailyOut of the file /safeEvent/download. The manipulation of the argument filename leads to path traversal. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://flowus.cn/share/d78abd42-5de8-45f1-a941-a11a2581be0c?code=G8A6P3"
    ],
    "受影响版本": [
      "20250513"
    ],
    "公开日期": "2025年05月26日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "SecCenter SMP-E1114P02",
    "CVE编号": "CVE-2025-5160",
    "漏洞描述": "A vulnerability classified as problematic has been found in H3C SecCenter SMP-E1114P02 up to 20250513. Affected is the function Download of the file /packetCaptureStrategy/download. The manipulation of the argument Name leads to path traversal. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://flowus.cn/share/3cec9266-793a-498e-acdb-4296b09a8c89?code=G8A6P3"
    ],
    "受影响版本": [
      "20250513"
    ],
    "公开日期": "2025年05月26日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "SecCenter SMP-E1114P02",
    "CVE编号": "CVE-2025-5159",
    "漏洞描述": "A vulnerability was found in H3C SecCenter SMP-E1114P02 up to 20250513. It has been rated as problematic. This issue affects the function Download of the file /cfgFile/1/download. The manipulation of the argument Name leads to path traversal. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://flowus.cn/share/ce95a04b-24e3-477a-bc3d-8344ede95ea8?code=G8A6P3"
    ],
    "受影响版本": [
      "20250513"
    ],
    "公开日期": "2025年05月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "SecCenter SMP-E1114P02",
    "CVE编号": "CVE-2025-5158",
    "漏洞描述": "A vulnerability was found in H3C SecCenter SMP-E1114P02 up to 20250513. It has been declared as problematic. This vulnerability affects the function downloadSoftware of the file /cfgFile/downloadSoftware. The manipulation of the argument filename leads to path traversal. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://flowus.cn/share/a17e9654-f054-49d9-a3c1-3e37dc6c91cc?code=G8A6P3"
    ],
    "受影响版本": [
      "20250513"
    ],
    "公开日期": "2025年05月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "SecCenter SMP-E1114P02",
    "CVE编号": "CVE-2025-5157",
    "漏洞描述": "A vulnerability was found in H3C SecCenter SMP-E1114P02 up to 20250513. It has been classified as critical. This affects the function fileContent of the file /cfgFile/fileContent. The manipulation of the argument filePath leads to path traversal. It is possible to initiate the attack remotely. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://flowus.cn/share/f78256ea-f210-4b35-ba71-85aba82d3e0a?code=G8A6P3"
    ],
    "受影响版本": [
      "20250513"
    ],
    "公开日期": "2025年05月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "GR-5400AX",
    "CVE编号": "CVE-2025-5156",
    "漏洞描述": "A vulnerability was found in H3C GR-5400AX up to 100R008 and classified as critical. Affected by this issue is the function EditWlanMacList of the file /routing/goform/aspForm. The manipulation of the argument param leads to buffer overflow. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/CH13hh/tmp_store_cc/blob/main/H3C%20GB5400AX/6.md"
    ],
    "受影响版本": [
      "100R008"
    ],
    "公开日期": "2025年05月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic R200G",
    "CVE编号": "CVE-2025-4998",
    "漏洞描述": "A vulnerability has been found in H3C Magic R200G up to 100R002 and classified as problematic. Affected by this vulnerability is the function Edit_BasicSSID/Edit_BasicSSID_5G/SetAPWifiorLedInfoById/SetMobileAPInfoById/Asp_SetTimingtimeWifiAndLed/AddMacList/EditMacList/AddWlanMacList/EditWlanMacList of the file /goform/aspForm of the component HTTP POST Request Handler. The manipulation of the argument param leads to denial of service. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/CH13hh/tmp_store_cc/blob/main/H3C%20Magic%20R200G/1.md"
    ],
    "受影响版本": [
      "100R002"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "R2+ProG",
    "CVE编号": "CVE-2025-4997",
    "漏洞描述": "A vulnerability, which was classified as problematic, was found in H3C R2+ProG up to 200R004. Affected is the function UpdateWanParams/AddMacList/EditMacList/AddWlanMacList/EditWlanMacList/Edit_BasicSSID/Edit_GuestSSIDFor2P4G/Edit_BasicSSID_5G/SetAPInfoById of the file /goform/aspForm of the component HTTP POST Request Handler. The manipulation of the argument param leads to denial of service. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/CH13hh/tmp_store_cc/blob/main/H3C%20R2%2BProG/1.md"
    ],
    "受影响版本": [
      "200R004"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "Cozy Vision Technologies Pvt. Ltd.",
    "设备类型": "OTA",
    "产品型号": "SMS Alert Order Notifications – WooCommerce",
    "CVE编号": "CVE-2025-47682",
    "漏洞描述": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in Cozy Vision Technologies Pvt. Ltd. SMS Alert Order Notifications – WooCommerce allows SQL Injection.This issue affects SMS Alert Order Notifications – WooCommerce: from n/a through 3.8.2.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/sms-alert/vulnerability/wordpress-sms-alert-order-notifications-woocommerce-3-8-1-sql-injection-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年05月12日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "GR-5400AX",
    "CVE编号": "CVE-2025-4446",
    "漏洞描述": "A vulnerability has been found in H3C GR-5400AX up to 100R008 and classified as critical. This vulnerability affects the function Edit_List_SSID of the file /goform/aspForm. The manipulation of the argument param leads to buffer overflow. The attack needs to be approached within the local network.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/CH13hh/tmp_store_cc/blob/main/H3C%20GB5400AX/5.md"
    ],
    "受影响版本": [
      "100R008"
    ],
    "公开日期": "2025年05月09日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "GR-1800AX",
    "CVE编号": "CVE-2025-4440",
    "漏洞描述": "A vulnerability was found in H3C GR-1800AX up to 100R008 and classified as critical. Affected by this issue is the function EnableIpv6 of the file /goform/aspForm. The manipulation of the argument param leads to buffer overflow. Access to the local network is required for this attack to succeed. The exploit has been disclosed to the public and may be used.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/CH13hh/tmp_store_cc/blob/main/H3C%20GR-1800AX/1.md"
    ],
    "受影响版本": [
      "100R008"
    ],
    "公开日期": "2025年05月08日"
  },
  {
    "设备品牌": "vantage6",
    "设备类型": "OTA",
    "产品型号": "vantage6",
    "CVE编号": "CVE-2025-43863",
    "漏洞描述": "vantage6 is an open source framework built to enable, manage and deploy privacy enhancing technologies like Federated Learning and Multi-Party Computation. If attacker gets access to an authenticated session, they can try to brute-force the user password by using the change password functionality: they can call that route infinitely which will return the message that password is wrong until it is correct. This vulnerability is fixed in 4.11.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/vantage6/vantage6/security/advisories/GHSA-j6g5-p62x-58hw"
    ],
    "受影响版本": [
      "< 4.11.0"
    ],
    "公开日期": "2025年06月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-39735",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix slab-out-of-bounds read in ea_get()\n\nDuring the \"size_check\" label in ea_get(), the code checks if the extended\nattribute list (xattr) size matches ea_size. If not, it logs\n\"ea_get: invalid extended attribute\" and calls print_hex_dump().\n\nHere, EALIST_SIZE(ea_buf->xattr) returns 4110417968, which exceeds\nINT_MAX (2,147,483,647). Then ea_size is clamped:\n\n\tint size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));\n\nAlthough clamp_t aims to bound ea_size between 0 and 4110417968, the upper\nlimit is treated as an int, causing an overflow above 2^31 - 1. This leads\n\"size\" to wrap around and become negative (-184549328).\n\nThe \"size\" is then passed to print_hex_dump() (called \"len\" in\nprint_hex_dump()), it is passed as type size_t (an unsigned\ntype), this is then stored inside a variable called\n\"int remaining\", which is then assigned to \"int linelen\" which\nis then passed to hex_dump_to_buffer(). In print_hex_dump()\nthe for loop, iterates through 0 to len-1, where len is\n18446744073525002176, calling hex_dump_to_buffer()\non each iteration:\n\n\tfor (i = 0; i < len; i += rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\n\t\thex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t   linebuf, sizeof(linebuf), ascii);\n\n\t\t...\n\t}\n\nThe expected stopping condition (i < len) is effectively broken\nsince len is corrupted and very large. This eventually leads to\nthe \"ptr+i\" being passed to hex_dump_to_buffer() to get closer\nto the end of the actual bounds of \"ptr\", eventually an out of\nbounds access is done in hex_dump_to_buffer() in the following\nfor loop:\n\n\tfor (j = 0; j < len; j++) {\n\t\t\tif (linebuflen < lx + 2)\n\t\t\t\tgoto overflow2;\n\t\t\tch = ptr[j];\n\t\t...\n\t}\n\nTo fix this we should validate \"EALIST_SIZE(ea_buf->xattr)\"\nbefore it is utilised.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3d6fd5b9c6acbc005e53d0211c7381f566babec1",
      "https://git.kernel.org/stable/c/50afcee7011155933d8d5e8832f52eeee018cfd3",
      "https://git.kernel.org/stable/c/78c9cbde8880ec02d864c166bcb4fe989ce1d95f",
      "https://git.kernel.org/stable/c/46e2c031aa59ea65128991cbca474bd5c0c2ecdb",
      "https://git.kernel.org/stable/c/a8c31808925b11393a6601f534bb63bac5366bab",
      "https://git.kernel.org/stable/c/0beddc2a3f9b9cf7d8887973041e36c2d0fa3652",
      "https://git.kernel.org/stable/c/16d3d36436492aa248b2d8045e75585ebcc2f34d",
      "https://git.kernel.org/stable/c/5263822558a8a7c0d0248d5679c2dcf4d5cda61f",
      "https://git.kernel.org/stable/c/fdf480da5837c23b146c4743c18de97202fcab37"
    ],
    "受影响版本": [
      "6e39b681d1eb16f408493bf5023788b57f68998c",
      "bbf3f1fd8a0ac7df1db36a9b9e923041a14369f2",
      "27a93c45e16ac25a0e2b5e5668e2d1beca56a478",
      "9c356fc32a4480a2c0e537a05f2a8617633ddad0",
      "9353cdf28d4c5c0ff19c5df7fbf81ea774de43a4",
      "8c505ebeed8045b488b2e60b516c752b851f8437",
      "d9f9d96136cba8fedd647d2c024342ce090133c2",
      "d9f9d96136cba8fedd647d2c024342ce090133c2",
      "d9f9d96136cba8fedd647d2c024342ce090133c2",
      "4ea25fa8747fb8b1e5a11d87b852023ecf7ae420",
      "676a787048aafd4d1b38a522b05a9cc77e1b0a33"
    ],
    "公开日期": "2025年04月18日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "GR-3000AX",
    "CVE编号": "CVE-2025-3854",
    "漏洞描述": "A vulnerability, which was classified as critical, was found in H3C GR-3000AX up to V100R006. Affected is the function EnableIpv6/UpdateWanModeMulti/UpdateIpv6Params/EditWlanMacList/Edit_List_SSID of the file /goform/aspForm of the component HTTP POST Request Handler. The manipulation of the argument param leads to buffer overflow. The attack needs to be initiated within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component. Other functions might be affected as well.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/CH13hh/tmp_store_cc/blob/main/H3C%20GR-3000AX/1.md",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R006"
    ],
    "公开日期": "2025年04月22日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-38066",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm cache: prevent BUG_ON by blocking retries on failed device resumes\n\nA cache device failing to resume due to mapping errors should not be\nretried, as the failure leaves a partially initialized policy object.\nRepeating the resume operation risks triggering BUG_ON when reloading\ncache mappings into the incomplete policy object.\n\nReproduce steps:\n\n1. create a cache metadata consisting of 512 or more cache blocks,\n   with some mappings stored in the first array block of the mapping\n   array. Here we use cache_restore v1.0 to build the metadata.\n\ncat <<EOF >> cmeta.xml\n<superblock uuid=\"\" block_size=\"128\" nr_cache_blocks=\"512\" \\\npolicy=\"smq\" hint_width=\"4\">\n  <mappings>\n    <mapping cache_block=\"0\" origin_block=\"0\" dirty=\"false\"/>\n  </mappings>\n</superblock>\nEOF\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ncache_restore -i cmeta.xml -o /dev/mapper/cmeta --metadata-version=2\ndmsetup remove cmeta\n\n2. wipe the second array block of the mapping array to simulate\n   data degradations.\n\nmapping_root=$(dd if=/dev/sdc bs=1c count=8 skip=192 \\\n2>/dev/null | hexdump -e '1/8 \"%u\\n\"')\nablock=$(dd if=/dev/sdc bs=1c count=8 skip=$((4096*mapping_root+2056)) \\\n2>/dev/null | hexdump -e '1/8 \"%u\\n\"')\ndd if=/dev/zero of=/dev/sdc bs=4k count=1 seek=$ablock\n\n3. try bringing up the cache device. The resume is expected to fail\n   due to the broken array block.\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc 262144\"\ndmsetup create cache --notable\ndmsetup load cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\ndmsetup resume cache\n\n4. try resuming the cache again. An unexpected BUG_ON is triggered\n   while loading cache mappings.\n\ndmsetup resume cache\n\nKernel logs:\n\n(snip)\n------------[ cut here ]------------\nkernel BUG at drivers/md/dm-cache-policy-smq.c:752!\nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI\nCPU: 0 UID: 0 PID: 332 Comm: dmsetup Not tainted 6.13.4 #3\nRIP: 0010:smq_load_mapping+0x3e5/0x570\n\nFix by disallowing resume operations for devices that failed the\ninitial attempt.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c614584c2a66b538f469089ac089457a34590c14",
      "https://git.kernel.org/stable/c/c5356a5e80442131e2714d0d26bb110590e4e568",
      "https://git.kernel.org/stable/c/025c8f477625eb39006ded650e7d027bcfb20e79",
      "https://git.kernel.org/stable/c/00586b78eeb7c626a14ca13453a1631f88a7cf36",
      "https://git.kernel.org/stable/c/3986ef4a9b6a0d9c28bc325d8713beba5e67586f",
      "https://git.kernel.org/stable/c/cc80a5cc520939d0a7d071cc4ae4b3c55ef171d0",
      "https://git.kernel.org/stable/c/f3128e3074e8af565cc6a66fe3384a56df87f803",
      "https://git.kernel.org/stable/c/5da692e2262b8f81993baa9592f57d12c2703dea"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-38050",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/hugetlb: fix kernel NULL pointer dereference when replacing free hugetlb folios\n\nA kernel crash was observed when replacing free hugetlb folios:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000028\nPGD 0 P4D 0\nOops: Oops: 0000 [#1] SMP NOPTI\nCPU: 28 UID: 0 PID: 29639 Comm: test_cma.sh Tainted 6.15.0-rc6-zp #41 PREEMPT(voluntary)\nRIP: 0010:alloc_and_dissolve_hugetlb_folio+0x1d/0x1f0\nRSP: 0018:ffffc9000b30fa90 EFLAGS: 00010286\nRAX: 0000000000000000 RBX: 0000000000342cca RCX: ffffea0043000000\nRDX: ffffc9000b30fb08 RSI: ffffea0043000000 RDI: 0000000000000000\nRBP: ffffc9000b30fb20 R08: 0000000000001000 R09: 0000000000000000\nR10: ffff88886f92eb00 R11: 0000000000000000 R12: ffffea0043000000\nR13: 0000000000000000 R14: 00000000010c0200 R15: 0000000000000004\nFS:  00007fcda5f14740(0000) GS:ffff8888ec1d8000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000028 CR3: 0000000391402000 CR4: 0000000000350ef0\nCall Trace:\n<TASK>\n replace_free_hugepage_folios+0xb6/0x100\n alloc_contig_range_noprof+0x18a/0x590\n ? srso_return_thunk+0x5/0x5f\n ? down_read+0x12/0xa0\n ? srso_return_thunk+0x5/0x5f\n cma_range_alloc.constprop.0+0x131/0x290\n __cma_alloc+0xcf/0x2c0\n cma_alloc_write+0x43/0xb0\n simple_attr_write_xsigned.constprop.0.isra.0+0xb2/0x110\n debugfs_attr_write+0x46/0x70\n full_proxy_write+0x62/0xa0\n vfs_write+0xf8/0x420\n ? srso_return_thunk+0x5/0x5f\n ? filp_flush+0x86/0xa0\n ? srso_return_thunk+0x5/0x5f\n ? filp_close+0x1f/0x30\n ? srso_return_thunk+0x5/0x5f\n ? do_dup2+0xaf/0x160\n ? srso_return_thunk+0x5/0x5f\n ksys_write+0x65/0xe0\n do_syscall_64+0x64/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nThere is a potential race between __update_and_free_hugetlb_folio() and\nreplace_free_hugepage_folios():\n\nCPU1                              CPU2\n__update_and_free_hugetlb_folio   replace_free_hugepage_folios\n                                    folio_test_hugetlb(folio)\n                                    -- It's still hugetlb folio.\n\n  __folio_clear_hugetlb(folio)\n  hugetlb_free_folio(folio)\n                                    h = folio_hstate(folio)\n                                    -- Here, h is NULL pointer\n\nWhen the above race condition occurs, folio_hstate(folio) returns NULL,\nand subsequent access to this NULL pointer will cause the system to crash.\nTo resolve this issue, execute folio_hstate(folio) under the protection\nof the hugetlb_lock lock, ensuring that folio_hstate(folio) does not\nreturn NULL.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e97283978a9848190d451f7038ac399613445f79",
      "https://git.kernel.org/stable/c/113ed54ad276c352ee5ce109bdcf0df118a43bda"
    ],
    "受影响版本": [
      "04f13d241b8b146b23038bffd907cb8278391d07",
      "04f13d241b8b146b23038bffd907cb8278391d07"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-38048",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio_ring: Fix data race by tagging event_triggered as racy for KCSAN\n\nsyzbot reports a data-race when accessing the event_triggered, here is the\nsimplified stack when the issue occurred:\n\n==================================================================\nBUG: KCSAN: data-race in virtqueue_disable_cb / virtqueue_enable_cb_delayed\n\nwrite to 0xffff8881025bc452 of 1 bytes by task 3288 on cpu 0:\n virtqueue_enable_cb_delayed+0x42/0x3c0 drivers/virtio/virtio_ring.c:2653\n start_xmit+0x230/0x1310 drivers/net/virtio_net.c:3264\n __netdev_start_xmit include/linux/netdevice.h:5151 [inline]\n netdev_start_xmit include/linux/netdevice.h:5160 [inline]\n xmit_one net/core/dev.c:3800 [inline]\n\nread to 0xffff8881025bc452 of 1 bytes by interrupt on cpu 1:\n virtqueue_disable_cb_split drivers/virtio/virtio_ring.c:880 [inline]\n virtqueue_disable_cb+0x92/0x180 drivers/virtio/virtio_ring.c:2566\n skb_xmit_done+0x5f/0x140 drivers/net/virtio_net.c:777\n vring_interrupt+0x161/0x190 drivers/virtio/virtio_ring.c:2715\n __handle_irq_event_percpu+0x95/0x490 kernel/irq/handle.c:158\n handle_irq_event_percpu kernel/irq/handle.c:193 [inline]\n\nvalue changed: 0x01 -> 0x00\n==================================================================\n\nWhen the data race occurs, the function virtqueue_enable_cb_delayed() sets\nevent_triggered to false, and virtqueue_disable_cb_split/packed() reads it\nas false due to the race condition. Since event_triggered is an unreliable\nhint used for optimization, this should only cause the driver temporarily\nsuggest that the device not send an interrupt notification when the event\nindex is used.\n\nFix this KCSAN reported data-race issue by explicitly tagging the access as\ndata_racy.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/02d2d6caee3abc9335cfca35f8eb4492173ae6f2",
      "https://git.kernel.org/stable/c/b6d6419548286b2b9d2b90df824d3cab797f6ae8",
      "https://git.kernel.org/stable/c/b49b5132e4c7307599492aee1cdc6d89f7f2a7da",
      "https://git.kernel.org/stable/c/b730cb109633c455ce8a7cd6934986c6a16d88d8",
      "https://git.kernel.org/stable/c/4ed8f0e808b3fcc71c5b8be7902d8738ed595b17",
      "https://git.kernel.org/stable/c/2e2f925fe737576df2373931c95e1a2b66efdfef"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-38042",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: ti: k3-udma-glue: Drop skip_fdq argument from k3_udma_glue_reset_rx_chn\n\nThe user of k3_udma_glue_reset_rx_chn() e.g. ti_am65_cpsw_nuss can\nrun on multiple platforms having different DMA architectures.\nOn some platforms there can be one FDQ for all flows in the RX channel\nwhile for others there is a separate FDQ for each flow in the RX channel.\n\nSo far we have been relying on the skip_fdq argument of\nk3_udma_glue_reset_rx_chn().\n\nInstead of relying on the user to provide this information, infer it\nbased on DMA architecture during k3_udma_glue_request_rx_chn() and save it\nin an internal flag 'single_fdq'. Use that flag at\nk3_udma_glue_reset_rx_chn() to deicide if the FDQ needs\nto be cleared for every flow or just for flow 0.\n\nFixes the below issue on ti_am65_cpsw_nuss driver on AM62-SK.\n\n> ip link set eth1 down\n> ip link set eth0 down\n> ethtool -L eth0 rx 8\n> ip link set eth0 up\n> modprobe -r ti_am65_cpsw_nuss\n\n[  103.045726] ------------[ cut here ]------------\n[  103.050505] k3_knav_desc_pool size 512000 != avail 64000\n[  103.050703] WARNING: CPU: 1 PID: 450 at drivers/net/ethernet/ti/k3-cppi-desc-pool.c:33 k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool]\n[  103.068810] Modules linked in: ti_am65_cpsw_nuss(-) k3_cppi_desc_pool snd_soc_hdmi_codec crct10dif_ce snd_soc_simple_card snd_soc_simple_card_utils display_connector rtc_ti_k3 k3_j72xx_bandgap tidss drm_client_lib snd_soc_davinci_mcas\np drm_dma_helper tps6598x phylink snd_soc_ti_udma rti_wdt drm_display_helper snd_soc_tlv320aic3x_i2c typec at24 phy_gmii_sel snd_soc_ti_edma snd_soc_tlv320aic3x sii902x snd_soc_ti_sdma sa2ul omap_mailbox drm_kms_helper authenc cfg80211 r\nfkill fuse drm drm_panel_orientation_quirks backlight ip_tables x_tables ipv6 [last unloaded: k3_cppi_desc_pool]\n[  103.119950] CPU: 1 UID: 0 PID: 450 Comm: modprobe Not tainted 6.13.0-rc7-00001-g9c5e3435fa66 #1011\n[  103.119968] Hardware name: Texas Instruments AM625 SK (DT)\n[  103.119974] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  103.119983] pc : k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool]\n[  103.148007] lr : k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool]\n[  103.154709] sp : ffff8000826ebbc0\n[  103.158015] x29: ffff8000826ebbc0 x28: ffff0000090b6300 x27: 0000000000000000\n[  103.165145] x26: 0000000000000000 x25: 0000000000000000 x24: ffff0000019df6b0\n[  103.172271] x23: ffff0000019df6b8 x22: ffff0000019df410 x21: ffff8000826ebc88\n[  103.179397] x20: 000000000007d000 x19: ffff00000a3b3000 x18: 0000000000000000\n[  103.186522] x17: 0000000000000000 x16: 0000000000000000 x15: 000001e8c35e1cde\n[  103.193647] x14: 0000000000000396 x13: 000000000000035c x12: 0000000000000000\n[  103.200772] x11: 000000000000003a x10: 00000000000009c0 x9 : ffff8000826eba20\n[  103.207897] x8 : ffff0000090b6d20 x7 : ffff00007728c180 x6 : ffff00007728c100\n[  103.215022] x5 : 0000000000000001 x4 : ffff000000508a50 x3 : ffff7ffff6146000\n[  103.222147] x2 : 0000000000000000 x1 : e300b4173ee6b200 x0 : 0000000000000000\n[  103.229274] Call trace:\n[  103.231714]  k3_cppi_desc_pool_destroy+0xa0/0xa8 [k3_cppi_desc_pool] (P)\n[  103.238408]  am65_cpsw_nuss_free_rx_chns+0x28/0x4c [ti_am65_cpsw_nuss]\n[  103.244942]  devm_action_release+0x14/0x20\n[  103.249040]  release_nodes+0x3c/0x68\n[  103.252610]  devres_release_all+0x8c/0xdc\n[  103.256614]  device_unbind_cleanup+0x18/0x60\n[  103.260876]  device_release_driver_internal+0xf8/0x178\n[  103.266004]  driver_detach+0x50/0x9c\n[  103.269571]  bus_remove_driver+0x6c/0xbc\n[  103.273485]  driver_unregister+0x30/0x60\n[  103.277401]  platform_driver_unregister+0x14/0x20\n[  103.282096]  am65_cpsw_nuss_driver_exit+0x18/0xff4 [ti_am65_cpsw_nuss]\n[  103.288620]  __arm64_sys_delete_module+0x17c/0x25c\n[  103.293404]  invoke_syscall+0x44/0x100\n[  103.297149]  el0_svc_common.constprop.0+0xc0/0xe0\n[  103.301845]  do_el0_svc+0x1c/0x28\n[  103.305155]  el0_svc+0x28/0x98\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d0dd9d133ef8fdc894e0be9aa27dc49ef5f813cb",
      "https://git.kernel.org/stable/c/0da30874729baeb01889b0eca16cfda122687503"
    ],
    "受影响版本": [
      "d702419134133db1eab2067dc6ea5723467fd917",
      "d702419134133db1eab2067dc6ea5723467fd917"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-38033",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/Kconfig: make CFI_AUTO_DEFAULT depend on !RUST or Rust >= 1.88\n\nCalling core::fmt::write() from rust code while FineIBT is enabled\nresults in a kernel panic:\n\n[ 4614.199779] kernel BUG at arch/x86/kernel/cet.c:132!\n[ 4614.205343] Oops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n[ 4614.211781] CPU: 2 UID: 0 PID: 6057 Comm: dmabuf_dump Tainted: G     U     O       6.12.17-android16-0-g6ab38c534a43 #1 9da040f27673ec3945e23b998a0f8bd64c846599\n[ 4614.227832] Tainted: [U]=USER, [O]=OOT_MODULE\n[ 4614.241247] RIP: 0010:do_kernel_cp_fault+0xea/0xf0\n...\n[ 4614.398144] RIP: 0010:_RNvXs5_NtNtNtCs3o2tGsuHyou_4core3fmt3num3impyNtB9_7Display3fmt+0x0/0x20\n[ 4614.407792] Code: 48 f7 df 48 0f 48 f9 48 89 f2 89 c6 5d e9 18 fd ff ff 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 41 81 ea 14 61 af 2c 74 03 0f 0b 90 <66> 0f 1f 00 55 48 89 e5 48 89 f2 48 8b 3f be 01 00 00 00 5d e9 e7\n[ 4614.428775] RSP: 0018:ffffb95acfa4ba68 EFLAGS: 00010246\n[ 4614.434609] RAX: 0000000000000000 RBX: 0000000000000010 RCX: 0000000000000000\n[ 4614.442587] RDX: 0000000000000007 RSI: ffffb95acfa4ba70 RDI: ffffb95acfa4bc88\n[ 4614.450557] RBP: ffffb95acfa4bae0 R08: ffff0a00ffffff05 R09: 0000000000000070\n[ 4614.458527] R10: 0000000000000000 R11: ffffffffab67eaf0 R12: ffffb95acfa4bcc8\n[ 4614.466493] R13: ffffffffac5d50f0 R14: 0000000000000000 R15: 0000000000000000\n[ 4614.474473]  ? __cfi__RNvXs5_NtNtNtCs3o2tGsuHyou_4core3fmt3num3impyNtB9_7Display3fmt+0x10/0x10\n[ 4614.484118]  ? _RNvNtCs3o2tGsuHyou_4core3fmt5write+0x1d2/0x250\n\nThis happens because core::fmt::write() calls\ncore::fmt::rt::Argument::fmt(), which currently has CFI disabled:\n\nlibrary/core/src/fmt/rt.rs:\n171     // FIXME: Transmuting formatter in new and indirectly branching to/calling\n172     // it here is an explicit CFI violation.\n173     #[allow(inline_no_sanitize)]\n174     #[no_sanitize(cfi, kcfi)]\n175     #[inline]\n176     pub(super) unsafe fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n\nThis causes a Control Protection exception, because FineIBT has sealed\noff the original function's endbr64.\n\nThis makes rust currently incompatible with FineIBT. Add a Kconfig\ndependency that prevents FineIBT from getting turned on by default\nif rust is enabled.\n\n[ Rust 1.88.0 (scheduled for 2025-06-26) should have this fixed [1],\n  and thus we relaxed the condition with Rust >= 1.88.\n\n  When `objtool` lands checking for this with e.g. [2], the plan is\n  to ideally run that in upstream Rust's CI to prevent regressions\n  early [3], since we do not control `core`'s source code.\n\n  Alice tested the Rust PR backported to an older compiler.\n\n  Peter would like that Rust provides a stable `core` which can be\n  pulled into the kernel: \"Relying on that much out of tree code is\n  'unfortunate'\".\n\n    - Miguel ]\n\n[ Reduced splat. - Miguel ]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5a8d073d87da4ad1496b35adaee5719e94665d81",
      "https://git.kernel.org/stable/c/6b9956d09382bcbd5fd260c4b60ec48680a4cffb",
      "https://git.kernel.org/stable/c/5595c31c370957aabe739ac3996aedba8267603f"
    ],
    "受影响版本": [
      "d6f635bcaca8d38dfa47ee20658705f9eff156b5",
      "d6f635bcaca8d38dfa47ee20658705f9eff156b5",
      "d6f635bcaca8d38dfa47ee20658705f9eff156b5"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37964",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/mm: Eliminate window where TLB flushes may be inadvertently skipped\n\ntl;dr: There is a window in the mm switching code where the new CR3 is\nset and the CPU should be getting TLB flushes for the new mm.  But\nshould_flush_tlb() has a bug and suppresses the flush.  Fix it by\nwidening the window where should_flush_tlb() sends an IPI.\n\nLong Version:\n\n=== History ===\n\nThere were a few things leading up to this.\n\nFirst, updating mm_cpumask() was observed to be too expensive, so it was\nmade lazier.  But being lazy caused too many unnecessary IPIs to CPUs\ndue to the now-lazy mm_cpumask().  So code was added to cull\nmm_cpumask() periodically[2].  But that culling was a bit too aggressive\nand skipped sending TLB flushes to CPUs that need them.  So here we are\nagain.\n\n=== Problem ===\n\nThe too-aggressive code in should_flush_tlb() strikes in this window:\n\n\t// Turn on IPIs for this CPU/mm combination, but only\n\t// if should_flush_tlb() agrees:\n\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\n\tnext_tlb_gen = atomic64_read(&next->context.tlb_gen);\n\tchoose_new_asid(next, next_tlb_gen, &new_asid, &need_flush);\n\tload_new_mm_cr3(need_flush);\n\t// ^ After 'need_flush' is set to false, IPIs *MUST*\n\t// be sent to this CPU and not be ignored.\n\n        this_cpu_write(cpu_tlbstate.loaded_mm, next);\n\t// ^ Not until this point does should_flush_tlb()\n\t// become true!\n\nshould_flush_tlb() will suppress TLB flushes between load_new_mm_cr3()\nand writing to 'loaded_mm', which is a window where they should not be\nsuppressed.  Whoops.\n\n=== Solution ===\n\nThankfully, the fuzzy \"just about to write CR3\" window is already marked\nwith loaded_mm==LOADED_MM_SWITCHING.  Simply checking for that state in\nshould_flush_tlb() is sufficient to ensure that the CPU is targeted with\nan IPI.\n\nThis will cause more TLB flush IPIs.  But the window is relatively small\nand I do not expect this to cause any kind of measurable performance\nimpact.\n\nUpdate the comment where LOADED_MM_SWITCHING is written since it grew\nyet another user.\n\nPeter Z also raised a concern that should_flush_tlb() might not observe\n'loaded_mm' and 'is_lazy' in the same order that switch_mm_irqs_off()\nwrites them.  Add a barrier to ensure that they are observed in the\norder they are written.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/12f703811af043d32b1c8a30001b2fa04d5cd0ac",
      "https://git.kernel.org/stable/c/02ad4ce144bd27f71f583f667fdf3b3ba0753477",
      "https://git.kernel.org/stable/c/d41072906abec8bb8e01ed16afefbaa558908c89",
      "https://git.kernel.org/stable/c/d87392094f96e162fa5fa5a8640d70cc0952806f",
      "https://git.kernel.org/stable/c/399ec9ca8fc4999e676ff89a90184ec40031cf59",
      "https://git.kernel.org/stable/c/fea4e317f9e7e1f449ce90dedc27a2d2a95bee5a"
    ],
    "受影响版本": [
      "848b5815177582de0e1d0118725378e0fbadca20",
      "b47002ed65ade940839b7f439ff4a194e7d5ec28",
      "a04fe3bfc71e28009e20357b79df1e8ef7c9d600",
      "3dbe889a1b829b4c07e0836ff853fe649e51ce4f",
      "6db2526c1d694c91c6e05e2f186c085e9460f202",
      "6db2526c1d694c91c6e05e2f186c085e9460f202",
      "d1347977661342cb09a304a17701eb2d4aa21dec"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37953",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsch_htb: make htb_deactivate() idempotent\n\nAlan reported a NULL pointer dereference in htb_next_rb_node()\nafter we made htb_qlen_notify() idempotent.\n\nIt turns out in the following case it introduced some regression:\n\nhtb_dequeue_tree():\n  |-> fq_codel_dequeue()\n    |-> qdisc_tree_reduce_backlog()\n      |-> htb_qlen_notify()\n        |-> htb_deactivate()\n  |-> htb_next_rb_node()\n  |-> htb_deactivate()\n\nFor htb_next_rb_node(), after calling the 1st htb_deactivate(), the\nclprio[prio]->ptr could be already set to  NULL, which means\nhtb_next_rb_node() is vulnerable here.\n\nFor htb_deactivate(), although we checked qlen before calling it, in\ncase of qlen==0 after qdisc_tree_reduce_backlog(), we may call it again\nwhich triggers the warning inside.\n\nTo fix the issues here, we need to:\n\n1) Make htb_deactivate() idempotent, that is, simply return if we\n   already call it before.\n2) Make htb_next_rb_node() safe against ptr==NULL.\n\nMany thanks to Alan for testing and for the reproducer.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/99ff8a20fd61315bf9ae627440a5ff07d22ee153",
      "https://git.kernel.org/stable/c/c928dd4f6bf0c25c72b11824a1e9ac9bd37296a0",
      "https://git.kernel.org/stable/c/31ff70ad39485698cf779f2078132d80b57f6c07",
      "https://git.kernel.org/stable/c/98cd7ed92753090a714f0802d4434314526fe61d",
      "https://git.kernel.org/stable/c/c4792b9e38d2f61b07eac72f10909fa76130314b",
      "https://git.kernel.org/stable/c/3769478610135e82b262640252d90f6efb05be71"
    ],
    "受影响版本": [
      "e6b45f4de763b00dc1c55e685e2dd1aaf525d3c1",
      "73cf6af13153d62f9b76eff422eea79dbc70f15e",
      "bbbf5e0f87078b715e7a665d662a2c0e77f044ae",
      "0a188c0e197383683fd093ab1ea6ce9a5869a6ea",
      "a61f1b5921761fbaf166231418bc1db301e5bf59",
      "5ba8b837b522d7051ef81bacf3d95383ff8edce5"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37945",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: phy: allow MDIO bus PM ops to start/stop state machine for phylink-controlled PHY\n\nDSA has 2 kinds of drivers:\n\n1. Those who call dsa_switch_suspend() and dsa_switch_resume() from\n   their device PM ops: qca8k-8xxx, bcm_sf2, microchip ksz\n2. Those who don't: all others. The above methods should be optional.\n\nFor type 1, dsa_switch_suspend() calls dsa_user_suspend() -> phylink_stop(),\nand dsa_switch_resume() calls dsa_user_resume() -> phylink_start().\nThese seem good candidates for setting mac_managed_pm = true because\nthat is essentially its definition [1], but that does not seem to be the\nbiggest problem for now, and is not what this change focuses on.\n\nTalking strictly about the 2nd category of DSA drivers here (which\ndo not have MAC managed PM, meaning that for their attached PHYs,\nmdio_bus_phy_suspend() and mdio_bus_phy_resume() should run in full),\nI have noticed that the following warning from mdio_bus_phy_resume() is\ntriggered:\n\n\tWARN_ON(phydev->state != PHY_HALTED && phydev->state != PHY_READY &&\n\t\tphydev->state != PHY_UP);\n\nbecause the PHY state machine is running.\n\nIt's running as a result of a previous dsa_user_open() -> ... ->\nphylink_start() -> phy_start() having been initiated by the user.\n\nThe previous mdio_bus_phy_suspend() was supposed to have called\nphy_stop_machine(), but it didn't. So this is why the PHY is in state\nPHY_NOLINK by the time mdio_bus_phy_resume() runs.\n\nmdio_bus_phy_suspend() did not call phy_stop_machine() because for\nphylink, the phydev->adjust_link function pointer is NULL. This seems a\ntechnicality introduced by commit fddd91016d16 (\"phylib: fix PAL state\nmachine restart on resume\"). That commit was written before phylink\nexisted, and was intended to avoid crashing with consumer drivers which\ndon't use the PHY state machine - phylink always does, when using a PHY.\nBut phylink itself has historically not been developed with\nsuspend/resume in mind, and apparently not tested too much in that\nscenario, allowing this bug to exist unnoticed for so long. Plus, prior\nto the WARN_ON(), it would have likely been invisible.\n\nThis issue is not in fact restricted to type 2 DSA drivers (according to\nthe above ad-hoc classification), but can be extrapolated to any MAC\ndriver with phylink and MDIO-bus-managed PHY PM ops. DSA is just where\nthe issue was reported. Assuming mac_managed_pm is set correctly, a\nquick search indicates the following other drivers might be affected:\n\n$ grep -Zlr PHYLINK_NETDEV drivers/ | xargs -0 grep -L mac_managed_pm\ndrivers/net/ethernet/atheros/ag71xx.c\ndrivers/net/ethernet/microchip/sparx5/sparx5_main.c\ndrivers/net/ethernet/microchip/lan966x/lan966x_main.c\ndrivers/net/ethernet/freescale/dpaa2/dpaa2-mac.c\ndrivers/net/ethernet/freescale/fs_enet/fs_enet-main.c\ndrivers/net/ethernet/freescale/dpaa/dpaa_eth.c\ndrivers/net/ethernet/freescale/ucc_geth.c\ndrivers/net/ethernet/freescale/enetc/enetc_pf_common.c\ndrivers/net/ethernet/marvell/mvpp2/mvpp2_main.c\ndrivers/net/ethernet/marvell/mvneta.c\ndrivers/net/ethernet/marvell/prestera/prestera_main.c\ndrivers/net/ethernet/mediatek/mtk_eth_soc.c\ndrivers/net/ethernet/altera/altera_tse_main.c\ndrivers/net/ethernet/wangxun/txgbe/txgbe_phy.c\ndrivers/net/ethernet/meta/fbnic/fbnic_phylink.c\ndrivers/net/ethernet/tehuti/tn40_phy.c\ndrivers/net/ethernet/mscc/ocelot_net.c\n\nMake the existing conditions dependent on the PHY device having a\nphydev->phy_link_change() implementation equal to the default\nphy_link_change() provided by phylib. Otherwise, we implicitly know that\nthe phydev has the phylink-provided phylink_phy_change() callback, and\nwhen phylink is used, the PHY state machine always needs to be stopped/\nstarted on the suspend/resume path. The code is structured as such that\nif phydev->phy_link_change() is absent, it is a matter of time until the\nkernel will crash - no need to further complicate the test.\n\nThus, for the situation where the PM is not managed b\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a6ed6f8ec81b8ca7100dcd9e62bdbc0dff1b2259",
      "https://git.kernel.org/stable/c/54e5d00a8de6c13f6c01a94ed48025e882cd15f7",
      "https://git.kernel.org/stable/c/bd4037d51d3f6667636a1383e78e48a5b7b60755",
      "https://git.kernel.org/stable/c/fc75ea20ffb452652f0d4033f38fe88d7cfdae35"
    ],
    "受影响版本": [
      "744d23c71af39c7dc77ac7c3cac87ae86a181a85",
      "744d23c71af39c7dc77ac7c3cac87ae86a181a85",
      "744d23c71af39c7dc77ac7c3cac87ae86a181a85",
      "744d23c71af39c7dc77ac7c3cac87ae86a181a85",
      "47ac7b2f6a1ffef76e55a9ec146881a36673284b",
      "7dc0ed411de3450e75b2a9600b5742cbf0908167"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37942",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: pidff: Make sure to fetch pool before checking SIMULTANEOUS_MAX\n\nAs noted by Anssi some 20 years ago, pool report is sometimes messed up.\nThis worked fine on many devices but casued oops on VRS DirectForce PRO.\n\nHere, we're making sure pool report is refetched before trying to access\nany of it's fields. While loop was replaced with a for loop + exit\nconditions were moved aroud to decrease the possibility of creating an\ninfinite loop scenario.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/211861869766a7bb7c72158aee0140ec67e182a7",
      "https://git.kernel.org/stable/c/344d903be8b5c0733ed0f4bc5be34b4a26d905c8",
      "https://git.kernel.org/stable/c/a6f5d30a5c7713238c5c65c98ad95dacb73688d5",
      "https://git.kernel.org/stable/c/1f650dcec32d22deb1d6db12300a2b98483099a9"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37928",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm-bufio: don't schedule in atomic context\n\nA BUG was reported as below when CONFIG_DEBUG_ATOMIC_SLEEP and\ntry_verify_in_tasklet are enabled.\n[  129.444685][  T934] BUG: sleeping function called from invalid context at drivers/md/dm-bufio.c:2421\n[  129.444723][  T934] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 934, name: kworker/1:4\n[  129.444740][  T934] preempt_count: 201, expected: 0\n[  129.444756][  T934] RCU nest depth: 0, expected: 0\n[  129.444781][  T934] Preemption disabled at:\n[  129.444789][  T934] [<ffffffd816231900>] shrink_work+0x21c/0x248\n[  129.445167][  T934] kernel BUG at kernel/sched/walt/walt_debug.c:16!\n[  129.445183][  T934] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\n[  129.445204][  T934] Skip md ftrace buffer dump for: 0x1609e0\n[  129.447348][  T934] CPU: 1 PID: 934 Comm: kworker/1:4 Tainted: G        W  OE      6.6.56-android15-8-o-g6f82312b30b9-debug #1 1400000003000000474e5500b3187743670464e8\n[  129.447362][  T934] Hardware name: Qualcomm Technologies, Inc. Parrot QRD, Alpha-M (DT)\n[  129.447373][  T934] Workqueue: dm_bufio_cache shrink_work\n[  129.447394][  T934] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  129.447406][  T934] pc : android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug]\n[  129.447435][  T934] lr : __traceiter_android_rvh_schedule_bug+0x44/0x6c\n[  129.447451][  T934] sp : ffffffc0843dbc90\n[  129.447459][  T934] x29: ffffffc0843dbc90 x28: ffffffffffffffff x27: 0000000000000c8b\n[  129.447479][  T934] x26: 0000000000000040 x25: ffffff804b3d6260 x24: ffffffd816232b68\n[  129.447497][  T934] x23: ffffff805171c5b4 x22: 0000000000000000 x21: ffffffd816231900\n[  129.447517][  T934] x20: ffffff80306ba898 x19: 0000000000000000 x18: ffffffc084159030\n[  129.447535][  T934] x17: 00000000d2b5dd1f x16: 00000000d2b5dd1f x15: ffffffd816720358\n[  129.447554][  T934] x14: 0000000000000004 x13: ffffff89ef978000 x12: 0000000000000003\n[  129.447572][  T934] x11: ffffffd817a823c4 x10: 0000000000000202 x9 : 7e779c5735de9400\n[  129.447591][  T934] x8 : ffffffd81560d004 x7 : 205b5d3938373434 x6 : ffffffd8167397c8\n[  129.447610][  T934] x5 : 0000000000000000 x4 : 0000000000000001 x3 : ffffffc0843db9e0\n[  129.447629][  T934] x2 : 0000000000002f15 x1 : 0000000000000000 x0 : 0000000000000000\n[  129.447647][  T934] Call trace:\n[  129.447655][  T934]  android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug 1400000003000000474e550080cce8a8a78606b6]\n[  129.447681][  T934]  __might_resched+0x190/0x1a8\n[  129.447694][  T934]  shrink_work+0x180/0x248\n[  129.447706][  T934]  process_one_work+0x260/0x624\n[  129.447718][  T934]  worker_thread+0x28c/0x454\n[  129.447729][  T934]  kthread+0x118/0x158\n[  129.447742][  T934]  ret_from_fork+0x10/0x20\n[  129.447761][  T934] Code: ???????? ???????? ???????? d2b5dd1f (d4210000)\n[  129.447772][  T934] ---[ end trace 0000000000000000 ]---\n\ndm_bufio_lock will call spin_lock_bh when try_verify_in_tasklet\nis enabled, and __scan will be called in atomic context.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a99f5bf4f7197009859dbce14c12f8e2ce5a5a69",
      "https://git.kernel.org/stable/c/c8c83052283bcf2fdd467a33d1d2bd5ba36e935a",
      "https://git.kernel.org/stable/c/f45108257280e0a1cc951ce254853721b40c0812",
      "https://git.kernel.org/stable/c/69a37b3ba85088fc6b903b8e1db7f0a1d4d0b52d",
      "https://git.kernel.org/stable/c/a3d8f0a7f5e8b193db509c7191fefeed3533fc44"
    ],
    "受影响版本": [
      "7cd326747f46ffe1c7bff5682e97dfbcb98990ec",
      "7cd326747f46ffe1c7bff5682e97dfbcb98990ec",
      "7cd326747f46ffe1c7bff5682e97dfbcb98990ec",
      "7cd326747f46ffe1c7bff5682e97dfbcb98990ec",
      "7cd326747f46ffe1c7bff5682e97dfbcb98990ec"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37904",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix the inode leak in btrfs_iget()\n\n[BUG]\nThere is a bug report that a syzbot reproducer can lead to the following\nbusy inode at unmount time:\n\n  BTRFS info (device loop1): last unmount of filesystem 1680000e-3c1e-4c46-84b6-56bd3909af50\n  VFS: Busy inodes after unmount of loop1 (btrfs)\n  ------------[ cut here ]------------\n  kernel BUG at fs/super.c:650!\n  Oops: invalid opcode: 0000 [#1] SMP KASAN NOPTI\n  CPU: 0 UID: 0 PID: 48168 Comm: syz-executor Not tainted 6.15.0-rc2-00471-g119009db2674 #2 PREEMPT(full)\n  Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n  RIP: 0010:generic_shutdown_super+0x2e9/0x390 fs/super.c:650\n  Call Trace:\n   <TASK>\n   kill_anon_super+0x3a/0x60 fs/super.c:1237\n   btrfs_kill_super+0x3b/0x50 fs/btrfs/super.c:2099\n   deactivate_locked_super+0xbe/0x1a0 fs/super.c:473\n   deactivate_super fs/super.c:506 [inline]\n   deactivate_super+0xe2/0x100 fs/super.c:502\n   cleanup_mnt+0x21f/0x440 fs/namespace.c:1435\n   task_work_run+0x14d/0x240 kernel/task_work.c:227\n   resume_user_mode_work include/linux/resume_user_mode.h:50 [inline]\n   exit_to_user_mode_loop kernel/entry/common.c:114 [inline]\n   exit_to_user_mode_prepare include/linux/entry-common.h:329 [inline]\n   __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline]\n   syscall_exit_to_user_mode+0x269/0x290 kernel/entry/common.c:218\n   do_syscall_64+0xd4/0x250 arch/x86/entry/syscall_64.c:100\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f\n   </TASK>\n\n[CAUSE]\nWhen btrfs_alloc_path() failed, btrfs_iget() directly returned without\nreleasing the inode already allocated by btrfs_iget_locked().\n\nThis results the above busy inode and trigger the kernel BUG.\n\n[FIX]\nFix it by calling iget_failed() if btrfs_alloc_path() failed.\n\nIf we hit error inside btrfs_read_locked_inode(), it will properly call\niget_failed(), so nothing to worry about.\n\nAlthough the iget_failed() cleanup inside btrfs_read_locked_inode() is a\nbreak of the normal error handling scheme, let's fix the obvious bug\nand backport first, then rework the error handling later.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/30a339bece3a44ab0a821477139e84fb86af9761",
      "https://git.kernel.org/stable/c/48c1d1bb525b1c44b8bdc8e7ec5629cb6c2b9fc4"
    ],
    "受影响版本": [
      "7c855e16ab72596d771355050ffe026e6b99f91c",
      "7c855e16ab72596d771355050ffe026e6b99f91c"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37901",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nirqchip/qcom-mpm: Prevent crash when trying to handle non-wake GPIOs\n\nOn Qualcomm chipsets not all GPIOs are wakeup capable. Those GPIOs do not\nhave a corresponding MPM pin and should not be handled inside the MPM\ndriver. The IRQ domain hierarchy is always applied, so it's required to\nexplicitly disconnect the hierarchy for those. The pinctrl-msm driver marks\nthese with GPIO_NO_WAKE_IRQ. qcom-pdc has a check for this, but\nirq-qcom-mpm is currently missing the check. This is causing crashes when\nsetting up interrupts for non-wake GPIOs:\n\n root@rb1:~# gpiomon -c gpiochip1 10\n   irq: IRQ159: trimming hierarchy from :soc@0:interrupt-controller@f200000-1\n   Unable to handle kernel paging request at virtual address ffff8000a1dc3820\n   Hardware name: Qualcomm Technologies, Inc. Robotics RB1 (DT)\n   pc : mpm_set_type+0x80/0xcc\n   lr : mpm_set_type+0x5c/0xcc\n   Call trace:\n    mpm_set_type+0x80/0xcc (P)\n    qcom_mpm_set_type+0x64/0x158\n    irq_chip_set_type_parent+0x20/0x38\n    msm_gpio_irq_set_type+0x50/0x530\n    __irq_set_trigger+0x60/0x184\n    __setup_irq+0x304/0x6bc\n    request_threaded_irq+0xc8/0x19c\n    edge_detector_setup+0x260/0x364\n    linereq_create+0x420/0x5a8\n    gpio_ioctl+0x2d4/0x6c0\n\nFix this by copying the check for GPIO_NO_WAKE_IRQ from qcom-pdc.c, so that\nMPM is removed entirely from the hierarchy for non-wake GPIOs.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/45aced97f01d5ab14c8a2a60f6748f18c501c3f5",
      "https://git.kernel.org/stable/c/dfbaecf7e38f5e9bfa5e47a1e525ffbb58bab8cf",
      "https://git.kernel.org/stable/c/f102342360950b56959e5fff4a874ea88ae13758",
      "https://git.kernel.org/stable/c/d5c10448f411a925dd59005785cb971f0626e032",
      "https://git.kernel.org/stable/c/38a05c0b87833f5b188ae43b428b1f792df2b384"
    ],
    "受影响版本": [
      "a6199bb514d8a63f61c2a22c1f912376e14d0fb2",
      "a6199bb514d8a63f61c2a22c1f912376e14d0fb2",
      "a6199bb514d8a63f61c2a22c1f912376e14d0fb2",
      "a6199bb514d8a63f61c2a22c1f912376e14d0fb2",
      "a6199bb514d8a63f61c2a22c1f912376e14d0fb2"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37898",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc64/ftrace: fix module loading without patchable function entries\n\nget_stubs_size assumes that there must always be at least one patchable\nfunction entry, which is not always the case (modules that export data\nbut no code), otherwise it returns -ENOEXEC and thus the section header\nsh_size is set to that value. During module_memory_alloc() the size is\npassed to execmem_alloc() after being page-aligned and thus set to zero\nwhich will cause it to fail the allocation (and thus module loading) as\n__vmalloc_node_range() checks for zero-sized allocs and returns null:\n\n[  115.466896] module_64: cast_common: doesn't contain __patchable_function_entries.\n[  115.469189] ------------[ cut here ]------------\n[  115.469496] WARNING: CPU: 0 PID: 274 at mm/vmalloc.c:3778 __vmalloc_node_range_noprof+0x8b4/0x8f0\n...\n[  115.478574] ---[ end trace 0000000000000000 ]---\n[  115.479545] execmem: unable to allocate memory\n\nFix this by removing the check completely, since it is anyway not\nhelpful to propagate this as an error upwards.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/358b559afec7806b9d01c2405b490e782c347022",
      "https://git.kernel.org/stable/c/534f5a8ba27863141e29766467a3e1f61bcb47ac"
    ],
    "受影响版本": [
      "eec37961a56aa4f3fe1c33ffd48eec7d1bb0c009",
      "eec37961a56aa4f3fe1c33ffd48eec7d1bb0c009"
    ],
    "公开日期": "2025年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37876",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfs: Only create /proc/fs/netfs with CONFIG_PROC_FS\n\nWhen testing a special config:\n\nCONFIG_NETFS_SUPPORTS=y\nCONFIG_PROC_FS=n\n\nThe system crashes with something like:\n\n[    3.766197] ------------[ cut here ]------------\n[    3.766484] kernel BUG at mm/mempool.c:560!\n[    3.766789] Oops: invalid opcode: 0000 [#1] SMP NOPTI\n[    3.767123] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Tainted: G        W\n[    3.767777] Tainted: [W]=WARN\n[    3.767968] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996),\n[    3.768523] RIP: 0010:mempool_alloc_slab.cold+0x17/0x19\n[    3.768847] Code: 50 fe ff 58 5b 5d 41 5c 41 5d 41 5e 41 5f e9 93 95 13 00\n[    3.769977] RSP: 0018:ffffc90000013998 EFLAGS: 00010286\n[    3.770315] RAX: 000000000000002f RBX: ffff888100ba8640 RCX: 0000000000000000\n[    3.770749] RDX: 0000000000000000 RSI: 0000000000000003 RDI: 00000000ffffffff\n[    3.771217] RBP: 0000000000092880 R08: 0000000000000000 R09: ffffc90000013828\n[    3.771664] R10: 0000000000000001 R11: 00000000ffffffea R12: 0000000000092cc0\n[    3.772117] R13: 0000000000000400 R14: ffff8881004b1620 R15: ffffea0004ef7e40\n[    3.772554] FS:  0000000000000000(0000) GS:ffff8881b5f3c000(0000) knlGS:0000000000000000\n[    3.773061] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[    3.773443] CR2: ffffffff830901b4 CR3: 0000000004296001 CR4: 0000000000770ef0\n[    3.773884] PKRU: 55555554\n[    3.774058] Call Trace:\n[    3.774232]  <TASK>\n[    3.774371]  mempool_alloc_noprof+0x6a/0x190\n[    3.774649]  ? _printk+0x57/0x80\n[    3.774862]  netfs_alloc_request+0x85/0x2ce\n[    3.775147]  netfs_readahead+0x28/0x170\n[    3.775395]  read_pages+0x6c/0x350\n[    3.775623]  ? srso_alias_return_thunk+0x5/0xfbef5\n[    3.775928]  page_cache_ra_unbounded+0x1bd/0x2a0\n[    3.776247]  filemap_get_pages+0x139/0x970\n[    3.776510]  ? srso_alias_return_thunk+0x5/0xfbef5\n[    3.776820]  filemap_read+0xf9/0x580\n[    3.777054]  ? srso_alias_return_thunk+0x5/0xfbef5\n[    3.777368]  ? srso_alias_return_thunk+0x5/0xfbef5\n[    3.777674]  ? find_held_lock+0x32/0x90\n[    3.777929]  ? netfs_start_io_read+0x19/0x70\n[    3.778221]  ? netfs_start_io_read+0x19/0x70\n[    3.778489]  ? srso_alias_return_thunk+0x5/0xfbef5\n[    3.778800]  ? lock_acquired+0x1e6/0x450\n[    3.779054]  ? srso_alias_return_thunk+0x5/0xfbef5\n[    3.779379]  netfs_buffered_read_iter+0x57/0x80\n[    3.779670]  __kernel_read+0x158/0x2c0\n[    3.779927]  bprm_execve+0x300/0x7a0\n[    3.780185]  kernel_execve+0x10c/0x140\n[    3.780423]  ? __pfx_kernel_init+0x10/0x10\n[    3.780690]  kernel_init+0xd5/0x150\n[    3.780910]  ret_from_fork+0x2d/0x50\n[    3.781156]  ? __pfx_kernel_init+0x10/0x10\n[    3.781414]  ret_from_fork_asm+0x1a/0x30\n[    3.781677]  </TASK>\n[    3.781823] Modules linked in:\n[    3.782065] ---[ end trace 0000000000000000 ]---\n\nThis is caused by the following error path in netfs_init():\n\n        if (!proc_mkdir(\"fs/netfs\", NULL))\n                goto error_proc;\n\nFix this by adding ifdef in netfs_main(), so that /proc/fs/netfs is only\ncreated with CONFIG_PROC_FS.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2ef6eea2efce01d1956ace483216f6b6e26330c9",
      "https://git.kernel.org/stable/c/6c4c5e0b96a90f2a11c378e66edc1f25165e10b6",
      "https://git.kernel.org/stable/c/40cb48eba3b4b79e110c1a35d33a48cac54507a2"
    ],
    "受影响版本": [
      "7eb5b3e3a0a55f2d166ca949ef47ca6e0c704aab",
      "7eb5b3e3a0a55f2d166ca949ef47ca6e0c704aab",
      "7eb5b3e3a0a55f2d166ca949ef47ca6e0c704aab"
    ],
    "公开日期": "2025年05月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37866",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxbf-bootctl: use sysfs_emit_at() in secure_boot_fuse_state_show()\n\nA warning is seen when running the latest kernel on a BlueField SOC:\n[251.512704] ------------[ cut here ]------------\n[251.512711] invalid sysfs_emit: buf:0000000003aa32ae\n[251.512720] WARNING: CPU: 1 PID: 705264 at fs/sysfs/file.c:767 sysfs_emit+0xac/0xc8\n\nThe warning is triggered because the mlxbf-bootctl driver invokes\n\"sysfs_emit()\" with a buffer pointer that is not aligned to the\nstart of the page. The driver should instead use \"sysfs_emit_at()\"\nto support non-zero offsets into the destination buffer.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5e1dcc5bfd7a2896178c604bc69d6ab9650967da",
      "https://git.kernel.org/stable/c/b129005ddfc0e6daf04a6d3b928a9e474f9b3918"
    ],
    "受影响版本": [
      "9886f575de5aefcfab537467c72e5176e5301df0",
      "9886f575de5aefcfab537467c72e5176e5301df0"
    ],
    "公开日期": "2025年05月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37859",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npage_pool: avoid infinite loop to schedule delayed worker\n\nWe noticed the kworker in page_pool_release_retry() was waken\nup repeatedly and infinitely in production because of the\nbuggy driver causing the inflight less than 0 and warning\nus in page_pool_inflight()[1].\n\nSince the inflight value goes negative, it means we should\nnot expect the whole page_pool to get back to work normally.\n\nThis patch mitigates the adverse effect by not rescheduling\nthe kworker when detecting the inflight negative in\npage_pool_release_retry().\n\n[1]\n[Mon Feb 10 20:36:11 2025] ------------[ cut here ]------------\n[Mon Feb 10 20:36:11 2025] Negative(-51446) inflight packet-pages\n...\n[Mon Feb 10 20:36:11 2025] Call Trace:\n[Mon Feb 10 20:36:11 2025]  page_pool_release_retry+0x23/0x70\n[Mon Feb 10 20:36:11 2025]  process_one_work+0x1b1/0x370\n[Mon Feb 10 20:36:11 2025]  worker_thread+0x37/0x3a0\n[Mon Feb 10 20:36:11 2025]  kthread+0x11a/0x140\n[Mon Feb 10 20:36:11 2025]  ? process_one_work+0x370/0x370\n[Mon Feb 10 20:36:11 2025]  ? __kthread_cancel_work+0x40/0x40\n[Mon Feb 10 20:36:11 2025]  ret_from_fork+0x35/0x40\n[Mon Feb 10 20:36:11 2025] ---[ end trace ebffe800f33e7e34 ]---\nNote: before this patch, the above calltrace would flood the\ndmesg due to repeated reschedule of release_dw kworker.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c3c7c57017ce1d4b2d3788c1fc59e7e39026e158",
      "https://git.kernel.org/stable/c/9f71db4fb82deb889e0bac4a51b34daea7d506a3",
      "https://git.kernel.org/stable/c/91522aba56e9fcdf64da25ffef9b27f8fad48e0f",
      "https://git.kernel.org/stable/c/90e089a64504982f8d62f223027cb9f903781f78",
      "https://git.kernel.org/stable/c/95f17738b86fd198924d874a5639bcdc49c7e5b8",
      "https://git.kernel.org/stable/c/7204335d1991c23fc615ab76f31f175748a578e1",
      "https://git.kernel.org/stable/c/e74e5aa33228c5e2cb4fc80ad103541a7b7805ec",
      "https://git.kernel.org/stable/c/738d1812ec2e395e953258aea912ddd867d11a13",
      "https://git.kernel.org/stable/c/43130d02baa137033c25297aaae95fd0edc41654"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37840",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmtd: rawnand: brcmnand: fix PM resume warning\n\nFixed warning on PM resume as shown below caused due to uninitialized\nstruct nand_operation that checks chip select field :\nWARN_ON(op->cs >= nanddev_ntargets(&chip->base)\n\n[   14.588522] ------------[ cut here ]------------\n[   14.588529] WARNING: CPU: 0 PID: 1392 at drivers/mtd/nand/raw/internals.h:139 nand_reset_op+0x1e0/0x1f8\n[   14.588553] Modules linked in: bdc udc_core\n[   14.588579] CPU: 0 UID: 0 PID: 1392 Comm: rtcwake Tainted: G        W          6.14.0-rc4-g5394eea10651 #16\n[   14.588590] Tainted: [W]=WARN\n[   14.588593] Hardware name: Broadcom STB (Flattened Device Tree)\n[   14.588598] Call trace:\n[   14.588604]  dump_backtrace from show_stack+0x18/0x1c\n[   14.588622]  r7:00000009 r6:0000008b r5:60000153 r4:c0fa558c\n[   14.588625]  show_stack from dump_stack_lvl+0x70/0x7c\n[   14.588639]  dump_stack_lvl from dump_stack+0x18/0x1c\n[   14.588653]  r5:c08d40b0 r4:c1003cb0\n[   14.588656]  dump_stack from __warn+0x84/0xe4\n[   14.588668]  __warn from warn_slowpath_fmt+0x18c/0x194\n[   14.588678]  r7:c08d40b0 r6:c1003cb0 r5:00000000 r4:00000000\n[   14.588681]  warn_slowpath_fmt from nand_reset_op+0x1e0/0x1f8\n[   14.588695]  r8:70c40dff r7:89705f41 r6:36b4a597 r5:c26c9444 r4:c26b0048\n[   14.588697]  nand_reset_op from brcmnand_resume+0x13c/0x150\n[   14.588714]  r9:00000000 r8:00000000 r7:c24f8010 r6:c228a3f8 r5:c26c94bc r4:c26b0040\n[   14.588717]  brcmnand_resume from platform_pm_resume+0x34/0x54\n[   14.588735]  r5:00000010 r4:c0840a50\n[   14.588738]  platform_pm_resume from dpm_run_callback+0x5c/0x14c\n[   14.588757]  dpm_run_callback from device_resume+0xc0/0x324\n[   14.588776]  r9:c24f8054 r8:c24f80a0 r7:00000000 r6:00000000 r5:00000010 r4:c24f8010\n[   14.588779]  device_resume from dpm_resume+0x130/0x160\n[   14.588799]  r9:c22539e4 r8:00000010 r7:c22bebb0 r6:c24f8010 r5:c22539dc r4:c22539b0\n[   14.588802]  dpm_resume from dpm_resume_end+0x14/0x20\n[   14.588822]  r10:c2204e40 r9:00000000 r8:c228a3fc r7:00000000 r6:00000003 r5:c228a414\n[   14.588826]  r4:00000010\n[   14.588828]  dpm_resume_end from suspend_devices_and_enter+0x274/0x6f8\n[   14.588848]  r5:c228a414 r4:00000000\n[   14.588851]  suspend_devices_and_enter from pm_suspend+0x228/0x2bc\n[   14.588868]  r10:c3502910 r9:c3501f40 r8:00000004 r7:c228a438 r6:c0f95e18 r5:00000000\n[   14.588871]  r4:00000003\n[   14.588874]  pm_suspend from state_store+0x74/0xd0\n[   14.588889]  r7:c228a438 r6:c0f934c8 r5:00000003 r4:00000003\n[   14.588892]  state_store from kobj_attr_store+0x1c/0x28\n[   14.588913]  r9:00000000 r8:00000000 r7:f09f9f08 r6:00000004 r5:c3502900 r4:c0283250\n[   14.588916]  kobj_attr_store from sysfs_kf_write+0x40/0x4c\n[   14.588936]  r5:c3502900 r4:c0d92a48\n[   14.588939]  sysfs_kf_write from kernfs_fop_write_iter+0x104/0x1f0\n[   14.588956]  r5:c3502900 r4:c3501f40\n[   14.588960]  kernfs_fop_write_iter from vfs_write+0x250/0x420\n[   14.588980]  r10:c0e14b48 r9:00000000 r8:c25f5780 r7:00443398 r6:f09f9f68 r5:c34f7f00\n[   14.588983]  r4:c042a88c\n[   14.588987]  vfs_write from ksys_write+0x74/0xe4\n[   14.589005]  r10:00000004 r9:c25f5780 r8:c02002fA0 r7:00000000 r6:00000000 r5:c34f7f00\n[   14.589008]  r4:c34f7f00\n[   14.589011]  ksys_write from sys_write+0x10/0x14\n[   14.589029]  r7:00000004 r6:004421c0 r5:00443398 r4:00000004\n[   14.589032]  sys_write from ret_fast_syscall+0x0/0x5c\n[   14.589044] Exception stack(0xf09f9fa8 to 0xf09f9ff0)\n[   14.589050] 9fa0:                   00000004 00443398 00000004 00443398 00000004 00000001\n[   14.589056] 9fc0: 00000004 00443398 004421c0 00000004 b6ecbd58 00000008 bebfbc38 0043eb78\n[   14.589062] 9fe0: 00440eb0 bebfbaf8 b6de18a0 b6e579e8\n[   14.589065] ---[ end trace 0000000000000000 ]---\n\nThe fix uses the higher level nand_reset(chip, chipnr); where chipnr = 0, when\ndoing PM resume operation in compliance with the controller support for single\ndie nand chip. Switching from nand_reset_op() to nan\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6f567c6a5250e3531cfd9c7ff254ecc2650464fa",
      "https://git.kernel.org/stable/c/8775581e1c48e1bdd04a893d6f6bbe5128ad0ea7",
      "https://git.kernel.org/stable/c/fbcb584efa5cd912ff8a151d67b8fe22f4162a85",
      "https://git.kernel.org/stable/c/9dd161f707ecb7db38e5f529e979a5b6eb565b2d",
      "https://git.kernel.org/stable/c/9bd51723ab51580e077c91d494c37e80703b8524",
      "https://git.kernel.org/stable/c/7266066b9469f04ed1d4c0fdddaea1425835eb55",
      "https://git.kernel.org/stable/c/c2eb3cffb0d972c5503e4d48921971c81def0fe5",
      "https://git.kernel.org/stable/c/659b1f29f3e2fd5d751fdf35c5526d1f1c9b3dd2",
      "https://git.kernel.org/stable/c/ddc210cf8b8a8be68051ad958bf3e2cef6b681c2"
    ],
    "受影响版本": [
      "97d90da8a886949f09bb4754843fb0b504956ad2",
      "97d90da8a886949f09bb4754843fb0b504956ad2",
      "97d90da8a886949f09bb4754843fb0b504956ad2",
      "97d90da8a886949f09bb4754843fb0b504956ad2",
      "97d90da8a886949f09bb4754843fb0b504956ad2",
      "97d90da8a886949f09bb4754843fb0b504956ad2",
      "97d90da8a886949f09bb4754843fb0b504956ad2",
      "97d90da8a886949f09bb4754843fb0b504956ad2",
      "97d90da8a886949f09bb4754843fb0b504956ad2"
    ],
    "公开日期": "2025年05月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37837",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/tegra241-cmdqv: Fix warnings due to dmam_free_coherent()\n\nTwo WARNINGs are observed when SMMU driver rolls back upon failure:\n arm-smmu-v3.9.auto: Failed to register iommu\n arm-smmu-v3.9.auto: probe with driver arm-smmu-v3 failed with error -22\n ------------[ cut here ]------------\n WARNING: CPU: 5 PID: 1 at kernel/dma/mapping.c:74 dmam_free_coherent+0xc0/0xd8\n Call trace:\n  dmam_free_coherent+0xc0/0xd8 (P)\n  tegra241_vintf_free_lvcmdq+0x74/0x188\n  tegra241_cmdqv_remove_vintf+0x60/0x148\n  tegra241_cmdqv_remove+0x48/0xc8\n  arm_smmu_impl_remove+0x28/0x60\n  devm_action_release+0x1c/0x40\n ------------[ cut here ]------------\n 128 pages are still in use!\n WARNING: CPU: 16 PID: 1 at mm/page_alloc.c:6902 free_contig_range+0x18c/0x1c8\n Call trace:\n  free_contig_range+0x18c/0x1c8 (P)\n  cma_release+0x154/0x2f0\n  dma_free_contiguous+0x38/0xa0\n  dma_direct_free+0x10c/0x248\n  dma_free_attrs+0x100/0x290\n  dmam_free_coherent+0x78/0xd8\n  tegra241_vintf_free_lvcmdq+0x74/0x160\n  tegra241_cmdqv_remove+0x98/0x198\n  arm_smmu_impl_remove+0x28/0x60\n  devm_action_release+0x1c/0x40\n\nThis is because the LVCMDQ queue memory are managed by devres, while that\ndmam_free_coherent() is called in the context of devm_action_release().\n\nJason pointed out that \"arm_smmu_impl_probe() has mis-ordered the devres\ncallbacks if ops->device_remove() is going to be manually freeing things\nthat probe allocated\":\nhttps://lore.kernel.org/linux-iommu/20250407174408.GB1722458@nvidia.com/\n\nIn fact, tegra241_cmdqv_init_structures() only allocates memory resources\nwhich means any failure that it generates would be similar to -ENOMEM, so\nthere is no point in having that \"falling back to standard SMMU\" routine,\nas the standard SMMU would likely fail to allocate memory too.\n\nRemove the unwind part in tegra241_cmdqv_init_structures(), and return a\nproper error code to ask SMMU driver to call tegra241_cmdqv_remove() via\nimpl_ops->device_remove(). Then, drop tegra241_vintf_free_lvcmdq() since\ndevres will take care of that.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e5dd974d6e00704553308ef1a88659f8dcfb39d4",
      "https://git.kernel.org/stable/c/5584dbf393df509159813645a487b1ef76557722",
      "https://git.kernel.org/stable/c/e38ed6908080047d8fa1763d1da86b584f9eb55b",
      "https://git.kernel.org/stable/c/767e22001dfce64cc03b7def1562338591ab6031"
    ],
    "受影响版本": [
      "483e0bd8883a40fd3dd3193997a4014337698d72",
      "483e0bd8883a40fd3dd3193997a4014337698d72",
      "483e0bd8883a40fd3dd3193997a4014337698d72",
      "483e0bd8883a40fd3dd3193997a4014337698d72"
    ],
    "公开日期": "2025年05月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37834",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/vmscan: don't try to reclaim hwpoison folio\n\nSyzkaller reports a bug as follows:\n\nInjecting memory failure for pfn 0x18b00e at process virtual address 0x20ffd000\nMemory failure: 0x18b00e: dirty swapcache page still referenced by 2 users\nMemory failure: 0x18b00e: recovery action for dirty swapcache page: Failed\npage: refcount:2 mapcount:0 mapping:0000000000000000 index:0x20ffd pfn:0x18b00e\nmemcg:ffff0000dd6d9000\nanon flags: 0x5ffffe00482011(locked|dirty|arch_1|swapbacked|hwpoison|node=0|zone=2|lastcpupid=0xfffff)\nraw: 005ffffe00482011 dead000000000100 dead000000000122 ffff0000e232a7c9\nraw: 0000000000020ffd 0000000000000000 00000002ffffffff ffff0000dd6d9000\npage dumped because: VM_BUG_ON_FOLIO(!folio_test_uptodate(folio))\n------------[ cut here ]------------\nkernel BUG at mm/swap_state.c:184!\nInternal error: Oops - BUG: 00000000f2000800 [#1] SMP\nModules linked in:\nCPU: 0 PID: 60 Comm: kswapd0 Not tainted 6.6.0-gcb097e7de84e #3\nHardware name: linux,dummy-virt (DT)\npstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : add_to_swap+0xbc/0x158\nlr : add_to_swap+0xbc/0x158\nsp : ffff800087f37340\nx29: ffff800087f37340 x28: fffffc00052c0380 x27: ffff800087f37780\nx26: ffff800087f37490 x25: ffff800087f37c78 x24: ffff800087f377a0\nx23: ffff800087f37c50 x22: 0000000000000000 x21: fffffc00052c03b4\nx20: 0000000000000000 x19: fffffc00052c0380 x18: 0000000000000000\nx17: 296f696c6f662865 x16: 7461646f7470755f x15: 747365745f6f696c\nx14: 6f6621284f494c4f x13: 0000000000000001 x12: ffff600036d8b97b\nx11: 1fffe00036d8b97a x10: ffff600036d8b97a x9 : dfff800000000000\nx8 : 00009fffc9274686 x7 : ffff0001b6c5cbd3 x6 : 0000000000000001\nx5 : ffff0000c25896c0 x4 : 0000000000000000 x3 : 0000000000000000\nx2 : 0000000000000000 x1 : ffff0000c25896c0 x0 : 0000000000000000\nCall trace:\n add_to_swap+0xbc/0x158\n shrink_folio_list+0x12ac/0x2648\n shrink_inactive_list+0x318/0x948\n shrink_lruvec+0x450/0x720\n shrink_node_memcgs+0x280/0x4a8\n shrink_node+0x128/0x978\n balance_pgdat+0x4f0/0xb20\n kswapd+0x228/0x438\n kthread+0x214/0x230\n ret_from_fork+0x10/0x20\n\nI can reproduce this issue with the following steps:\n\n1) When a dirty swapcache page is isolated by reclaim process and the\n   page isn't locked, inject memory failure for the page. \n   me_swapcache_dirty() clears uptodate flag and tries to delete from lru,\n   but fails.  Reclaim process will put the hwpoisoned page back to lru.\n\n2) The process that maps the hwpoisoned page exits, the page is deleted\n   the page will never be freed and will be in the lru forever.\n\n3) If we trigger a reclaim again and tries to reclaim the page,\n   add_to_swap() will trigger VM_BUG_ON_FOLIO due to the uptodate flag is\n   cleared.\n\nTo fix it, skip the hwpoisoned page in shrink_folio_list().  Besides, the\nhwpoison folio may not be unmapped by hwpoison_user_mappings() yet, unmap\nit in shrink_folio_list(), otherwise the folio will fail to be unmaped by\nhwpoison_user_mappings() since the folio isn't in lru list.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1c9798bf8145a92abf45aa9d38a6406d9eb8bdf0",
      "https://git.kernel.org/stable/c/912e9f0300c3564b72a8808db406e313193a37ad",
      "https://git.kernel.org/stable/c/1b0449544c6482179ac84530b61fc192a6527bfd"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月08日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37827",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: zoned: return EIO on RAID1 block group write pointer mismatch\n\nThere was a bug report about a NULL pointer dereference in\n__btrfs_add_free_space_zoned() that ultimately happens because a\nconversion from the default metadata profile DUP to a RAID1 profile on two\ndisks.\n\nThe stack trace has the following signature:\n\n  BTRFS error (device sdc): zoned: write pointer offset mismatch of zones in raid1 profile\n  BUG: kernel NULL pointer dereference, address: 0000000000000058\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD 0 P4D 0\n  Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI\n  RIP: 0010:__btrfs_add_free_space_zoned.isra.0+0x61/0x1a0\n  RSP: 0018:ffffa236b6f3f6d0 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: ffff96c8132f3400 RCX: 0000000000000001\n  RDX: 0000000010000000 RSI: 0000000000000000 RDI: ffff96c8132f3410\n  RBP: 0000000010000000 R08: 0000000000000003 R09: 0000000000000000\n  R10: 0000000000000000 R11: 00000000ffffffff R12: 0000000000000000\n  R13: ffff96c758f65a40 R14: 0000000000000001 R15: 000011aac0000000\n  FS: 00007fdab1cb2900(0000) GS:ffff96e60ca00000(0000) knlGS:0000000000000000\n  CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000058 CR3: 00000001a05ae000 CR4: 0000000000350ef0\n  Call Trace:\n  <TASK>\n  ? __die_body.cold+0x19/0x27\n  ? page_fault_oops+0x15c/0x2f0\n  ? exc_page_fault+0x7e/0x180\n  ? asm_exc_page_fault+0x26/0x30\n  ? __btrfs_add_free_space_zoned.isra.0+0x61/0x1a0\n  btrfs_add_free_space_async_trimmed+0x34/0x40\n  btrfs_add_new_free_space+0x107/0x120\n  btrfs_make_block_group+0x104/0x2b0\n  btrfs_create_chunk+0x977/0xf20\n  btrfs_chunk_alloc+0x174/0x510\n  ? srso_return_thunk+0x5/0x5f\n  btrfs_inc_block_group_ro+0x1b1/0x230\n  btrfs_relocate_block_group+0x9e/0x410\n  btrfs_relocate_chunk+0x3f/0x130\n  btrfs_balance+0x8ac/0x12b0\n  ? srso_return_thunk+0x5/0x5f\n  ? srso_return_thunk+0x5/0x5f\n  ? __kmalloc_cache_noprof+0x14c/0x3e0\n  btrfs_ioctl+0x2686/0x2a80\n  ? srso_return_thunk+0x5/0x5f\n  ? ioctl_has_perm.constprop.0.isra.0+0xd2/0x120\n  __x64_sys_ioctl+0x97/0xc0\n  do_syscall_64+0x82/0x160\n  ? srso_return_thunk+0x5/0x5f\n  ? __memcg_slab_free_hook+0x11a/0x170\n  ? srso_return_thunk+0x5/0x5f\n  ? kmem_cache_free+0x3f0/0x450\n  ? srso_return_thunk+0x5/0x5f\n  ? srso_return_thunk+0x5/0x5f\n  ? syscall_exit_to_user_mode+0x10/0x210\n  ? srso_return_thunk+0x5/0x5f\n  ? do_syscall_64+0x8e/0x160\n  ? sysfs_emit+0xaf/0xc0\n  ? srso_return_thunk+0x5/0x5f\n  ? srso_return_thunk+0x5/0x5f\n  ? seq_read_iter+0x207/0x460\n  ? srso_return_thunk+0x5/0x5f\n  ? vfs_read+0x29c/0x370\n  ? srso_return_thunk+0x5/0x5f\n  ? srso_return_thunk+0x5/0x5f\n  ? syscall_exit_to_user_mode+0x10/0x210\n  ? srso_return_thunk+0x5/0x5f\n  ? do_syscall_64+0x8e/0x160\n  ? srso_return_thunk+0x5/0x5f\n  ? exc_page_fault+0x7e/0x180\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n  RIP: 0033:0x7fdab1e0ca6d\n  RSP: 002b:00007ffeb2b60c80 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n  RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fdab1e0ca6d\n  RDX: 00007ffeb2b60d80 RSI: 00000000c4009420 RDI: 0000000000000003\n  RBP: 00007ffeb2b60cd0 R08: 0000000000000000 R09: 0000000000000013\n  R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\n  R13: 00007ffeb2b6343b R14: 00007ffeb2b60d80 R15: 0000000000000001\n  </TASK>\n  CR2: 0000000000000058\n  ---[ end trace 0000000000000000 ]---\n\nThe 1st line is the most interesting here:\n\n BTRFS error (device sdc): zoned: write pointer offset mismatch of zones in raid1 profile\n\nWhen a RAID1 block-group is created and a write pointer mismatch between\nthe disks in the RAID set is detected, btrfs sets the alloc_offset to the\nlength of the block group marking it as full. Afterwards the code expects\nthat a balance operation will evacuate the data in this block-group and\nrepair the problems.\n\nBut before this is possible, the new space of this block-group will be\naccounted in the free space cache. But in __btrfs_\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9a447f748f6c7287dad68fa91913cd382fa0fcc8",
      "https://git.kernel.org/stable/c/f4717a02cc422cf4bb2dbb280b154a1ae65c5f84",
      "https://git.kernel.org/stable/c/b0c26f47992672661340dd6ea931240213016609"
    ],
    "受影响版本": [
      "b1934cd6069538db2255dc94ba573771ecf3b560",
      "b1934cd6069538db2255dc94ba573771ecf3b560",
      "b1934cd6069538db2255dc94ba573771ecf3b560",
      "e91dab550dd1d2221333cac9f5c012ab5193696f"
    ],
    "公开日期": "2025年05月08日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37780",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nisofs: Prevent the use of too small fid\n\nsyzbot reported a slab-out-of-bounds Read in isofs_fh_to_parent. [1]\n\nThe handle_bytes value passed in by the reproducing program is equal to 12.\nIn handle_to_path(), only 12 bytes of memory are allocated for the structure\nfile_handle->f_handle member, which causes an out-of-bounds access when\naccessing the member parent_block of the structure isofs_fid in isofs,\nbecause accessing parent_block requires at least 16 bytes of f_handle.\nHere, fh_len is used to indirectly confirm that the value of handle_bytes\nis greater than 3 before accessing parent_block.\n\n[1]\nBUG: KASAN: slab-out-of-bounds in isofs_fh_to_parent+0x1b8/0x210 fs/isofs/export.c:183\nRead of size 4 at addr ffff0000cc030d94 by task syz-executor215/6466\nCPU: 1 UID: 0 PID: 6466 Comm: syz-executor215 Not tainted 6.14.0-rc7-syzkaller-ga2392f333575 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/12/2025\nCall trace:\n show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:466 (C)\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0xe4/0x150 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:408 [inline]\n print_report+0x198/0x550 mm/kasan/report.c:521\n kasan_report+0xd8/0x138 mm/kasan/report.c:634\n __asan_report_load4_noabort+0x20/0x2c mm/kasan/report_generic.c:380\n isofs_fh_to_parent+0x1b8/0x210 fs/isofs/export.c:183\n exportfs_decode_fh_raw+0x2dc/0x608 fs/exportfs/expfs.c:523\n do_handle_to_path+0xa0/0x198 fs/fhandle.c:257\n handle_to_path fs/fhandle.c:385 [inline]\n do_handle_open+0x8cc/0xb8c fs/fhandle.c:403\n __do_sys_open_by_handle_at fs/fhandle.c:443 [inline]\n __se_sys_open_by_handle_at fs/fhandle.c:434 [inline]\n __arm64_sys_open_by_handle_at+0x80/0x94 fs/fhandle.c:434\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151\n el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744\n el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762\n el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600\n\nAllocated by task 6466:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x40/0x78 mm/kasan/common.c:68\n kasan_save_alloc_info+0x40/0x50 mm/kasan/generic.c:562\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0xac/0xc4 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4294 [inline]\n __kmalloc_noprof+0x32c/0x54c mm/slub.c:4306\n kmalloc_noprof include/linux/slab.h:905 [inline]\n handle_to_path fs/fhandle.c:357 [inline]\n do_handle_open+0x5a4/0xb8c fs/fhandle.c:403\n __do_sys_open_by_handle_at fs/fhandle.c:443 [inline]\n __se_sys_open_by_handle_at fs/fhandle.c:434 [inline]\n __arm64_sys_open_by_handle_at+0x80/0x94 fs/fhandle.c:434\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151\n el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744\n el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762\n el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ee01a309ebf598be1ff8174901ed6e91619f1749",
      "https://git.kernel.org/stable/c/5e7de55602c61c8ff28db075cc49c8dd6989d7e0",
      "https://git.kernel.org/stable/c/63d5a3e207bf315a32c7d16de6c89753a759f95a",
      "https://git.kernel.org/stable/c/0fdafdaef796816a9ed0fd7ac812932d569d9beb",
      "https://git.kernel.org/stable/c/952e7a7e317f126d0a2b879fc531b716932d5ffa",
      "https://git.kernel.org/stable/c/56dfffea9fd3be0b3795a9ca6401e133a8427e0b",
      "https://git.kernel.org/stable/c/007124c896e7d4614ac1f6bd4dedb975c35a2a8e",
      "https://git.kernel.org/stable/c/0405d4b63d082861f4eaff9d39c78ee9dc34f845"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37775",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: fix the warning from __kernel_write_iter\n\n[ 2110.972290] ------------[ cut here ]------------\n[ 2110.972301] WARNING: CPU: 3 PID: 735 at fs/read_write.c:599 __kernel_write_iter+0x21b/0x280\n\nThis patch doesn't allow writing to directory.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/44079e544c9f6e3e9fb43a16ddf8b08cf686d657",
      "https://git.kernel.org/stable/c/b7ce8db490286c2e009758fa1416d66aeb333614",
      "https://git.kernel.org/stable/c/2a879da5c34a1e5d971e815d5b30f27eb6d69efc",
      "https://git.kernel.org/stable/c/1ed343481ba6911178bc5ca7a51be319eafcc747",
      "https://git.kernel.org/stable/c/b37f2f332b40ad1c27f18682a495850f2f04db0a"
    ],
    "受影响版本": [
      "0626e6641f6b467447c81dd7678a69c66f7746cf",
      "0626e6641f6b467447c81dd7678a69c66f7746cf",
      "0626e6641f6b467447c81dd7678a69c66f7746cf",
      "0626e6641f6b467447c81dd7678a69c66f7746cf",
      "0626e6641f6b467447c81dd7678a69c66f7746cf"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37761",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe: Fix an out-of-bounds shift when invalidating TLB\n\nWhen the size of the range invalidated is larger than\nrounddown_pow_of_two(ULONG_MAX),\nThe function macro roundup_pow_of_two(length) will hit an out-of-bounds\nshift [1].\n\nUse a full TLB invalidation for such cases.\nv2:\n- Use a define for the range size limit over which we use a full\n  TLB invalidation. (Lucas)\n- Use a better calculation of the limit.\n\n[1]:\n[   39.202421] ------------[ cut here ]------------\n[   39.202657] UBSAN: shift-out-of-bounds in ./include/linux/log2.h:57:13\n[   39.202673] shift exponent 64 is too large for 64-bit type 'long unsigned int'\n[   39.202688] CPU: 8 UID: 0 PID: 3129 Comm: xe_exec_system_ Tainted: G     U             6.14.0+ #10\n[   39.202690] Tainted: [U]=USER\n[   39.202690] Hardware name: ASUS System Product Name/PRIME B560M-A AC, BIOS 2001 02/01/2023\n[   39.202691] Call Trace:\n[   39.202692]  <TASK>\n[   39.202695]  dump_stack_lvl+0x6e/0xa0\n[   39.202699]  ubsan_epilogue+0x5/0x30\n[   39.202701]  __ubsan_handle_shift_out_of_bounds.cold+0x61/0xe6\n[   39.202705]  xe_gt_tlb_invalidation_range.cold+0x1d/0x3a [xe]\n[   39.202800]  ? find_held_lock+0x2b/0x80\n[   39.202803]  ? mark_held_locks+0x40/0x70\n[   39.202806]  xe_svm_invalidate+0x459/0x700 [xe]\n[   39.202897]  drm_gpusvm_notifier_invalidate+0x4d/0x70 [drm_gpusvm]\n[   39.202900]  __mmu_notifier_release+0x1f5/0x270\n[   39.202905]  exit_mmap+0x40e/0x450\n[   39.202912]  __mmput+0x45/0x110\n[   39.202914]  exit_mm+0xc5/0x130\n[   39.202916]  do_exit+0x21c/0x500\n[   39.202918]  ? lockdep_hardirqs_on_prepare+0xdb/0x190\n[   39.202920]  do_group_exit+0x36/0xa0\n[   39.202922]  get_signal+0x8f8/0x900\n[   39.202926]  arch_do_signal_or_restart+0x35/0x100\n[   39.202930]  syscall_exit_to_user_mode+0x1fc/0x290\n[   39.202932]  do_syscall_64+0xa1/0x180\n[   39.202934]  ? do_user_addr_fault+0x59f/0x8a0\n[   39.202937]  ? lock_release+0xd2/0x2a0\n[   39.202939]  ? do_user_addr_fault+0x5a9/0x8a0\n[   39.202942]  ? trace_hardirqs_off+0x4b/0xc0\n[   39.202944]  ? clear_bhb_loop+0x25/0x80\n[   39.202946]  ? clear_bhb_loop+0x25/0x80\n[   39.202947]  ? clear_bhb_loop+0x25/0x80\n[   39.202950]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[   39.202952] RIP: 0033:0x7fa945e543e1\n[   39.202961] Code: Unable to access opcode bytes at 0x7fa945e543b7.\n[   39.202962] RSP: 002b:00007ffca8fb4170 EFLAGS: 00000293\n[   39.202963] RAX: 000000000000003d RBX: 0000000000000000 RCX: 00007fa945e543e3\n[   39.202964] RDX: 0000000000000000 RSI: 00007ffca8fb41ac RDI: 00000000ffffffff\n[   39.202964] RBP: 00007ffca8fb4190 R08: 0000000000000000 R09: 00007fa945f600a0\n[   39.202965] R10: 0000000000000000 R11: 0000000000000293 R12: 0000000000000000\n[   39.202966] R13: 00007fa9460dd310 R14: 00007ffca8fb41ac R15: 0000000000000000\n[   39.202970]  </TASK>\n[   39.202970] ---[ end trace ]---\n\n(cherry picked from commit b88f48f86500bc0b44b4f73ac66d500a40d320ad)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/28477f701b63922ff88e9fb13f5519c11cd48b86",
      "https://git.kernel.org/stable/c/e4715858f87b78ce58cfa03bbe140321edbbaf20",
      "https://git.kernel.org/stable/c/7bcfeddb36b77f9fe3b010bb0b282b7618420bba"
    ],
    "受影响版本": [
      "332dd0116c82a75df175a459fa69dda3f23491a7",
      "332dd0116c82a75df175a459fa69dda3f23491a7",
      "332dd0116c82a75df175a459fa69dda3f23491a7"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37754",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915/huc: Fix fence not released on early probe errors\n\nHuC delayed loading fence, introduced with commit 27536e03271da\n(\"drm/i915/huc: track delayed HuC load with a fence\"), is registered with\nobject tracker early on driver probe but unregistered only from driver\nremove, which is not called on early probe errors.  Since its memory is\nallocated under devres, then released anyway, it may happen to be\nallocated again to the fence and reused on future driver probes, resulting\nin kernel warnings that taint the kernel:\n\n<4> [309.731371] ------------[ cut here ]------------\n<3> [309.731373] ODEBUG: init destroyed (active state 0) object: ffff88813d7dd2e0 object type: i915_sw_fence hint: sw_fence_dummy_notify+0x0/0x20 [i915]\n<4> [309.731575] WARNING: CPU: 2 PID: 3161 at lib/debugobjects.c:612 debug_print_object+0x93/0xf0\n...\n<4> [309.731693] CPU: 2 UID: 0 PID: 3161 Comm: i915_module_loa Tainted: G     U             6.14.0-CI_DRM_16362-gf0fd77956987+ #1\n...\n<4> [309.731700] RIP: 0010:debug_print_object+0x93/0xf0\n...\n<4> [309.731728] Call Trace:\n<4> [309.731730]  <TASK>\n...\n<4> [309.731949]  __debug_object_init+0x17b/0x1c0\n<4> [309.731957]  debug_object_init+0x34/0x50\n<4> [309.732126]  __i915_sw_fence_init+0x34/0x60 [i915]\n<4> [309.732256]  intel_huc_init_early+0x4b/0x1d0 [i915]\n<4> [309.732468]  intel_uc_init_early+0x61/0x680 [i915]\n<4> [309.732667]  intel_gt_common_init_early+0x105/0x130 [i915]\n<4> [309.732804]  intel_root_gt_init_early+0x63/0x80 [i915]\n<4> [309.732938]  i915_driver_probe+0x1fa/0xeb0 [i915]\n<4> [309.733075]  i915_pci_probe+0xe6/0x220 [i915]\n<4> [309.733198]  local_pci_probe+0x44/0xb0\n<4> [309.733203]  pci_device_probe+0xf4/0x270\n<4> [309.733209]  really_probe+0xee/0x3c0\n<4> [309.733215]  __driver_probe_device+0x8c/0x180\n<4> [309.733219]  driver_probe_device+0x24/0xd0\n<4> [309.733223]  __driver_attach+0x10f/0x220\n<4> [309.733230]  bus_for_each_dev+0x7d/0xe0\n<4> [309.733236]  driver_attach+0x1e/0x30\n<4> [309.733239]  bus_add_driver+0x151/0x290\n<4> [309.733244]  driver_register+0x5e/0x130\n<4> [309.733247]  __pci_register_driver+0x7d/0x90\n<4> [309.733251]  i915_pci_register_driver+0x23/0x30 [i915]\n<4> [309.733413]  i915_init+0x34/0x120 [i915]\n<4> [309.733655]  do_one_initcall+0x62/0x3f0\n<4> [309.733667]  do_init_module+0x97/0x2a0\n<4> [309.733671]  load_module+0x25ff/0x2890\n<4> [309.733688]  init_module_from_file+0x97/0xe0\n<4> [309.733701]  idempotent_init_module+0x118/0x330\n<4> [309.733711]  __x64_sys_finit_module+0x77/0x100\n<4> [309.733715]  x64_sys_call+0x1f37/0x2650\n<4> [309.733719]  do_syscall_64+0x91/0x180\n<4> [309.733763]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n<4> [309.733792]  </TASK>\n...\n<4> [309.733806] ---[ end trace 0000000000000000 ]---\n\nThat scenario is most easily reproducible with\nigt@i915_module_load@reload-with-fault-injection.\n\nFix the issue by moving the cleanup step to driver release path.\n\n(cherry picked from commit 795dbde92fe5c6996a02a5b579481de73035e7bf)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9f5ef4a5eaa61a7a4ed31231da45deb85065397a",
      "https://git.kernel.org/stable/c/c5a906806162aea62dbe5d327760ce3b7117ca17",
      "https://git.kernel.org/stable/c/4bd4bf79bcfe101f0385ab81dbabb6e3f7d96c00",
      "https://git.kernel.org/stable/c/f104ef4db9f8f3923cc06ed1fafb3da38df6006d",
      "https://git.kernel.org/stable/c/e3ea2eae70692a455e256787e4f54153fb739b90"
    ],
    "受影响版本": [
      "27536e03271da3dafcdddf735102041a26ad5bd0",
      "27536e03271da3dafcdddf735102041a26ad5bd0",
      "27536e03271da3dafcdddf735102041a26ad5bd0",
      "27536e03271da3dafcdddf735102041a26ad5bd0",
      "27536e03271da3dafcdddf735102041a26ad5bd0"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37752",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet_sched: sch_sfq: move the limit validation\n\nIt is not sufficient to directly validate the limit on the data that\nthe user passes as it can be updated based on how the other parameters\nare changed.\n\nMove the check at the end of the configuration update process to also\ncatch scenarios where the limit is indirectly updated, for example\nwith the following configurations:\n\ntc qdisc add dev dummy0 handle 1: root sfq limit 2 flows 1 depth 1\ntc qdisc add dev dummy0 handle 1: root sfq limit 2 flows 1 divisor 1\n\nThis fixes the following syzkaller reported crash:\n\n------------[ cut here ]------------\nUBSAN: array-index-out-of-bounds in net/sched/sch_sfq.c:203:6\nindex 65535 is out of range for type 'struct sfq_head[128]'\nCPU: 1 UID: 0 PID: 3037 Comm: syz.2.16 Not tainted 6.14.0-rc2-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 12/27/2024\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x201/0x300 lib/dump_stack.c:120\n ubsan_epilogue lib/ubsan.c:231 [inline]\n __ubsan_handle_out_of_bounds+0xf5/0x120 lib/ubsan.c:429\n sfq_link net/sched/sch_sfq.c:203 [inline]\n sfq_dec+0x53c/0x610 net/sched/sch_sfq.c:231\n sfq_dequeue+0x34e/0x8c0 net/sched/sch_sfq.c:493\n sfq_reset+0x17/0x60 net/sched/sch_sfq.c:518\n qdisc_reset+0x12e/0x600 net/sched/sch_generic.c:1035\n tbf_reset+0x41/0x110 net/sched/sch_tbf.c:339\n qdisc_reset+0x12e/0x600 net/sched/sch_generic.c:1035\n dev_reset_queue+0x100/0x1b0 net/sched/sch_generic.c:1311\n netdev_for_each_tx_queue include/linux/netdevice.h:2590 [inline]\n dev_deactivate_many+0x7e5/0xe70 net/sched/sch_generic.c:1375",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7d62ded97db6b7c94c891f704151f372b1ba4688",
      "https://git.kernel.org/stable/c/6c589aa318023690f1606c666a7fb5f4c1c9c219",
      "https://git.kernel.org/stable/c/1348214fa042a71406964097e743c87a42c85a49",
      "https://git.kernel.org/stable/c/d2718324f9e329b10ddc091fba5a0ba2b9d4d96a",
      "https://git.kernel.org/stable/c/f86293adce0c201cfabb283ef9d6f21292089bb8",
      "https://git.kernel.org/stable/c/5e5e1fcc1b8ed57f902c424c5d9b328a3a19073d",
      "https://git.kernel.org/stable/c/b36a68192037d1614317a09b0d78c7814e2eecf9",
      "https://git.kernel.org/stable/c/b3bf8f63e6179076b57c9de660c9f80b5abefe70"
    ],
    "受影响版本": [
      "1e6d9d87626cf89eeffb4d943db12cb5b10bf961",
      "1b562b7f9231432da40d12e19786c1bd7df653a7",
      "35d0137305ae2f97260a9047f445bd4434bd6cc7",
      "833e9a1c27b82024db7ff5038a51651f48f05e5e",
      "7d8947f2153ee9c5ab4cb17861a11cc45f30e8c4",
      "7fefc294204f10a3405f175f4ac2be16d63f135e",
      "10685681bafce6febb39770f3387621bf5d67d0b",
      "10685681bafce6febb39770f3387621bf5d67d0b"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-37739",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to avoid out-of-bounds access in f2fs_truncate_inode_blocks()\n\nsyzbot reports an UBSAN issue as below:\n\n------------[ cut here ]------------\nUBSAN: array-index-out-of-bounds in fs/f2fs/node.h:381:10\nindex 18446744073709550692 is out of range for type '__le32[5]' (aka 'unsigned int[5]')\nCPU: 0 UID: 0 PID: 5318 Comm: syz.0.0 Not tainted 6.14.0-rc3-syzkaller-00060-g6537cfb395f3 #0\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n ubsan_epilogue lib/ubsan.c:231 [inline]\n __ubsan_handle_out_of_bounds+0x121/0x150 lib/ubsan.c:429\n get_nid fs/f2fs/node.h:381 [inline]\n f2fs_truncate_inode_blocks+0xa5e/0xf60 fs/f2fs/node.c:1181\n f2fs_do_truncate_blocks+0x782/0x1030 fs/f2fs/file.c:808\n f2fs_truncate_blocks+0x10d/0x300 fs/f2fs/file.c:836\n f2fs_truncate+0x417/0x720 fs/f2fs/file.c:886\n f2fs_file_write_iter+0x1bdb/0x2550 fs/f2fs/file.c:5093\n aio_write+0x56b/0x7c0 fs/aio.c:1633\n io_submit_one+0x8a7/0x18a0 fs/aio.c:2052\n __do_sys_io_submit fs/aio.c:2111 [inline]\n __se_sys_io_submit+0x171/0x2e0 fs/aio.c:2081\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f238798cde9\n\nindex 18446744073709550692 (decimal, unsigned long long)\n= 0xfffffffffffffc64 (hexadecimal, unsigned long long)\n= -924 (decimal, long long)\n\nIn f2fs_truncate_inode_blocks(), UBSAN detects that get_nid() tries to\naccess .i_nid[-924], it means both offset[0] and level should zero.\n\nThe possible case should be in f2fs_do_truncate_blocks(), we try to\ntruncate inode size to zero, however, dn.ofs_in_node is zero and\ndn.node_page is not an inode page, so it fails to truncate inode page,\nand then pass zeroed free_from to f2fs_truncate_inode_blocks(), result\nin this issue.\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\tf2fs_truncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\nI guess the reason why dn.node_page is not an inode page could be: there\nare multiple nat entries share the same node block address, once the node\nblock address was reused, f2fs_get_node_page() may load a non-inode block.\n\nLet's add a sanity check for such condition to avoid out-of-bounds access\nissue.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a67e1bf03c609a751d1740a1789af25e599966fa",
      "https://git.kernel.org/stable/c/67e16ccba74dd8de0a7b10062f1e02d77432f573",
      "https://git.kernel.org/stable/c/98dbf2af63de0b551082c9bc48333910e009b09f",
      "https://git.kernel.org/stable/c/8b5e5aac44fee122947a269f9034c048e4c295de",
      "https://git.kernel.org/stable/c/ecc461331604b07cdbdb7360dbdf78471653264c",
      "https://git.kernel.org/stable/c/d7242fd7946d4cba0411effb6b5048ca55125747",
      "https://git.kernel.org/stable/c/6ba8b41d0aa4b82f90f0c416cb53fcef9696525d",
      "https://git.kernel.org/stable/c/e6494977bd4a83862118a05f57a8df40256951c0"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "i-PRO Co., Ltd.",
    "设备类型": "OTA",
    "产品型号": "Surveillance cameras provided by i-PRO Co., Ltd.",
    "CVE编号": "CVE-2025-36513",
    "漏洞描述": "Cross-site request forgery vulnerability exists in surveillance cameras provided by i-PRO Co., Ltd.. If a user views a crafted page while logged in to the affected product, unintended operations may be performed.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://i-pro.com/products_and_solutions/en/surveillance/solutions/technologies/cyber-security/psirt/security-advisories",
      "https://jvn.jp/en/jp/JVN10964289/"
    ],
    "受影响版本": [
      "see the information provided by the vendor"
    ],
    "公开日期": "2025年06月06日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-3546",
    "漏洞描述": "A vulnerability was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014. It has been declared as critical. Affected by this vulnerability is the function FCGI_CheckStringIfContainsSemicolon of the file /api/wizard/getLanguage of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack can only be done within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://gist.github.com/isstabber/154661f329e4ae6bfe15dcdc0b932ff3",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年04月14日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-3545",
    "漏洞描述": "A vulnerability was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014. It has been classified as critical. Affected is the function FCGI_CheckStringIfContainsSemicolon of the file /api/wizard/setLanguage of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack needs to be approached within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://gist.github.com/isstabber/cc7bc3281c0f0d6659d2f9934e1c57c1",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年04月14日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-3544",
    "漏洞描述": "A vulnerability was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014 and classified as critical. This issue affects the function FCGI_CheckStringIfContainsSemicolon of the file /api/wizard/getCapabilityWeb of the component HTTP POST Request Handler. The manipulation leads to command injection. Access to the local network is required for this attack to succeed. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://gist.github.com/isstabber/05dfeefa3685a369b8802626e0252e27",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年04月14日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-3543",
    "漏洞描述": "A vulnerability has been found in H3C Magic NX15, Magic NX30 Pro, Magic NX400 and Magic R3010 up to V100R014 and classified as critical. This vulnerability affects the function FCGI_WizardProtoProcess of the file /api/wizard/setsyncpppoecfg of the component HTTP POST Request Handler. The manipulation leads to command injection. Access to the local network is required for this attack. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://gist.github.com/mono7s/9369a3ef060b5655303cd234ba583bb5",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年04月14日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-3542",
    "漏洞描述": "A vulnerability, which was classified as critical, was found in H3C Magic NX15, Magic NX400 and Magic R3010 up to V100R014. This affects the function FCGI_WizardProtoProcess of the file /api/wizard/getsyncpppoecfg of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack needs to be initiated within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://gist.github.com/mono7s/dd7a0a1ec444bb2c228590d298e37a5d",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年04月13日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-3541",
    "漏洞描述": "A vulnerability, which was classified as critical, has been found in H3C Magic NX15, Magic NX30 Pro, Magic NX400 and Magic R3010 up to V100R014. Affected by this issue is the function FCGI_WizardProtoProcess of the file /api/wizard/getSpecs of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack needs to be done within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://gist.github.com/mono7s/fcbc1f02d69547704cc9027b29e51c73",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年04月13日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-3540",
    "漏洞描述": "A vulnerability classified as critical was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400 and Magic R3010 up to V100R014. Affected by this vulnerability is the function FCGI_WizardProtoProcess of the file /api/wizard/getCapability of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack can only be initiated within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://gist.github.com/mono7s/882650a9a9b54bedc374caf8308efef2",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年04月13日"
  },
  {
    "设备品牌": "i-PRO Co., Ltd.",
    "设备类型": "OTA",
    "产品型号": "i-PRO Configuration Tool",
    "CVE编号": "CVE-2025-32730",
    "漏洞描述": "Use of hard-coded cryptographic key vulnerability in i-PRO Configuration Tool affects the network system for i-PRO Co., Ltd. surveillance cameras and recorders. This vulnerability allows a local authenticated attacker to use the authentication information from the last connected surveillance cameras and recorders.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://i-pro.com/products_and_solutions/en/surveillance/solutions/technologies/cyber-security/psirt/security-advisories",
      "https://jvn.jp/en/jp/JVN84627857/"
    ],
    "受影响版本": [
      "see the information provided by the vendor"
    ],
    "公开日期": "2025年04月24日"
  },
  {
    "设备品牌": "Matat Technologies",
    "设备类型": "OTA",
    "产品型号": "Deliver via Shipos for WooCommerce",
    "CVE编号": "CVE-2025-32533",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Matat Technologies Deliver via Shipos for WooCommerce allows Reflected XSS. This issue affects Deliver via Shipos for WooCommerce: from n/a through 2.1.7.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/wc-shipos-delivery/vulnerability/wordpress-deliver-via-shipos-for-woocommerce-plugin-2-1-4-reflected-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年04月17日"
  },
  {
    "设备品牌": "Matat Technologies",
    "设备类型": "OTA",
    "产品型号": "TextMe SMS",
    "CVE编号": "CVE-2025-31789",
    "漏洞描述": "Missing Authorization vulnerability in Matat Technologies TextMe SMS allows Exploiting Incorrectly Configured Access Control Security Levels.This issue affects TextMe SMS: from n/a through 1.9.1.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/textme-sms-integration/vulnerability/wordpress-textme-sms-plugin-1-9-1-broken-access-control-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年04月03日"
  },
  {
    "设备品牌": "programphases",
    "设备类型": "OTA",
    "产品型号": "Insert HTML Here",
    "CVE编号": "CVE-2025-31379",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in programphases Insert HTML Here allows Reflected XSS. This issue affects Insert HTML Here: from n/a through 1.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/insert-html-here/vulnerability/wordpress-insert-html-here-plugin-1-0-reflected-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年04月11日"
  },
  {
    "设备品牌": "jupyterlab",
    "设备类型": "OTA",
    "产品型号": "jupyterlab-git",
    "CVE编号": "CVE-2025-30370",
    "漏洞描述": "jupyterlab-git is a JupyterLab extension for version control using Git. On many platforms, a third party can create a Git repository under a name that includes a shell command substitution string in the syntax $(<command>). These directory names are allowed in macOS and a majority of Linux distributions. If a user starts jupyter-lab in a parent directory of this inappropriately-named Git repository, opens it, and clicks \"Git > Open Git Repository in Terminal\" from the menu bar, then the injected command <command> is run in the user's shell without the user's permission. This issue is occurring because when that menu entry is clicked, jupyterlab-git opens the terminal and runs cd <git-repo-path> through the shell to set the current directory. Doing so runs any command substitution strings present in the directory name, which leads to the command injection issue described here. A previous patch provided an incomplete fix. This vulnerability is fixed in 0.51.1.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://github.com/jupyterlab/jupyterlab-git/security/advisories/GHSA-cj5w-8mjf-r5f8",
      "https://github.com/jupyterlab/jupyterlab-git/pull/1196",
      "https://github.com/jupyterlab/jupyterlab-git/commit/b46482993f76d3a546015c6a94ebed8b77fc2376",
      "https://github.com/jupyterlab/jupyterlab-git/blob/7eb3b06f0092223bd5494688ec264527bbeb2195/src/commandsAndMenu.tsx#L175-L184"
    ],
    "受影响版本": [
      "< 0.51.1"
    ],
    "公开日期": "2025年04月03日"
  },
  {
    "设备品牌": "BEC Technologies",
    "设备类型": "OTA",
    "产品型号": "Multiple Routers",
    "CVE编号": "CVE-2025-2773",
    "漏洞描述": "BEC Technologies Multiple Routers sys ping Command Injection Remote Code Execution Vulnerability. This vulnerability allows remote attackers to execute arbitrary code on affected installations of BEC Technologies Multiple Routers. Although authentication is required to exploit this vulnerability, the existing authentication mechanism can be bypassed.\n\nThe specific flaw exists within the management interface, which listens on TCP port 22 by default. The issue results from the lack of proper validation of a user-supplied string before using it to execute a system call. An attacker can leverage this vulnerability to execute code in the context of the device. Was ZDI-CAN-25903.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.zerodayinitiative.com/advisories/ZDI-25-187/"
    ],
    "受影响版本": [
      "1.04.1.512, 1.04.1.542"
    ],
    "公开日期": "2025年04月23日"
  },
  {
    "设备品牌": "BEC Technologies",
    "设备类型": "OTA",
    "产品型号": "Multiple Routers",
    "CVE编号": "CVE-2025-2772",
    "漏洞描述": "BEC Technologies Multiple Routers Insufficiently Protected Credentials Information Disclosure Vulnerability. This vulnerability allows network-adjacent attackers to disclose sensitive information on affected installations of BEC Technologies routers. Authentication is not required to exploit this vulnerability.\n\nThe specific flaw exists within /cgi-bin/tools_usermanage.asp. The issue results from transmitting a list of users and their credentials to be handled on the client side. An attacker can leverage this vulnerability to disclose transported credentials, leading to further compromise. Was ZDI-CAN-25895.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.zerodayinitiative.com/advisories/ZDI-25-185/"
    ],
    "受影响版本": [
      "1.04.1.512, 1.04.1.542"
    ],
    "公开日期": "2025年04月23日"
  },
  {
    "设备品牌": "BEC Technologies",
    "设备类型": "OTA",
    "产品型号": "Multiple Routers",
    "CVE编号": "CVE-2025-2771",
    "漏洞描述": "BEC Technologies Multiple Routers Authentication Bypass Vulnerability. This vulnerability allows remote attackers to bypass authentication on affected installations of BEC Technologies routers. Authentication is not required to exploit this vulnerability.\n\nThe specific flaw exists within the web-based user interface. The issue results from the lack of authentication prior to allowing access to functionality. An attacker can leverage this vulnerability to bypass authentication on the system. Was ZDI-CAN-25894.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.zerodayinitiative.com/advisories/ZDI-25-184/"
    ],
    "受影响版本": [
      "1.04.1.512, 1.04.1.542"
    ],
    "公开日期": "2025年04月23日"
  },
  {
    "设备品牌": "BEC Technologies",
    "设备类型": "OTA",
    "产品型号": "Multiple Routers",
    "CVE编号": "CVE-2025-2770",
    "漏洞描述": "BEC Technologies Multiple Routers Cleartext Password Storage Information Disclosure Vulnerability. This vulnerability allows remote attackers to disclose sensitive information on affected installations of BEC Technologies routers. Authentication is required to exploit this vulnerability.\n\nThe specific flaw exists within the web-based user interface. The issue results from storing credentials in a recoverable format. An attacker can leverage this vulnerability to disclose stored credentials, leading to further compromise. Was ZDI-CAN-25986.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.zerodayinitiative.com/advisories/ZDI-25-186/"
    ],
    "受影响版本": [
      "1.04.1.512, 1.04.1.542"
    ],
    "公开日期": "2025年04月23日"
  },
  {
    "设备品牌": "youki-dev",
    "设备类型": "OTA",
    "产品型号": "youki",
    "CVE编号": "CVE-2025-27612",
    "漏洞描述": "libcontainer is a library for container control. Prior to libcontainer 0.5.3, while creating a tenant container, the tenant builder accepts a list of capabilities to be added in the spec of tenant container. The logic here adds the given capabilities to all capabilities of main container if present in spec, otherwise simply set provided capabilities as capabilities of the tenant container. However, setting inherited caps in any case for tenant container can lead to elevation of capabilities, similar to CVE-2022-29162. This does not affect youki binary itself. This is only applicable if you are using libcontainer directly and using the tenant builder.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://github.com/youki-dev/youki/security/advisories/GHSA-5w4j-f78p-4wh9",
      "https://github.com/opencontainers/runc/security/advisories/GHSA-f3fp-gc8g-vw66",
      "https://github.com/youki-dev/youki/commit/747e342d2026fbf3a395db3e2a491ebef00082f1",
      "https://github.com/youki-dev/youki/blob/9e63fa4da1672a78ca45100f3059a732784a5174/crates/libcontainer/src/container/tenant_builder.rs#L408"
    ],
    "受影响版本": [
      "< 0.5.3"
    ],
    "公开日期": "2025年03月21日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-2732",
    "漏洞描述": "A vulnerability was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014. It has been rated as critical. Affected by this issue is some unknown functionality of the file /api/wizard/getWifiNeighbour of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack needs to be initiated within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/Qwen11/CVE_store/blob/main/H3C/vulnerability%20Information_4.md",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年03月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-2731",
    "漏洞描述": "A vulnerability was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014. It has been declared as critical. Affected by this vulnerability is an unknown functionality of the file /api/wizard/getDualbandSync of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack needs to be done within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/Qwen11/CVE_store/blob/main/H3C/vulnerability%20Information_3.md",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年03月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-2730",
    "漏洞描述": "A vulnerability was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014. It has been classified as critical. Affected is an unknown function of the file /api/wizard/getssidname of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack can only be initiated within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/Qwen11/CVE_store/blob/main/H3C/vulnerability%20Information_2.md",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年03月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-2729",
    "漏洞描述": "A vulnerability was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014 and classified as critical. This issue affects some unknown processing of the file /api/wizard/networkSetup of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack can only be done within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/Qwen11/CVE_store/blob/main/H3C/vulnerability%20Information_1.md",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年03月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX30 Pro",
    "CVE编号": "CVE-2025-2728",
    "漏洞描述": "A vulnerability has been found in H3C Magic NX30 Pro and Magic NX400 up to V100R014 and classified as critical. This vulnerability affects unknown code of the file /api/wizard/getNetworkConf. The manipulation leads to command injection. The attack needs to be approached within the local network. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/RK1Y8/cve_cve/blob/main/h3c.md",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年03月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX30 Pro",
    "CVE编号": "CVE-2025-2727",
    "漏洞描述": "A vulnerability, which was classified as critical, was found in H3C Magic NX30 Pro up to V100R007. This affects an unknown part of the file /api/wizard/getNetworkStatus of the component HTTP POST Request Handler. The manipulation leads to command injection. Access to the local network is required for this attack to succeed. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/ggstrunk/CVE/blob/main/wizard_getNetworkStatus.md",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R007"
    ],
    "公开日期": "2025年03月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-2726",
    "漏洞描述": "A vulnerability, which was classified as critical, has been found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014. Affected by this issue is some unknown functionality of the file /api/esps of the component HTTP POST Request Handler. The manipulation leads to command injection. Access to the local network is required for this attack. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/ZIKH26/CVE-information/blob/master/H3C/Vulnerability%20Information_2.md",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年03月25日"
  },
  {
    "设备品牌": "H3C",
    "设备类型": "OTA",
    "产品型号": "Magic NX15",
    "CVE编号": "CVE-2025-2725",
    "漏洞描述": "A vulnerability classified as critical was found in H3C Magic NX15, Magic NX30 Pro, Magic NX400, Magic R3010 and Magic BE18000 up to V100R014. Affected by this vulnerability is an unknown functionality of the file /api/login/auth of the component HTTP POST Request Handler. The manipulation leads to command injection. The attack needs to be initiated within the local network. The exploit has been disclosed to the public and may be used. It is recommended to upgrade the affected component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/ZIKH26/CVE-information/blob/master/H3C/Vulnerability%20Information_1.md",
      "https://zhiliao.h3c.com/theme/details/229784",
      "https://www.h3c.com/cn/Service/Document_Software/Software_Download/Consume_product/"
    ],
    "受影响版本": [
      "V100R014"
    ],
    "公开日期": "2025年03月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2025-26202",
    "漏洞描述": "Cross-Site Scripting (XSS) vulnerability exists in the WPA/WAPI Passphrase field of the Wireless Security settings (2.4GHz & 5GHz bands) in DZS Router Web Interface. An authenticated attacker can inject malicious JavaScript into the passphrase field, which is stored and later executed when an administrator views the passphrase via the \"Click here to display\" option on the Status page",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/A17-ba/CVE-2025-26202-Details"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年03月04日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2025-25985",
    "漏洞描述": "An issue in Macro-video Technologies Co.,Ltd V380E6_C1 IP camera (Hw_HsAKPIQp_WF_XHR) 1020302 allows a physically proximate attacker to execute arbitrary code via the /mnt/mtd/mvconf/wifi.ini and /mnt/mtd/mvconf/user_info.ini components.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/vladko312/Research_v380_IP_camera",
      "https://github.com/vladko312/Research_v380_IP_camera/blob/main/CVE-2025-25985.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年04月18日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2025-25984",
    "漏洞描述": "An issue in Macro-video Technologies Co.,Ltd V380E6_C1 IP camera (Hw_HsAKPIQp_WF_XHR) 1020302 allows a physically proximate attacker to execute arbitrary code via UART component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/vladko312/Research_v380_IP_camera",
      "https://github.com/vladko312/Research_v380_IP_camera/blob/main/CVE-2025-25984.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年04月18日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2025-25983",
    "漏洞描述": "An issue in Macro-video Technologies Co.,Ltd V380 Pro android application 2.1.44 and V380 Pro android application 2.1.64 allows an attacker to obtain sensitive information via the QE code based sharing component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/vladko312/Research_v380_IP_camera",
      "https://github.com/vladko312/Research_v380_IP_camera/blob/main/CVE-2025-25983.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年04月18日"
  },
  {
    "设备品牌": "Impact Technologies",
    "设备类型": "OTA",
    "产品型号": "ITIUM 6050",
    "CVE编号": "CVE-2025-2597",
    "漏洞描述": "Reflected Cross-Site Scripting (XSS) in ITIUM 6050 version 5.5.5.2-b3526 from Impact Technologies. This vulnerability could allow an attacker to execute malicious Javascript code via GET and POST requests to the ‘/index.php’ endpoint and injecting code into the ‘id_session.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.incibe.es/en/incibe-cert/notices/aviso/reflected-cross-site-scripting-xss-vulnerability-itium-6050"
    ],
    "受影响版本": [
      "5.5.5.2-b3526"
    ],
    "公开日期": "2025年03月21日"
  },
  {
    "设备品牌": "EBM Technologies",
    "设备类型": "OTA",
    "产品型号": "EBM Maintenance Center",
    "CVE编号": "CVE-2025-2585",
    "漏洞描述": "EBM Maintenance Center From EBM Technologies has a SQL Injection vulnerability, allowing remote attackers with regular privileges to inject arbitrary SQL commands to read, modify, and delete database contents.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.twcert.org.tw/tw/cp-132-10021-8786e-1.html",
      "https://www.twcert.org.tw/en/cp-139-10022-8e28e-2.html"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2025年03月21日"
  },
  {
    "设备品牌": "team-alembic",
    "设备类型": "OTA",
    "产品型号": "ash_authentication",
    "CVE编号": "CVE-2025-25202",
    "漏洞描述": "Ash Authentication is an authentication framework for Elixir applications. Applications which have been bootstrapped by the igniter installer present since AshAuthentication v4.1.0 and who have used the magic link strategy _or_ are manually revoking tokens are affected by revoked tokens being allowed to verify as valid. Unless one hase implemented any kind of custom token revocation feature in your application, then one will not be affected. The impact here for users using builtin functionality is that magic link tokens are reusable until they expire. With that said, magic link tokens are only valid for 10 minutes, so the surface area for abuse is extremely low here. The flaw is patched in version 4.4.9. Additionally a compile time warning is shown to users with remediation instructions if they upgrade. 4.4.9 ships with an upgrader, so those who use `mix igniter.upgrade ash_authentication` will have the necessary patch applied. Otherwise, one may run the upgrader manually as described in the error message. As a workaround, delete the generated `:revoked?` generic action in the token resource. This will cause it to use the one internal to Ash Authentication which has always been correct. Alternatively, manually make the changes that are included in the patch.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/team-alembic/ash_authentication/security/advisories/GHSA-qrm9-f75w-hg4c",
      "https://github.com/team-alembic/ash_authentication/commit/2dee55252df26fe3d990ff1199397cdcf1bfea8a"
    ],
    "受影响版本": [
      ">= 4.1.0, < 4.4.9"
    ],
    "公开日期": "2025年02月11日"
  },
  {
    "设备品牌": "Teplitsa. Technologies for Social Good",
    "设备类型": "OTA",
    "产品型号": "ShMapper by Teplitsa",
    "CVE编号": "CVE-2025-24674",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Teplitsa. Technologies for Social Good ShMapper by Teplitsa allows Stored XSS. This issue affects ShMapper by Teplitsa: from n/a through 1.5.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/shmapper-by-teplitsa/vulnerability/wordpress-shmapper-by-teplitsa-plugin-1-5-0-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年01月24日"
  },
  {
    "设备品牌": "Laymance Technologies LLC",
    "设备类型": "OTA",
    "产品型号": "MachForm Shortcode",
    "CVE编号": "CVE-2025-24636",
    "漏洞描述": "Cross-Site Request Forgery (CSRF) vulnerability in Laymance Technologies LLC MachForm Shortcode allows Stored XSS. This issue affects MachForm Shortcode: from n/a through 1.4.1.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/machform-shortcode/vulnerability/wordpress-machform-shortcode-plugin-1-4-1-csrf-to-stored-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年01月24日"
  },
  {
    "设备品牌": "Thorn Technologies LLC",
    "设备类型": "OTA",
    "产品型号": "Cache Sniper for Nginx",
    "CVE编号": "CVE-2025-23776",
    "漏洞描述": "Missing Authorization vulnerability in Thorn Technologies LLC Cache Sniper for Nginx allows Exploiting Incorrectly Configured Access Control Security Levels.This issue affects Cache Sniper for Nginx: from n/a through 1.0.4.2.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/snipe-nginx-cache/vulnerability/wordpress-cache-sniper-for-nginx-plugin-1-0-4-2-broken-access-control-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年01月16日"
  },
  {
    "设备品牌": "Wizcrew Technologies",
    "设备类型": "OTA",
    "产品型号": "go Social",
    "CVE编号": "CVE-2025-23426",
    "漏洞描述": "Cross-Site Request Forgery (CSRF) vulnerability in Wizcrew Technologies go Social allows Stored XSS.This issue affects go Social: from n/a through 1.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/go-social/vulnerability/wordpress-go-social-plugin-1-0-csrf-to-stored-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2025年01月16日"
  },
  {
    "设备品牌": "Google",
    "设备类型": "OTA",
    "产品型号": "AngularJS",
    "CVE编号": "CVE-2025-2336",
    "漏洞描述": "Improper sanitization of the value of the 'href' and 'xlink:href' attributes in '<image>' SVG elements in AngularJS's 'ngSanitize' module allows attackers to bypass common image source restrictions. This can lead to a form of  Content Spoofing https://owasp.org/www-community/attacks/Content_Spoofing  and also negatively affect the application's performance and behavior by using too large or slow-to-load images.\n\nThis issue affects AngularJS versions greater than or equal to 1.3.1.\n\nNote:\nThe AngularJS project is End-of-Life and will not receive any updates to address this issue. For more information see  here https://docs.angularjs.org/misc/version-support-status .",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.herodevs.com/vulnerability-directory/cve-2025-2336",
      "https://codepen.io/herodevs/pen/bNGYaXx/412a3a4218387479898912f60c269c6c"
    ],
    "受影响版本": [
      ">=1.3.1"
    ],
    "公开日期": "2025年06月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-23162",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe/vf: Don't try to trigger a full GT reset if VF\n\nVFs don't have access to the GDRST(0x941c) register that driver\nuses to reset a GT. Attempt to trigger a reset using debugfs:\n\n $ cat /sys/kernel/debug/dri/0000:00:02.1/gt0/force_reset\n\nor due to a hang condition detected by the driver leads to:\n\n [ ] xe 0000:00:02.1: [drm] GT0: trying reset from force_reset [xe]\n [ ] xe 0000:00:02.1: [drm] GT0: reset queued\n [ ] xe 0000:00:02.1: [drm] GT0: reset started\n [ ] ------------[ cut here ]------------\n [ ] xe 0000:00:02.1: [drm] GT0: VF is trying to write 0x1 to an inaccessible register 0x941c+0x0\n [ ] WARNING: CPU: 3 PID: 3069 at drivers/gpu/drm/xe/xe_gt_sriov_vf.c:996 xe_gt_sriov_vf_write32+0xc6/0x580 [xe]\n [ ] RIP: 0010:xe_gt_sriov_vf_write32+0xc6/0x580 [xe]\n [ ] Call Trace:\n [ ]  <TASK>\n [ ]  ? show_regs+0x6c/0x80\n [ ]  ? __warn+0x93/0x1c0\n [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe]\n [ ]  ? report_bug+0x182/0x1b0\n [ ]  ? handle_bug+0x6e/0xb0\n [ ]  ? exc_invalid_op+0x18/0x80\n [ ]  ? asm_exc_invalid_op+0x1b/0x20\n [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe]\n [ ]  ? xe_gt_sriov_vf_write32+0xc6/0x580 [xe]\n [ ]  ? xe_gt_tlb_invalidation_reset+0xef/0x110 [xe]\n [ ]  ? __mutex_unlock_slowpath+0x41/0x2e0\n [ ]  xe_mmio_write32+0x64/0x150 [xe]\n [ ]  do_gt_reset+0x2f/0xa0 [xe]\n [ ]  gt_reset_worker+0x14e/0x1e0 [xe]\n [ ]  process_one_work+0x21c/0x740\n [ ]  worker_thread+0x1db/0x3c0\n\nFix that by sending H2G VF_RESET(0x5507) action instead.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2eec2fa8666dcecebae33a565a818c9de9af8b50",
      "https://git.kernel.org/stable/c/90b16edb3213e4ae4a3138bb20703ae367e88a01",
      "https://git.kernel.org/stable/c/a9bc61a61372897886f58fdaa5582e3f7bf9a50b",
      "https://git.kernel.org/stable/c/459777724d306315070d24608fcd89aea85516d6"
    ],
    "受影响版本": [
      "dd08ebf6c3525a7ea2186e636df064ea47281987",
      "dd08ebf6c3525a7ea2186e636df064ea47281987",
      "dd08ebf6c3525a7ea2186e636df064ea47281987",
      "dd08ebf6c3525a7ea2186e636df064ea47281987"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-23145",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: fix NULL pointer in can_accept_new_subflow\n\nWhen testing valkey benchmark tool with MPTCP, the kernel panics in\n'mptcp_can_accept_new_subflow' because subflow_req->msk is NULL.\n\nCall trace:\n\n  mptcp_can_accept_new_subflow (./net/mptcp/subflow.c:63 (discriminator 4)) (P)\n  subflow_syn_recv_sock (./net/mptcp/subflow.c:854)\n  tcp_check_req (./net/ipv4/tcp_minisocks.c:863)\n  tcp_v4_rcv (./net/ipv4/tcp_ipv4.c:2268)\n  ip_protocol_deliver_rcu (./net/ipv4/ip_input.c:207)\n  ip_local_deliver_finish (./net/ipv4/ip_input.c:234)\n  ip_local_deliver (./net/ipv4/ip_input.c:254)\n  ip_rcv_finish (./net/ipv4/ip_input.c:449)\n  ...\n\nAccording to the debug log, the same req received two SYN-ACK in a very\nshort time, very likely because the client retransmits the syn ack due\nto multiple reasons.\n\nEven if the packets are transmitted with a relevant time interval, they\ncan be processed by the server on different CPUs concurrently). The\n'subflow_req->msk' ownership is transferred to the subflow the first,\nand there will be a risk of a null pointer dereference here.\n\nThis patch fixes this issue by moving the 'subflow_req->msk' under the\n`own_req == true` conditional.\n\nNote that the !msk check in subflow_hmac_valid() can be dropped, because\nthe same check already exists under the own_req mpj branch where the\ncode has been moved to.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8cf7fef1bb2ffea7792bcbf71ca00216cecc725d",
      "https://git.kernel.org/stable/c/b3088bd2a6790c8efff139d86d7a9d0b1305977b",
      "https://git.kernel.org/stable/c/855bf0aacd51fced11ea9aa0d5101ee0febaeadb",
      "https://git.kernel.org/stable/c/7f9ae060ed64aef8f174c5f1ea513825b1be9af1",
      "https://git.kernel.org/stable/c/dc81e41a307df523072186b241fa8244fecd7803",
      "https://git.kernel.org/stable/c/efd58a8dd9e7a709a90ee486a4247c923d27296f",
      "https://git.kernel.org/stable/c/4b2649b9717678aeb097893cc49f59311a1ecab0",
      "https://git.kernel.org/stable/c/443041deb5ef6a1289a99ed95015ec7442f141dc"
    ],
    "受影响版本": [
      "9466a1ccebbe54ac57fb8a89c2b4b854826546a8",
      "9466a1ccebbe54ac57fb8a89c2b4b854826546a8",
      "9466a1ccebbe54ac57fb8a89c2b4b854826546a8",
      "9466a1ccebbe54ac57fb8a89c2b4b854826546a8",
      "9466a1ccebbe54ac57fb8a89c2b4b854826546a8",
      "9466a1ccebbe54ac57fb8a89c2b4b854826546a8",
      "9466a1ccebbe54ac57fb8a89c2b4b854826546a8",
      "9466a1ccebbe54ac57fb8a89c2b4b854826546a8"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-23144",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbacklight: led_bl: Hold led_access lock when calling led_sysfs_disable()\n\nLockdep detects the following issue on led-backlight removal:\n  [  142.315935] ------------[ cut here ]------------\n  [  142.315954] WARNING: CPU: 2 PID: 292 at drivers/leds/led-core.c:455 led_sysfs_enable+0x54/0x80\n  ...\n  [  142.500725] Call trace:\n  [  142.503176]  led_sysfs_enable+0x54/0x80 (P)\n  [  142.507370]  led_bl_remove+0x80/0xa8 [led_bl]\n  [  142.511742]  platform_remove+0x30/0x58\n  [  142.515501]  device_remove+0x54/0x90\n  ...\n\nIndeed, led_sysfs_enable() has to be called with the led_access\nlock held.\n\nHold the lock when calling led_sysfs_disable().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/87d947a0607be384bfe7bb0935884a711e35ca07",
      "https://git.kernel.org/stable/c/74c7d67a3c305fc1fa03c32a838e8446fb7aee14",
      "https://git.kernel.org/stable/c/b447885ec9130cf86f355e011dc6b94d6ccfb5b7",
      "https://git.kernel.org/stable/c/1c82f5a393d8b9a5c1ea032413719862098afd4b",
      "https://git.kernel.org/stable/c/61a5c565fd2442d3128f3bab5f022658adc3a4e6",
      "https://git.kernel.org/stable/c/11d128f7eacec276c75cf4712880a6307ca9c885",
      "https://git.kernel.org/stable/c/b8ddf5107f53789448900f04fa220f34cd2f777e",
      "https://git.kernel.org/stable/c/276822a00db3c1061382b41e72cafc09d6a0ec30"
    ],
    "受影响版本": [
      "ae232e45acf9621f2c96b41ca3af006ac7552c33",
      "ae232e45acf9621f2c96b41ca3af006ac7552c33",
      "ae232e45acf9621f2c96b41ca3af006ac7552c33",
      "ae232e45acf9621f2c96b41ca3af006ac7552c33",
      "ae232e45acf9621f2c96b41ca3af006ac7552c33",
      "ae232e45acf9621f2c96b41ca3af006ac7552c33",
      "ae232e45acf9621f2c96b41ca3af006ac7552c33",
      "ae232e45acf9621f2c96b41ca3af006ac7552c33"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-23132",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: quota: fix to avoid warning in dquot_writeback_dquots()\n\nF2FS-fs (dm-59): checkpoint=enable has some unwritten data.\n\n------------[ cut here ]------------\nWARNING: CPU: 6 PID: 8013 at fs/quota/dquot.c:691 dquot_writeback_dquots+0x2fc/0x308\npc : dquot_writeback_dquots+0x2fc/0x308\nlr : f2fs_quota_sync+0xcc/0x1c4\nCall trace:\ndquot_writeback_dquots+0x2fc/0x308\nf2fs_quota_sync+0xcc/0x1c4\nf2fs_write_checkpoint+0x3d4/0x9b0\nf2fs_issue_checkpoint+0x1bc/0x2c0\nf2fs_sync_fs+0x54/0x150\nf2fs_do_sync_file+0x2f8/0x814\n__f2fs_ioctl+0x1960/0x3244\nf2fs_ioctl+0x54/0xe0\n__arm64_sys_ioctl+0xa8/0xe4\ninvoke_syscall+0x58/0x114\n\ncheckpoint and f2fs_remount may race as below, resulting triggering warning\nin dquot_writeback_dquots().\n\natomic write                                    remount\n                                                - do_remount\n                                                 - down_write(&sb->s_umount);\n                                                  - f2fs_remount\n- ioctl\n - f2fs_do_sync_file\n  - f2fs_sync_fs\n   - f2fs_write_checkpoint\n    - block_operations\n     - locked = down_read_trylock(&sbi->sb->s_umount)\n       : fail to lock due to the write lock was held by remount\n                                                 - up_write(&sb->s_umount);\n     - f2fs_quota_sync\n      - dquot_writeback_dquots\n       - WARN_ON_ONCE(!rwsem_is_locked(&sb->s_umount))\n       : trigger warning because s_umount lock was unlocked by remount\n\nIf checkpoint comes from mount/umount/remount/freeze/quotactl, caller of\ncheckpoint has already held s_umount lock, calling dquot_writeback_dquots()\nin the context should be safe.\n\nSo let's record task to sbi->umount_lock_holder, so that checkpoint can\nknow whether the lock has held in the context or not by checking current\nw/ it.\n\nIn addition, in order to not misrepresent caller of checkpoint, we should\nnot allow to trigger async checkpoint for those callers: mount/umount/remount/\nfreeze/quotactl.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d7acf0a6c87aa282c86a36dbaa2f92fda88c5884",
      "https://git.kernel.org/stable/c/eb85c2410d6f581e957cd03a644ff6ddbe592af9"
    ],
    "受影响版本": [
      "af033b2aa8a874fd5737fafe90d159136527b5b4",
      "af033b2aa8a874fd5737fafe90d159136527b5b4"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-23130",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to avoid panic once fallocation fails for pinfile\n\nsyzbot reports a f2fs bug as below:\n\n------------[ cut here ]------------\nkernel BUG at fs/f2fs/segment.c:2746!\nCPU: 0 UID: 0 PID: 5323 Comm: syz.0.0 Not tainted 6.13.0-rc2-syzkaller-00018-g7cb1b4663150 #0\nRIP: 0010:get_new_segment fs/f2fs/segment.c:2746 [inline]\nRIP: 0010:new_curseg+0x1f52/0x1f70 fs/f2fs/segment.c:2876\nCall Trace:\n <TASK>\n __allocate_new_segment+0x1ce/0x940 fs/f2fs/segment.c:3210\n f2fs_allocate_new_section fs/f2fs/segment.c:3224 [inline]\n f2fs_allocate_pinning_section+0xfa/0x4e0 fs/f2fs/segment.c:3238\n f2fs_expand_inode_data+0x696/0xca0 fs/f2fs/file.c:1830\n f2fs_fallocate+0x537/0xa10 fs/f2fs/file.c:1940\n vfs_fallocate+0x569/0x6e0 fs/open.c:327\n do_vfs_ioctl+0x258c/0x2e40 fs/ioctl.c:885\n __do_sys_ioctl fs/ioctl.c:904 [inline]\n __se_sys_ioctl+0x80/0x170 fs/ioctl.c:892\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nConcurrent pinfile allocation may run out of free section, result in\npanic in get_new_segment(), let's expand pin_sem lock coverage to\ninclude f2fs_gc(), so that we can make sure to reclaim enough free\nspace for following allocation.\n\nIn addition, do below changes to enhance error path handling:\n- call f2fs_bug_on() only in non-pinfile allocation path in\nget_new_segment().\n- call reset_curseg_fields() to reset all fields of curseg in\nnew_curseg()",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9392862608d081a8346a3b841f862d732fce954b",
      "https://git.kernel.org/stable/c/48ea8b200414ac69ea96f4c231f5c7ef1fbeffef"
    ],
    "受影响版本": [
      "f5a53edcf01eae21dc3ef1845515229e8459e5cc",
      "f5a53edcf01eae21dc3ef1845515229e8459e5cc"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Sechard Information Technologies",
    "设备类型": "OTA",
    "产品型号": "SecHard",
    "CVE编号": "CVE-2025-2311",
    "漏洞描述": "Incorrect Use of Privileged APIs, Cleartext Transmission of Sensitive Information, Insufficiently Protected Credentials vulnerability in Sechard Information Technologies SecHard allows Authentication Bypass, Interface Manipulation, Authentication Abuse, Harvesting Information via API Event Monitoring.This issue affects SecHard: before 3.3.0.20220411.",
    "攻击向量": "ADJACENT_NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-25-0074"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2025年03月20日"
  },
  {
    "设备品牌": "smub",
    "设备类型": "OTA",
    "产品型号": "Easy Digital Downloads – eCommerce Payments and Subscriptions made easy",
    "CVE编号": "CVE-2025-2252",
    "漏洞描述": "The Easy Digital Downloads – eCommerce Payments and Subscriptions made easy plugin for WordPress is vulnerable to Sensitive Information Exposure in all versions up to, and including, 3.3.6.1 via the edd_ajax_get_download_title() function. This makes it possible for unauthenticated attackers to extract private post titles of downloads. The impact here is minimal.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.wordfence.com/threat-intel/vulnerabilities/id/9e0e3b81-55fe-46b2-bae1-d7321d74c485?source=cve",
      "https://plugins.trac.wordpress.org/browser/easy-digital-downloads/tags/3.3.6.1/includes/ajax-functions.php#L466",
      "https://plugins.trac.wordpress.org/browser/easy-digital-downloads/tags/3.3.6.1/includes/ajax-functions.php#L459",
      "https://plugins.trac.wordpress.org/changeset/3257409/easy-digital-downloads/trunk/includes/ajax-functions.php?contextall=1",
      "https://plugins.trac.wordpress.org/changeset/3257409/easy-digital-downloads/trunk/includes/ajax-functions.php?old=3226442&old_path=easy-digital-downloads%2Ftrunk%2Fincludes%2Fajax-functions.php"
    ],
    "受影响版本": [
      "*"
    ],
    "公开日期": "2025年03月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22124",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/md-bitmap: fix wrong bitmap_limit for clustermd when write sb\n\nIn clustermd, separate write-intent-bitmaps are used for each cluster\nnode:\n\n0                    4k                     8k                    12k\n-------------------------------------------------------------------\n| idle                | md super            | bm super [0] + bits |\n| bm bits[0, contd]   | bm super[1] + bits  | bm bits[1, contd]   |\n| bm super[2] + bits  | bm bits [2, contd]  | bm super[3] + bits  |\n| bm bits [3, contd]  |                     |                     |\n\nSo in node 1, pg_index in __write_sb_page() could equal to\nbitmap->storage.file_pages. Then bitmap_limit will be calculated to\n0. md_super_write() will be called with 0 size.\nThat means the first 4k sb area of node 1 will never be updated\nthrough filemap_write_page().\nThis bug causes hang of mdadm/clustermd_tests/01r1_Grow_resize.\n\nHere use (pg_index % bitmap->storage.file_pages) to make calculation\nof bitmap_limit correct.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/bc3a9788961631359527763d7e1fcf26554c7cb1",
      "https://git.kernel.org/stable/c/6130825f34d41718c98a9b1504a79a23e379701e"
    ],
    "受影响版本": [
      "ab99a87542f194f28e2364a42afbf9fb48b1c724",
      "ab99a87542f194f28e2364a42afbf9fb48b1c724",
      "655cc01889fa9b65441922565cddee64af49e6d6",
      "5600d6013c634c2b6b6c6c55c8ecb50c3a6211f2"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22113",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: avoid journaling sb update on error if journal is destroying\n\nPresently we always BUG_ON if trying to start a transaction on a journal marked\nwith JBD2_UNMOUNT, since this should never happen. However, while ltp running\nstress tests, it was observed that in case of some error handling paths, it is\npossible for update_super_work to start a transaction after the journal is\ndestroyed eg:\n\n(umount)\next4_kill_sb\n  kill_block_super\n    generic_shutdown_super\n      sync_filesystem /* commits all txns */\n      evict_inodes\n        /* might start a new txn */\n      ext4_put_super\n\tflush_work(&sbi->s_sb_upd_work) /* flush the workqueue */\n        jbd2_journal_destroy\n          journal_kill_thread\n            journal->j_flags |= JBD2_UNMOUNT;\n          jbd2_journal_commit_transaction\n            jbd2_journal_get_descriptor_buffer\n              jbd2_journal_bmap\n                ext4_journal_bmap\n                  ext4_map_blocks\n                    ...\n                    ext4_inode_error\n                      ext4_handle_error\n                        schedule_work(&sbi->s_sb_upd_work)\n\n                                               /* work queue kicks in */\n                                               update_super_work\n                                                 jbd2_journal_start\n                                                   start_this_handle\n                                                     BUG_ON(journal->j_flags &\n                                                            JBD2_UNMOUNT)\n\nHence, introduce a new mount flag to indicate journal is destroying and only do\na journaled (and deferred) update of sb if this flag is not set. Otherwise, just\nfallback to an un-journaled commit.\n\nFurther, in the journal destroy path, we have the following sequence:\n\n  1. Set mount flag indicating journal is destroying\n  2. force a commit and wait for it\n  3. flush pending sb updates\n\nThis sequence is important as it ensures that, after this point, there is no sb\nupdate that might be journaled so it is safe to update the sb outside the\njournal. (To avoid race discussed in 2d01ddc86606)\n\nAlso, we don't need a similar check in ext4_grp_locked_error since it is only\ncalled from mballoc and AFAICT it would be always valid to schedule work here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/db05767b5bc307143d99fe2afd8c43af58d2ebef",
      "https://git.kernel.org/stable/c/ce2f26e73783b4a7c46a86e3af5b5c8de0971790"
    ],
    "受影响版本": [
      "2d01ddc86606564fb08c56e3bc93a0693895f710",
      "2d01ddc86606564fb08c56e3bc93a0693895f710"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22109",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nax25: Remove broken autobind\n\nBinding AX25 socket by using the autobind feature leads to memory leaks\nin ax25_connect() and also refcount leaks in ax25_release(). Memory\nleak was detected with kmemleak:\n\n================================================================\nunreferenced object 0xffff8880253cd680 (size 96):\nbacktrace:\n__kmalloc_node_track_caller_noprof (./include/linux/kmemleak.h:43)\nkmemdup_noprof (mm/util.c:136)\nax25_rt_autobind (net/ax25/ax25_route.c:428)\nax25_connect (net/ax25/af_ax25.c:1282)\n__sys_connect_file (net/socket.c:2045)\n__sys_connect (net/socket.c:2064)\n__x64_sys_connect (net/socket.c:2067)\ndo_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83)\nentry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)\n================================================================\n\nWhen socket is bound, refcounts must be incremented the way it is done\nin ax25_bind() and ax25_setsockopt() (SO_BINDTODEVICE). In case of\nautobind, the refcounts are not incremented.\n\nThis bug leads to the following issue reported by Syzkaller:\n\n================================================================\nax25_connect(): syz-executor318 uses autobind, please contact jreuter@yaina.de\n------------[ cut here ]------------\nrefcount_t: decrement hit 0; leaking memory.\nWARNING: CPU: 0 PID: 5317 at lib/refcount.c:31 refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c:31\nModules linked in:\nCPU: 0 UID: 0 PID: 5317 Comm: syz-executor318 Not tainted 6.14.0-rc4-syzkaller-00278-gece144f151ac #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c:31\n...\nCall Trace:\n <TASK>\n __refcount_dec include/linux/refcount.h:336 [inline]\n refcount_dec include/linux/refcount.h:351 [inline]\n ref_tracker_free+0x6af/0x7e0 lib/ref_tracker.c:236\n netdev_tracker_free include/linux/netdevice.h:4302 [inline]\n netdev_put include/linux/netdevice.h:4319 [inline]\n ax25_release+0x368/0x960 net/ax25/af_ax25.c:1080\n __sock_release net/socket.c:647 [inline]\n sock_close+0xbc/0x240 net/socket.c:1398\n __fput+0x3e9/0x9f0 fs/file_table.c:464\n __do_sys_close fs/open.c:1580 [inline]\n __se_sys_close fs/open.c:1565 [inline]\n __x64_sys_close+0x7f/0x110 fs/open.c:1565\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n ...\n </TASK>\n================================================================\n\nConsidering the issues above and the comments left in the code that say:\n\"check if we can remove this feature. It is broken.\"; \"autobinding in this\nmay or may not work\"; - it is better to completely remove this feature than\nto fix it because it is broken and leads to various kinds of memory bugs.\n\nNow calling connect() without first binding socket will result in an\nerror (-EINVAL). Userspace software that relies on the autobind feature\nmight get broken. However, this feature does not seem widely used with\nthis specific driver as it was not reliable at any point of time, and it\nis already broken anyway. E.g. ax25-tools and ax25-apps packages for\npopular distributions do not use the autobind feature for AF_AX25.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/61203fdd3e35519db9a98b6ff8983c620ffc4696",
      "https://git.kernel.org/stable/c/2f6efbabceb6b2914ee9bafb86d9a51feae9cce8"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22105",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbonding: check xdp prog when set bond mode\n\nFollowing operations can trigger a warning[1]:\n\n    ip netns add ns1\n    ip netns exec ns1 ip link add bond0 type bond mode balance-rr\n    ip netns exec ns1 ip link set dev bond0 xdp obj af_xdp_kern.o sec xdp\n    ip netns exec ns1 ip link set bond0 type bond mode broadcast\n    ip netns del ns1\n\nWhen delete the namespace, dev_xdp_uninstall() is called to remove xdp\nprogram on bond dev, and bond_xdp_set() will check the bond mode. If bond\nmode is changed after attaching xdp program, the warning may occur.\n\nSome bond modes (broadcast, etc.) do not support native xdp. Set bond mode\nwith xdp program attached is not good. Add check for xdp program when set\nbond mode.\n\n    [1]\n    ------------[ cut here ]------------\n    WARNING: CPU: 0 PID: 11 at net/core/dev.c:9912 unregister_netdevice_many_notify+0x8d9/0x930\n    Modules linked in:\n    CPU: 0 UID: 0 PID: 11 Comm: kworker/u4:0 Not tainted 6.14.0-rc4 #107\n    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.15.0-0-g2dd4b9b3f840-prebuilt.qemu.org 04/01/2014\n    Workqueue: netns cleanup_net\n    RIP: 0010:unregister_netdevice_many_notify+0x8d9/0x930\n    Code: 00 00 48 c7 c6 6f e3 a2 82 48 c7 c7 d0 b3 96 82 e8 9c 10 3e ...\n    RSP: 0018:ffffc90000063d80 EFLAGS: 00000282\n    RAX: 00000000ffffffa1 RBX: ffff888004959000 RCX: 00000000ffffdfff\n    RDX: 0000000000000000 RSI: 00000000ffffffea RDI: ffffc90000063b48\n    RBP: ffffc90000063e28 R08: ffffffff82d39b28 R09: 0000000000009ffb\n    R10: 0000000000000175 R11: ffffffff82d09b40 R12: ffff8880049598e8\n    R13: 0000000000000001 R14: dead000000000100 R15: ffffc90000045000\n    FS:  0000000000000000(0000) GS:ffff888007a00000(0000) knlGS:0000000000000000\n    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    CR2: 000000000d406b60 CR3: 000000000483e000 CR4: 00000000000006f0\n    Call Trace:\n     <TASK>\n     ? __warn+0x83/0x130\n     ? unregister_netdevice_many_notify+0x8d9/0x930\n     ? report_bug+0x18e/0x1a0\n     ? handle_bug+0x54/0x90\n     ? exc_invalid_op+0x18/0x70\n     ? asm_exc_invalid_op+0x1a/0x20\n     ? unregister_netdevice_many_notify+0x8d9/0x930\n     ? bond_net_exit_batch_rtnl+0x5c/0x90\n     cleanup_net+0x237/0x3d0\n     process_one_work+0x163/0x390\n     worker_thread+0x293/0x3b0\n     ? __pfx_worker_thread+0x10/0x10\n     kthread+0xec/0x1e0\n     ? __pfx_kthread+0x10/0x10\n     ? __pfx_kthread+0x10/0x10\n     ret_from_fork+0x2f/0x50\n     ? __pfx_kthread+0x10/0x10\n     ret_from_fork_asm+0x1a/0x30\n     </TASK>\n    ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0dd4fac43bdea23cfe4bb2a3eabb76d752ac32fb",
      "https://git.kernel.org/stable/c/094ee6017ea09c11d6af187935a949df32803ce0"
    ],
    "受影响版本": [
      "9e2ee5c7e7c35d195e2aa0692a7241d47a433d1e",
      "9e2ee5c7e7c35d195e2aa0692a7241d47a433d1e"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22075",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nrtnetlink: Allocate vfinfo size for VF GUIDs when supported\n\nCommit 30aad41721e0 (\"net/core: Add support for getting VF GUIDs\")\nadded support for getting VF port and node GUIDs in netlink ifinfo\nmessages, but their size was not taken into consideration in the\nfunction that allocates the netlink message, causing the following\nwarning when a netlink message is filled with many VF port and node\nGUIDs:\n # echo 64 > /sys/bus/pci/devices/0000\\:08\\:00.0/sriov_numvfs\n # ip link show dev ib0\n RTNETLINK answers: Message too long\n Cannot send link get request: Message too long\n\nKernel warning:\n\n ------------[ cut here ]------------\n WARNING: CPU: 2 PID: 1930 at net/core/rtnetlink.c:4151 rtnl_getlink+0x586/0x5a0\n Modules linked in: xt_conntrack xt_MASQUERADE nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter overlay mlx5_ib macsec mlx5_core tls rpcrdma rdma_ucm ib_uverbs ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm iw_cm ib_ipoib fuse ib_cm ib_core\n CPU: 2 UID: 0 PID: 1930 Comm: ip Not tainted 6.14.0-rc2+ #1\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n RIP: 0010:rtnl_getlink+0x586/0x5a0\n Code: cb 82 e8 3d af 0a 00 4d 85 ff 0f 84 08 ff ff ff 4c 89 ff 41 be ea ff ff ff e8 66 63 5b ff 49 c7 07 80 4f cb 82 e9 36 fc ff ff <0f> 0b e9 16 fe ff ff e8 de a0 56 00 66 66 2e 0f 1f 84 00 00 00 00\n RSP: 0018:ffff888113557348 EFLAGS: 00010246\n RAX: 00000000ffffffa6 RBX: ffff88817e87aa34 RCX: dffffc0000000000\n RDX: 0000000000000003 RSI: 0000000000000000 RDI: ffff88817e87afb8\n RBP: 0000000000000009 R08: ffffffff821f44aa R09: 0000000000000000\n R10: ffff8881260f79a8 R11: ffff88817e87af00 R12: ffff88817e87aa00\n R13: ffffffff8563d300 R14: 00000000ffffffa6 R15: 00000000ffffffff\n FS:  00007f63a5dbf280(0000) GS:ffff88881ee00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007f63a5ba4493 CR3: 00000001700fe002 CR4: 0000000000772eb0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n PKRU: 55555554\n Call Trace:\n  <TASK>\n  ? __warn+0xa5/0x230\n  ? rtnl_getlink+0x586/0x5a0\n  ? report_bug+0x22d/0x240\n  ? handle_bug+0x53/0xa0\n  ? exc_invalid_op+0x14/0x50\n  ? asm_exc_invalid_op+0x16/0x20\n  ? skb_trim+0x6a/0x80\n  ? rtnl_getlink+0x586/0x5a0\n  ? __pfx_rtnl_getlink+0x10/0x10\n  ? rtnetlink_rcv_msg+0x1e5/0x860\n  ? __pfx___mutex_lock+0x10/0x10\n  ? rcu_is_watching+0x34/0x60\n  ? __pfx_lock_acquire+0x10/0x10\n  ? stack_trace_save+0x90/0xd0\n  ? filter_irq_stacks+0x1d/0x70\n  ? kasan_save_stack+0x30/0x40\n  ? kasan_save_stack+0x20/0x40\n  ? kasan_save_track+0x10/0x30\n  rtnetlink_rcv_msg+0x21c/0x860\n  ? entry_SYSCALL_64_after_hwframe+0x76/0x7e\n  ? __pfx_rtnetlink_rcv_msg+0x10/0x10\n  ? arch_stack_walk+0x9e/0xf0\n  ? rcu_is_watching+0x34/0x60\n  ? lock_acquire+0xd5/0x410\n  ? rcu_is_watching+0x34/0x60\n  netlink_rcv_skb+0xe0/0x210\n  ? __pfx_rtnetlink_rcv_msg+0x10/0x10\n  ? __pfx_netlink_rcv_skb+0x10/0x10\n  ? rcu_is_watching+0x34/0x60\n  ? __pfx___netlink_lookup+0x10/0x10\n  ? lock_release+0x62/0x200\n  ? netlink_deliver_tap+0xfd/0x290\n  ? rcu_is_watching+0x34/0x60\n  ? lock_release+0x62/0x200\n  ? netlink_deliver_tap+0x95/0x290\n  netlink_unicast+0x31f/0x480\n  ? __pfx_netlink_unicast+0x10/0x10\n  ? rcu_is_watching+0x34/0x60\n  ? lock_acquire+0xd5/0x410\n  netlink_sendmsg+0x369/0x660\n  ? lock_release+0x62/0x200\n  ? __pfx_netlink_sendmsg+0x10/0x10\n  ? import_ubuf+0xb9/0xf0\n  ? __import_iovec+0x254/0x2b0\n  ? lock_release+0x62/0x200\n  ? __pfx_netlink_sendmsg+0x10/0x10\n  ____sys_sendmsg+0x559/0x5a0\n  ? __pfx_____sys_sendmsg+0x10/0x10\n  ? __pfx_copy_msghdr_from_user+0x10/0x10\n  ? rcu_is_watching+0x34/0x60\n  ? do_read_fault+0x213/0x4a0\n  ? rcu_is_watching+0x34/0x60\n  ___sys_sendmsg+0xe4/0x150\n  ? __pfx____sys_sendmsg+0x10/0x10\n  ? do_fault+0x2cc/0x6f0\n  ? handle_pte_fault+0x2e3/0x3d0\n  ? __pfx_handle_pte_fault+0x10/0x10\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0f5489707cf528f9df2f39a3045c1ee713ec90e7",
      "https://git.kernel.org/stable/c/bb7bdf636cef74cdd7a7d548bdc7457ae161f617",
      "https://git.kernel.org/stable/c/5fed5f6de3cf734b231a11775748a6871ee3020f",
      "https://git.kernel.org/stable/c/15f150771e0ec97f8ab1657e7d2568e593c7fa04",
      "https://git.kernel.org/stable/c/28b21ee8e8fb326ba961a4bbce04ec04c65e705a",
      "https://git.kernel.org/stable/c/365c1ae819455561d4746aafabad673e4bcb0163",
      "https://git.kernel.org/stable/c/5f39454468329bb7fc7fc4895a6ba6ae3b95027e",
      "https://git.kernel.org/stable/c/23f00807619d15063d676218f36c5dfeda1eb420"
    ],
    "受影响版本": [
      "30aad41721e087babcf27c5192474724d555936c",
      "30aad41721e087babcf27c5192474724d555936c",
      "30aad41721e087babcf27c5192474724d555936c",
      "30aad41721e087babcf27c5192474724d555936c",
      "30aad41721e087babcf27c5192474724d555936c",
      "30aad41721e087babcf27c5192474724d555936c",
      "30aad41721e087babcf27c5192474724d555936c",
      "30aad41721e087babcf27c5192474724d555936c"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22069",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: fgraph: Fix stack layout to match __arch_ftrace_regs argument of ftrace_return_to_handler\n\nNaresh Kamboju reported a \"Bad frame pointer\" kernel warning while\nrunning LTP trace ftrace_stress_test.sh in riscv. We can reproduce the\nsame issue with the following command:\n\n```\n$ cd /sys/kernel/debug/tracing\n$ echo 'f:myprobe do_nanosleep%return args1=$retval' > dynamic_events\n$ echo 1 > events/fprobes/enable\n$ echo 1 > tracing_on\n$ sleep 1\n```\n\nAnd we can get the following kernel warning:\n\n[  127.692888] ------------[ cut here ]------------\n[  127.693755] Bad frame pointer: expected ff2000000065be50, received ba34c141e9594000\n[  127.693755]   from func do_nanosleep return to ffffffff800ccb16\n[  127.698699] WARNING: CPU: 1 PID: 129 at kernel/trace/fgraph.c:755 ftrace_return_to_handler+0x1b2/0x1be\n[  127.699894] Modules linked in:\n[  127.700908] CPU: 1 UID: 0 PID: 129 Comm: sleep Not tainted 6.14.0-rc3-g0ab191c74642 #32\n[  127.701453] Hardware name: riscv-virtio,qemu (DT)\n[  127.701859] epc : ftrace_return_to_handler+0x1b2/0x1be\n[  127.702032]  ra : ftrace_return_to_handler+0x1b2/0x1be\n[  127.702151] epc : ffffffff8013b5e0 ra : ffffffff8013b5e0 sp : ff2000000065bd10\n[  127.702221]  gp : ffffffff819c12f8 tp : ff60000080853100 t0 : 6e00000000000000\n[  127.702284]  t1 : 0000000000000020 t2 : 6e7566206d6f7266 s0 : ff2000000065bd80\n[  127.702346]  s1 : ff60000081262000 a0 : 000000000000007b a1 : ffffffff81894f20\n[  127.702408]  a2 : 0000000000000010 a3 : fffffffffffffffe a4 : 0000000000000000\n[  127.702470]  a5 : 0000000000000000 a6 : 0000000000000008 a7 : 0000000000000038\n[  127.702530]  s2 : ba34c141e9594000 s3 : 0000000000000000 s4 : ff2000000065bdd0\n[  127.702591]  s5 : 00007fff8adcf400 s6 : 000055556dc1d8c0 s7 : 0000000000000068\n[  127.702651]  s8 : 00007fff8adf5d10 s9 : 000000000000006d s10: 0000000000000001\n[  127.702710]  s11: 00005555737377c8 t3 : ffffffff819d899e t4 : ffffffff819d899e\n[  127.702769]  t5 : ffffffff819d89a0 t6 : ff2000000065bb18\n[  127.702826] status: 0000000200000120 badaddr: 0000000000000000 cause: 0000000000000003\n[  127.703292] [<ffffffff8013b5e0>] ftrace_return_to_handler+0x1b2/0x1be\n[  127.703760] [<ffffffff80017bce>] return_to_handler+0x16/0x26\n[  127.704009] [<ffffffff80017bb8>] return_to_handler+0x0/0x26\n[  127.704057] [<ffffffff800d3352>] common_nsleep+0x42/0x54\n[  127.704117] [<ffffffff800d44a2>] __riscv_sys_clock_nanosleep+0xba/0x10a\n[  127.704176] [<ffffffff80901c56>] do_trap_ecall_u+0x188/0x218\n[  127.704295] [<ffffffff8090cc3e>] handle_exception+0x14a/0x156\n[  127.705436] ---[ end trace 0000000000000000 ]---\n\nThe reason is that the stack layout for constructing argument for the\nftrace_return_to_handler in the return_to_handler does not match the\n__arch_ftrace_regs structure of riscv, leading to unexpected results.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/78b39c587b8f6c69140177108f9c08a75b1c7c37",
      "https://git.kernel.org/stable/c/67a5ba8f742f247bc83e46dd2313c142b1383276"
    ],
    "受影响版本": [
      "a3ed4157b7d89800a0008de0c9e46a438a5c3745",
      "a3ed4157b7d89800a0008de0c9e46a438a5c3745"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22061",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: airoha: Fix qid report in airoha_tc_get_htb_get_leaf_queue()\n\nFix the following kernel warning deleting HTB offloaded leafs and/or root\nHTB qdisc in airoha_eth driver properly reporting qid in\nairoha_tc_get_htb_get_leaf_queue routine.\n\n$tc qdisc replace dev eth1 root handle 10: htb offload\n$tc class add dev eth1 arent 10: classid 10:4 htb rate 100mbit ceil 100mbit\n$tc qdisc replace dev eth1 parent 10:4 handle 4: ets bands 8 \\\n quanta 1514 3028 4542 6056 7570 9084 10598 12112\n$tc qdisc del dev eth1 root\n\n[   55.827864] ------------[ cut here ]------------\n[   55.832493] WARNING: CPU: 3 PID: 2678 at 0xffffffc0798695a4\n[   55.956510] CPU: 3 PID: 2678 Comm: tc Tainted: G           O 6.6.71 #0\n[   55.963557] Hardware name: Airoha AN7581 Evaluation Board (DT)\n[   55.969383] pstate: 20400005 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   55.976344] pc : 0xffffffc0798695a4\n[   55.979851] lr : 0xffffffc079869a20\n[   55.983358] sp : ffffffc0850536a0\n[   55.986665] x29: ffffffc0850536a0 x28: 0000000000000024 x27: 0000000000000001\n[   55.993800] x26: 0000000000000000 x25: ffffff8008b19000 x24: ffffff800222e800\n[   56.000935] x23: 0000000000000001 x22: 0000000000000000 x21: ffffff8008b19000\n[   56.008071] x20: ffffff8002225800 x19: ffffff800379d000 x18: 0000000000000000\n[   56.015206] x17: ffffffbf9ea59000 x16: ffffffc080018000 x15: 0000000000000000\n[   56.022342] x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000001\n[   56.029478] x11: ffffffc081471008 x10: ffffffc081575a98 x9 : 0000000000000000\n[   56.036614] x8 : ffffffc08167fd40 x7 : ffffffc08069e104 x6 : ffffff8007f86000\n[   56.043748] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000001\n[   56.050884] x2 : 0000000000000000 x1 : 0000000000000250 x0 : ffffff800222c000\n[   56.058020] Call trace:\n[   56.060459]  0xffffffc0798695a4\n[   56.063618]  0xffffffc079869a20\n[   56.066777]  __qdisc_destroy+0x40/0xa0\n[   56.070528]  qdisc_put+0x54/0x6c\n[   56.073748]  qdisc_graft+0x41c/0x648\n[   56.077324]  tc_get_qdisc+0x168/0x2f8\n[   56.080978]  rtnetlink_rcv_msg+0x230/0x330\n[   56.085076]  netlink_rcv_skb+0x5c/0x128\n[   56.088913]  rtnetlink_rcv+0x14/0x1c\n[   56.092490]  netlink_unicast+0x1e0/0x2c8\n[   56.096413]  netlink_sendmsg+0x198/0x3c8\n[   56.100337]  ____sys_sendmsg+0x1c4/0x274\n[   56.104261]  ___sys_sendmsg+0x7c/0xc0\n[   56.107924]  __sys_sendmsg+0x44/0x98\n[   56.111492]  __arm64_sys_sendmsg+0x20/0x28\n[   56.115580]  invoke_syscall.constprop.0+0x58/0xfc\n[   56.120285]  do_el0_svc+0x3c/0xbc\n[   56.123592]  el0_svc+0x18/0x4c\n[   56.126647]  el0t_64_sync_handler+0x118/0x124\n[   56.131005]  el0t_64_sync+0x150/0x154\n[   56.134660] ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d7f76197e49e46a8c082a6fededaa8a07e69a860",
      "https://git.kernel.org/stable/c/57b290d97c6150774bf929117ca737a26d8fc33d"
    ],
    "受影响版本": [
      "ef1ca9271313b4ea7b03de69576aacef1e78f381",
      "ef1ca9271313b4ea7b03de69576aacef1e78f381"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22036",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nexfat: fix random stack corruption after get_block\n\nWhen get_block is called with a buffer_head allocated on the stack, such\nas do_mpage_readpage, stack corruption due to buffer_head UAF may occur in\nthe following race condition situation.\n\n     <CPU 0>                      <CPU 1>\nmpage_read_folio\n  <<bh on stack>>\n  do_mpage_readpage\n    exfat_get_block\n      bh_read\n        __bh_read\n\t  get_bh(bh)\n          submit_bh\n          wait_on_buffer\n                              ...\n                              end_buffer_read_sync\n                                __end_buffer_read_notouch\n                                   unlock_buffer\n          <<keep going>>\n        ...\n      ...\n    ...\n  ...\n<<bh is not valid out of mpage_read_folio>>\n   .\n   .\nanother_function\n  <<variable A on stack>>\n                                   put_bh(bh)\n                                     atomic_dec(bh->b_count)\n  * stack corruption here *\n\nThis patch returns -EAGAIN if a folio does not have buffers when bh_read\nneeds to be called. By doing this, the caller can fallback to functions\nlike block_read_full_folio(), create a buffer_head in the folio, and then\ncall get_block again.\n\nLet's do not call bh_read() with on-stack buffer_head.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/49b0a6ab8e528a0c1c50e37cef9b9c7c121365f2",
      "https://git.kernel.org/stable/c/f7447286363dc1e410bf30b87d75168f3519f9cc",
      "https://git.kernel.org/stable/c/f807a6bf2005740fa26b4f59c4a003dc966b9afd",
      "https://git.kernel.org/stable/c/1bb7ff4204b6d4927e982cd256286c09ed4fd8ca"
    ],
    "受影响版本": [
      "11a347fb6cef62ce47e84b97c45f2b2497c7593b",
      "11a347fb6cef62ce47e84b97c45f2b2497c7593b",
      "11a347fb6cef62ce47e84b97c45f2b2497c7593b",
      "11a347fb6cef62ce47e84b97c45f2b2497c7593b"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22028",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: vimc: skip .s_stream() for stopped entities\n\nSyzbot reported [1] a warning prompted by a check in call_s_stream()\nthat checks whether .s_stream() operation is warranted for unstarted\nor stopped subdevs.\n\nAdd a simple fix in vimc_streamer_pipeline_terminate() ensuring that\nentities skip a call to .s_stream() unless they have been previously\nproperly started.\n\n[1] Syzbot report:\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 5933 at drivers/media/v4l2-core/v4l2-subdev.c:460 call_s_stream+0x2df/0x350 drivers/media/v4l2-core/v4l2-subdev.c:460\nModules linked in:\nCPU: 0 UID: 0 PID: 5933 Comm: syz-executor330 Not tainted 6.13.0-rc2-syzkaller-00362-g2d8308bf5b67 #0\n...\nCall Trace:\n <TASK>\n vimc_streamer_pipeline_terminate+0x218/0x320 drivers/media/test-drivers/vimc/vimc-streamer.c:62\n vimc_streamer_pipeline_init drivers/media/test-drivers/vimc/vimc-streamer.c:101 [inline]\n vimc_streamer_s_stream+0x650/0x9a0 drivers/media/test-drivers/vimc/vimc-streamer.c:203\n vimc_capture_start_streaming+0xa1/0x130 drivers/media/test-drivers/vimc/vimc-capture.c:256\n vb2_start_streaming+0x15f/0x5a0 drivers/media/common/videobuf2/videobuf2-core.c:1789\n vb2_core_streamon+0x2a7/0x450 drivers/media/common/videobuf2/videobuf2-core.c:2348\n vb2_streamon drivers/media/common/videobuf2/videobuf2-v4l2.c:875 [inline]\n vb2_ioctl_streamon+0xf4/0x170 drivers/media/common/videobuf2/videobuf2-v4l2.c:1118\n __video_do_ioctl+0xaf0/0xf00 drivers/media/v4l2-core/v4l2-ioctl.c:3122\n video_usercopy+0x4d2/0x1620 drivers/media/v4l2-core/v4l2-ioctl.c:3463\n v4l2_ioctl+0x1ba/0x250 drivers/media/v4l2-core/v4l2-dev.c:366\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:906 [inline]\n __se_sys_ioctl fs/ioctl.c:892 [inline]\n __x64_sys_ioctl+0x190/0x200 fs/ioctl.c:892\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f2b85c01b19\n...",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a505075730d23ccc19fc4ac382a0ed73b630c057",
      "https://git.kernel.org/stable/c/845e9286ff99ee88cfdeb2b748f730003a512190",
      "https://git.kernel.org/stable/c/6f6064dab4dcfb7e34a395040a0c9dc22cc8765d",
      "https://git.kernel.org/stable/c/7a58d4c4cf8ff60ab1f93399deefaf6057da91c7",
      "https://git.kernel.org/stable/c/36cef585e2a31e4ddf33a004b0584a7a572246de"
    ],
    "受影响版本": [
      "adc589d2a20808fb99d46a78175cd023f2040338",
      "adc589d2a20808fb99d46a78175cd023f2040338",
      "adc589d2a20808fb99d46a78175cd023f2040338",
      "adc589d2a20808fb99d46a78175cd023f2040338",
      "adc589d2a20808fb99d46a78175cd023f2040338",
      "77fbb561bb09f56877dd84318212da393909975f",
      "73236bf581e96eb48808fea522351ed81e24c9cc",
      "e7ae48ae47227c0302b9f4b15a5bf45934a55673"
    ],
    "公开日期": "2025年04月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22015",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/migrate: fix shmem xarray update during migration\n\nA shmem folio can be either in page cache or in swap cache, but not at the\nsame time.  Namely, once it is in swap cache, folio->mapping should be\nNULL, and the folio is no longer in a shmem mapping.\n\nIn __folio_migrate_mapping(), to determine the number of xarray entries to\nupdate, folio_test_swapbacked() is used, but that conflates shmem in page\ncache case and shmem in swap cache case.  It leads to xarray multi-index\nentry corruption, since it turns a sibling entry to a normal entry during\nxas_store() (see [1] for a userspace reproduction).  Fix it by only using\nfolio_test_swapcache() to determine whether xarray is storing swap cache\nentries or not to choose the right number of xarray entries to update.\n\n[1] https://lore.kernel.org/linux-mm/Z8idPCkaJW1IChjT@casper.infradead.org/\n\nNote:\nIn __split_huge_page(), folio_test_anon() && folio_test_swapcache() is\nused to get swap_cache address space, but that ignores the shmem folio in\nswap cache case.  It could lead to NULL pointer dereferencing when a\nin-swap-cache shmem folio is split at __xa_store(), since\n!folio_test_anon() is true and folio->mapping is NULL.  But fortunately,\nits caller split_huge_page_to_list_to_order() bails out early with EBUSY\nwhen folio->mapping is NULL.  So no need to take care of it here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/49100c0b070e900f87c8fac3be9b9ef8a30fa673",
      "https://git.kernel.org/stable/c/29124ae980e2860f0eec7355949d3d3292ee81da",
      "https://git.kernel.org/stable/c/c057ee03f751d6cecf7ee64f52f6545d94082aaa",
      "https://git.kernel.org/stable/c/75cfb92eb63298d717b6b0118f91ba12c4fcfeb5",
      "https://git.kernel.org/stable/c/60cf233b585cdf1f3c5e52d1225606b86acd08b0"
    ],
    "受影响版本": [
      "be72d197b2281e2ee3f28017fc9be1ab17e26d16",
      "07550b1461d4d0499165e7d6f7718cfd0e440427",
      "fc346d0a70a13d52fe1c4bc49516d83a42cd7c4c",
      "fc346d0a70a13d52fe1c4bc49516d83a42cd7c4c",
      "fc346d0a70a13d52fe1c4bc49516d83a42cd7c4c"
    ],
    "公开日期": "2025年04月08日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-22014",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoc: qcom: pdr: Fix the potential deadlock\n\nWhen some client process A call pdr_add_lookup() to add the look up for\nthe service and does schedule locator work, later a process B got a new\nserver packet indicating locator is up and call pdr_locator_new_server()\nwhich eventually sets pdr->locator_init_complete to true which process A\nsees and takes list lock and queries domain list but it will timeout due\nto deadlock as the response will queued to the same qmi->wq and it is\nordered workqueue and process B is not able to complete new server\nrequest work due to deadlock on list lock.\n\nFix it by removing the unnecessary list iteration as the list iteration\nis already being done inside locator work, so avoid it here and just\ncall schedule_work() here.\n\n       Process A                        Process B\n\n                                     process_scheduled_works()\npdr_add_lookup()                      qmi_data_ready_work()\n process_scheduled_works()             pdr_locator_new_server()\n                                         pdr->locator_init_complete=true;\n   pdr_locator_work()\n    mutex_lock(&pdr->list_lock);\n\n     pdr_locate_service()                  mutex_lock(&pdr->list_lock);\n\n      pdr_get_domain_list()\n       pr_err(\"PDR: %s get domain list\n               txn wait failed: %d\\n\",\n               req->service_name,\n               ret);\n\nTimeout error log due to deadlock:\n\n\"\n PDR: tms/servreg get domain list txn wait failed: -110\n PDR: service lookup for msm/adsp/sensor_pd:tms/servreg failed: -110\n\"\n\nThanks to Bjorn and Johan for letting me know that this commit also fixes\nan audio regression when using the in-kernel pd-mapper as that makes it\neasier to hit this race. [1]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/72a222b6af10c2a05a5fad0029246229ed8912c2",
      "https://git.kernel.org/stable/c/daba84612236de3ab39083e62c9e326a654ebd20",
      "https://git.kernel.org/stable/c/0a566a79aca9851fae140536e0fc5b0853c90a90",
      "https://git.kernel.org/stable/c/f2bbfd50e95bc117360f0f59e629aa03d821ebd6",
      "https://git.kernel.org/stable/c/f4489260f5713c94e1966e5f20445bff262876f4",
      "https://git.kernel.org/stable/c/02612f1e4c34d94d6c8ee75bf7d254ed697e22d4",
      "https://git.kernel.org/stable/c/2eeb03ad9f42dfece63051be2400af487ddb96d2"
    ],
    "受影响版本": [
      "fbe639b44a82755d639df1c5d147c93f02ac5a0f",
      "fbe639b44a82755d639df1c5d147c93f02ac5a0f",
      "fbe639b44a82755d639df1c5d147c93f02ac5a0f",
      "fbe639b44a82755d639df1c5d147c93f02ac5a0f",
      "fbe639b44a82755d639df1c5d147c93f02ac5a0f",
      "fbe639b44a82755d639df1c5d147c93f02ac5a0f",
      "fbe639b44a82755d639df1c5d147c93f02ac5a0f"
    ],
    "公开日期": "2025年04月08日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21984",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: fix kernel BUG when userfaultfd_move encounters swapcache\n\nuserfaultfd_move() checks whether the PTE entry is present or a\nswap entry.\n\n- If the PTE entry is present, move_present_pte() handles folio\n  migration by setting:\n\n  src_folio->index = linear_page_index(dst_vma, dst_addr);\n\n- If the PTE entry is a swap entry, move_swap_pte() simply copies\n  the PTE to the new dst_addr.\n\nThis approach is incorrect because, even if the PTE is a swap entry,\nit can still reference a folio that remains in the swap cache.\n\nThis creates a race window between steps 2 and 4.\n 1. add_to_swap: The folio is added to the swapcache.\n 2. try_to_unmap: PTEs are converted to swap entries.\n 3. pageout: The folio is written back.\n 4. Swapcache is cleared.\nIf userfaultfd_move() occurs in the window between steps 2 and 4,\nafter the swap PTE has been moved to the destination, accessing the\ndestination triggers do_swap_page(), which may locate the folio in\nthe swapcache. However, since the folio's index has not been updated\nto match the destination VMA, do_swap_page() will detect a mismatch.\n\nThis can result in two critical issues depending on the system\nconfiguration.\n\nIf KSM is disabled, both small and large folios can trigger a BUG\nduring the add_rmap operation due to:\n\n page_pgoff(folio, page) != linear_page_index(vma, address)\n\n[   13.336953] page: refcount:6 mapcount:1 mapping:00000000f43db19c index:0xffffaf150 pfn:0x4667c\n[   13.337520] head: order:2 mapcount:1 entire_mapcount:0 nr_pages_mapped:1 pincount:0\n[   13.337716] memcg:ffff00000405f000\n[   13.337849] anon flags: 0x3fffc0000020459(locked|uptodate|dirty|owner_priv_1|head|swapbacked|node=0|zone=0|lastcpupid=0xffff)\n[   13.338630] raw: 03fffc0000020459 ffff80008507b538 ffff80008507b538 ffff000006260361\n[   13.338831] raw: 0000000ffffaf150 0000000000004000 0000000600000000 ffff00000405f000\n[   13.339031] head: 03fffc0000020459 ffff80008507b538 ffff80008507b538 ffff000006260361\n[   13.339204] head: 0000000ffffaf150 0000000000004000 0000000600000000 ffff00000405f000\n[   13.339375] head: 03fffc0000000202 fffffdffc0199f01 ffffffff00000000 0000000000000001\n[   13.339546] head: 0000000000000004 0000000000000000 00000000ffffffff 0000000000000000\n[   13.339736] page dumped because: VM_BUG_ON_PAGE(page_pgoff(folio, page) != linear_page_index(vma, address))\n[   13.340190] ------------[ cut here ]------------\n[   13.340316] kernel BUG at mm/rmap.c:1380!\n[   13.340683] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\n[   13.340969] Modules linked in:\n[   13.341257] CPU: 1 UID: 0 PID: 107 Comm: a.out Not tainted 6.14.0-rc3-gcf42737e247a-dirty #299\n[   13.341470] Hardware name: linux,dummy-virt (DT)\n[   13.341671] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   13.341815] pc : __page_check_anon_rmap+0xa0/0xb0\n[   13.341920] lr : __page_check_anon_rmap+0xa0/0xb0\n[   13.342018] sp : ffff80008752bb20\n[   13.342093] x29: ffff80008752bb20 x28: fffffdffc0199f00 x27: 0000000000000001\n[   13.342404] x26: 0000000000000000 x25: 0000000000000001 x24: 0000000000000001\n[   13.342575] x23: 0000ffffaf0d0000 x22: 0000ffffaf0d0000 x21: fffffdffc0199f00\n[   13.342731] x20: fffffdffc0199f00 x19: ffff000006210700 x18: 00000000ffffffff\n[   13.342881] x17: 6c203d2120296567 x16: 6170202c6f696c6f x15: 662866666f67705f\n[   13.343033] x14: 6567617028454741 x13: 2929737365726464 x12: ffff800083728ab0\n[   13.343183] x11: ffff800082996bf8 x10: 0000000000000fd7 x9 : ffff80008011bc40\n[   13.343351] x8 : 0000000000017fe8 x7 : 00000000fffff000 x6 : ffff8000829eebf8\n[   13.343498] x5 : c0000000fffff000 x4 : 0000000000000000 x3 : 0000000000000000\n[   13.343645] x2 : 0000000000000000 x1 : ffff0000062db980 x0 : 000000000000005f\n[   13.343876] Call trace:\n[   13.344045]  __page_check_anon_rmap+0xa0/0xb0 (P)\n[   13.344234]  folio_add_anon_rmap_ptes+0x22c/0x320\n[   13.344333]  do_swap_page+0x1060/0x1400\n[   13.344417]  __handl\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4e9507246298fd6f1ca7bb42ef01a6e34fb93684",
      "https://git.kernel.org/stable/c/b1e11bd86c0943bb7624efebdc384340a50ad683",
      "https://git.kernel.org/stable/c/c50f8e6053b0503375c2975bf47f182445aebb4c"
    ],
    "受影响版本": [
      "adef440691bab824e39c1b17382322d195e1fab0",
      "adef440691bab824e39c1b17382322d195e1fab0",
      "adef440691bab824e39c1b17382322d195e1fab0"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21961",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\neth: bnxt: fix truesize for mb-xdp-pass case\n\nWhen mb-xdp is set and return is XDP_PASS, packet is converted from\nxdp_buff to sk_buff with xdp_update_skb_shared_info() in\nbnxt_xdp_build_skb().\nbnxt_xdp_build_skb() passes incorrect truesize argument to\nxdp_update_skb_shared_info().\nThe truesize is calculated as BNXT_RX_PAGE_SIZE * sinfo->nr_frags but\nthe skb_shared_info was wiped by napi_build_skb() before.\nSo it stores sinfo->nr_frags before bnxt_xdp_build_skb() and use it\ninstead of getting skb_shared_info from xdp_get_shared_info_from_buff().\n\nSplat looks like:\n ------------[ cut here ]------------\n WARNING: CPU: 2 PID: 0 at net/core/skbuff.c:6072 skb_try_coalesce+0x504/0x590\n Modules linked in: xt_nat xt_tcpudp veth af_packet xt_conntrack nft_chain_nat xt_MASQUERADE nf_conntrack_netlink xfrm_user xt_addrtype nft_coms\n CPU: 2 UID: 0 PID: 0 Comm: swapper/2 Not tainted 6.14.0-rc2+ #3\n RIP: 0010:skb_try_coalesce+0x504/0x590\n Code: 4b fd ff ff 49 8b 34 24 40 80 e6 40 0f 84 3d fd ff ff 49 8b 74 24 48 40 f6 c6 01 0f 84 2e fd ff ff 48 8d 4e ff e9 25 fd ff ff <0f> 0b e99\n RSP: 0018:ffffb62c4120caa8 EFLAGS: 00010287\n RAX: 0000000000000003 RBX: ffffb62c4120cb14 RCX: 0000000000000ec0\n RDX: 0000000000001000 RSI: ffffa06e5d7dc000 RDI: 0000000000000003\n RBP: ffffa06e5d7ddec0 R08: ffffa06e6120a800 R09: ffffa06e7a119900\n R10: 0000000000002310 R11: ffffa06e5d7dcec0 R12: ffffe4360575f740\n R13: ffffe43600000000 R14: 0000000000000002 R15: 0000000000000002\n FS:  0000000000000000(0000) GS:ffffa0755f700000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007f147b76b0f8 CR3: 00000001615d4000 CR4: 00000000007506f0\n PKRU: 55555554\n Call Trace:\n  <IRQ>\n  ? __warn+0x84/0x130\n  ? skb_try_coalesce+0x504/0x590\n  ? report_bug+0x18a/0x1a0\n  ? handle_bug+0x53/0x90\n  ? exc_invalid_op+0x14/0x70\n  ? asm_exc_invalid_op+0x16/0x20\n  ? skb_try_coalesce+0x504/0x590\n  inet_frag_reasm_finish+0x11f/0x2e0\n  ip_defrag+0x37a/0x900\n  ip_local_deliver+0x51/0x120\n  ip_sublist_rcv_finish+0x64/0x70\n  ip_sublist_rcv+0x179/0x210\n  ip_list_rcv+0xf9/0x130\n\nHow to reproduce:\n<Node A>\nip link set $interface1 xdp obj xdp_pass.o\nip link set $interface1 mtu 9000 up\nip a a 10.0.0.1/24 dev $interface1\n<Node B>\nip link set $interfac2 mtu 9000 up\nip a a 10.0.0.2/24 dev $interface2\nping 10.0.0.1 -s 65000\n\nFollowing ping.py patch adds xdp-mb-pass case. so ping.py is going to be\nable to reproduce this issue.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/19107e71be330dbccb9f8f9f4cf0a9abeadad802",
      "https://git.kernel.org/stable/c/b4679807c6083ade4d47f03f80da891afcb6ef62",
      "https://git.kernel.org/stable/c/9f7b2aa5034e24d3c49db73d5f760c0435fe31c2"
    ],
    "受影响版本": [
      "1dc4c557bfedfcdf7fc0c46795857773b7ad66e7",
      "1dc4c557bfedfcdf7fc0c46795857773b7ad66e7",
      "1dc4c557bfedfcdf7fc0c46795857773b7ad66e7"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21957",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla1280: Fix kernel oops when debug level > 2\n\nA null dereference or oops exception will eventually occur when qla1280.c\ndriver is compiled with DEBUG_QLA1280 enabled and ql_debug_level > 2.  I\nthink its clear from the code that the intention here is sg_dma_len(s) not\nlength of sg_next(s) when printing the debug info.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/afa27b7c17a48e01546ccaad0ab017ad0496a522",
      "https://git.kernel.org/stable/c/11a8dac1177a596648a020a7f3708257a2f95fee",
      "https://git.kernel.org/stable/c/c737e2a5fb7f90b96a96121da1b50a9c74ae9b8c",
      "https://git.kernel.org/stable/c/24602e2664c515a4f2950d7b52c3d5997463418c",
      "https://git.kernel.org/stable/c/ea371d1cdefb0951c7127a33bcd7eb931cf44571",
      "https://git.kernel.org/stable/c/af71ba921d08c241a817010f96458dc5e5e26762",
      "https://git.kernel.org/stable/c/7ac2473e727d67a38266b2b7e55c752402ab588c",
      "https://git.kernel.org/stable/c/5233e3235dec3065ccc632729675575dbe3c6b8a"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21949",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nLoongArch: Set hugetlb mmap base address aligned with pmd size\n\nWith ltp test case \"testcases/bin/hugefork02\", there is a dmesg error\nreport message such as:\n\n kernel BUG at mm/hugetlb.c:5550!\n Oops - BUG[#1]:\n CPU: 0 UID: 0 PID: 1517 Comm: hugefork02 Not tainted 6.14.0-rc2+ #241\n Hardware name: QEMU QEMU Virtual Machine, BIOS unknown 2/2/2022\n pc 90000000004eaf1c ra 9000000000485538 tp 900000010edbc000 sp 900000010edbf940\n a0 900000010edbfb00 a1 9000000108d20280 a2 00007fffe9474000 a3 00007ffff3474000\n a4 0000000000000000 a5 0000000000000003 a6 00000000003cadd3 a7 0000000000000000\n t0 0000000001ffffff t1 0000000001474000 t2 900000010ecd7900 t3 00007fffe9474000\n t4 00007fffe9474000 t5 0000000000000040 t6 900000010edbfb00 t7 0000000000000001\n t8 0000000000000005 u0 90000000004849d0 s9 900000010edbfa00 s0 9000000108d20280\n s1 00007fffe9474000 s2 0000000002000000 s3 9000000108d20280 s4 9000000002b38b10\n s5 900000010edbfb00 s6 00007ffff3474000 s7 0000000000000406 s8 900000010edbfa08\n    ra: 9000000000485538 unmap_vmas+0x130/0x218\n   ERA: 90000000004eaf1c __unmap_hugepage_range+0x6f4/0x7d0\n  PRMD: 00000004 (PPLV0 +PIE -PWE)\n  EUEN: 00000007 (+FPE +SXE +ASXE -BTE)\n  ECFG: 00071c1d (LIE=0,2-4,10-12 VS=7)\n ESTAT: 000c0000 [BRK] (IS= ECode=12 EsubCode=0)\n PRID: 0014c010 (Loongson-64bit, Loongson-3A5000)\n Process hugefork02 (pid: 1517, threadinfo=00000000a670eaf4, task=000000007a95fc64)\n Call Trace:\n [<90000000004eaf1c>] __unmap_hugepage_range+0x6f4/0x7d0\n [<9000000000485534>] unmap_vmas+0x12c/0x218\n [<9000000000494068>] exit_mmap+0xe0/0x308\n [<900000000025fdc4>] mmput+0x74/0x180\n [<900000000026a284>] do_exit+0x294/0x898\n [<900000000026aa30>] do_group_exit+0x30/0x98\n [<900000000027bed4>] get_signal+0x83c/0x868\n [<90000000002457b4>] arch_do_signal_or_restart+0x54/0xfa0\n [<90000000015795e8>] irqentry_exit_to_user_mode+0xb8/0x138\n [<90000000002572d0>] tlb_do_page_fault_1+0x114/0x1b4\n\nThe problem is that base address allocated from hugetlbfs is not aligned\nwith pmd size. Here add a checking for hugetlbfs and align base address\nwith pmd size. After this patch the test case \"testcases/bin/hugefork02\"\npasses to run.\n\nThis is similar to the commit 7f24cbc9c4d42db8a3c8484d1 (\"mm/mmap: teach\ngeneric_get_unmapped_area{_topdown} to handle hugetlb mappings\").",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/242b34f48a377afe4b285b472bd0f17744fca8e8",
      "https://git.kernel.org/stable/c/3109d5ff484b7bc7b955f166974c6776d91f247b"
    ],
    "受影响版本": [
      "fa96b57c149061f71a70bd6582d995f6424fbbf4",
      "fa96b57c149061f71a70bd6582d995f6424fbbf4"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21943",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpio: aggregator: protect driver attr handlers against module unload\n\nBoth new_device_store and delete_device_store touch module global\nresources (e.g. gpio_aggregator_lock). To prevent race conditions with\nmodule unload, a reference needs to be held.\n\nAdd try_module_get() in these handlers.\n\nFor new_device_store, this eliminates what appears to be the most dangerous\nscenario: if an id is allocated from gpio_aggregator_idr but\nplatform_device_register has not yet been called or completed, a concurrent\nmodule unload could fail to unregister/delete the device, leaving behind a\ndangling platform device/GPIO forwarder. This can result in various issues.\nThe following simple reproducer demonstrates these problems:\n\n  #!/bin/bash\n  while :; do\n    # note: whether 'gpiochip0 0' exists or not does not matter.\n    echo 'gpiochip0 0' > /sys/bus/platform/drivers/gpio-aggregator/new_device\n  done &\n  while :; do\n    modprobe gpio-aggregator\n    modprobe -r gpio-aggregator\n  done &\n  wait\n\n  Starting with the following warning, several kinds of warnings will appear\n  and the system may become unstable:\n\n  ------------[ cut here ]------------\n  list_del corruption, ffff888103e2e980->next is LIST_POISON1 (dead000000000100)\n  WARNING: CPU: 1 PID: 1327 at lib/list_debug.c:56 __list_del_entry_valid_or_report+0xa3/0x120\n  [...]\n  RIP: 0010:__list_del_entry_valid_or_report+0xa3/0x120\n  [...]\n  Call Trace:\n   <TASK>\n   ? __list_del_entry_valid_or_report+0xa3/0x120\n   ? __warn.cold+0x93/0xf2\n   ? __list_del_entry_valid_or_report+0xa3/0x120\n   ? report_bug+0xe6/0x170\n   ? __irq_work_queue_local+0x39/0xe0\n   ? handle_bug+0x58/0x90\n   ? exc_invalid_op+0x13/0x60\n   ? asm_exc_invalid_op+0x16/0x20\n   ? __list_del_entry_valid_or_report+0xa3/0x120\n   gpiod_remove_lookup_table+0x22/0x60\n   new_device_store+0x315/0x350 [gpio_aggregator]\n   kernfs_fop_write_iter+0x137/0x1f0\n   vfs_write+0x262/0x430\n   ksys_write+0x60/0xd0\n   do_syscall_64+0x6c/0x180\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n   [...]\n   </TASK>\n  ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fd6aa1f8cbe0979eb66ac32ebc231bf0b10a2117",
      "https://git.kernel.org/stable/c/807789018186cf508ceb3a1f8f02935cd195717b",
      "https://git.kernel.org/stable/c/9334c88fc2fbc6836b307d269fcc1744c69701c0",
      "https://git.kernel.org/stable/c/d99dc8f7ea01ee1b21306e0eda8eb18a4af80db6",
      "https://git.kernel.org/stable/c/8fb07fb1bba91d45846ed8605c3097fe67a7d54c",
      "https://git.kernel.org/stable/c/56281a76b805b5ac61feb5d580139695a22f87f0",
      "https://git.kernel.org/stable/c/12f65d1203507f7db3ba59930fe29a3b8eee9945"
    ],
    "受影响版本": [
      "828546e24280f721350a7a0dcc92416e917b4382",
      "828546e24280f721350a7a0dcc92416e917b4382",
      "828546e24280f721350a7a0dcc92416e917b4382",
      "828546e24280f721350a7a0dcc92416e917b4382",
      "828546e24280f721350a7a0dcc92416e917b4382",
      "828546e24280f721350a7a0dcc92416e917b4382",
      "828546e24280f721350a7a0dcc92416e917b4382"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21932",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: abort vma_modify() on merge out of memory failure\n\nThe remainder of vma_modify() relies upon the vmg state remaining pristine\nafter a merge attempt.\n\nUsually this is the case, however in the one edge case scenario of a merge\nattempt failing not due to the specified range being unmergeable, but\nrather due to an out of memory error arising when attempting to commit the\nmerge, this assumption becomes untrue.\n\nThis results in vmg->start, end being modified, and thus the proceeding\nattempts to split the VMA will be done with invalid start/end values.\n\nThankfully, it is likely practically impossible for us to hit this in\nreality, as it would require a maple tree node pre-allocation failure that\nwould likely never happen due to it being 'too small to fail', i.e.  the\nkernel would simply keep retrying reclaim until it succeeded.\n\nHowever, this scenario remains theoretically possible, and what we are\ndoing here is wrong so we must correct it.\n\nThe safest option is, when this scenario occurs, to simply give up the\noperation.  If we cannot allocate memory to merge, then we cannot allocate\nmemory to split either (perhaps moreso!).\n\nAny scenario where this would be happening would be under very extreme\n(likely fatal) memory pressure, so it's best we give up early.\n\nSo there is no doubt it is appropriate to simply bail out in this\nscenario.\n\nHowever, in general we must if at all possible never assume VMG state is\nstable after a merge attempt, since merge operations update VMG fields. \nAs a result, additionally also make this clear by storing start, end in\nlocal variables.\n\nThe issue was reported originally by syzkaller, and by Brad Spengler (via\nan off-list discussion), and in both instances it manifested as a\ntriggering of the assert:\n\n\tVM_WARN_ON_VMG(start >= end, vmg);\n\nIn vma_merge_existing_range().\n\nIt seems at least one scenario in which this is occurring is one in which\nthe merge being attempted is due to an madvise() across multiple VMAs\nwhich looks like this:\n\n        start     end\n          |<------>|\n     |----------|------|\n     |   vma    | next |\n     |----------|------|\n\nWhen madvise_walk_vmas() is invoked, we first find vma in the above\n(determining prev to be equal to vma as we are offset into vma), and then\nenter the loop.\n\nWe determine the end of vma that forms part of the range we are\nmadvise()'ing by setting 'tmp' to this value:\n\n\t\t/* Here vma->vm_start <= start < (end|vma->vm_end) */\n\t\ttmp = vma->vm_end;\n\nWe then invoke the madvise() operation via visit(), letting prev get\nupdated to point to vma as part of the operation:\n\n\t\t/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */\n\t\terror = visit(vma, &prev, start, tmp, arg);\n\nWhere the visit() function pointer in this instance is\nmadvise_vma_behavior().\n\nAs observed in syzkaller reports, it is ultimately madvise_update_vma()\nthat is invoked, calling vma_modify_flags_name() and vma_modify() in turn.\n\nThen, in vma_modify(), we attempt the merge:\n\n\tmerged = vma_merge_existing_range(vmg);\n\tif (merged)\n\t\treturn merged;\n\nWe invoke this with vmg->start, end set to start, tmp as such:\n\n        start  tmp\n          |<--->|\n     |----------|------|\n     |   vma    | next |\n     |----------|------|\n\nWe find ourselves in the merge right scenario, but the one in which we\ncannot remove the middle (we are offset into vma).\n\nHere we have a special case where vmg->start, end get set to perhaps\nunintuitive values - we intended to shrink the middle VMA and expand the\nnext.\n\nThis means vmg->start, end are set to...  vma->vm_start, start.\n\nNow the commit_merge() fails, and vmg->start, end are left like this. \nThis means we return to the rest of vma_modify() with vmg->start, end\n(here denoted as start', end') set as:\n\n  start' end'\n     |<-->|\n     |----------|------|\n     |   vma    | next |\n     |----------|------|\n\nSo we now erroneously try to split accordingly.  This is where the\nunfortunate\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/79636d2981b066acd945117387a9533f56411f6f",
      "https://git.kernel.org/stable/c/53fd215f7886a1e8dea5a9ca1391dbb697fff601",
      "https://git.kernel.org/stable/c/47b16d0462a460000b8f05dfb1292377ac48f3ca"
    ],
    "受影响版本": [
      "2f1c6611b0a89afcb8641471af5f223c9caa01e0",
      "2f1c6611b0a89afcb8641471af5f223c9caa01e0",
      "2f1c6611b0a89afcb8641471af5f223c9caa01e0"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21931",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nhwpoison, memory_hotplug: lock folio before unmap hwpoisoned folio\n\nCommit b15c87263a69 (\"hwpoison, memory_hotplug: allow hwpoisoned pages to\nbe offlined) add page poison checks in do_migrate_range in order to make\noffline hwpoisoned page possible by introducing isolate_lru_page and\ntry_to_unmap for hwpoisoned page.  However folio lock must be held before\ncalling try_to_unmap.  Add it to fix this problem.\n\nWarning will be produced if folio is not locked during unmap:\n\n  ------------[ cut here ]------------\n  kernel BUG at ./include/linux/swapops.h:400!\n  Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\n  Modules linked in:\n  CPU: 4 UID: 0 PID: 411 Comm: bash Tainted: G        W          6.13.0-rc1-00016-g3c434c7ee82a-dirty #41\n  Tainted: [W]=WARN\n  Hardware name: QEMU QEMU Virtual Machine, BIOS 0.0.0 02/06/2015\n  pstate: 40400005 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n  pc : try_to_unmap_one+0xb08/0xd3c\n  lr : try_to_unmap_one+0x3dc/0xd3c\n  Call trace:\n   try_to_unmap_one+0xb08/0xd3c (P)\n   try_to_unmap_one+0x3dc/0xd3c (L)\n   rmap_walk_anon+0xdc/0x1f8\n   rmap_walk+0x3c/0x58\n   try_to_unmap+0x88/0x90\n   unmap_poisoned_folio+0x30/0xa8\n   do_migrate_range+0x4a0/0x568\n   offline_pages+0x5a4/0x670\n   memory_block_action+0x17c/0x374\n   memory_subsys_offline+0x3c/0x78\n   device_offline+0xa4/0xd0\n   state_store+0x8c/0xf0\n   dev_attr_store+0x18/0x2c\n   sysfs_kf_write+0x44/0x54\n   kernfs_fop_write_iter+0x118/0x1a8\n   vfs_write+0x3a8/0x4bc\n   ksys_write+0x6c/0xf8\n   __arm64_sys_write+0x1c/0x28\n   invoke_syscall+0x44/0x100\n   el0_svc_common.constprop.0+0x40/0xe0\n   do_el0_svc+0x1c/0x28\n   el0_svc+0x30/0xd0\n   el0t_64_sync_handler+0xc8/0xcc\n   el0t_64_sync+0x198/0x19c\n  Code: f9407be0 b5fff320 d4210000 17ffff97 (d4210000)\n  ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3926b572fd073491bde13ec42ee08ac1b337bf4d",
      "https://git.kernel.org/stable/c/93df6da64b004f75d307ed08d3f0f1020280d339",
      "https://git.kernel.org/stable/c/576a2f4c437c19bec7d05d05b5990f178d2b0f40",
      "https://git.kernel.org/stable/c/629dfc6ba5431056701d4e44830f3409b989955a",
      "https://git.kernel.org/stable/c/af288a426c3e3552b62595c6138ec6371a17dbba"
    ],
    "受影响版本": [
      "b15c87263a69272423771118c653e9a1d0672caa",
      "b15c87263a69272423771118c653e9a1d0672caa",
      "b15c87263a69272423771118c653e9a1d0672caa",
      "b15c87263a69272423771118c653e9a1d0672caa",
      "b15c87263a69272423771118c653e9a1d0672caa",
      "85ef35ab972b7484f41c3bb2bbc79de212e19129",
      "060853fdd434ce620dd1dd7619ede834bd33b9d0",
      "cb1206e85df291fefde27401190329e26996c54c",
      "2c25071bed4b1f9c4cfb10a7914847d7069794bf",
      "2c87072a3bf9bbcd747618bb2ccc3cd0da181db6",
      "a2b977e3d9e4298d28ebe5cfff9e0859b74a7ac7"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21910",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: cfg80211: regulatory: improve invalid hints checking\n\nSyzbot keeps reporting an issue [1] that occurs when erroneous symbols\nsent from userspace get through into user_alpha2[] via\nregulatory_hint_user() call. Such invalid regulatory hints should be\nrejected.\n\nWhile a sanity check from commit 47caf685a685 (\"cfg80211: regulatory:\nreject invalid hints\") looks to be enough to deter these very cases,\nthere is a way to get around it due to 2 reasons.\n\n1) The way isalpha() works, symbols other than latin lower and\nupper letters may be used to determine a country/domain.\nFor instance, greek letters will also be considered upper/lower\nletters and for such characters isalpha() will return true as well.\nHowever, ISO-3166-1 alpha2 codes should only hold latin\ncharacters.\n\n2) While processing a user regulatory request, between\nreg_process_hint_user() and regulatory_hint_user() there happens to\nbe a call to queue_regulatory_request() which modifies letters in\nrequest->alpha2[] with toupper(). This works fine for latin symbols,\nless so for weird letter characters from the second part of _ctype[].\n\nSyzbot triggers a warning in is_user_regdom_saved() by first sending\nover an unexpected non-latin letter that gets malformed by toupper()\ninto a character that ends up failing isalpha() check.\n\nPrevent this by enhancing is_an_alpha2() to ensure that incoming\nsymbols are latin letters and nothing else.\n\n[1] Syzbot report:\n------------[ cut here ]------------\nUnexpected user alpha2: A�\nWARNING: CPU: 1 PID: 964 at net/wireless/reg.c:442 is_user_regdom_saved net/wireless/reg.c:440 [inline]\nWARNING: CPU: 1 PID: 964 at net/wireless/reg.c:442 restore_alpha2 net/wireless/reg.c:3424 [inline]\nWARNING: CPU: 1 PID: 964 at net/wireless/reg.c:442 restore_regulatory_settings+0x3c0/0x1e50 net/wireless/reg.c:3516\nModules linked in:\nCPU: 1 UID: 0 PID: 964 Comm: kworker/1:2 Not tainted 6.12.0-rc5-syzkaller-00044-gc1e939a21eb1 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\nWorkqueue: events_power_efficient crda_timeout_work\nRIP: 0010:is_user_regdom_saved net/wireless/reg.c:440 [inline]\nRIP: 0010:restore_alpha2 net/wireless/reg.c:3424 [inline]\nRIP: 0010:restore_regulatory_settings+0x3c0/0x1e50 net/wireless/reg.c:3516\n...\nCall Trace:\n <TASK>\n crda_timeout_work+0x27/0x50 net/wireless/reg.c:542\n process_one_work kernel/workqueue.c:3229 [inline]\n process_scheduled_works+0xa65/0x1850 kernel/workqueue.c:3310\n worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n kthread+0x2f2/0x390 kernel/kthread.c:389\n ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/62b1a9bbfebba4b4c2bb6c1ede9ef7ecee7a9ff6",
      "https://git.kernel.org/stable/c/da3f599517ef2ea851208df3229d07728d238dc5",
      "https://git.kernel.org/stable/c/6a5e3b23054cee3b92683d1467e3fa83921f5622",
      "https://git.kernel.org/stable/c/f4112cb477c727a65787a4065a75ca593bb5b2f4",
      "https://git.kernel.org/stable/c/35ef07112b61b06eb30683a6563c9f6378c02476",
      "https://git.kernel.org/stable/c/be7c5f00aa7f1344293e4d48d0e12be83a2f223d",
      "https://git.kernel.org/stable/c/17aa34c84867f6cd181a5743e1c647e7766962a6",
      "https://git.kernel.org/stable/c/59b348be7597c4a9903cb003c69e37df20c04a30"
    ],
    "受影响版本": [
      "09d989d179d0c679043556dda77c51b41a2dae7e",
      "09d989d179d0c679043556dda77c51b41a2dae7e",
      "09d989d179d0c679043556dda77c51b41a2dae7e",
      "09d989d179d0c679043556dda77c51b41a2dae7e",
      "09d989d179d0c679043556dda77c51b41a2dae7e",
      "09d989d179d0c679043556dda77c51b41a2dae7e",
      "09d989d179d0c679043556dda77c51b41a2dae7e",
      "09d989d179d0c679043556dda77c51b41a2dae7e"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21907",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: memory-failure: update ttu flag inside unmap_poisoned_folio\n\nPatch series \"mm: memory_failure: unmap poisoned folio during migrate\nproperly\", v3.\n\nFix two bugs during folio migration if the folio is poisoned.\n\n\nThis patch (of 3):\n\nCommit 6da6b1d4a7df (\"mm/hwpoison: convert TTU_IGNORE_HWPOISON to\nTTU_HWPOISON\") introduce TTU_HWPOISON to replace TTU_IGNORE_HWPOISON in\norder to stop send SIGBUS signal when accessing an error page after a\nmemory error on a clean folio.  However during page migration, anon folio\nmust be set with TTU_HWPOISON during unmap_*().  For pagecache we need\nsome policy just like the one in hwpoison_user_mappings to set this flag. \nSo move this policy from hwpoison_user_mappings to unmap_poisoned_folio to\nhandle this warning properly.\n\nWarning will be produced during unamp poison folio with the following log:\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 1 PID: 365 at mm/rmap.c:1847 try_to_unmap_one+0x8fc/0xd3c\n  Modules linked in:\n  CPU: 1 UID: 0 PID: 365 Comm: bash Tainted: G        W          6.13.0-rc1-00018-gacdb4bbda7ab #42\n  Tainted: [W]=WARN\n  Hardware name: QEMU QEMU Virtual Machine, BIOS 0.0.0 02/06/2015\n  pstate: 20400005 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n  pc : try_to_unmap_one+0x8fc/0xd3c\n  lr : try_to_unmap_one+0x3dc/0xd3c\n  Call trace:\n   try_to_unmap_one+0x8fc/0xd3c (P)\n   try_to_unmap_one+0x3dc/0xd3c (L)\n   rmap_walk_anon+0xdc/0x1f8\n   rmap_walk+0x3c/0x58\n   try_to_unmap+0x88/0x90\n   unmap_poisoned_folio+0x30/0xa8\n   do_migrate_range+0x4a0/0x568\n   offline_pages+0x5a4/0x670\n   memory_block_action+0x17c/0x374\n   memory_subsys_offline+0x3c/0x78\n   device_offline+0xa4/0xd0\n   state_store+0x8c/0xf0\n   dev_attr_store+0x18/0x2c\n   sysfs_kf_write+0x44/0x54\n   kernfs_fop_write_iter+0x118/0x1a8\n   vfs_write+0x3a8/0x4bc\n   ksys_write+0x6c/0xf8\n   __arm64_sys_write+0x1c/0x28\n   invoke_syscall+0x44/0x100\n   el0_svc_common.constprop.0+0x40/0xe0\n   do_el0_svc+0x1c/0x28\n   el0_svc+0x30/0xd0\n   el0t_64_sync_handler+0xc8/0xcc\n   el0t_64_sync+0x198/0x19c\n  ---[ end trace 0000000000000000 ]---\n\n[mawupeng1@huawei.com: unmap_poisoned_folio(): remove shadowed local `mapping', per Miaohe]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/608cc7deb428f1122ed426060233622ebf667b6e",
      "https://git.kernel.org/stable/c/425c12c076e6fc6b2cb04b9f960319d31dcabc76",
      "https://git.kernel.org/stable/c/b81679b1633aa43c0d973adfa816d78c1ed0d032"
    ],
    "受影响版本": [
      "6da6b1d4a7df8c35770186b53ef65d388398e139",
      "6da6b1d4a7df8c35770186b53ef65d388398e139",
      "6da6b1d4a7df8c35770186b53ef65d388398e139",
      "deab8114fb67dcb0e6293b665c3c7083fbadff17",
      "6dcf132fe236045bd7f50c008660ea086d09af1f"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21906",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: mvm: clean up ROC on failure\n\nIf the firmware fails to start the session protection, then we\ndo call iwl_mvm_roc_finished() here, but that won't do anything\nat all because IWL_MVM_STATUS_ROC_P2P_RUNNING was never set.\nSet IWL_MVM_STATUS_ROC_P2P_RUNNING in the failure/stop path.\nIf it started successfully before, it's already set, so that\ndoesn't matter, and if it didn't start it needs to be set to\nclean up.\n\nNot doing so will lead to a WARN_ON() later on a fresh remain-\non-channel, since the link is already active when activated as\nit was never deactivated.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a88c18409b5d69f426d5acc583c053eac71756a3",
      "https://git.kernel.org/stable/c/d1a12fcb9051bbf38b2e5af310ffb102a0fab6f9",
      "https://git.kernel.org/stable/c/f9751163bffd3fe60794929829f810968c6de73d"
    ],
    "受影响版本": [
      "35c1bbd93c4e6969b3ac238b48a8bdff3e223ed8",
      "35c1bbd93c4e6969b3ac238b48a8bdff3e223ed8",
      "35c1bbd93c4e6969b3ac238b48a8bdff3e223ed8"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21905",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: limit printed string from FW file\n\nThere's no guarantee here that the file is always with a\nNUL-termination, so reading the string may read beyond the\nend of the TLV. If that's the last TLV in the file, it can\nperhaps even read beyond the end of the file buffer.\n\nFix that by limiting the print format to the size of the\nbuffer we have.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/38f0d398b6d7640d223db69df022c4a232f24774",
      "https://git.kernel.org/stable/c/c0e626f2b2390472afac52dfe72b29daf9ed8e1d",
      "https://git.kernel.org/stable/c/47616b82f2d42ea2060334746fed9a2988d845c9",
      "https://git.kernel.org/stable/c/88ed69f924638c7503644e1f8eed1e976f3ffa7a",
      "https://git.kernel.org/stable/c/b02f8d5a71c8571ccf77f285737c566db73ef5e5",
      "https://git.kernel.org/stable/c/f265e6031d0bc4fc40c4619cb42466722b46eaa9",
      "https://git.kernel.org/stable/c/59cdda202829d1d6a095d233386870a59aff986f",
      "https://git.kernel.org/stable/c/e0dc2c1bef722cbf16ae557690861e5f91208129"
    ],
    "受影响版本": [
      "aee1b6385e29e472ae5592b9652b750a29bf702e",
      "aee1b6385e29e472ae5592b9652b750a29bf702e",
      "aee1b6385e29e472ae5592b9652b750a29bf702e",
      "aee1b6385e29e472ae5592b9652b750a29bf702e",
      "aee1b6385e29e472ae5592b9652b750a29bf702e",
      "aee1b6385e29e472ae5592b9652b750a29bf702e",
      "aee1b6385e29e472ae5592b9652b750a29bf702e",
      "aee1b6385e29e472ae5592b9652b750a29bf702e"
    ],
    "公开日期": "2025年04月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21878",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: npcm: disable interrupt enable bit before devm_request_irq\n\nThe customer reports that there is a soft lockup issue related to\nthe i2c driver. After checking, the i2c module was doing a tx transfer\nand the bmc machine reboots in the middle of the i2c transaction, the i2c\nmodule keeps the status without being reset.\n\nDue to such an i2c module status, the i2c irq handler keeps getting\ntriggered since the i2c irq handler is registered in the kernel booting\nprocess after the bmc machine is doing a warm rebooting.\nThe continuous triggering is stopped by the soft lockup watchdog timer.\n\nDisable the interrupt enable bit in the i2c module before calling\ndevm_request_irq to fix this issue since the i2c relative status bit\nis read-only.\n\nHere is the soft lockup log.\n[   28.176395] watchdog: BUG: soft lockup - CPU#0 stuck for 26s! [swapper/0:1]\n[   28.183351] Modules linked in:\n[   28.186407] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.15.120-yocto-s-dirty-bbebc78 #1\n[   28.201174] pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   28.208128] pc : __do_softirq+0xb0/0x368\n[   28.212055] lr : __do_softirq+0x70/0x368\n[   28.215972] sp : ffffff8035ebca00\n[   28.219278] x29: ffffff8035ebca00 x28: 0000000000000002 x27: ffffff80071a3780\n[   28.226412] x26: ffffffc008bdc000 x25: ffffffc008bcc640 x24: ffffffc008be50c0\n[   28.233546] x23: ffffffc00800200c x22: 0000000000000000 x21: 000000000000001b\n[   28.240679] x20: 0000000000000000 x19: ffffff80001c3200 x18: ffffffffffffffff\n[   28.247812] x17: ffffffc02d2e0000 x16: ffffff8035eb8b40 x15: 00001e8480000000\n[   28.254945] x14: 02c3647e37dbfcb6 x13: 02c364f2ab14200c x12: 0000000002c364f2\n[   28.262078] x11: 00000000fa83b2da x10: 000000000000b67e x9 : ffffffc008010250\n[   28.269211] x8 : 000000009d983d00 x7 : 7fffffffffffffff x6 : 0000036d74732434\n[   28.276344] x5 : 00ffffffffffffff x4 : 0000000000000015 x3 : 0000000000000198\n[   28.283476] x2 : ffffffc02d2e0000 x1 : 00000000000000e0 x0 : ffffffc008bdcb40\n[   28.290611] Call trace:\n[   28.293052]  __do_softirq+0xb0/0x368\n[   28.296625]  __irq_exit_rcu+0xe0/0x100\n[   28.300374]  irq_exit+0x14/0x20\n[   28.303513]  handle_domain_irq+0x68/0x90\n[   28.307440]  gic_handle_irq+0x78/0xb0\n[   28.311098]  call_on_irq_stack+0x20/0x38\n[   28.315019]  do_interrupt_handler+0x54/0x5c\n[   28.319199]  el1_interrupt+0x2c/0x4c\n[   28.322777]  el1h_64_irq_handler+0x14/0x20\n[   28.326872]  el1h_64_irq+0x74/0x78\n[   28.330269]  __setup_irq+0x454/0x780\n[   28.333841]  request_threaded_irq+0xd0/0x1b4\n[   28.338107]  devm_request_threaded_irq+0x84/0x100\n[   28.342809]  npcm_i2c_probe_bus+0x188/0x3d0\n[   28.346990]  platform_probe+0x6c/0xc4\n[   28.350653]  really_probe+0xcc/0x45c\n[   28.354227]  __driver_probe_device+0x8c/0x160\n[   28.358578]  driver_probe_device+0x44/0xe0\n[   28.362670]  __driver_attach+0x124/0x1d0\n[   28.366589]  bus_for_each_dev+0x7c/0xe0\n[   28.370426]  driver_attach+0x28/0x30\n[   28.373997]  bus_add_driver+0x124/0x240\n[   28.377830]  driver_register+0x7c/0x124\n[   28.381662]  __platform_driver_register+0x2c/0x34\n[   28.386362]  npcm_i2c_init+0x3c/0x5c\n[   28.389937]  do_one_initcall+0x74/0x230\n[   28.393768]  kernel_init_freeable+0x24c/0x2b4\n[   28.398126]  kernel_init+0x28/0x130\n[   28.401614]  ret_from_fork+0x10/0x20\n[   28.405189] Kernel panic - not syncing: softlockup: hung tasks\n[   28.411011] SMP: stopping secondary CPUs\n[   28.414933] Kernel Offset: disabled\n[   28.418412] CPU features: 0x00000000,00000802\n[   28.427644] Rebooting in 20 seconds..",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f32d7b4dc6e791523c70e83049645dcba2a2aa33",
      "https://git.kernel.org/stable/c/e3aea1dba97d31eceed7b622000af0406988b9c8",
      "https://git.kernel.org/stable/c/545b563eb00d0576775da4011b3f7ffefc9e8c60",
      "https://git.kernel.org/stable/c/1b267e1b87d52b16e7dfcc7ab2ab760f6f8f9ca9",
      "https://git.kernel.org/stable/c/12d0e39916705b68d2d8ba20a8e35d1d27afc260",
      "https://git.kernel.org/stable/c/846e371631c57365eeb89e5db1ab0f344169af93",
      "https://git.kernel.org/stable/c/dd1998e243f5fa25d348a384ba0b6c84d980f2b2"
    ],
    "受影响版本": [
      "56a1485b102ed1cd5a4af8e87ed794699fd1cad2",
      "56a1485b102ed1cd5a4af8e87ed794699fd1cad2",
      "56a1485b102ed1cd5a4af8e87ed794699fd1cad2",
      "56a1485b102ed1cd5a4af8e87ed794699fd1cad2",
      "56a1485b102ed1cd5a4af8e87ed794699fd1cad2",
      "56a1485b102ed1cd5a4af8e87ed794699fd1cad2",
      "56a1485b102ed1cd5a4af8e87ed794699fd1cad2"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21877",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nusbnet: gl620a: fix endpoint checking in genelink_bind()\n\nSyzbot reports [1] a warning in usb_submit_urb() triggered by\ninconsistencies between expected and actually present endpoints\nin gl620a driver. Since genelink_bind() does not properly\nverify whether specified eps are in fact provided by the device,\nin this case, an artificially manufactured one, one may get a\nmismatch.\n\nFix the issue by resorting to a usbnet utility function\nusbnet_get_endpoints(), usually reserved for this very problem.\nCheck for endpoints and return early before proceeding further if\nany are missing.\n\n[1] Syzbot report:\nusb 5-1: Manufacturer: syz\nusb 5-1: SerialNumber: syz\nusb 5-1: config 0 descriptor??\ngl620a 5-1:0.23 usb0: register 'gl620a' at usb-dummy_hcd.0-1, ...\n------------[ cut here ]------------\nusb 5-1: BOGUS urb xfer, pipe 3 != type 1\nWARNING: CPU: 2 PID: 1841 at drivers/usb/core/urb.c:503 usb_submit_urb+0xe4b/0x1730 drivers/usb/core/urb.c:503\nModules linked in:\nCPU: 2 UID: 0 PID: 1841 Comm: kworker/2:2 Not tainted 6.12.0-syzkaller-07834-g06afb0f36106 #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\nWorkqueue: mld mld_ifc_work\nRIP: 0010:usb_submit_urb+0xe4b/0x1730 drivers/usb/core/urb.c:503\n...\nCall Trace:\n <TASK>\n usbnet_start_xmit+0x6be/0x2780 drivers/net/usb/usbnet.c:1467\n __netdev_start_xmit include/linux/netdevice.h:5002 [inline]\n netdev_start_xmit include/linux/netdevice.h:5011 [inline]\n xmit_one net/core/dev.c:3590 [inline]\n dev_hard_start_xmit+0x9a/0x7b0 net/core/dev.c:3606\n sch_direct_xmit+0x1ae/0xc30 net/sched/sch_generic.c:343\n __dev_xmit_skb net/core/dev.c:3827 [inline]\n __dev_queue_xmit+0x13d4/0x43e0 net/core/dev.c:4400\n dev_queue_xmit include/linux/netdevice.h:3168 [inline]\n neigh_resolve_output net/core/neighbour.c:1514 [inline]\n neigh_resolve_output+0x5bc/0x950 net/core/neighbour.c:1494\n neigh_output include/net/neighbour.h:539 [inline]\n ip6_finish_output2+0xb1b/0x2070 net/ipv6/ip6_output.c:141\n __ip6_finish_output net/ipv6/ip6_output.c:215 [inline]\n ip6_finish_output+0x3f9/0x1360 net/ipv6/ip6_output.c:226\n NF_HOOK_COND include/linux/netfilter.h:303 [inline]\n ip6_output+0x1f8/0x540 net/ipv6/ip6_output.c:247\n dst_output include/net/dst.h:450 [inline]\n NF_HOOK include/linux/netfilter.h:314 [inline]\n NF_HOOK include/linux/netfilter.h:308 [inline]\n mld_sendpack+0x9f0/0x11d0 net/ipv6/mcast.c:1819\n mld_send_cr net/ipv6/mcast.c:2120 [inline]\n mld_ifc_work+0x740/0xca0 net/ipv6/mcast.c:2651\n process_one_work+0x9c5/0x1ba0 kernel/workqueue.c:3229\n process_scheduled_works kernel/workqueue.c:3310 [inline]\n worker_thread+0x6c8/0xf00 kernel/workqueue.c:3391\n kthread+0x2c1/0x3a0 kernel/kthread.c:389\n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5f2dbabbce04b1ffcd6d8d07564adb94db577536",
      "https://git.kernel.org/stable/c/24dd971104057c8828d420a48e0a5af6e6f30d3e",
      "https://git.kernel.org/stable/c/9bcb8cbc3e5d67eb223bfb7e2291a270dbb699dc",
      "https://git.kernel.org/stable/c/67ebc3391c8377738e97a43374054d9718fdb6e4",
      "https://git.kernel.org/stable/c/a2ee5e55b50a97d13617c8653482c0ad4decff8c",
      "https://git.kernel.org/stable/c/4e8b8d43373bf837be159366f0192502f97ec7a5",
      "https://git.kernel.org/stable/c/ded25730c96949cb8b048b29c557e38569124943",
      "https://git.kernel.org/stable/c/1cf9631d836b289bd5490776551961c883ae8a4f"
    ],
    "受影响版本": [
      "47ee3051c856cc2aa95d35d577a8cb37279d540f",
      "47ee3051c856cc2aa95d35d577a8cb37279d540f",
      "47ee3051c856cc2aa95d35d577a8cb37279d540f",
      "47ee3051c856cc2aa95d35d577a8cb37279d540f",
      "47ee3051c856cc2aa95d35d577a8cb37279d540f",
      "47ee3051c856cc2aa95d35d577a8cb37279d540f",
      "47ee3051c856cc2aa95d35d577a8cb37279d540f",
      "47ee3051c856cc2aa95d35d577a8cb37279d540f"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21872",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nefi: Don't map the entire mokvar table to determine its size\n\nCurrently, when validating the mokvar table, we (re)map the entire table\non each iteration of the loop, adding space as we discover new entries.\nIf the table grows over a certain size, this fails due to limitations of\nearly_memmap(), and we get a failure and traceback:\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 0 at mm/early_ioremap.c:139 __early_ioremap+0xef/0x220\n  ...\n  Call Trace:\n   <TASK>\n   ? __early_ioremap+0xef/0x220\n   ? __warn.cold+0x93/0xfa\n   ? __early_ioremap+0xef/0x220\n   ? report_bug+0xff/0x140\n   ? early_fixup_exception+0x5d/0xb0\n   ? early_idt_handler_common+0x2f/0x3a\n   ? __early_ioremap+0xef/0x220\n   ? efi_mokvar_table_init+0xce/0x1d0\n   ? setup_arch+0x864/0xc10\n   ? start_kernel+0x6b/0xa10\n   ? x86_64_start_reservations+0x24/0x30\n   ? x86_64_start_kernel+0xed/0xf0\n   ? common_startup_64+0x13e/0x141\n   </TASK>\n  ---[ end trace 0000000000000000 ]---\n  mokvar: Failed to map EFI MOKvar config table pa=0x7c4c3000, size=265187.\n\nMapping the entire structure isn't actually necessary, as we don't ever\nneed more than one entry header mapped at once.\n\nChanges efi_mokvar_table_init() to only map each entry header, not the\nentire table, when determining the table size.  Since we're not mapping\nany data past the variable name, it also changes the code to enforce\nthat each variable name is NUL terminated, rather than attempting to\nverify it in place.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/46c0454ffb78ce9d3355a3cccac86383ea8ddd55",
      "https://git.kernel.org/stable/c/ea3f0b362dfe4ef885ef812bfaf4088176422c91",
      "https://git.kernel.org/stable/c/65f4aebb8127708ba668dd938e83b8558abfc5cd",
      "https://git.kernel.org/stable/c/97bd560b6cc4c26386a53b4881bf03e96f9ba03a",
      "https://git.kernel.org/stable/c/2b90e7ace79774a3540ce569e000388f8d22c9e0"
    ],
    "受影响版本": [
      "58c909022a5a56cd1d9e89c8c5461fd1f6a27bb5",
      "58c909022a5a56cd1d9e89c8c5461fd1f6a27bb5",
      "58c909022a5a56cd1d9e89c8c5461fd1f6a27bb5",
      "58c909022a5a56cd1d9e89c8c5461fd1f6a27bb5",
      "58c909022a5a56cd1d9e89c8c5461fd1f6a27bb5"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21861",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/migrate_device: don't add folio to be freed to LRU in migrate_device_finalize()\n\nIf migration succeeded, we called\nfolio_migrate_flags()->mem_cgroup_migrate() to migrate the memcg from the\nold to the new folio.  This will set memcg_data of the old folio to 0.\n\nSimilarly, if migration failed, memcg_data of the dst folio is left unset.\n\nIf we call folio_putback_lru() on such folios (memcg_data == 0), we will\nadd the folio to be freed to the LRU, making memcg code unhappy.  Running\nthe hmm selftests:\n\n  # ./hmm-tests\n  ...\n  #  RUN           hmm.hmm_device_private.migrate ...\n  [  102.078007][T14893] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x7ff27d200 pfn:0x13cc00\n  [  102.079974][T14893] anon flags: 0x17ff00000020018(uptodate|dirty|swapbacked|node=0|zone=2|lastcpupid=0x7ff)\n  [  102.082037][T14893] raw: 017ff00000020018 dead000000000100 dead000000000122 ffff8881353896c9\n  [  102.083687][T14893] raw: 00000007ff27d200 0000000000000000 00000001ffffffff 0000000000000000\n  [  102.085331][T14893] page dumped because: VM_WARN_ON_ONCE_FOLIO(!memcg && !mem_cgroup_disabled())\n  [  102.087230][T14893] ------------[ cut here ]------------\n  [  102.088279][T14893] WARNING: CPU: 0 PID: 14893 at ./include/linux/memcontrol.h:726 folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.090478][T14893] Modules linked in:\n  [  102.091244][T14893] CPU: 0 UID: 0 PID: 14893 Comm: hmm-tests Not tainted 6.13.0-09623-g6c216bc522fd #151\n  [  102.093089][T14893] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014\n  [  102.094848][T14893] RIP: 0010:folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.096104][T14893] Code: ...\n  [  102.099908][T14893] RSP: 0018:ffffc900236c37b0 EFLAGS: 00010293\n  [  102.101152][T14893] RAX: 0000000000000000 RBX: ffffea0004f30000 RCX: ffffffff8183f426\n  [  102.102684][T14893] RDX: ffff8881063cb880 RSI: ffffffff81b8117f RDI: ffff8881063cb880\n  [  102.104227][T14893] RBP: 0000000000000000 R08: 0000000000000005 R09: 0000000000000000\n  [  102.105757][T14893] R10: 0000000000000001 R11: 0000000000000002 R12: ffffc900236c37d8\n  [  102.107296][T14893] R13: ffff888277a2bcb0 R14: 000000000000001f R15: 0000000000000000\n  [  102.108830][T14893] FS:  00007ff27dbdd740(0000) GS:ffff888277a00000(0000) knlGS:0000000000000000\n  [  102.110643][T14893] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [  102.111924][T14893] CR2: 00007ff27d400000 CR3: 000000010866e000 CR4: 0000000000750ef0\n  [  102.113478][T14893] PKRU: 55555554\n  [  102.114172][T14893] Call Trace:\n  [  102.114805][T14893]  <TASK>\n  [  102.115397][T14893]  ? folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.116547][T14893]  ? __warn.cold+0x110/0x210\n  [  102.117461][T14893]  ? folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.118667][T14893]  ? report_bug+0x1b9/0x320\n  [  102.119571][T14893]  ? handle_bug+0x54/0x90\n  [  102.120494][T14893]  ? exc_invalid_op+0x17/0x50\n  [  102.121433][T14893]  ? asm_exc_invalid_op+0x1a/0x20\n  [  102.122435][T14893]  ? __wake_up_klogd.part.0+0x76/0xd0\n  [  102.123506][T14893]  ? dump_page+0x4f/0x60\n  [  102.124352][T14893]  ? folio_lruvec_lock_irqsave+0x10e/0x170\n  [  102.125500][T14893]  folio_batch_move_lru+0xd4/0x200\n  [  102.126577][T14893]  ? __pfx_lru_add+0x10/0x10\n  [  102.127505][T14893]  __folio_batch_add_and_move+0x391/0x720\n  [  102.128633][T14893]  ? __pfx_lru_add+0x10/0x10\n  [  102.129550][T14893]  folio_putback_lru+0x16/0x80\n  [  102.130564][T14893]  migrate_device_finalize+0x9b/0x530\n  [  102.131640][T14893]  dmirror_migrate_to_device.constprop.0+0x7c5/0xad0\n  [  102.133047][T14893]  dmirror_fops_unlocked_ioctl+0x89b/0xc80\n\nLikely, nothing else goes wrong: putting the last folio reference will\nremove the folio from the LRU again.  So besides memcg complaining, adding\nthe folio to be freed to the LRU is just an unnecessary step.\n\nThe new flow resembles what we have in migrate_folio_move(): add the dst\nto the lru, rem\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3f9240d59e9a95d19f06120bfd1d0e681c6c0ac7",
      "https://git.kernel.org/stable/c/069dd21ea8262204f94737878389c2815a054a9e",
      "https://git.kernel.org/stable/c/41cddf83d8b00f29fd105e7a0777366edc69a5cf"
    ],
    "受影响版本": [
      "8763cb45ab967a92a5ee49e9c544c0f0ea90e2d6",
      "8763cb45ab967a92a5ee49e9c544c0f0ea90e2d6",
      "8763cb45ab967a92a5ee49e9c544c0f0ea90e2d6"
    ],
    "公开日期": "2025年03月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21858",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ngeneve: Fix use-after-free in geneve_find_dev().\n\nsyzkaller reported a use-after-free in geneve_find_dev() [0]\nwithout repro.\n\ngeneve_configure() links struct geneve_dev.next to\nnet_generic(net, geneve_net_id)->geneve_list.\n\nThe net here could differ from dev_net(dev) if IFLA_NET_NS_PID,\nIFLA_NET_NS_FD, or IFLA_TARGET_NETNSID is set.\n\nWhen dev_net(dev) is dismantled, geneve_exit_batch_rtnl() finally\ncalls unregister_netdevice_queue() for each dev in the netns,\nand later the dev is freed.\n\nHowever, its geneve_dev.next is still linked to the backend UDP\nsocket netns.\n\nThen, use-after-free will occur when another geneve dev is created\nin the netns.\n\nLet's call geneve_dellink() instead in geneve_destroy_tunnels().\n\n[0]:\nBUG: KASAN: slab-use-after-free in geneve_find_dev drivers/net/geneve.c:1295 [inline]\nBUG: KASAN: slab-use-after-free in geneve_configure+0x234/0x858 drivers/net/geneve.c:1343\nRead of size 2 at addr ffff000054d6ee24 by task syz.1.4029/13441\n\nCPU: 1 UID: 0 PID: 13441 Comm: syz.1.4029 Not tainted 6.13.0-g0ad9617c78ac #24 dc35ca22c79fb82e8e7bc5c9c9adafea898b1e3d\nHardware name: linux,dummy-virt (DT)\nCall trace:\n show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:466 (C)\n __dump_stack lib/dump_stack.c:94 [inline]\n dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120\n print_address_description mm/kasan/report.c:378 [inline]\n print_report+0x16c/0x6f0 mm/kasan/report.c:489\n kasan_report+0xc0/0x120 mm/kasan/report.c:602\n __asan_report_load2_noabort+0x20/0x30 mm/kasan/report_generic.c:379\n geneve_find_dev drivers/net/geneve.c:1295 [inline]\n geneve_configure+0x234/0x858 drivers/net/geneve.c:1343\n geneve_newlink+0xb8/0x128 drivers/net/geneve.c:1634\n rtnl_newlink_create+0x23c/0x868 net/core/rtnetlink.c:3795\n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]\n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021\n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911\n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543\n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938\n netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]\n netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1348\n netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1892\n sock_sendmsg_nosec net/socket.c:713 [inline]\n __sock_sendmsg net/socket.c:728 [inline]\n ____sys_sendmsg+0x410/0x6f8 net/socket.c:2568\n ___sys_sendmsg+0x178/0x1d8 net/socket.c:2622\n __sys_sendmsg net/socket.c:2654 [inline]\n __do_sys_sendmsg net/socket.c:2659 [inline]\n __se_sys_sendmsg net/socket.c:2657 [inline]\n __arm64_sys_sendmsg+0x12c/0x1c8 net/socket.c:2657\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49\n el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132\n do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151\n el0_svc+0x4c/0xa8 arch/arm64/kernel/entry-common.c:744\n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:762\n el0t_64_sync+0x198/0x1a0 arch/arm64/kernel/entry.S:600\n\nAllocated by task 13247:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x30/0x68 mm/kasan/common.c:68\n kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568\n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]\n __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394\n kasan_kmalloc include/linux/kasan.h:260 [inline]\n __do_kmalloc_node mm/slub.c:4298 [inline]\n __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4304\n __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:645\n alloc_netdev_mqs+0xb8/0x11a0 net/core/dev.c:11470\n rtnl_create_link+0x2b8/0xb50 net/core/rtnetlink.c:3604\n rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3780\n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]\n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021\n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911\n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543\n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938\n netlink_unicast_kernel net/netlink/af_n\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d5e86e27de0936f3cb0a299ce519d993e9cf3886",
      "https://git.kernel.org/stable/c/5a0538ac6826807d6919f6aecbb8996c2865af2c",
      "https://git.kernel.org/stable/c/f74f6560146714241c6e167b03165ee77a86e316",
      "https://git.kernel.org/stable/c/904e746b2e7fa952ab8801b303ce826a63153d78",
      "https://git.kernel.org/stable/c/3ce92ca990cfac88a87c61df3cc0b5880e688ecf",
      "https://git.kernel.org/stable/c/da9b0ae47f084014b1e4b3f31f70a0defd047ff3",
      "https://git.kernel.org/stable/c/788dbca056a8783ec063da3c9d49a3a71c76c283",
      "https://git.kernel.org/stable/c/9593172d93b9f91c362baec4643003dc29802929"
    ],
    "受影响版本": [
      "2d07dc79fe04a43d82a346ced6bbf07bdb523f1b",
      "2d07dc79fe04a43d82a346ced6bbf07bdb523f1b",
      "2d07dc79fe04a43d82a346ced6bbf07bdb523f1b",
      "2d07dc79fe04a43d82a346ced6bbf07bdb523f1b",
      "2d07dc79fe04a43d82a346ced6bbf07bdb523f1b",
      "2d07dc79fe04a43d82a346ced6bbf07bdb523f1b",
      "2d07dc79fe04a43d82a346ced6bbf07bdb523f1b",
      "2d07dc79fe04a43d82a346ced6bbf07bdb523f1b"
    ],
    "公开日期": "2025年03月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21845",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmtd: spi-nor: sst: Fix SST write failure\n\n'commit 18bcb4aa54ea (\"mtd: spi-nor: sst: Factor out common write operation\nto `sst_nor_write_data()`\")' introduced a bug where only one byte of data\nis written, regardless of the number of bytes passed to\nsst_nor_write_data(), causing a kernel crash during the write operation.\nEnsure the correct number of bytes are written as passed to\nsst_nor_write_data().\n\nCall trace:\n[   57.400180] ------------[ cut here ]------------\n[   57.404842] While writing 2 byte written 1 bytes\n[   57.409493] WARNING: CPU: 0 PID: 737 at drivers/mtd/spi-nor/sst.c:187 sst_nor_write_data+0x6c/0x74\n[   57.418464] Modules linked in:\n[   57.421517] CPU: 0 UID: 0 PID: 737 Comm: mtd_debug Not tainted 6.12.0-g5ad04afd91f9 #30\n[   57.429517] Hardware name: Xilinx Versal A2197 Processor board revA - x-prc-02 revA (DT)\n[   57.437600] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   57.444557] pc : sst_nor_write_data+0x6c/0x74\n[   57.448911] lr : sst_nor_write_data+0x6c/0x74\n[   57.453264] sp : ffff80008232bb40\n[   57.456570] x29: ffff80008232bb40 x28: 0000000000010000 x27: 0000000000000001\n[   57.463708] x26: 000000000000ffff x25: 0000000000000000 x24: 0000000000000000\n[   57.470843] x23: 0000000000010000 x22: ffff80008232bbf0 x21: ffff000816230000\n[   57.477978] x20: ffff0008056c0080 x19: 0000000000000002 x18: 0000000000000006\n[   57.485112] x17: 0000000000000000 x16: 0000000000000000 x15: ffff80008232b580\n[   57.492246] x14: 0000000000000000 x13: ffff8000816d1530 x12: 00000000000004a4\n[   57.499380] x11: 000000000000018c x10: ffff8000816fd530 x9 : ffff8000816d1530\n[   57.506515] x8 : 00000000fffff7ff x7 : ffff8000816fd530 x6 : 0000000000000001\n[   57.513649] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000\n[   57.520782] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0008049b0000\n[   57.527916] Call trace:\n[   57.530354]  sst_nor_write_data+0x6c/0x74\n[   57.534361]  sst_nor_write+0xb4/0x18c\n[   57.538019]  mtd_write_oob_std+0x7c/0x88\n[   57.541941]  mtd_write_oob+0x70/0xbc\n[   57.545511]  mtd_write+0x68/0xa8\n[   57.548733]  mtdchar_write+0x10c/0x290\n[   57.552477]  vfs_write+0xb4/0x3a8\n[   57.555791]  ksys_write+0x74/0x10c\n[   57.559189]  __arm64_sys_write+0x1c/0x28\n[   57.563109]  invoke_syscall+0x54/0x11c\n[   57.566856]  el0_svc_common.constprop.0+0xc0/0xe0\n[   57.571557]  do_el0_svc+0x1c/0x28\n[   57.574868]  el0_svc+0x30/0xcc\n[   57.577921]  el0t_64_sync_handler+0x120/0x12c\n[   57.582276]  el0t_64_sync+0x190/0x194\n[   57.585933] ---[ end trace 0000000000000000 ]---\n\n[pratyush@kernel.org: add Cc stable tag]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/bb1accc7e0f688886f0c634f2e878b8ac4ee6a58",
      "https://git.kernel.org/stable/c/9553391f32f8c43e12fc7c04e1035160b5ea20bf",
      "https://git.kernel.org/stable/c/539bd20352832b9244238a055eb169ccf1c41ff6"
    ],
    "受影响版本": [
      "18bcb4aa54eab75dce41e5c176a1c2bff94f0f79",
      "18bcb4aa54eab75dce41e5c176a1c2bff94f0f79",
      "18bcb4aa54eab75dce41e5c176a1c2bff94f0f79"
    ],
    "公开日期": "2025年03月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21824",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpu: host1x: Fix a use of uninitialized mutex\n\ncommit c8347f915e67 (\"gpu: host1x: Fix boot regression for Tegra\")\ncaused a use of uninitialized mutex leading to below warning when\nCONFIG_DEBUG_MUTEXES and CONFIG_DEBUG_LOCK_ALLOC are enabled.\n\n[   41.662843] ------------[ cut here ]------------\n[   41.663012] DEBUG_LOCKS_WARN_ON(lock->magic != lock)\n[   41.663035] WARNING: CPU: 4 PID: 794 at kernel/locking/mutex.c:587 __mutex_lock+0x670/0x878\n[   41.663458] Modules linked in: rtw88_8822c(+) bluetooth(+) rtw88_pci rtw88_core mac80211 aquantia libarc4 crc_itu_t cfg80211 tegra194_cpufreq dwmac_tegra(+) arm_dsu_pmu stmmac_platform stmmac pcs_xpcs rfkill at24 host1x(+) tegra_bpmp_thermal ramoops reed_solomon fuse loop nfnetlink xfs mmc_block rpmb_core ucsi_ccg ina3221 crct10dif_ce xhci_tegra ghash_ce lm90 sha2_ce sha256_arm64 sha1_ce sdhci_tegra pwm_fan sdhci_pltfm sdhci gpio_keys rtc_tegra cqhci mmc_core phy_tegra_xusb i2c_tegra tegra186_gpc_dma i2c_tegra_bpmp spi_tegra114 dm_mirror dm_region_hash dm_log dm_mod\n[   41.665078] CPU: 4 UID: 0 PID: 794 Comm: (udev-worker) Not tainted 6.11.0-29.31_1538613708.el10.aarch64+debug #1\n[   41.665838] Hardware name: NVIDIA NVIDIA Jetson AGX Orin Developer Kit/Jetson, BIOS 36.3.0-gcid-35594366 02/26/2024\n[   41.672555] pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   41.679636] pc : __mutex_lock+0x670/0x878\n[   41.683834] lr : __mutex_lock+0x670/0x878\n[   41.688035] sp : ffff800084b77090\n[   41.691446] x29: ffff800084b77160 x28: ffffdd4bebf7b000 x27: ffffdd4be96b1000\n[   41.698799] x26: 1fffe0002308361c x25: 1ffff0001096ee18 x24: 0000000000000000\n[   41.706149] x23: 0000000000000000 x22: 0000000000000002 x21: ffffdd4be6e3c7a0\n[   41.713500] x20: ffff800084b770f0 x19: ffff00011841b1e8 x18: 0000000000000000\n[   41.720675] x17: 0000000000000000 x16: 0000000000000000 x15: 0720072007200720\n[   41.728023] x14: 0000000000000000 x13: 0000000000000001 x12: ffff6001a96eaab3\n[   41.735375] x11: 1fffe001a96eaab2 x10: ffff6001a96eaab2 x9 : ffffdd4be4838bbc\n[   41.742723] x8 : 00009ffe5691554e x7 : ffff000d4b755593 x6 : 0000000000000001\n[   41.749985] x5 : ffff000d4b755590 x4 : 1fffe0001d88f001 x3 : dfff800000000000\n[   41.756988] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0000ec478000\n[   41.764251] Call trace:\n[   41.766695]  __mutex_lock+0x670/0x878\n[   41.770373]  mutex_lock_nested+0x2c/0x40\n[   41.774134]  host1x_intr_start+0x54/0xf8 [host1x]\n[   41.778863]  host1x_runtime_resume+0x150/0x228 [host1x]\n[   41.783935]  pm_generic_runtime_resume+0x84/0xc8\n[   41.788485]  __rpm_callback+0xa0/0x478\n[   41.792422]  rpm_callback+0x15c/0x1a8\n[   41.795922]  rpm_resume+0x698/0xc08\n[   41.799597]  __pm_runtime_resume+0xa8/0x140\n[   41.803621]  host1x_probe+0x810/0xbc0 [host1x]\n[   41.807909]  platform_probe+0xcc/0x1a8\n[   41.811845]  really_probe+0x188/0x800\n[   41.815347]  __driver_probe_device+0x164/0x360\n[   41.819810]  driver_probe_device+0x64/0x1a8\n[   41.823834]  __driver_attach+0x180/0x490\n[   41.827773]  bus_for_each_dev+0x104/0x1a0\n[   41.831797]  driver_attach+0x44/0x68\n[   41.835296]  bus_add_driver+0x23c/0x4e8\n[   41.839235]  driver_register+0x15c/0x3a8\n[   41.843170]  __platform_register_drivers+0xa4/0x208\n[   41.848159]  tegra_host1x_init+0x4c/0xff8 [host1x]\n[   41.853147]  do_one_initcall+0xd4/0x380\n[   41.856997]  do_init_module+0x1dc/0x698\n[   41.860758]  load_module+0xc70/0x1300\n[   41.864435]  __do_sys_init_module+0x1a8/0x1d0\n[   41.868721]  __arm64_sys_init_module+0x74/0xb0\n[   41.873183]  invoke_syscall.constprop.0+0xdc/0x1e8\n[   41.877997]  do_el0_svc+0x154/0x1d0\n[   41.881671]  el0_svc+0x54/0x140\n[   41.884820]  el0t_64_sync_handler+0x120/0x130\n[   41.889285]  el0t_64_sync+0x1a4/0x1a8\n[   41.892960] irq event stamp: 69737\n[   41.896370] hardirqs last  enabled at (69737): [<ffffdd4be6d7768c>] _raw_spin_unlock_irqrestore+0x44/0xe8\n[   41.905739] hardirqs last disabled at (69736):\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/396d8e5136b4476672bc15b83ba312486bb4bf76",
      "https://git.kernel.org/stable/c/127e91638ddcd02b80de92fec2240609a9f90426",
      "https://git.kernel.org/stable/c/02458fbfaa0170aabf8506f7d4ed054f02414251"
    ],
    "受影响版本": [
      "c8347f915e6779f6c861e7a041adf3559d51b363",
      "c8347f915e6779f6c861e7a041adf3559d51b363",
      "c8347f915e6779f6c861e7a041adf3559d51b363"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21810",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndriver core: class: Fix wild pointer dereferences in API class_dev_iter_next()\n\nThere are a potential wild pointer dereferences issue regarding APIs\nclass_dev_iter_(init|next|exit)(), as explained by below typical usage:\n\n// All members of @iter are wild pointers.\nstruct class_dev_iter iter;\n\n// class_dev_iter_init(@iter, @class, ...) checks parameter @class for\n// potential class_to_subsys() error, and it returns void type and does\n// not initialize its output parameter @iter, so caller can not detect\n// the error and continues to invoke class_dev_iter_next(@iter) even if\n// @iter still contains wild pointers.\nclass_dev_iter_init(&iter, ...);\n\n// Dereference these wild pointers in @iter here once suffer the error.\nwhile (dev = class_dev_iter_next(&iter)) { ... };\n\n// Also dereference these wild pointers here.\nclass_dev_iter_exit(&iter);\n\nActually, all callers of these APIs have such usage pattern in kernel tree.\nFix by:\n- Initialize output parameter @iter by memset() in class_dev_iter_init()\n  and give callers prompt by pr_crit() for the error.\n- Check if @iter is valid in class_dev_iter_next().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f4b9bc823b0cfdebfed479c0e87d6939c7562e87",
      "https://git.kernel.org/stable/c/1614e75d1a1b63db6421c7a4bf37004720c7376c",
      "https://git.kernel.org/stable/c/5c504e9767b947cf7d4e29b811c0c8b3c53242b7",
      "https://git.kernel.org/stable/c/e128f82f7006991c99a58114f70ef61e937b1ac1"
    ],
    "受影响版本": [
      "7b884b7f24b42fa25e92ed724ad82f137610afaf",
      "7b884b7f24b42fa25e92ed724ad82f137610afaf",
      "7b884b7f24b42fa25e92ed724ad82f137610afaf",
      "7b884b7f24b42fa25e92ed724ad82f137610afaf"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21807",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock: fix queue freeze vs limits lock order in sysfs store methods\n\nqueue_attr_store() always freezes a device queue before calling the\nattribute store operation. For attributes that control queue limits, the\nstore operation will also lock the queue limits with a call to\nqueue_limits_start_update(). However, some drivers (e.g. SCSI sd) may\nneed to issue commands to a device to obtain limit values from the\nhardware with the queue limits locked. This creates a potential ABBA\ndeadlock situation if a user attempts to modify a limit (thus freezing\nthe device queue) while the device driver starts a revalidation of the\ndevice queue limits.\n\nAvoid such deadlock by not freezing the queue before calling the\n->store_limit() method in struct queue_sysfs_entry and instead use the\nqueue_limits_commit_update_frozen helper to freeze the queue after taking\nthe limits lock.\n\nThis also removes taking the sysfs lock for the store_limit method as\nit doesn't protect anything here, but creates even more nesting.\nHopefully it will go away from the actual sysfs methods entirely soon.\n\n(commit log adapted from a similar patch from  Damien Le Moal)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8985da5481562e96b95e94ed8e5cc9b6565eb82b",
      "https://git.kernel.org/stable/c/c99f66e4084a62a2cc401c4704a84328aeddc9ec"
    ],
    "受影响版本": [
      "0327ca9d53bfbb0918867313049bba7046900f73",
      "0327ca9d53bfbb0918867313049bba7046900f73"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21806",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: let net.core.dev_weight always be non-zero\n\nThe following problem was encountered during stability test:\n\n(NULL net_device): NAPI poll function process_backlog+0x0/0x530 \\\n\treturned 1, exceeding its budget of 0.\n------------[ cut here ]------------\nlist_add double add: new=ffff88905f746f48, prev=ffff88905f746f48, \\\n\tnext=ffff88905f746e40.\nWARNING: CPU: 18 PID: 5462 at lib/list_debug.c:35 \\\n\t__list_add_valid_or_report+0xf3/0x130\nCPU: 18 UID: 0 PID: 5462 Comm: ping Kdump: loaded Not tainted 6.13.0-rc7+\nRIP: 0010:__list_add_valid_or_report+0xf3/0x130\nCall Trace:\n? __warn+0xcd/0x250\n? __list_add_valid_or_report+0xf3/0x130\nenqueue_to_backlog+0x923/0x1070\nnetif_rx_internal+0x92/0x2b0\n__netif_rx+0x15/0x170\nloopback_xmit+0x2ef/0x450\ndev_hard_start_xmit+0x103/0x490\n__dev_queue_xmit+0xeac/0x1950\nip_finish_output2+0x6cc/0x1620\nip_output+0x161/0x270\nip_push_pending_frames+0x155/0x1a0\nraw_sendmsg+0xe13/0x1550\n__sys_sendto+0x3bf/0x4e0\n__x64_sys_sendto+0xdc/0x1b0\ndo_syscall_64+0x5b/0x170\nentry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nThe reproduction command is as follows:\n  sysctl -w net.core.dev_weight=0\n  ping 127.0.0.1\n\nThis is because when the napi's weight is set to 0, process_backlog() may\nreturn 0 and clear the NAPI_STATE_SCHED bit of napi->state, causing this\nnapi to be re-polled in net_rx_action() until __do_softirq() times out.\nSince the NAPI_STATE_SCHED bit has been cleared, napi_schedule_rps() can\nbe retriggered in enqueue_to_backlog(), causing this issue.\n\nMaking the napi's weight always non-zero solves this problem.\n\nTriggering this issue requires system-wide admin (setting is\nnot namespaced).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d0e0f9c8218826926d7692980c98236d9f21fd3c",
      "https://git.kernel.org/stable/c/c337c08819a4ec49edfdcd8fc46fbee120d8a5b2",
      "https://git.kernel.org/stable/c/0e2f1d93d287d544d26f8ff293ea820a8079b9f8",
      "https://git.kernel.org/stable/c/5860abbf15eeb61838b5e32e721ba67b0aa84450",
      "https://git.kernel.org/stable/c/6ce38b5a6a49e65bad163162a54cb3f104c40b48",
      "https://git.kernel.org/stable/c/33e2168788f8fb5cb8bd4f36cb1ef37d1d34dada",
      "https://git.kernel.org/stable/c/1489824e5226a26841c70639ebd2d1aed390764b",
      "https://git.kernel.org/stable/c/d1f9f79fa2af8e3b45cffdeef66e05833480148a"
    ],
    "受影响版本": [
      "e3876605450979fe52a1a03e7eb78a89bf59e76a",
      "e3876605450979fe52a1a03e7eb78a89bf59e76a",
      "e3876605450979fe52a1a03e7eb78a89bf59e76a",
      "e3876605450979fe52a1a03e7eb78a89bf59e76a",
      "e3876605450979fe52a1a03e7eb78a89bf59e76a",
      "e3876605450979fe52a1a03e7eb78a89bf59e76a",
      "e3876605450979fe52a1a03e7eb78a89bf59e76a",
      "e3876605450979fe52a1a03e7eb78a89bf59e76a"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21796",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: clear acl_access/acl_default after releasing them\n\nIf getting acl_default fails, acl_access and acl_default will be released\nsimultaneously. However, acl_access will still retain a pointer pointing\nto the released posix_acl, which will trigger a WARNING in\nnfs3svc_release_getacl like this:\n\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 26 PID: 3199 at lib/refcount.c:28\nrefcount_warn_saturate+0xb5/0x170\nModules linked in:\nCPU: 26 UID: 0 PID: 3199 Comm: nfsd Not tainted\n6.12.0-rc6-00079-g04ae226af01f-dirty #8\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.1-2.fc37 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xb5/0x170\nCode: cc cc 0f b6 1d b3 20 a5 03 80 fb 01 0f 87 65 48 d8 00 83 e3 01 75\ne4 48 c7 c7 c0 3b 9b 85 c6 05 97 20 a5 03 01 e8 fb 3e 30 ff <0f> 0b eb\ncd 0f b6 1d 8a3\nRSP: 0018:ffffc90008637cd8 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff83904fde\nRDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88871ed36380\nRBP: ffff888158beeb40 R08: 0000000000000001 R09: fffff520010c6f56\nR10: ffffc90008637ab7 R11: 0000000000000001 R12: 0000000000000001\nR13: ffff888140e77400 R14: ffff888140e77408 R15: ffffffff858b42c0\nFS:  0000000000000000(0000) GS:ffff88871ed00000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000562384d32158 CR3: 000000055cc6a000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n ? refcount_warn_saturate+0xb5/0x170\n ? __warn+0xa5/0x140\n ? refcount_warn_saturate+0xb5/0x170\n ? report_bug+0x1b1/0x1e0\n ? handle_bug+0x53/0xa0\n ? exc_invalid_op+0x17/0x40\n ? asm_exc_invalid_op+0x1a/0x20\n ? tick_nohz_tick_stopped+0x1e/0x40\n ? refcount_warn_saturate+0xb5/0x170\n ? refcount_warn_saturate+0xb5/0x170\n nfs3svc_release_getacl+0xc9/0xe0\n svc_process_common+0x5db/0xb60\n ? __pfx_svc_process_common+0x10/0x10\n ? __rcu_read_unlock+0x69/0xa0\n ? __pfx_nfsd_dispatch+0x10/0x10\n ? svc_xprt_received+0xa1/0x120\n ? xdr_init_decode+0x11d/0x190\n svc_process+0x2a7/0x330\n svc_handle_xprt+0x69d/0x940\n svc_recv+0x180/0x2d0\n nfsd+0x168/0x200\n ? __pfx_nfsd+0x10/0x10\n kthread+0x1a2/0x1e0\n ? kthread+0xf4/0x1e0\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x34/0x60\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1a/0x30\n </TASK>\nKernel panic - not syncing: kernel: panic_on_warn set ...\n\nClear acl_access/acl_default after posix_acl_release is called to prevent\nUAF from being triggered.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8a1737ae42c928384ab6447f6ee1a882510e85fa",
      "https://git.kernel.org/stable/c/6f7cfee1a316891890c505563aa54f3476db52fd",
      "https://git.kernel.org/stable/c/2e59b2b68782519560b3d6a41dd66a3d01a01cd3",
      "https://git.kernel.org/stable/c/55d947315fb5f67a35e4e1d3e01bb886b9c6decf",
      "https://git.kernel.org/stable/c/f8d871523142f7895f250a856f8c4a4181614510",
      "https://git.kernel.org/stable/c/1fd94884174bd20beb1773990fd3b1aa877688d9",
      "https://git.kernel.org/stable/c/7faf14a7b0366f153284db0ad3347c457ea70136"
    ],
    "受影响版本": [
      "a257cdd0e2179630d3201c32ba14d7fcb3c3a055",
      "a257cdd0e2179630d3201c32ba14d7fcb3c3a055",
      "a257cdd0e2179630d3201c32ba14d7fcb3c3a055",
      "a257cdd0e2179630d3201c32ba14d7fcb3c3a055",
      "a257cdd0e2179630d3201c32ba14d7fcb3c3a055",
      "a257cdd0e2179630d3201c32ba14d7fcb3c3a055",
      "a257cdd0e2179630d3201c32ba14d7fcb3c3a055"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21752",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: don't use btrfs_set_item_key_safe on RAID stripe-extents\n\nDon't use btrfs_set_item_key_safe() to modify the keys in the RAID\nstripe-tree, as this can lead to corruption of the tree, which is caught\nby the checks in btrfs_set_item_key_safe():\n\n BTRFS info (device nvme1n1): leaf 49168384 gen 15 total ptrs 194 free space 8329 owner 12\n BTRFS info (device nvme1n1): refs 2 lock_owner 1030 current 1030\n  [ snip ]\n  item 105 key (354549760 230 20480) itemoff 14587 itemsize 16\n                  stride 0 devid 5 physical 67502080\n  item 106 key (354631680 230 4096) itemoff 14571 itemsize 16\n                  stride 0 devid 1 physical 88559616\n  item 107 key (354631680 230 32768) itemoff 14555 itemsize 16\n                  stride 0 devid 1 physical 88555520\n  item 108 key (354717696 230 28672) itemoff 14539 itemsize 16\n                  stride 0 devid 2 physical 67604480\n  [ snip ]\n BTRFS critical (device nvme1n1): slot 106 key (354631680 230 32768) new key (354635776 230 4096)\n ------------[ cut here ]------------\n kernel BUG at fs/btrfs/ctree.c:2602!\n Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI\n CPU: 1 UID: 0 PID: 1055 Comm: fsstress Not tainted 6.13.0-rc1+ #1464\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014\n RIP: 0010:btrfs_set_item_key_safe+0xf7/0x270\n Code: <snip>\n RSP: 0018:ffffc90001337ab0 EFLAGS: 00010287\n RAX: 0000000000000000 RBX: ffff8881115fd000 RCX: 0000000000000000\n RDX: 0000000000000001 RSI: 0000000000000001 RDI: 00000000ffffffff\n RBP: ffff888110ed6f50 R08: 00000000ffffefff R09: ffffffff8244c500\n R10: 00000000ffffefff R11: 00000000ffffffff R12: ffff888100586000\n R13: 00000000000000c9 R14: ffffc90001337b1f R15: ffff888110f23b58\n FS:  00007f7d75c72740(0000) GS:ffff88813bd00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007fa811652c60 CR3: 0000000111398001 CR4: 0000000000370eb0\n Call Trace:\n  <TASK>\n  ? __die_body.cold+0x14/0x1a\n  ? die+0x2e/0x50\n  ? do_trap+0xca/0x110\n  ? do_error_trap+0x65/0x80\n  ? btrfs_set_item_key_safe+0xf7/0x270\n  ? exc_invalid_op+0x50/0x70\n  ? btrfs_set_item_key_safe+0xf7/0x270\n  ? asm_exc_invalid_op+0x1a/0x20\n  ? btrfs_set_item_key_safe+0xf7/0x270\n  btrfs_partially_delete_raid_extent+0xc4/0xe0\n  btrfs_delete_raid_extent+0x227/0x240\n  __btrfs_free_extent.isra.0+0x57f/0x9c0\n  ? exc_coproc_segment_overrun+0x40/0x40\n  __btrfs_run_delayed_refs+0x2fa/0xe80\n  btrfs_run_delayed_refs+0x81/0xe0\n  btrfs_commit_transaction+0x2dd/0xbe0\n  ? preempt_count_add+0x52/0xb0\n  btrfs_sync_file+0x375/0x4c0\n  do_fsync+0x39/0x70\n  __x64_sys_fsync+0x13/0x20\n  do_syscall_64+0x54/0x110\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n RIP: 0033:0x7f7d7550ef90\n Code: <snip>\n RSP: 002b:00007ffd70237248 EFLAGS: 00000202 ORIG_RAX: 000000000000004a\n RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007f7d7550ef90\n RDX: 000000000000013a RSI: 000000000040eb28 RDI: 0000000000000004\n RBP: 000000000000001b R08: 0000000000000078 R09: 00007ffd7023725c\n R10: 00007f7d75400390 R11: 0000000000000202 R12: 028f5c28f5c28f5c\n R13: 8f5c28f5c28f5c29 R14: 000000000040b520 R15: 00007f7d75c726c8\n  </TASK>\n\nWhile the root cause of the tree order corruption isn't clear, using\nbtrfs_duplicate_item() to copy the item and then adjusting both the key\nand the per-device physical addresses is a safe way to counter this\nproblem.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1c25eff52ee5a02a2c4be659a44ae972d9989742",
      "https://git.kernel.org/stable/c/dc14ba10781bd2629835696b7cc1febf914768e9"
    ],
    "受影响版本": [
      "02c372e1f016e5113217597ab37b399c4e407477",
      "02c372e1f016e5113217597ab37b399c4e407477"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21751",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: HWS, change error flow on matcher disconnect\n\nCurrently, when firmware failure occurs during matcher disconnect flow,\nthe error flow of the function reconnects the matcher back and returns\nan error, which continues running the calling function and eventually\nfrees the matcher that is being disconnected.\nThis leads to a case where we have a freed matcher on the matchers list,\nwhich in turn leads to use-after-free and eventual crash.\n\nThis patch fixes that by not trying to reconnect the matcher back when\nsome FW command fails during disconnect.\n\nNote that we're dealing here with FW error. We can't overcome this\nproblem. This might lead to bad steering state (e.g. wrong connection\nbetween matchers), and will also lead to resource leakage, as it is\nthe case with any other error handling during resource destruction.\n\nHowever, the goal here is to allow the driver to continue and not crash\nthe machine with use-after-free error.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/23a86c76a1a197e8fbbbd0ce3e826eb58c471624",
      "https://git.kernel.org/stable/c/1ce840c7a659aa53a31ef49f0271b4fd0dc10296"
    ],
    "受影响版本": [
      "472dd792348f6601ccaa97d5626ee4faff891901",
      "472dd792348f6601ccaa97d5626ee4faff891901"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21747",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/ast: astdp: Fix timeout for enabling video signal\n\nThe ASTDP transmitter sometimes takes up to 1 second for enabling the\nvideo signal, while the timeout is only 200 msec. This results in a\nkernel error message. Increase the timeout to 1 second. An example\nof the error message is shown below.\n\n[  697.084433] ------------[ cut here ]------------\n[  697.091115] ast 0000:02:00.0: [drm] drm_WARN_ON(!__ast_dp_wait_enable(ast, enabled))\n[  697.091233] WARNING: CPU: 1 PID: 160 at drivers/gpu/drm/ast/ast_dp.c:232 ast_dp_set_enable+0x123/0x140 [ast]\n[...]\n[  697.272469] RIP: 0010:ast_dp_set_enable+0x123/0x140 [ast]\n[...]\n[  697.415283] Call Trace:\n[  697.420727]  <TASK>\n[  697.425908]  ? show_trace_log_lvl+0x196/0x2c0\n[  697.433304]  ? show_trace_log_lvl+0x196/0x2c0\n[  697.440693]  ? drm_atomic_helper_commit_modeset_enables+0x30a/0x470\n[  697.450115]  ? ast_dp_set_enable+0x123/0x140 [ast]\n[  697.458059]  ? __warn.cold+0xaf/0xca\n[  697.464713]  ? ast_dp_set_enable+0x123/0x140 [ast]\n[  697.472633]  ? report_bug+0x134/0x1d0\n[  697.479544]  ? handle_bug+0x58/0x90\n[  697.486127]  ? exc_invalid_op+0x13/0x40\n[  697.492975]  ? asm_exc_invalid_op+0x16/0x20\n[  697.500224]  ? preempt_count_sub+0x14/0xc0\n[  697.507473]  ? ast_dp_set_enable+0x123/0x140 [ast]\n[  697.515377]  ? ast_dp_set_enable+0x123/0x140 [ast]\n[  697.523227]  drm_atomic_helper_commit_modeset_enables+0x30a/0x470\n[  697.532388]  drm_atomic_helper_commit_tail+0x58/0x90\n[  697.540400]  ast_mode_config_helper_atomic_commit_tail+0x30/0x40 [ast]\n[  697.550009]  commit_tail+0xfe/0x1d0\n[  697.556547]  drm_atomic_helper_commit+0x198/0x1c0\n\nThis is a cosmetical problem. Enabling the video signal still works\neven with the error message. The problem has always been present, but\nonly recent versions of the ast driver warn about missing the timeout.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/589839379031cce220c9cab9f27cb5477195067e",
      "https://git.kernel.org/stable/c/fd39c41bcd82d5ebaaebadb944eab5598c668a90"
    ],
    "受影响版本": [
      "4e29cc7c5c673299cfbaf4982fc8b6a72c9f706f",
      "4e29cc7c5c673299cfbaf4982fc8b6a72c9f706f"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21733",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/osnoise: Fix resetting of tracepoints\n\nIf a timerlat tracer is started with the osnoise option OSNOISE_WORKLOAD\ndisabled, but then that option is enabled and timerlat is removed, the\ntracepoints that were enabled on timerlat registration do not get\ndisabled. If the option is disabled again and timelat is started, then it\ntriggers a warning in the tracepoint code due to registering the\ntracepoint again without ever disabling it.\n\nDo not use the same user space defined options to know to disable the\ntracepoints when timerlat is removed. Instead, set a global flag when it\nis enabled and use that flag to know to disable the events.\n\n ~# echo NO_OSNOISE_WORKLOAD > /sys/kernel/tracing/osnoise/options\n ~# echo timerlat > /sys/kernel/tracing/current_tracer\n ~# echo OSNOISE_WORKLOAD > /sys/kernel/tracing/osnoise/options\n ~# echo nop > /sys/kernel/tracing/current_tracer\n ~# echo NO_OSNOISE_WORKLOAD > /sys/kernel/tracing/osnoise/options\n ~# echo timerlat > /sys/kernel/tracing/current_tracer\n\nTriggers:\n\n ------------[ cut here ]------------\n WARNING: CPU: 6 PID: 1337 at kernel/tracepoint.c:294 tracepoint_add_func+0x3b6/0x3f0\n Modules linked in:\n CPU: 6 UID: 0 PID: 1337 Comm: rtla Not tainted 6.13.0-rc4-test-00018-ga867c441128e-dirty #73\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n RIP: 0010:tracepoint_add_func+0x3b6/0x3f0\n Code: 48 8b 53 28 48 8b 73 20 4c 89 04 24 e8 23 59 11 00 4c 8b 04 24 e9 36 fe ff ff 0f 0b b8 ea ff ff ff 45 84 e4 0f 84 68 fe ff ff <0f> 0b e9 61 fe ff ff 48 8b 7b 18 48 85 ff 0f 84 4f ff ff ff 49 8b\n RSP: 0018:ffffb9b003a87ca0 EFLAGS: 00010202\n RAX: 00000000ffffffef RBX: ffffffff92f30860 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: ffff9bf59e91ccd0 RDI: ffffffff913b6410\n RBP: 000000000000000a R08: 00000000000005c7 R09: 0000000000000002\n R10: ffffb9b003a87ce0 R11: 0000000000000002 R12: 0000000000000001\n R13: ffffb9b003a87ce0 R14: ffffffffffffffef R15: 0000000000000008\n FS:  00007fce81209240(0000) GS:ffff9bf6fdd00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000055e99b728000 CR3: 00000001277c0002 CR4: 0000000000172ef0\n Call Trace:\n  <TASK>\n  ? __warn.cold+0xb7/0x14d\n  ? tracepoint_add_func+0x3b6/0x3f0\n  ? report_bug+0xea/0x170\n  ? handle_bug+0x58/0x90\n  ? exc_invalid_op+0x17/0x70\n  ? asm_exc_invalid_op+0x1a/0x20\n  ? __pfx_trace_sched_migrate_callback+0x10/0x10\n  ? tracepoint_add_func+0x3b6/0x3f0\n  ? __pfx_trace_sched_migrate_callback+0x10/0x10\n  ? __pfx_trace_sched_migrate_callback+0x10/0x10\n  tracepoint_probe_register+0x78/0xb0\n  ? __pfx_trace_sched_migrate_callback+0x10/0x10\n  osnoise_workload_start+0x2b5/0x370\n  timerlat_tracer_init+0x76/0x1b0\n  tracing_set_tracer+0x244/0x400\n  tracing_set_trace_write+0xa0/0xe0\n  vfs_write+0xfc/0x570\n  ? do_sys_openat2+0x9c/0xe0\n  ksys_write+0x72/0xf0\n  do_syscall_64+0x79/0x1c0\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ee8c4c39a8f97467d63adfe03bcd45139d8c8b53",
      "https://git.kernel.org/stable/c/b45707c3c0671d9c49fa7b94c197a508aa55d16f",
      "https://git.kernel.org/stable/c/e482cecd2305be1e3e6a8ee70c9b86c511484f7b",
      "https://git.kernel.org/stable/c/e3ff4245928f948f3eb2e852aa350b870421c358"
    ],
    "受影响版本": [
      "e88ed227f639ebcb31ed4e5b88756b47d904584b",
      "e88ed227f639ebcb31ed4e5b88756b47d904584b",
      "e88ed227f639ebcb31ed4e5b88756b47d904584b",
      "e88ed227f639ebcb31ed4e5b88756b47d904584b"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21730",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw89: avoid to init mgnt_entry list twice when WoWLAN failed\n\nIf WoWLAN failed in resume flow, the rtw89_ops_add_interface() triggered\nwithout removing the interface first. Then the mgnt_entry list init again,\ncausing the list_empty() check in rtw89_chanctx_ops_assign_vif()\nuseless, and list_add_tail() again. Therefore, we have added a check to\nprevent double adding of the list.\n\nrtw89_8852ce 0000:01:00.0: failed to check wow status disabled\nrtw89_8852ce 0000:01:00.0: wow: failed to check disable fw ready\nrtw89_8852ce 0000:01:00.0: wow: failed to swap to normal fw\nrtw89_8852ce 0000:01:00.0: failed to disable wow\nrtw89_8852ce 0000:01:00.0: failed to resume for wow -110\nrtw89_8852ce 0000:01:00.0: MAC has already powered on\ni2c_hid_acpi i2c-ILTK0001:00: PM: acpi_subsys_resume+0x0/0x60 returned 0 after 284705 usecs\nlist_add corruption. prev->next should be next (ffff9d9719d82228), but was ffff9d9719f96030. (prev=ffff9d9719f96030).\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:34!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 2 PID: 6918 Comm: kworker/u8:19 Tainted: G     U     O\nHardware name: Google Anraggar/Anraggar, BIOS Google_Anraggar.15217.514.0 03/25/2024\nWorkqueue: events_unbound async_run_entry_fn\nRIP: 0010:__list_add_valid_or_report+0x9f/0xb0\nCode: e8 56 89 ff ff 0f 0b 48 c7 c7 3e fc e0 96 48 89 c6 e8 45 89 ff ...\nRSP: 0018:ffffa51b42bbbaf0 EFLAGS: 00010246\nRAX: 0000000000000075 RBX: ffff9d9719d82ab0 RCX: 13acb86e047a4400\nRDX: 3fffffffffffffff RSI: 0000000000000000 RDI: 00000000ffffdfff\nRBP: ffffa51b42bbbb28 R08: ffffffff9768e250 R09: 0000000000001fff\nR10: ffffffff9765e250 R11: 0000000000005ffd R12: ffff9d9719f95c40\nR13: ffff9d9719f95be8 R14: ffff9d97081bfd78 R15: ffff9d9719d82060\nFS:  0000000000000000(0000) GS:ffff9d9a6fb00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007e7d029a4060 CR3: 0000000345e38000 CR4: 0000000000750ee0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? __die_body+0x68/0xb0\n ? die+0xaa/0xd0\n ? do_trap+0x9f/0x170\n ? __list_add_valid_or_report+0x9f/0xb0\n ? __list_add_valid_or_report+0x9f/0xb0\n ? handle_invalid_op+0x69/0x90\n ? __list_add_valid_or_report+0x9f/0xb0\n ? exc_invalid_op+0x3c/0x50\n ? asm_exc_invalid_op+0x16/0x20\n ? __list_add_valid_or_report+0x9f/0xb0\n rtw89_chanctx_ops_assign_vif+0x1f9/0x210 [rtw89_core cbb375c44bf28564ce479002bff66617a25d9ac1]\n ? __mutex_unlock_slowpath+0xa0/0xf0\n rtw89_ops_assign_vif_chanctx+0x4b/0x90 [rtw89_core cbb375c44bf28564ce479002bff66617a25d9ac1]\n drv_assign_vif_chanctx+0xa7/0x1f0 [mac80211 6efaad16237edaaea0868b132d4f93ecf918a8b6]\n ieee80211_reconfig+0x9cb/0x17b0 [mac80211 6efaad16237edaaea0868b132d4f93ecf918a8b6]\n ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 572d03acaaa933fe38251be7fce3b3675284b8ed]\n ? dev_printk_emit+0x51/0x70\n ? _dev_info+0x6e/0x90\n wiphy_resume+0x89/0x180 [cfg80211 572d03acaaa933fe38251be7fce3b3675284b8ed]\n ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 572d03acaaa933fe38251be7fce3b3675284b8ed]\n dpm_run_callback+0x37/0x1e0\n device_resume+0x26d/0x4b0\n ? __pfx_dpm_watchdog_handler+0x10/0x10\n async_resume+0x1d/0x30\n async_run_entry_fn+0x29/0xd0\n worker_thread+0x397/0x970\n kthread+0xed/0x110\n ? __pfx_worker_thread+0x10/0x10\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x38/0x50\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1b/0x30\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7fc295fdd3992a9a07d12fd3f2e84dface23aedc",
      "https://git.kernel.org/stable/c/4ed5bf49819757303e657f3900725febf2f3926f",
      "https://git.kernel.org/stable/c/2f7667675df1b40b73ecc53b4b8c3189b1e5f2c1"
    ],
    "受影响版本": [
      "0007546cb406be0dddf3d43f07683825affc6d4d",
      "68ec751b288178de7d19b71ea61648269a35b8cd",
      "68ec751b288178de7d19b71ea61648269a35b8cd"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21692",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: fix ets qdisc OOB Indexing\n\nHaowei Yan <g1042620637@gmail.com> found that ets_class_from_arg() can\nindex an Out-Of-Bound class in ets_class_from_arg() when passed clid of\n0. The overflow may cause local privilege escalation.\n\n [   18.852298] ------------[ cut here ]------------\n [   18.853271] UBSAN: array-index-out-of-bounds in net/sched/sch_ets.c:93:20\n [   18.853743] index 18446744073709551615 is out of range for type 'ets_class [16]'\n [   18.854254] CPU: 0 UID: 0 PID: 1275 Comm: poc Not tainted 6.12.6-dirty #17\n [   18.854821] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n [   18.856532] Call Trace:\n [   18.857441]  <TASK>\n [   18.858227]  dump_stack_lvl+0xc2/0xf0\n [   18.859607]  dump_stack+0x10/0x20\n [   18.860908]  __ubsan_handle_out_of_bounds+0xa7/0xf0\n [   18.864022]  ets_class_change+0x3d6/0x3f0\n [   18.864322]  tc_ctl_tclass+0x251/0x910\n [   18.864587]  ? lock_acquire+0x5e/0x140\n [   18.865113]  ? __mutex_lock+0x9c/0xe70\n [   18.866009]  ? __mutex_lock+0xa34/0xe70\n [   18.866401]  rtnetlink_rcv_msg+0x170/0x6f0\n [   18.866806]  ? __lock_acquire+0x578/0xc10\n [   18.867184]  ? __pfx_rtnetlink_rcv_msg+0x10/0x10\n [   18.867503]  netlink_rcv_skb+0x59/0x110\n [   18.867776]  rtnetlink_rcv+0x15/0x30\n [   18.868159]  netlink_unicast+0x1c3/0x2b0\n [   18.868440]  netlink_sendmsg+0x239/0x4b0\n [   18.868721]  ____sys_sendmsg+0x3e2/0x410\n [   18.869012]  ___sys_sendmsg+0x88/0xe0\n [   18.869276]  ? rseq_ip_fixup+0x198/0x260\n [   18.869563]  ? rseq_update_cpu_node_id+0x10a/0x190\n [   18.869900]  ? trace_hardirqs_off+0x5a/0xd0\n [   18.870196]  ? syscall_exit_to_user_mode+0xcc/0x220\n [   18.870547]  ? do_syscall_64+0x93/0x150\n [   18.870821]  ? __memcg_slab_free_hook+0x69/0x290\n [   18.871157]  __sys_sendmsg+0x69/0xd0\n [   18.871416]  __x64_sys_sendmsg+0x1d/0x30\n [   18.871699]  x64_sys_call+0x9e2/0x2670\n [   18.871979]  do_syscall_64+0x87/0x150\n [   18.873280]  ? do_syscall_64+0x93/0x150\n [   18.874742]  ? lock_release+0x7b/0x160\n [   18.876157]  ? do_user_addr_fault+0x5ce/0x8f0\n [   18.877833]  ? irqentry_exit_to_user_mode+0xc2/0x210\n [   18.879608]  ? irqentry_exit+0x77/0xb0\n [   18.879808]  ? clear_bhb_loop+0x15/0x70\n [   18.880023]  ? clear_bhb_loop+0x15/0x70\n [   18.880223]  ? clear_bhb_loop+0x15/0x70\n [   18.880426]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n [   18.880683] RIP: 0033:0x44a957\n [   18.880851] Code: ff ff e8 fc 00 00 00 66 2e 0f 1f 84 00 00 00 00 00 66 90 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 28 89 54 24 1c 48 8974 24 10\n [   18.881766] RSP: 002b:00007ffcdd00fad8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\n [   18.882149] RAX: ffffffffffffffda RBX: 00007ffcdd010db8 RCX: 000000000044a957\n [   18.882507] RDX: 0000000000000000 RSI: 00007ffcdd00fb70 RDI: 0000000000000003\n [   18.885037] RBP: 00007ffcdd010bc0 R08: 000000000703c770 R09: 000000000703c7c0\n [   18.887203] R10: 0000000000000080 R11: 0000000000000246 R12: 0000000000000001\n [   18.888026] R13: 00007ffcdd010da8 R14: 00000000004ca7d0 R15: 0000000000000001\n [   18.888395]  </TASK>\n [   18.888610] ---[ end trace ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/03c56665dab1f4ac844bc156652d50d639093fa5",
      "https://git.kernel.org/stable/c/bcf0d815e728a3a304b50455b32a3170c16e1eaa",
      "https://git.kernel.org/stable/c/1332c6ed446be787f901ed1064ec6a3c694f028a",
      "https://git.kernel.org/stable/c/f4168299e553f17aa2ba4016e77a9c38da40eb1d",
      "https://git.kernel.org/stable/c/997f6ec4208b23c87daf9f044689685f091826f7",
      "https://git.kernel.org/stable/c/f6b0f05fbfa4044f890e8a348288c0d9a20bd1d0",
      "https://git.kernel.org/stable/c/d62b04fca4340a0d468d7853bd66e511935a18cb"
    ],
    "受影响版本": [
      "dcc68b4d8084e1ac9af0d4022d6b1aff6a139a33",
      "dcc68b4d8084e1ac9af0d4022d6b1aff6a139a33",
      "dcc68b4d8084e1ac9af0d4022d6b1aff6a139a33",
      "dcc68b4d8084e1ac9af0d4022d6b1aff6a139a33",
      "dcc68b4d8084e1ac9af0d4022d6b1aff6a139a33",
      "dcc68b4d8084e1ac9af0d4022d6b1aff6a139a33",
      "dcc68b4d8084e1ac9af0d4022d6b1aff6a139a33"
    ],
    "公开日期": "2025年02月10日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21664",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm thin: make get_first_thin use rcu-safe list first function\n\nThe documentation in rculist.h explains the absence of list_empty_rcu()\nand cautions programmers against relying on a list_empty() ->\nlist_first() sequence in RCU safe code.  This is because each of these\nfunctions performs its own READ_ONCE() of the list head.  This can lead\nto a situation where the list_empty() sees a valid list entry, but the\nsubsequent list_first() sees a different view of list head state after a\nmodification.\n\nIn the case of dm-thin, this author had a production box crash from a GP\nfault in the process_deferred_bios path.  This function saw a valid list\nhead in get_first_thin() but when it subsequently dereferenced that and\nturned it into a thin_c, it got the inside of the struct pool, since the\nlist was now empty and referring to itself.  The kernel on which this\noccurred printed both a warning about a refcount_t being saturated, and\na UBSAN error for an out-of-bounds cpuid access in the queued spinlock,\nprior to the fault itself.  When the resulting kdump was examined, it\nwas possible to see another thread patiently waiting in thin_dtr's\nsynchronize_rcu.\n\nThe thin_dtr call managed to pull the thin_c out of the active thins\nlist (and have it be the last entry in the active_thins list) at just\nthe wrong moment which lead to this crash.\n\nFortunately, the fix here is straight forward.  Switch get_first_thin()\nfunction to use list_first_or_null_rcu() which performs just a single\nREAD_ONCE() and returns NULL if the list is already empty.\n\nThis was run against the devicemapper test suite's thin-provisioning\nsuites for delete and suspend and no regressions were observed.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ec037fe8c0d0f6140e3d8a49c7b29cb5582160b8",
      "https://git.kernel.org/stable/c/cd30a3960433ec2db94b3689752fa3c5df44d649",
      "https://git.kernel.org/stable/c/802666a40c71a23542c43a3f87e3a2d0f4e8fe45",
      "https://git.kernel.org/stable/c/12771050b6d059eea096993bf2001da9da9fddff",
      "https://git.kernel.org/stable/c/6b305e98de0d225ccebfb225730a9f560d28ecb0",
      "https://git.kernel.org/stable/c/cbd0d5ecfa390ac29c5380200147d09c381b2ac6",
      "https://git.kernel.org/stable/c/80f130bfad1dab93b95683fc39b87235682b8f72"
    ],
    "受影响版本": [
      "b10ebd34cccae1b431caf1be54919aede2be7cbe",
      "b10ebd34cccae1b431caf1be54919aede2be7cbe",
      "b10ebd34cccae1b431caf1be54919aede2be7cbe",
      "b10ebd34cccae1b431caf1be54919aede2be7cbe",
      "b10ebd34cccae1b431caf1be54919aede2be7cbe",
      "b10ebd34cccae1b431caf1be54919aede2be7cbe",
      "b10ebd34cccae1b431caf1be54919aede2be7cbe"
    ],
    "公开日期": "2025年01月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2025-21645",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86/amd/pmc: Only disable IRQ1 wakeup where i8042 actually enabled it\n\nWakeup for IRQ1 should be disabled only in cases where i8042 had\nactually enabled it, otherwise \"wake_depth\" for this IRQ will try to\ndrop below zero and there will be an unpleasant WARN() logged:\n\nkernel: atkbd serio0: Disabling IRQ1 wakeup source to avoid platform firmware bug\nkernel: ------------[ cut here ]------------\nkernel: Unbalanced IRQ 1 wake disable\nkernel: WARNING: CPU: 10 PID: 6431 at kernel/irq/manage.c:920 irq_set_irq_wake+0x147/0x1a0\n\nThe PMC driver uses DEFINE_SIMPLE_DEV_PM_OPS() to define its dev_pm_ops\nwhich sets amd_pmc_suspend_handler() to the .suspend, .freeze, and\n.poweroff handlers. i8042_pm_suspend(), however, is only set as\nthe .suspend handler.\n\nFix the issue by call PMC suspend handler only from the same set of\ndev_pm_ops handlers as i8042_pm_suspend(), which currently means just\nthe .suspend handler.\n\nTo reproduce this issue try hibernating (S4) the machine after a fresh boot\nwithout putting it into s2idle first.\n\n[ij: edited the commit message.]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ab47d72b736e78d3c2370b26e0bfc46eb0918391",
      "https://git.kernel.org/stable/c/5cc621085e2b7a9b1905a98f8e5a86bb4aea2016",
      "https://git.kernel.org/stable/c/b25778c87a6bce40c31e92364f08aa6240309e25",
      "https://git.kernel.org/stable/c/dd410d784402c5775f66faf8b624e85e41c38aaf"
    ],
    "受影响版本": [
      "72e5a83b7c8401856cc3732150af24e43726717a",
      "8e60615e8932167057b363c11a7835da7f007106",
      "8e60615e8932167057b363c11a7835da7f007106",
      "8e60615e8932167057b363c11a7835da7f007106",
      "3fc9dc0340e0b5df8059313537b55f82c1e84e94"
    ],
    "公开日期": "2025年01月19日"
  },
  {
    "设备品牌": "StarCitizenTools",
    "设备类型": "OTA",
    "产品型号": "mediawiki-extensions-TabberNeue",
    "CVE编号": "CVE-2025-21612",
    "漏洞描述": "TabberNeue is a MediaWiki extension that allows the wiki to create tabs. Prior to 2.7.2, TabberTransclude.php doesn't escape the user-supplied page name when outputting, so an XSS payload as the page name can be used here. This vulnerability is fixed in 2.7.2.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/StarCitizenTools/mediawiki-extensions-TabberNeue/security/advisories/GHSA-4x6x-8rm8-c37j",
      "https://github.com/StarCitizenTools/mediawiki-extensions-TabberNeue/commit/d8c3db4e5935476e496d979fb01f775d3d3282e6",
      "https://github.com/StarCitizenTools/mediawiki-extensions-TabberNeue/commit/f229cab099c69006e25d4bad3579954e481dc566"
    ],
    "受影响版本": [
      ">= 1.9.1, < 2.7.2",
      ">= d8c3db4e5935476e496d979fb01f775d3d3282e6, < f229cab099c69006e25d4bad3579954e481dc566"
    ],
    "公开日期": "2025年01月06日"
  },
  {
    "设备品牌": "FITSTATS Technologies",
    "设备类型": "OTA",
    "产品型号": "AthleteMonitoring",
    "CVE编号": "CVE-2025-1842",
    "漏洞描述": "A vulnerability classified as problematic was found in FITSTATS Technologies AthleteMonitoring up to 20250302. This vulnerability affects unknown code of the file /login.php. The manipulation of the argument username leads to cross site scripting. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used. The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "无官方补丁，建议联系厂商或及时更新系统"
    ],
    "受影响版本": [
      "20250302"
    ],
    "公开日期": "2025年03月03日"
  },
  {
    "设备品牌": "N/A",
    "设备类型": "OTA",
    "产品型号": "Vuetify",
    "CVE编号": "CVE-2025-1461",
    "漏洞描述": "Improper neutralization of the value of the 'eventMoreText' property of the 'VCalendar' component in Vuetify allows unsanitized HTML to be inserted into the page. This can lead to a  Cross-Site Scripting (XSS) https://owasp.org/www-community/attacks/xss  attack. The vulnerability occurs because the default Vuetify translator will return the translation key as the translation, if it can't find an actual translation.\n\nThis issue affects Vuetify versions greater than or equal to 2.0.0 and less than 3.0.0.\n\nNote:\nVersion 2.x of Vuetify is End-of-Life and will not receive any updates to address this issue. For more information see  here https://v2.vuetifyjs.com/en/about/eol/ .",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.herodevs.com/vulnerability-directory/cve-2025-1461",
      "https://github.com/neverendingsupport/nes-vuetify-cve-2025-1461"
    ],
    "受影响版本": [
      ">=2.0.0 <3.0.0"
    ],
    "公开日期": "2025年05月28日"
  },
  {
    "设备品牌": "Google",
    "设备类型": "OTA",
    "产品型号": "AngularJS",
    "CVE编号": "CVE-2025-0716",
    "漏洞描述": "Improper sanitization of the value of the 'href' and 'xlink:href' attributes in '<image>' SVG elements in AngularJS allows attackers to bypass common image source restrictions. This can lead to a form of  Content Spoofing https://owasp.org/www-community/attacks/Content_Spoofing  and also negatively affect the application's performance and behavior by using too large or slow-to-load images.\n\nThis issue affects all versions of AngularJS.\n\nNote:\nThe AngularJS project is End-of-Life and will not receive any updates to address this issue. For more information see  here https://docs.angularjs.org/misc/version-support-status .",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.herodevs.com/vulnerability-directory/cve-2025-0716",
      "https://codepen.io/herodevs/pen/qEWQmpd/a86a0d29310e12c7a3756768e6c7b915"
    ],
    "受影响版本": [
      ">=0.0.0"
    ],
    "公开日期": "2025年04月29日"
  },
  {
    "设备品牌": "Swift Project",
    "设备类型": "OTA",
    "产品型号": "Swift ASN1",
    "CVE编号": "CVE-2025-0343",
    "漏洞描述": "Swift ASN.1 can be caused to crash when parsing certain BER/DER constructions. This crash is caused by a confusion in the ASN.1 library itself which assumes that certain objects can only be provided in either constructed or primitive forms, and will trigger a preconditionFailure if that constraint isn't met.\n\nImportantly, these constraints are actually required to be true in DER, but that correctness wasn't enforced on the early node parser side so it was incorrect to rely on it later on in decoding, which is what the library did.\n\nThese crashes can be triggered when parsing any DER/BER format object. There is no memory-safety issue here: the crash is a graceful one from the Swift runtime. The impact of this is that it can be used as a denial-of-service vector when parsing BER/DER data from unknown sources, e.g. when parsing TLS certificates.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/apple/swift-asn1/security/advisories/GHSA-w8xv-rwgf-4fwh"
    ],
    "受影响版本": [
      "1.0.0"
    ],
    "公开日期": "2025年01月15日"
  },
  {
    "设备品牌": "Microchip",
    "设备类型": "OTA",
    "产品型号": "TimeProvider 4100",
    "CVE编号": "CVE-2024-9054",
    "漏洞描述": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'), Exposure of Sensitive Information to an Unauthorized Actor vulnerability in Microchip TimeProvider 4100 (Configuration modules) allows Command Injection.This issue affects TimeProvider 4100: from 1.0 before 2.4.7.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-rce-through-configuration-file",
      "https://www.gruppotim.it/it/footer/red-team.html"
    ],
    "受影响版本": [
      "1.0"
    ],
    "公开日期": "2024年10月04日"
  },
  {
    "设备品牌": "GoodWe Technologies Co., Ltd.",
    "设备类型": "OTA",
    "产品型号": "GW1500‑XS",
    "CVE编号": "CVE-2024-8893",
    "漏洞描述": "Use of Hard-coded Credentials vulnerability in GoodWe Technologies Co., Ltd. GW1500‑XS allows anyone in physical proximity to the device to fully access the web interface of the inverter via Wi‑Fi.This issue affects GW1500‑XS: 1.1.2.1.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://os-s.net/publications/advisories/CVE-2024-8893.pdf"
    ],
    "受影响版本": [
      "1.1.2.1"
    ],
    "公开日期": "2025年02月14日"
  },
  {
    "设备品牌": "Google",
    "设备类型": "OTA",
    "产品型号": "AngularJS",
    "CVE编号": "CVE-2024-8373",
    "漏洞描述": "Improper sanitization of the value of the [srcset] attribute in <source> HTML elements in AngularJS allows attackers to bypass common image source restrictions, which can also lead to a form of  Content Spoofing https://owasp.org/www-community/attacks/Content_Spoofing .\n\nThis issue affects all versions of AngularJS.\n\nNote:\nThe AngularJS project is End-of-Life and will not receive any updates to address this issue. For more information see  here https://docs.angularjs.org/misc/version-support-status .",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.herodevs.com/vulnerability-directory/cve-2024-8373",
      "https://codepen.io/herodevs/full/bGPQgMp/8da9ce87e99403ee13a295c305ebfa0b"
    ],
    "受影响版本": [
      ">=0.0.0"
    ],
    "公开日期": "2024年09月09日"
  },
  {
    "设备品牌": "Google",
    "设备类型": "OTA",
    "产品型号": "AngularJS",
    "CVE编号": "CVE-2024-8372",
    "漏洞描述": "Improper sanitization of the value of the 'srcset' attribute in AngularJS allows attackers to bypass common image source restrictions, which can also lead to a form of  Content Spoofing https://owasp.org/www-community/attacks/Content_Spoofing .\n\nThis issue affects AngularJS versions 1.3.0-rc.4 and greater.\n\nNote:\nThe AngularJS project is End-of-Life and will not receive any updates to address this issue. For more information see  here https://docs.angularjs.org/misc/version-support-status .",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.herodevs.com/vulnerability-directory/cve-2024-8372",
      "https://codepen.io/herodevs/full/xxoQRNL/0072e627abe03e9cda373bc75b4c1017"
    ],
    "受影响版本": [
      ">=1.3.0-rc.4"
    ],
    "公开日期": "2024年09月09日"
  },
  {
    "设备品牌": "Eryaz Information Technologies",
    "设备类型": "OTA",
    "产品型号": "NatraCar B2B Dealer Management Program",
    "CVE编号": "CVE-2024-8259",
    "漏洞描述": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in Eryaz Information Technologies NatraCar B2B Dealer Management Program allows SQL Injection.This issue affects NatraCar B2B Dealer Management Program: through 09.12.2024.\n\n\n\nNOTE: The vendor was contacted and it was learned that the product is not supported.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-24-1881"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年12月09日"
  },
  {
    "设备品牌": "Microchip",
    "设备类型": "OTA",
    "产品型号": "TimeProvider 4100",
    "CVE编号": "CVE-2024-7801",
    "漏洞描述": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in Microchip TimeProvider 4100 (Data plot modules) allows SQL Injection.This issue affects TimeProvider 4100: from 1.0 before 2.4.7.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-unathenticated-sql-injection",
      "https://www.gruppotim.it/it/footer/red-team.html"
    ],
    "受影响版本": [
      "1.0"
    ],
    "公开日期": "2024年10月04日"
  },
  {
    "设备品牌": "Brain Information Technologies Inc.",
    "设备类型": "OTA",
    "产品型号": "Brain Low-Code",
    "CVE编号": "CVE-2024-7071",
    "漏洞描述": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'), CWE - 564 - SQL Injection: Hibernate vulnerability in Brain Information Technologies Inc. Brain Low-Code allows SQL Injection.This issue affects Brain Low-Code: before 2.1.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-24-1349"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年08月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-58089",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix double accounting race when btrfs_run_delalloc_range() failed\n\n[BUG]\nWhen running btrfs with block size (4K) smaller than page size (64K,\naarch64), there is a very high chance to crash the kernel at\ngeneric/750, with the following messages:\n(before the call traces, there are 3 extra debug messages added)\n\n  BTRFS warning (device dm-3): read-write for sector size 4096 with page size 65536 is experimental\n  BTRFS info (device dm-3): checking UUID tree\n  hrtimer: interrupt took 5451385 ns\n  BTRFS error (device dm-3): cow_file_range failed, root=4957 inode=257 start=1605632 len=69632: -28\n  BTRFS error (device dm-3): run_delalloc_nocow failed, root=4957 inode=257 start=1605632 len=69632: -28\n  BTRFS error (device dm-3): failed to run delalloc range, root=4957 ino=257 folio=1572864 submit_bitmap=8-15 start=1605632 len=69632: -28\n  ------------[ cut here ]------------\n  WARNING: CPU: 2 PID: 3020984 at ordered-data.c:360 can_finish_ordered_extent+0x370/0x3b8 [btrfs]\n  CPU: 2 UID: 0 PID: 3020984 Comm: kworker/u24:1 Tainted: G           OE      6.13.0-rc1-custom+ #89\n  Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE\n  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n  Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]\n  pc : can_finish_ordered_extent+0x370/0x3b8 [btrfs]\n  lr : can_finish_ordered_extent+0x1ec/0x3b8 [btrfs]\n  Call trace:\n   can_finish_ordered_extent+0x370/0x3b8 [btrfs] (P)\n   can_finish_ordered_extent+0x1ec/0x3b8 [btrfs] (L)\n   btrfs_mark_ordered_io_finished+0x130/0x2b8 [btrfs]\n   extent_writepage+0x10c/0x3b8 [btrfs]\n   extent_write_cache_pages+0x21c/0x4e8 [btrfs]\n   btrfs_writepages+0x94/0x160 [btrfs]\n   do_writepages+0x74/0x190\n   filemap_fdatawrite_wbc+0x74/0xa0\n   start_delalloc_inodes+0x17c/0x3b0 [btrfs]\n   btrfs_start_delalloc_roots+0x17c/0x288 [btrfs]\n   shrink_delalloc+0x11c/0x280 [btrfs]\n   flush_space+0x288/0x328 [btrfs]\n   btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]\n   process_one_work+0x228/0x680\n   worker_thread+0x1bc/0x360\n   kthread+0x100/0x118\n   ret_from_fork+0x10/0x20\n  ---[ end trace 0000000000000000 ]---\n  BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1605632 OE len=16384 to_dec=16384 left=0\n  BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1622016 OE len=12288 to_dec=12288 left=0\n  Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008\n  BTRFS critical (device dm-3): bad ordered extent accounting, root=4957 ino=257 OE offset=1634304 OE len=8192 to_dec=4096 left=0\n  CPU: 1 UID: 0 PID: 3286940 Comm: kworker/u24:3 Tainted: G        W  OE      6.13.0-rc1-custom+ #89\n  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n  Workqueue:  btrfs_work_helper [btrfs] (btrfs-endio-write)\n  pstate: 404000c5 (nZcv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n  pc : process_one_work+0x110/0x680\n  lr : worker_thread+0x1bc/0x360\n  Call trace:\n   process_one_work+0x110/0x680 (P)\n   worker_thread+0x1bc/0x360 (L)\n   worker_thread+0x1bc/0x360\n   kthread+0x100/0x118\n   ret_from_fork+0x10/0x20\n  Code: f84086a1 f9000fe1 53041c21 b9003361 (f9400661)\n  ---[ end trace 0000000000000000 ]---\n  Kernel panic - not syncing: Oops: Fatal exception\n  SMP: stopping secondary CPUs\n  SMP: failed to stop secondary CPUs 2-3\n  Dumping ftrace buffer:\n     (ftrace buffer empty)\n  Kernel Offset: 0x275bb9540000 from 0xffff800080000000\n  PHYS_OFFSET: 0xffff8fbba0000000\n  CPU features: 0x100,00000070,00801250,8201720b\n\n[CAUSE]\nThe above warning is triggered immediately after the delalloc range\nfailure, this happens in the following sequence:\n\n- Range [1568K, 1636K) is dirty\n\n   1536K  1568K     1600K    1636K  1664K\n   |      |/////////|////////|      |\n\n  Where 1536K, 1600K and 1664K are page boundaries (64K page size)\n\n- Enter extent_writepage() for page 1536K\n\n- Enter run_delalloc_nocow() with locke\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/21333148b5c9e52f41fafcedec3810b56a5e0e40",
      "https://git.kernel.org/stable/c/0283ee1912c8e243c931f4ee5b3672e954fe0384",
      "https://git.kernel.org/stable/c/72dad8e377afa50435940adfb697e070d3556670"
    ],
    "受影响版本": [
      "d1051d6ebf8ef3517a5a3cf82bba8436d190f1c2",
      "d1051d6ebf8ef3517a5a3cf82bba8436d190f1c2",
      "d1051d6ebf8ef3517a5a3cf82bba8436d190f1c2",
      "eb124aaa2e85e9dceac37be5b7166a04b9b26735"
    ],
    "公开日期": "2025年03月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-58084",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirmware: qcom: scm: Fix missing read barrier in qcom_scm_get_tzmem_pool()\n\nCommit 2e4955167ec5 (\"firmware: qcom: scm: Fix __scm and waitq\ncompletion variable initialization\") introduced a write barrier in probe\nfunction to store global '__scm' variable.  We all known barriers are\npaired (see memory-barriers.txt: \"Note that write barriers should\nnormally be paired with read or address-dependency barriers\"), therefore\naccessing it from concurrent contexts requires read barrier.  Previous\ncommit added such barrier in qcom_scm_is_available(), so let's use that\ndirectly.\n\nLack of this read barrier can result in fetching stale '__scm' variable\nvalue, NULL, and dereferencing it.\n\nNote that barrier in qcom_scm_is_available() satisfies here the control\ndependency.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fee921e3c641f64185abee83f9a6e65f0b380682",
      "https://git.kernel.org/stable/c/e03db7c1255ebabba5e1a447754faeb138de15a2",
      "https://git.kernel.org/stable/c/b628510397b5cafa1f5d3e848a28affd1c635302"
    ],
    "受影响版本": [
      "449d0d84bcd8246b508d07995326d13c54488b8c",
      "449d0d84bcd8246b508d07995326d13c54488b8c",
      "449d0d84bcd8246b508d07995326d13c54488b8c"
    ],
    "公开日期": "2025年03月06日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-58079",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: uvcvideo: Fix crash during unbind if gpio unit is in use\n\nWe used the wrong device for the device managed functions. We used the\nusb device, when we should be using the interface device.\n\nIf we unbind the driver from the usb interface, the cleanup functions\nare never called. In our case, the IRQ is never disabled.\n\nIf an IRQ is triggered, it will try to access memory sections that are\nalready free, causing an OOPS.\n\nWe cannot use the function devm_request_threaded_irq here. The devm_*\nclean functions may be called after the main structure is released by\nuvc_delete.\n\nLuckily this bug has small impact, as it is only affected by devices\nwith gpio units and the user has to unbind the device, a disconnect will\nnot trigger this error.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0fdd7cc593385e46e92e180b71e264fc9c195298",
      "https://git.kernel.org/stable/c/3c00e94d00ca079bef7906d6f39d1091bccfedd3",
      "https://git.kernel.org/stable/c/0b5e0445bc8384c18bd35cb9fe87f6258c6271d9",
      "https://git.kernel.org/stable/c/d2eac8b14ac690aa73052aa6d4ba69005715367e",
      "https://git.kernel.org/stable/c/5d2e65cbe53d0141ed095cf31c2dcf3d8668c11d",
      "https://git.kernel.org/stable/c/a9ea1a3d88b7947ce8cadb2afceee7a54872bbc5"
    ],
    "受影响版本": [
      "2886477ff98740cc3333cf785e4de0b1ff3d7a28",
      "2886477ff98740cc3333cf785e4de0b1ff3d7a28",
      "2886477ff98740cc3333cf785e4de0b1ff3d7a28",
      "2886477ff98740cc3333cf785e4de0b1ff3d7a28",
      "2886477ff98740cc3333cf785e4de0b1ff3d7a28",
      "2886477ff98740cc3333cf785e4de0b1ff3d7a28"
    ],
    "公开日期": "2025年03月06日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-58018",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvkm: correctly calculate the available space of the GSP cmdq buffer\n\nr535_gsp_cmdq_push() waits for the available page in the GSP cmdq\nbuffer when handling a large RPC request. When it sees at least one\navailable page in the cmdq, it quits the waiting with the amount of\nfree buffer pages in the queue.\n\nUnfortunately, it always takes the [write pointer, buf_size) as\navailable buffer pages before rolling back and wrongly calculates the\nsize of the data should be copied. Thus, it can overwrite the RPC\nrequest that GSP is currently reading, which causes GSP hang due\nto corrupted RPC request:\n\n[  549.209389] ------------[ cut here ]------------\n[  549.214010] WARNING: CPU: 8 PID: 6314 at drivers/gpu/drm/nouveau/nvkm/subdev/gsp/r535.c:116 r535_gsp_msgq_wait+0xd0/0x190 [nvkm]\n[  549.225678] Modules linked in: nvkm(E+) gsp_log(E) snd_seq_dummy(E) snd_hrtimer(E) snd_seq(E) snd_timer(E) snd_seq_device(E) snd(E) soundcore(E) rfkill(E) qrtr(E) vfat(E) fat(E) ipmi_ssif(E) amd_atl(E) intel_rapl_msr(E) intel_rapl_common(E) mlx5_ib(E) amd64_edac(E) edac_mce_amd(E) kvm_amd(E) ib_uverbs(E) kvm(E) ib_core(E) acpi_ipmi(E) ipmi_si(E) mxm_wmi(E) ipmi_devintf(E) rapl(E) i2c_piix4(E) wmi_bmof(E) joydev(E) ptdma(E) acpi_cpufreq(E) k10temp(E) pcspkr(E) ipmi_msghandler(E) xfs(E) libcrc32c(E) ast(E) i2c_algo_bit(E) crct10dif_pclmul(E) drm_shmem_helper(E) nvme_tcp(E) crc32_pclmul(E) ahci(E) drm_kms_helper(E) libahci(E) nvme_fabrics(E) crc32c_intel(E) nvme(E) cdc_ether(E) mlx5_core(E) nvme_core(E) usbnet(E) drm(E) libata(E) ccp(E) ghash_clmulni_intel(E) mii(E) t10_pi(E) mlxfw(E) sp5100_tco(E) psample(E) pci_hyperv_intf(E) wmi(E) dm_multipath(E) sunrpc(E) dm_mirror(E) dm_region_hash(E) dm_log(E) dm_mod(E) be2iscsi(E) bnx2i(E) cnic(E) uio(E) cxgb4i(E) cxgb4(E) tls(E) libcxgbi(E) libcxgb(E) qla4xxx(E)\n[  549.225752]  iscsi_boot_sysfs(E) iscsi_tcp(E) libiscsi_tcp(E) libiscsi(E) scsi_transport_iscsi(E) fuse(E) [last unloaded: gsp_log(E)]\n[  549.326293] CPU: 8 PID: 6314 Comm: insmod Tainted: G            E      6.9.0-rc6+ #1\n[  549.334039] Hardware name: ASRockRack 1U1G-MILAN/N/ROMED8-NL, BIOS L3.12E 09/06/2022\n[  549.341781] RIP: 0010:r535_gsp_msgq_wait+0xd0/0x190 [nvkm]\n[  549.347343] Code: 08 00 00 89 da c1 e2 0c 48 8d ac 11 00 10 00 00 48 8b 0c 24 48 85 c9 74 1f c1 e0 0c 4c 8d 6d 30 83 e8 30 89 01 e9 68 ff ff ff <0f> 0b 49 c7 c5 92 ff ff ff e9 5a ff ff ff ba ff ff ff ff be c0 0c\n[  549.366090] RSP: 0018:ffffacbccaaeb7d0 EFLAGS: 00010246\n[  549.371315] RAX: 0000000000000000 RBX: 0000000000000012 RCX: 0000000000923e28\n[  549.378451] RDX: 0000000000000000 RSI: 0000000055555554 RDI: ffffacbccaaeb730\n[  549.385590] RBP: 0000000000000001 R08: ffff8bd14d235f70 R09: ffff8bd14d235f70\n[  549.392721] R10: 0000000000000002 R11: ffff8bd14d233864 R12: 0000000000000020\n[  549.399854] R13: ffffacbccaaeb818 R14: 0000000000000020 R15: ffff8bb298c67000\n[  549.406988] FS:  00007f5179244740(0000) GS:ffff8bd14d200000(0000) knlGS:0000000000000000\n[  549.415076] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  549.420829] CR2: 00007fa844000010 CR3: 00000001567dc005 CR4: 0000000000770ef0\n[  549.427963] PKRU: 55555554\n[  549.430672] Call Trace:\n[  549.433126]  <TASK>\n[  549.435233]  ? __warn+0x7f/0x130\n[  549.438473]  ? r535_gsp_msgq_wait+0xd0/0x190 [nvkm]\n[  549.443426]  ? report_bug+0x18a/0x1a0\n[  549.447098]  ? handle_bug+0x3c/0x70\n[  549.450589]  ? exc_invalid_op+0x14/0x70\n[  549.454430]  ? asm_exc_invalid_op+0x16/0x20\n[  549.458619]  ? r535_gsp_msgq_wait+0xd0/0x190 [nvkm]\n[  549.463565]  r535_gsp_msg_recv+0x46/0x230 [nvkm]\n[  549.468257]  r535_gsp_rpc_push+0x106/0x160 [nvkm]\n[  549.473033]  r535_gsp_rpc_rm_ctrl_push+0x40/0x130 [nvkm]\n[  549.478422]  nvidia_grid_init_vgpu_types+0xbc/0xe0 [nvkm]\n[  549.483899]  nvidia_grid_init+0xb1/0xd0 [nvkm]\n[  549.488420]  ? srso_alias_return_thunk+0x5/0xfbef5\n[  549.493213]  nvkm_device_pci_probe+0x305/0x420 [nvkm]\n[  549.498338]  local_pci_probe+0x46/\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/56e6c7f6d2a6b4e0aae0528c502e56825bb40598",
      "https://git.kernel.org/stable/c/6b6b75728c86f60c1fc596f0d4542427d0e6065b",
      "https://git.kernel.org/stable/c/01ed662bdd6fce4f59c1804b334610d710d79fa0"
    ],
    "受影响版本": [
      "176fdcbddfd288408ce8571c1760ad618d962096",
      "176fdcbddfd288408ce8571c1760ad618d962096",
      "176fdcbddfd288408ce8571c1760ad618d962096"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-58009",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: L2CAP: handle NULL sock pointer in l2cap_sock_alloc\n\nA NULL sock pointer is passed into l2cap_sock_alloc() when it is called\nfrom l2cap_sock_new_connection_cb() and the error handling paths should\nalso be aware of it.\n\nSeemingly a more elegant solution would be to swap bt_sock_alloc() and\nl2cap_chan_create() calls since they are not interdependent to that moment\nbut then l2cap_chan_create() adds the soon to be deallocated and still\ndummy-initialized channel to the global list accessible by many L2CAP\npaths. The channel would be removed from the list in short period of time\nbut be a bit more straight-forward here and just check for NULL instead of\nchanging the order of function calls.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE static\nanalysis tool.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a9a7672fc1a0fe18502493936ccb06413ab89ea6",
      "https://git.kernel.org/stable/c/8e605f580a97530e5a3583beea458a3fa4cbefbd",
      "https://git.kernel.org/stable/c/cf601a24120c674cd7c907ea695f92617af6abd0",
      "https://git.kernel.org/stable/c/297ce7f544aa675b0d136d788cad0710cdfb0785",
      "https://git.kernel.org/stable/c/245d48c1ba3e7a1779c2f4cbc6f581ddc8a78e22",
      "https://git.kernel.org/stable/c/691218a50c3139f7f57ffa79fb89d932eda9571e",
      "https://git.kernel.org/stable/c/49c0d55d59662430f1829ae85b969619573d0fa1",
      "https://git.kernel.org/stable/c/5f397409f8ee5bc82901eeaf799e1cbc4f8edcf1"
    ],
    "受影响版本": [
      "f6ad641646b67f29c7578dcd6c25813c7dcbf51e",
      "daa13175a6dea312a76099066cb4cbd4fc959a84",
      "a8677028dd5123e5e525b8195483994d87123de4",
      "bb2f2342a6ddf7c04f9aefbbfe86104cd138e629",
      "8ad09ddc63ace3950ac43db6fbfe25b40f589dd6",
      "61686abc2f3c2c67822aa23ce6f160467ec83d35",
      "7c4f78cdb8e7501e9f92d291a7d956591bf73be9",
      "7c4f78cdb8e7501e9f92d291a7d956591bf73be9"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-58005",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntpm: Change to kvalloc() in eventlog/acpi.c\n\nThe following failure was reported on HPE ProLiant D320:\n\n[   10.693310][    T1] tpm_tis STM0925:00: 2.0 TPM (device-id 0x3, rev-id 0)\n[   10.848132][    T1] ------------[ cut here ]------------\n[   10.853559][    T1] WARNING: CPU: 59 PID: 1 at mm/page_alloc.c:4727 __alloc_pages_noprof+0x2ca/0x330\n[   10.862827][    T1] Modules linked in:\n[   10.866671][    T1] CPU: 59 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.0-lp155.2.g52785e2-default #1 openSUSE Tumbleweed (unreleased) 588cd98293a7c9eba9013378d807364c088c9375\n[   10.882741][    T1] Hardware name: HPE ProLiant DL320 Gen12/ProLiant DL320 Gen12, BIOS 1.20 10/28/2024\n[   10.892170][    T1] RIP: 0010:__alloc_pages_noprof+0x2ca/0x330\n[   10.898103][    T1] Code: 24 08 e9 4a fe ff ff e8 34 36 fa ff e9 88 fe ff ff 83 fe 0a 0f 86 b3 fd ff ff 80 3d 01 e7 ce 01 00 75 09 c6 05 f8 e6 ce 01 01 <0f> 0b 45 31 ff e9 e5 fe ff ff f7 c2 00 00 08 00 75 42 89 d9 80 e1\n[   10.917750][    T1] RSP: 0000:ffffb7cf40077980 EFLAGS: 00010246\n[   10.923777][    T1] RAX: 0000000000000000 RBX: 0000000000040cc0 RCX: 0000000000000000\n[   10.931727][    T1] RDX: 0000000000000000 RSI: 000000000000000c RDI: 0000000000040cc0\n\nThe above transcript shows that ACPI pointed a 16 MiB buffer for the log\nevents because RSI maps to the 'order' parameter of __alloc_pages_noprof().\nAddress the bug by moving from devm_kmalloc() to devm_add_action() and\nkvmalloc() and devm_add_action().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a676c0401de59548a5bc1b7aaf98f556ae8ea6db",
      "https://git.kernel.org/stable/c/0621d2599d6e02d05c85d6bbd58eaea2f15b3503",
      "https://git.kernel.org/stable/c/77779d1258a287f2c5c2c6aeae203e0996209c77",
      "https://git.kernel.org/stable/c/50365a6304a57266e8f4d3078060743c3b7a1e0d",
      "https://git.kernel.org/stable/c/422d7f4e8d817be467986589c7968d3ea402f7da",
      "https://git.kernel.org/stable/c/4c8bfe643bbd00b04ee8f9545ef33bf6a68c38db",
      "https://git.kernel.org/stable/c/a3a860bc0fd6c07332e4911cf9a238d20de90173"
    ],
    "受影响版本": [
      "55a82ab3181be039c6440d3f2f69260ad6fe2988",
      "55a82ab3181be039c6440d3f2f69260ad6fe2988",
      "55a82ab3181be039c6440d3f2f69260ad6fe2988",
      "55a82ab3181be039c6440d3f2f69260ad6fe2988",
      "55a82ab3181be039c6440d3f2f69260ad6fe2988",
      "55a82ab3181be039c6440d3f2f69260ad6fe2988",
      "55a82ab3181be039c6440d3f2f69260ad6fe2988"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57979",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npps: Fix a use-after-free\n\nOn a board running ntpd and gpsd, I'm seeing a consistent use-after-free\nin sys_exit() from gpsd when rebooting:\n\n    pps pps1: removed\n    ------------[ cut here ]------------\n    kobject: '(null)' (00000000db4bec24): is not initialized, yet kobject_put() is being called.\n    WARNING: CPU: 2 PID: 440 at lib/kobject.c:734 kobject_put+0x120/0x150\n    CPU: 2 UID: 299 PID: 440 Comm: gpsd Not tainted 6.11.0-rc6-00308-gb31c44928842 #1\n    Hardware name: Raspberry Pi 4 Model B Rev 1.1 (DT)\n    pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n    pc : kobject_put+0x120/0x150\n    lr : kobject_put+0x120/0x150\n    sp : ffffffc0803d3ae0\n    x29: ffffffc0803d3ae0 x28: ffffff8042dc9738 x27: 0000000000000001\n    x26: 0000000000000000 x25: ffffff8042dc9040 x24: ffffff8042dc9440\n    x23: ffffff80402a4620 x22: ffffff8042ef4bd0 x21: ffffff80405cb600\n    x20: 000000000008001b x19: ffffff8040b3b6e0 x18: 0000000000000000\n    x17: 0000000000000000 x16: 0000000000000000 x15: 696e6920746f6e20\n    x14: 7369203a29343263 x13: 205d303434542020 x12: 0000000000000000\n    x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000\n    x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000\n    x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000\n    x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000\n    Call trace:\n     kobject_put+0x120/0x150\n     cdev_put+0x20/0x3c\n     __fput+0x2c4/0x2d8\n     ____fput+0x1c/0x38\n     task_work_run+0x70/0xfc\n     do_exit+0x2a0/0x924\n     do_group_exit+0x34/0x90\n     get_signal+0x7fc/0x8c0\n     do_signal+0x128/0x13b4\n     do_notify_resume+0xdc/0x160\n     el0_svc+0xd4/0xf8\n     el0t_64_sync_handler+0x140/0x14c\n     el0t_64_sync+0x190/0x194\n    ---[ end trace 0000000000000000 ]---\n\n...followed by more symptoms of corruption, with similar stacks:\n\n    refcount_t: underflow; use-after-free.\n    kernel BUG at lib/list_debug.c:62!\n    Kernel panic - not syncing: Oops - BUG: Fatal exception\n\nThis happens because pps_device_destruct() frees the pps_device with the\nembedded cdev immediately after calling cdev_del(), but, as the comment\nabove cdev_del() notes, fops for previously opened cdevs are still\ncallable even after cdev_del() returns. I think this bug has always\nbeen there: I can't explain why it suddenly started happening every time\nI reboot this particular board.\n\nIn commit d953e0e837e6 (\"pps: Fix a use-after free bug when\nunregistering a source.\"), George Spelvin suggested removing the\nembedded cdev. That seems like the simplest way to fix this, so I've\nimplemented his suggestion, using __register_chrdev() with pps_idr\nbecoming the source of truth for which minor corresponds to which\ndevice.\n\nBut now that pps_idr defines userspace visibility instead of cdev_add(),\nwe need to be sure the pps->dev refcount can't reach zero while\nuserspace can still find it again. So, the idr_remove() call moves to\npps_unregister_cdev(), and pps_idr now holds a reference to pps->dev.\n\n    pps_core: source serial1 got cdev (251:1)\n    <...>\n    pps pps1: removed\n    pps_core: unregistering pps1\n    pps_core: deallocating pps1",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/785c78ed0d39d1717cca3ef931d3e51337b5e90e",
      "https://git.kernel.org/stable/c/1a7735ab2cb9747518a7416fb5929e85442dec62",
      "https://git.kernel.org/stable/c/c4041b6b0a7a3def8cf3f3d6120ff337bc4c40f7",
      "https://git.kernel.org/stable/c/91932db1d96b2952299ce30c1c693d834d10ace6",
      "https://git.kernel.org/stable/c/cd3bbcb6b3a7caa5ce67de76723b6d8531fb7f64",
      "https://git.kernel.org/stable/c/7e5ee3281dc09014367f5112b6d566ba36ea2d49",
      "https://git.kernel.org/stable/c/85241f7de216f8298f6e48540ea13d7dcd100870",
      "https://git.kernel.org/stable/c/c79a39dc8d060b9e64e8b0fa9d245d44befeefbe"
    ],
    "受影响版本": [
      "d953e0e837e65ecc1ddaa4f9560f7925878a0de6",
      "d953e0e837e65ecc1ddaa4f9560f7925878a0de6",
      "d953e0e837e65ecc1ddaa4f9560f7925878a0de6",
      "d953e0e837e65ecc1ddaa4f9560f7925878a0de6",
      "d953e0e837e65ecc1ddaa4f9560f7925878a0de6",
      "d953e0e837e65ecc1ddaa4f9560f7925878a0de6",
      "d953e0e837e65ecc1ddaa4f9560f7925878a0de6",
      "d953e0e837e65ecc1ddaa4f9560f7925878a0de6",
      "77327a71f9841b7dfa708195d1cb133d4ef4a989",
      "cd59fb14918a6b20c1ac8be121fa6397b97b00cb",
      "49626fbb0360332e40fd76a48cb2ba876d6134ad"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57976",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: do proper folio cleanup when cow_file_range() failed\n\n[BUG]\nWhen testing with COW fixup marked as BUG_ON() (this is involved with the\nnew pin_user_pages*() change, which should not result new out-of-band\ndirty pages), I hit a crash triggered by the BUG_ON() from hitting COW\nfixup path.\n\nThis BUG_ON() happens just after a failed btrfs_run_delalloc_range():\n\n  BTRFS error (device dm-2): failed to run delalloc range, root 348 ino 405 folio 65536 submit_bitmap 6-15 start 90112 len 106496: -28\n  ------------[ cut here ]------------\n  kernel BUG at fs/btrfs/extent_io.c:1444!\n  Internal error: Oops - BUG: 00000000f2000800 [#1] SMP\n  CPU: 0 UID: 0 PID: 434621 Comm: kworker/u24:8 Tainted: G           OE      6.12.0-rc7-custom+ #86\n  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n  Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]\n  pc : extent_writepage_io+0x2d4/0x308 [btrfs]\n  lr : extent_writepage_io+0x2d4/0x308 [btrfs]\n  Call trace:\n   extent_writepage_io+0x2d4/0x308 [btrfs]\n   extent_writepage+0x218/0x330 [btrfs]\n   extent_write_cache_pages+0x1d4/0x4b0 [btrfs]\n   btrfs_writepages+0x94/0x150 [btrfs]\n   do_writepages+0x74/0x190\n   filemap_fdatawrite_wbc+0x88/0xc8\n   start_delalloc_inodes+0x180/0x3b0 [btrfs]\n   btrfs_start_delalloc_roots+0x174/0x280 [btrfs]\n   shrink_delalloc+0x114/0x280 [btrfs]\n   flush_space+0x250/0x2f8 [btrfs]\n   btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]\n   process_one_work+0x164/0x408\n   worker_thread+0x25c/0x388\n   kthread+0x100/0x118\n   ret_from_fork+0x10/0x20\n  Code: aa1403e1 9402f3ef aa1403e0 9402f36f (d4210000)\n  ---[ end trace 0000000000000000 ]---\n\n[CAUSE]\nThat failure is mostly from cow_file_range(), where we can hit -ENOSPC.\n\nAlthough the -ENOSPC is already a bug related to our space reservation\ncode, let's just focus on the error handling.\n\nFor example, we have the following dirty range [0, 64K) of an inode,\nwith 4K sector size and 4K page size:\n\n   0        16K        32K       48K       64K\n   |///////////////////////////////////////|\n   |#######################################|\n\nWhere |///| means page are still dirty, and |###| means the extent io\ntree has EXTENT_DELALLOC flag.\n\n- Enter extent_writepage() for page 0\n\n- Enter btrfs_run_delalloc_range() for range [0, 64K)\n\n- Enter cow_file_range() for range [0, 64K)\n\n- Function btrfs_reserve_extent() only reserved one 16K extent\n  So we created extent map and ordered extent for range [0, 16K)\n\n   0        16K        32K       48K       64K\n   |////////|//////////////////////////////|\n   |<- OE ->|##############################|\n\n   And range [0, 16K) has its delalloc flag cleared.\n   But since we haven't yet submit any bio, involved 4 pages are still\n   dirty.\n\n- Function btrfs_reserve_extent() returns with -ENOSPC\n  Now we have to run error cleanup, which will clear all\n  EXTENT_DELALLOC* flags and clear the dirty flags for the remaining\n  ranges:\n\n   0        16K        32K       48K       64K\n   |////////|                              |\n   |        |                              |\n\n  Note that range [0, 16K) still has its pages dirty.\n\n- Some time later, writeback is triggered again for the range [0, 16K)\n  since the page range still has dirty flags.\n\n- btrfs_run_delalloc_range() will do nothing because there is no\n  EXTENT_DELALLOC flag.\n\n- extent_writepage_io() finds page 0 has no ordered flag\n  Which falls into the COW fixup path, triggering the BUG_ON().\n\nUnfortunately this error handling bug dates back to the introduction of\nbtrfs.  Thankfully with the abuse of COW fixup, at least it won't crash\nthe kernel.\n\n[FIX]\nInstead of immediately unlocking the extent and folios, we keep the extent\nand folios locked until either erroring out or the whole delalloc range\nfinished.\n\nWhen the whole delalloc range finished without error, we just unlock the\nwhole range with PAGE_SET_ORDERED (and PAGE_UNLOCK for !keep_locked\ncases)\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/692cf71173bb41395c855acbbbe197d3aedfa5d4",
      "https://git.kernel.org/stable/c/06f364284794f149d2abc167c11d556cf20c954b"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57975",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: do proper folio cleanup when run_delalloc_nocow() failed\n\n[BUG]\nWith CONFIG_DEBUG_VM set, test case generic/476 has some chance to crash\nwith the following VM_BUG_ON_FOLIO():\n\n  BTRFS error (device dm-3): cow_file_range failed, start 1146880 end 1253375 len 106496 ret -28\n  BTRFS error (device dm-3): run_delalloc_nocow failed, start 1146880 end 1253375 len 106496 ret -28\n  page: refcount:4 mapcount:0 mapping:00000000592787cc index:0x12 pfn:0x10664\n  aops:btrfs_aops [btrfs] ino:101 dentry name(?):\"f1774\"\n  flags: 0x2fffff80004028(uptodate|lru|private|node=0|zone=2|lastcpupid=0xfffff)\n  page dumped because: VM_BUG_ON_FOLIO(!folio_test_locked(folio))\n  ------------[ cut here ]------------\n  kernel BUG at mm/page-writeback.c:2992!\n  Internal error: Oops - BUG: 00000000f2000800 [#1] SMP\n  CPU: 2 UID: 0 PID: 3943513 Comm: kworker/u24:15 Tainted: G           OE      6.12.0-rc7-custom+ #87\n  Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE\n  Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n  Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]\n  pc : folio_clear_dirty_for_io+0x128/0x258\n  lr : folio_clear_dirty_for_io+0x128/0x258\n  Call trace:\n   folio_clear_dirty_for_io+0x128/0x258\n   btrfs_folio_clamp_clear_dirty+0x80/0xd0 [btrfs]\n   __process_folios_contig+0x154/0x268 [btrfs]\n   extent_clear_unlock_delalloc+0x5c/0x80 [btrfs]\n   run_delalloc_nocow+0x5f8/0x760 [btrfs]\n   btrfs_run_delalloc_range+0xa8/0x220 [btrfs]\n   writepage_delalloc+0x230/0x4c8 [btrfs]\n   extent_writepage+0xb8/0x358 [btrfs]\n   extent_write_cache_pages+0x21c/0x4e8 [btrfs]\n   btrfs_writepages+0x94/0x150 [btrfs]\n   do_writepages+0x74/0x190\n   filemap_fdatawrite_wbc+0x88/0xc8\n   start_delalloc_inodes+0x178/0x3a8 [btrfs]\n   btrfs_start_delalloc_roots+0x174/0x280 [btrfs]\n   shrink_delalloc+0x114/0x280 [btrfs]\n   flush_space+0x250/0x2f8 [btrfs]\n   btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]\n   process_one_work+0x164/0x408\n   worker_thread+0x25c/0x388\n   kthread+0x100/0x118\n   ret_from_fork+0x10/0x20\n  Code: 910a8021 a90363f7 a9046bf9 94012379 (d4210000)\n  ---[ end trace 0000000000000000 ]---\n\n[CAUSE]\nThe first two lines of extra debug messages show the problem is caused\nby the error handling of run_delalloc_nocow().\n\nE.g. we have the following dirtied range (4K blocksize 4K page size):\n\n    0                 16K                  32K\n    |//////////////////////////////////////|\n    |  Pre-allocated  |\n\nAnd the range [0, 16K) has a preallocated extent.\n\n- Enter run_delalloc_nocow() for range [0, 16K)\n  Which found range [0, 16K) is preallocated, can do the proper NOCOW\n  write.\n\n- Enter fallback_to_fow() for range [16K, 32K)\n  Since the range [16K, 32K) is not backed by preallocated extent, we\n  have to go COW.\n\n- cow_file_range() failed for range [16K, 32K)\n  So cow_file_range() will do the clean up by clearing folio dirty,\n  unlock the folios.\n\n  Now the folios in range [16K, 32K) is unlocked.\n\n- Enter extent_clear_unlock_delalloc() from run_delalloc_nocow()\n  Which is called with PAGE_START_WRITEBACK to start page writeback.\n  But folios can only be marked writeback when it's properly locked,\n  thus this triggered the VM_BUG_ON_FOLIO().\n\nFurthermore there is another hidden but common bug that\nrun_delalloc_nocow() is not clearing the folio dirty flags in its error\nhandling path.\nThis is the common bug shared between run_delalloc_nocow() and\ncow_file_range().\n\n[FIX]\n- Clear folio dirty for range [@start, @cur_offset)\n  Introduce a helper, cleanup_dirty_folios(), which\n  will find and lock the folio in the range, clear the dirty flag and\n  start/end the writeback, with the extra handling for the\n  @locked_folio.\n\n- Introduce a helper to clear folio dirty, start and end writeback\n\n- Introduce a helper to record the last failed COW range end\n  This is to trace which range we should skip, to avoid double\n  unlocking.\n\n- Skip the failed COW range for the e\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5ae72abbf91eb172ce3a838a4dc34be3c9707296",
      "https://git.kernel.org/stable/c/2434533f1c963e7317c45880c98287e5bed98325",
      "https://git.kernel.org/stable/c/c2b47df81c8e20a8e8cd94f0d7df211137ae94ed"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57929",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm array: fix releasing a faulty array block twice in dm_array_cursor_end\n\nWhen dm_bm_read_lock() fails due to locking or checksum errors, it\nreleases the faulty block implicitly while leaving an invalid output\npointer behind. The caller of dm_bm_read_lock() should not operate on\nthis invalid dm_block pointer, or it will lead to undefined result.\nFor example, the dm_array_cursor incorrectly caches the invalid pointer\non reading a faulty array block, causing a double release in\ndm_array_cursor_end(), then hitting the BUG_ON in dm-bufio cache_put().\n\nReproduce steps:\n\n1. initialize a cache device\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc $262144\"\ndd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1\ndmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\n\n2. wipe the second array block offline\n\ndmsteup remove cache cmeta cdata corig\nmapping_root=$(dd if=/dev/sdc bs=1c count=8 skip=192 \\\n2>/dev/null | hexdump -e '1/8 \"%u\\n\"')\nablock=$(dd if=/dev/sdc bs=1c count=8 skip=$((4096*mapping_root+2056)) \\\n2>/dev/null | hexdump -e '1/8 \"%u\\n\"')\ndd if=/dev/zero of=/dev/sdc bs=4k count=1 seek=$ablock\n\n3. try reopen the cache device\n\ndmsetup create cmeta --table \"0 8192 linear /dev/sdc 0\"\ndmsetup create cdata --table \"0 65536 linear /dev/sdc 8192\"\ndmsetup create corig --table \"0 524288 linear /dev/sdc $262144\"\ndmsetup create cache --table \"0 524288 cache /dev/mapper/cmeta \\\n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0\"\n\nKernel logs:\n\n(snip)\ndevice-mapper: array: array_block_check failed: blocknr 0 != wanted 10\ndevice-mapper: block manager: array validator check failed for block 10\ndevice-mapper: array: get_ablock failed\ndevice-mapper: cache metadata: dm_array_cursor_next for mapping failed\n------------[ cut here ]------------\nkernel BUG at drivers/md/dm-bufio.c:638!\n\nFix by setting the cached block pointer to NULL on errors.\n\nIn addition to the reproducer described above, this fix can be\nverified using the \"array_cursor/damaged\" test in dm-unit:\n  dm-unit run /pdata/array_cursor/damaged --kernel-dir <KERNEL_DIR>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9c7c03d0e926762adf3a3a0ba86156fb5e19538b",
      "https://git.kernel.org/stable/c/fc1ef07c3522e257e32702954f265debbcb096a7",
      "https://git.kernel.org/stable/c/738994872d77e189b2d13c501a1d145e95d98f46",
      "https://git.kernel.org/stable/c/e477021d252c007f0c6d45b5d13d341efed03979",
      "https://git.kernel.org/stable/c/6002bec5354f86d1a2df21468f68e3ec03ede9da",
      "https://git.kernel.org/stable/c/017c4470bff53585370028fec9341247bad358ff",
      "https://git.kernel.org/stable/c/f2893c0804d86230ffb8f1c8703fdbb18648abc8"
    ],
    "受影响版本": [
      "fdd1315aa5f022fe6574efdc2d9535f75a0ee255",
      "fdd1315aa5f022fe6574efdc2d9535f75a0ee255",
      "fdd1315aa5f022fe6574efdc2d9535f75a0ee255",
      "fdd1315aa5f022fe6574efdc2d9535f75a0ee255",
      "fdd1315aa5f022fe6574efdc2d9535f75a0ee255",
      "fdd1315aa5f022fe6574efdc2d9535f75a0ee255",
      "fdd1315aa5f022fe6574efdc2d9535f75a0ee255"
    ],
    "公开日期": "2025年01月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57923",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: zlib: fix avail_in bytes for s390 zlib HW compression path\n\nSince the input data length passed to zlib_compress_folios() can be\narbitrary, always setting strm.avail_in to a multiple of PAGE_SIZE may\ncause read-in bytes to exceed the input range. Currently this triggers\nan assert in btrfs_compress_folios() on the debug kernel (see below).\nFix strm.avail_in calculation for S390 hardware acceleration path.\n\n  assertion failed: *total_in <= orig_len, in fs/btrfs/compression.c:1041\n  ------------[ cut here ]------------\n  kernel BUG at fs/btrfs/compression.c:1041!\n  monitor event: 0040 ilc:2 [#1] PREEMPT SMP\n  CPU: 16 UID: 0 PID: 325 Comm: kworker/u273:3 Not tainted 6.13.0-20241204.rc1.git6.fae3b21430ca.300.fc41.s390x+debug #1\n  Hardware name: IBM 3931 A01 703 (z/VM 7.4.0)\n  Workqueue: btrfs-delalloc btrfs_work_helper\n  Krnl PSW : 0704d00180000000 0000021761df6538 (btrfs_compress_folios+0x198/0x1a0)\n             R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:1 PM:0 RI:0 EA:3\n  Krnl GPRS: 0000000080000000 0000000000000001 0000000000000047 0000000000000000\n             0000000000000006 ffffff01757bb000 000001976232fcc0 000000000000130c\n             000001976232fcd0 000001976232fcc8 00000118ff4a0e30 0000000000000001\n             00000111821ab400 0000011100000000 0000021761df6534 000001976232fb58\n  Krnl Code: 0000021761df6528: c020006f5ef4        larl    %r2,0000021762be2310\n             0000021761df652e: c0e5ffbd09d5        brasl   %r14,00000217615978d8\n            #0000021761df6534: af000000            mc      0,0\n            >0000021761df6538: 0707                bcr     0,%r7\n             0000021761df653a: 0707                bcr     0,%r7\n             0000021761df653c: 0707                bcr     0,%r7\n             0000021761df653e: 0707                bcr     0,%r7\n             0000021761df6540: c004004bb7ec        brcl    0,000002176276d518\n  Call Trace:\n   [<0000021761df6538>] btrfs_compress_folios+0x198/0x1a0\n  ([<0000021761df6534>] btrfs_compress_folios+0x194/0x1a0)\n   [<0000021761d97788>] compress_file_range+0x3b8/0x6d0\n   [<0000021761dcee7c>] btrfs_work_helper+0x10c/0x160\n   [<0000021761645760>] process_one_work+0x2b0/0x5d0\n   [<000002176164637e>] worker_thread+0x20e/0x3e0\n   [<000002176165221a>] kthread+0x15a/0x170\n   [<00000217615b859c>] __ret_from_fork+0x3c/0x60\n   [<00000217626e72d2>] ret_from_fork+0xa/0x38\n  INFO: lockdep is turned off.\n  Last Breaking-Event-Address:\n   [<0000021761597924>] _printk+0x4c/0x58\n  Kernel panic - not syncing: Fatal exception: panic_on_oops",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/25adbb08aeadcff883ab801df99fd20fefbb6ca4",
      "https://git.kernel.org/stable/c/0ee4736c003daded513de0ff112d4a1e9c85bbab"
    ],
    "受影响版本": [
      "fd1e75d0105d2289e24b6d63cee49e6f7952c8bf",
      "fd1e75d0105d2289e24b6d63cee49e6f7952c8bf"
    ],
    "公开日期": "2025年01月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57902",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_packet: fix vlan_get_tci() vs MSG_PEEK\n\nBlamed commit forgot MSG_PEEK case, allowing a crash [1] as found\nby syzbot.\n\nRework vlan_get_tci() to not touch skb at all,\nso that it can be used from many cpus on the same skb.\n\nAdd a const qualifier to skb argument.\n\n[1]\nskbuff: skb_under_panic: text:ffffffff8a8da482 len:32 put:14 head:ffff88807a1d5800 data:ffff88807a1d5810 tail:0x14 end:0x140 dev:<NULL>\n------------[ cut here ]------------\n kernel BUG at net/core/skbuff.c:206 !\nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI\nCPU: 0 UID: 0 PID: 5880 Comm: syz-executor172 Not tainted 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\n RIP: 0010:skb_panic net/core/skbuff.c:206 [inline]\n RIP: 0010:skb_under_panic+0x14b/0x150 net/core/skbuff.c:216\nCode: 0b 8d 48 c7 c6 9e 6c 26 8e 48 8b 54 24 08 8b 0c 24 44 8b 44 24 04 4d 89 e9 50 41 54 41 57 41 56 e8 3a 5a 79 f7 48 83 c4 20 90 <0f> 0b 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3\nRSP: 0018:ffffc90003baf5b8 EFLAGS: 00010286\nRAX: 0000000000000087 RBX: dffffc0000000000 RCX: 8565c1eec37aa000\nRDX: 0000000000000000 RSI: 0000000080000000 RDI: 0000000000000000\nRBP: ffff88802616fb50 R08: ffffffff817f0a4c R09: 1ffff92000775e50\nR10: dffffc0000000000 R11: fffff52000775e51 R12: 0000000000000140\nR13: ffff88807a1d5800 R14: ffff88807a1d5810 R15: 0000000000000014\nFS:  00007fa03261f6c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffd65753000 CR3: 0000000031720000 CR4: 00000000003526f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n  skb_push+0xe5/0x100 net/core/skbuff.c:2636\n  vlan_get_tci+0x272/0x550 net/packet/af_packet.c:565\n  packet_recvmsg+0x13c9/0x1ef0 net/packet/af_packet.c:3616\n  sock_recvmsg_nosec net/socket.c:1044 [inline]\n  sock_recvmsg+0x22f/0x280 net/socket.c:1066\n  ____sys_recvmsg+0x1c6/0x480 net/socket.c:2814\n  ___sys_recvmsg net/socket.c:2856 [inline]\n  do_recvmmsg+0x426/0xab0 net/socket.c:2951\n  __sys_recvmmsg net/socket.c:3025 [inline]\n  __do_sys_recvmmsg net/socket.c:3048 [inline]\n  __se_sys_recvmmsg net/socket.c:3041 [inline]\n  __x64_sys_recvmmsg+0x199/0x250 net/socket.c:3041\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/66ffb0cf2125dcf9e902eede4a43653a24fd9cb2",
      "https://git.kernel.org/stable/c/fa57f07ba0622c8692f40e1300adca59277b0044",
      "https://git.kernel.org/stable/c/65c67049e9ed481f6b52264b39618b8c6dfb1d3e",
      "https://git.kernel.org/stable/c/d91b4a9baa018a001d5c884e236c0cfd31f9f4a1",
      "https://git.kernel.org/stable/c/7aa78d0d8546d8ce5a764add3f55d72e707c18f1",
      "https://git.kernel.org/stable/c/b65292a548d847099a4fe0fff53122a06e798e25",
      "https://git.kernel.org/stable/c/77ee7a6d16b6ec07b5c3ae2b6b60a24c1afbed09"
    ],
    "受影响版本": [
      "c77064e76c768fb101ea5ff92dc771142fc9d8fd",
      "83e2dfadcb6258fe3111c8a8ec9cf34465e55e64",
      "d0a1f9aa70f0d8a05b6320e8a3f3b83adab8dac3",
      "5839f59ff1dd4e35b9e767927931a039484839e1",
      "5a041d25b67042cbe06a0fb292ee22fd1147e65c",
      "79eecf631c14e7f4057186570ac20e2cfac3802e",
      "79eecf631c14e7f4057186570ac20e2cfac3802e",
      "3dfd84aa72fa7329ed4a257c8f40e0c9aff4dc8f",
      "66f23a7b5174b5d3e7111fd2d0d5a4f3faaa12e5"
    ],
    "公开日期": "2025年01月15日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57901",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_packet: fix vlan_get_protocol_dgram() vs MSG_PEEK\n\nBlamed commit forgot MSG_PEEK case, allowing a crash [1] as found\nby syzbot.\n\nRework vlan_get_protocol_dgram() to not touch skb at all,\nso that it can be used from many cpus on the same skb.\n\nAdd a const qualifier to skb argument.\n\n[1]\nskbuff: skb_under_panic: text:ffffffff8a8ccd05 len:29 put:14 head:ffff88807fc8e400 data:ffff88807fc8e3f4 tail:0x11 end:0x140 dev:<NULL>\n------------[ cut here ]------------\n kernel BUG at net/core/skbuff.c:206 !\nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI\nCPU: 1 UID: 0 PID: 5892 Comm: syz-executor883 Not tainted 6.13.0-rc4-syzkaller-00054-gd6ef8b40d075 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\n RIP: 0010:skb_panic net/core/skbuff.c:206 [inline]\n RIP: 0010:skb_under_panic+0x14b/0x150 net/core/skbuff.c:216\nCode: 0b 8d 48 c7 c6 86 d5 25 8e 48 8b 54 24 08 8b 0c 24 44 8b 44 24 04 4d 89 e9 50 41 54 41 57 41 56 e8 5a 69 79 f7 48 83 c4 20 90 <0f> 0b 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3\nRSP: 0018:ffffc900038d7638 EFLAGS: 00010282\nRAX: 0000000000000087 RBX: dffffc0000000000 RCX: 609ffd18ea660600\nRDX: 0000000000000000 RSI: 0000000080000000 RDI: 0000000000000000\nRBP: ffff88802483c8d0 R08: ffffffff817f0a8c R09: 1ffff9200071ae60\nR10: dffffc0000000000 R11: fffff5200071ae61 R12: 0000000000000140\nR13: ffff88807fc8e400 R14: ffff88807fc8e3f4 R15: 0000000000000011\nFS:  00007fbac5e006c0(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fbac5e00d58 CR3: 000000001238e000 CR4: 00000000003526f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n  skb_push+0xe5/0x100 net/core/skbuff.c:2636\n  vlan_get_protocol_dgram+0x165/0x290 net/packet/af_packet.c:585\n  packet_recvmsg+0x948/0x1ef0 net/packet/af_packet.c:3552\n  sock_recvmsg_nosec net/socket.c:1033 [inline]\n  sock_recvmsg+0x22f/0x280 net/socket.c:1055\n  ____sys_recvmsg+0x1c6/0x480 net/socket.c:2803\n  ___sys_recvmsg net/socket.c:2845 [inline]\n  do_recvmmsg+0x426/0xab0 net/socket.c:2940\n  __sys_recvmmsg net/socket.c:3014 [inline]\n  __do_sys_recvmmsg net/socket.c:3037 [inline]\n  __se_sys_recvmmsg net/socket.c:3030 [inline]\n  __x64_sys_recvmmsg+0x199/0x250 net/socket.c:3030\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/560cbdd26b510626f3f4f27d34c44dfd3dd3499d",
      "https://git.kernel.org/stable/c/0d3fa6c3c9ca7aa255696150f5b759ac4a4974e1",
      "https://git.kernel.org/stable/c/de4f8d477c67ec1d7c28f3486c3e47d147d90a01",
      "https://git.kernel.org/stable/c/5d336714db324bef84490c75dcc48b387ef0346e",
      "https://git.kernel.org/stable/c/a693b87692b4d7c50f4fc08a996678d60534a9da",
      "https://git.kernel.org/stable/c/cd8488fdc7116f6da277515647b167859d4f72b1",
      "https://git.kernel.org/stable/c/f91a5b8089389eb408501af2762f168c3aaa7b79"
    ],
    "受影响版本": [
      "c77064e76c768fb101ea5ff92dc771142fc9d8fd",
      "83e2dfadcb6258fe3111c8a8ec9cf34465e55e64",
      "d0a1f9aa70f0d8a05b6320e8a3f3b83adab8dac3",
      "5839f59ff1dd4e35b9e767927931a039484839e1",
      "5a041d25b67042cbe06a0fb292ee22fd1147e65c",
      "79eecf631c14e7f4057186570ac20e2cfac3802e",
      "79eecf631c14e7f4057186570ac20e2cfac3802e",
      "3dfd84aa72fa7329ed4a257c8f40e0c9aff4dc8f",
      "66f23a7b5174b5d3e7111fd2d0d5a4f3faaa12e5"
    ],
    "公开日期": "2025年01月15日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57895",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: set ATTR_CTIME flags when setting mtime\n\nDavid reported that the new warning from setattr_copy_mgtime is coming\nlike the following.\n\n[  113.215316] ------------[ cut here ]------------\n[  113.215974] WARNING: CPU: 1 PID: 31 at fs/attr.c:300 setattr_copy+0x1ee/0x200\n[  113.219192] CPU: 1 UID: 0 PID: 31 Comm: kworker/1:1 Not tainted 6.13.0-rc1+ #234\n[  113.220127] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014\n[  113.221530] Workqueue: ksmbd-io handle_ksmbd_work [ksmbd]\n[  113.222220] RIP: 0010:setattr_copy+0x1ee/0x200\n[  113.222833] Code: 24 28 49 8b 44 24 30 48 89 53 58 89 43 6c 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc 48 89 df e8 77 d6 ff ff e9 cd fe ff ff <0f> 0b e9 be fe ff ff 66 0\n[  113.225110] RSP: 0018:ffffaf218010fb68 EFLAGS: 00010202\n[  113.225765] RAX: 0000000000000120 RBX: ffffa446815f8568 RCX: 0000000000000003\n[  113.226667] RDX: ffffaf218010fd38 RSI: ffffa446815f8568 RDI: ffffffff94eb03a0\n[  113.227531] RBP: ffffaf218010fb90 R08: 0000001a251e217d R09: 00000000675259fa\n[  113.228426] R10: 0000000002ba8a6d R11: ffffa4468196c7a8 R12: ffffaf218010fd38\n[  113.229304] R13: 0000000000000120 R14: ffffffff94eb03a0 R15: 0000000000000000\n[  113.230210] FS:  0000000000000000(0000) GS:ffffa44739d00000(0000) knlGS:0000000000000000\n[  113.231215] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  113.232055] CR2: 00007efe0053d27e CR3: 000000000331a000 CR4: 00000000000006b0\n[  113.232926] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  113.233812] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  113.234797] Call Trace:\n[  113.235116]  <TASK>\n[  113.235393]  ? __warn+0x73/0xd0\n[  113.235802]  ? setattr_copy+0x1ee/0x200\n[  113.236299]  ? report_bug+0xf3/0x1e0\n[  113.236757]  ? handle_bug+0x4d/0x90\n[  113.237202]  ? exc_invalid_op+0x13/0x60\n[  113.237689]  ? asm_exc_invalid_op+0x16/0x20\n[  113.238185]  ? setattr_copy+0x1ee/0x200\n[  113.238692]  btrfs_setattr+0x80/0x820 [btrfs]\n[  113.239285]  ? get_stack_info_noinstr+0x12/0xf0\n[  113.239857]  ? __module_address+0x22/0xa0\n[  113.240368]  ? handle_ksmbd_work+0x6e/0x460 [ksmbd]\n[  113.240993]  ? __module_text_address+0x9/0x50\n[  113.241545]  ? __module_address+0x22/0xa0\n[  113.242033]  ? unwind_next_frame+0x10e/0x920\n[  113.242600]  ? __pfx_stack_trace_consume_entry+0x10/0x10\n[  113.243268]  notify_change+0x2c2/0x4e0\n[  113.243746]  ? stack_depot_save_flags+0x27/0x730\n[  113.244339]  ? set_file_basic_info+0x130/0x2b0 [ksmbd]\n[  113.244993]  set_file_basic_info+0x130/0x2b0 [ksmbd]\n[  113.245613]  ? process_scheduled_works+0xbe/0x310\n[  113.246181]  ? worker_thread+0x100/0x240\n[  113.246696]  ? kthread+0xc8/0x100\n[  113.247126]  ? ret_from_fork+0x2b/0x40\n[  113.247606]  ? ret_from_fork_asm+0x1a/0x30\n[  113.248132]  smb2_set_info+0x63f/0xa70 [ksmbd]\n\nksmbd is trying to set the atime and mtime via notify_change without also\nsetting the ctime. so This patch add ATTR_CTIME flags when setting mtime\nto avoid a warning.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1d7ee876b8b96efc14e177a7fe8d45ac25d68849",
      "https://git.kernel.org/stable/c/52cefcff6a4a814f4f8e357422fcfb71fd2ebf75",
      "https://git.kernel.org/stable/c/21e46a79bbe6c4e1aa73b3ed998130f2ff07b128"
    ],
    "受影响版本": [
      "0626e6641f6b467447c81dd7678a69c66f7746cf",
      "0626e6641f6b467447c81dd7678a69c66f7746cf",
      "0626e6641f6b467447c81dd7678a69c66f7746cf"
    ],
    "公开日期": "2025年01月15日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57843",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-net: fix overflow inside virtnet_rq_alloc\n\nWhen the frag just got a page, then may lead to regression on VM.\nSpecially if the sysctl net.core.high_order_alloc_disable value is 1,\nthen the frag always get a page when do refill.\n\nWhich could see reliable crashes or scp failure (scp a file 100M in size\nto VM).\n\nThe issue is that the virtnet_rq_dma takes up 16 bytes at the beginning\nof a new frag. When the frag size is larger than PAGE_SIZE,\neverything is fine. However, if the frag is only one page and the\ntotal size of the buffer and virtnet_rq_dma is larger than one page, an\noverflow may occur.\n\nThe commit f9dac92ba908 (\"virtio_ring: enable premapped mode whatever\nuse_dma_api\") introduced this problem. And we reverted some commits to\nfix this in last linux version. Now we try to enable it and fix this\nbug directly.\n\nHere, when the frag size is not enough, we reduce the buffer len to fix\nthis problem.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a8f7d6963768b114ec9644ff0148dde4c104e84b",
      "https://git.kernel.org/stable/c/67a11de8965c2ab19e215fb6651d44847e068614",
      "https://git.kernel.org/stable/c/6aacd1484468361d1d04badfe75f264fa5314864"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年01月11日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57841",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fix memory leak in tcp_conn_request()\n\nIf inet_csk_reqsk_queue_hash_add() return false, tcp_conn_request() will\nreturn without free the dst memory, which allocated in af_ops->route_req.\n\nHere is the kmemleak stack:\n\nunreferenced object 0xffff8881198631c0 (size 240):\n  comm \"softirq\", pid 0, jiffies 4299266571 (age 1802.392s)\n  hex dump (first 32 bytes):\n    00 10 9b 03 81 88 ff ff 80 98 da bc ff ff ff ff  ................\n    81 55 18 bb ff ff ff ff 00 00 00 00 00 00 00 00  .U..............\n  backtrace:\n    [<ffffffffb93e8d4c>] kmem_cache_alloc+0x60c/0xa80\n    [<ffffffffba11b4c5>] dst_alloc+0x55/0x250\n    [<ffffffffba227bf6>] rt_dst_alloc+0x46/0x1d0\n    [<ffffffffba23050a>] __mkroute_output+0x29a/0xa50\n    [<ffffffffba23456b>] ip_route_output_key_hash+0x10b/0x240\n    [<ffffffffba2346bd>] ip_route_output_flow+0x1d/0x90\n    [<ffffffffba254855>] inet_csk_route_req+0x2c5/0x500\n    [<ffffffffba26b331>] tcp_conn_request+0x691/0x12c0\n    [<ffffffffba27bd08>] tcp_rcv_state_process+0x3c8/0x11b0\n    [<ffffffffba2965c6>] tcp_v4_do_rcv+0x156/0x3b0\n    [<ffffffffba299c98>] tcp_v4_rcv+0x1cf8/0x1d80\n    [<ffffffffba239656>] ip_protocol_deliver_rcu+0xf6/0x360\n    [<ffffffffba2399a6>] ip_local_deliver_finish+0xe6/0x1e0\n    [<ffffffffba239b8e>] ip_local_deliver+0xee/0x360\n    [<ffffffffba239ead>] ip_rcv+0xad/0x2f0\n    [<ffffffffba110943>] __netif_receive_skb_one_core+0x123/0x140\n\nCall dst_release() to free the dst memory when\ninet_csk_reqsk_queue_hash_add() return false in tcp_conn_request().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9d38959677291552d1b0ed2689a540af279b5bf8",
      "https://git.kernel.org/stable/c/de3f999bf8aee16e9da1c1224191abdc69e97c9d",
      "https://git.kernel.org/stable/c/2af69905180b3fea12f9c1db374b153a06977021",
      "https://git.kernel.org/stable/c/b0b190218c78d8aeecfba36ea3a90063b3ede52d",
      "https://git.kernel.org/stable/c/4f4aa4aa28142d53f8b06585c478476cfe325cfc"
    ],
    "受影响版本": [
      "527bec1f56ac7a2fceb8eb77eb0fc2678ecba394",
      "c14f3c3793f7a785763e353df7fc40426187f832",
      "fdae4d139f4778b20a40c60705c53f5f146459b5",
      "ff46e3b4421923937b7f6e44ffcd3549a074f321",
      "ff46e3b4421923937b7f6e44ffcd3549a074f321",
      "360892e60710427229fc1f7bb2218cf4d578229b"
    ],
    "公开日期": "2025年01月15日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57809",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: imx6: Fix suspend/resume support on i.MX6QDL\n\nThe suspend/resume functionality is currently broken on the i.MX6QDL\nplatform, as documented in the NXP errata (ERR005723):\n\n  https://www.nxp.com/docs/en/errata/IMX6DQCE.pdf\n\nThis patch addresses the issue by sharing most of the suspend/resume\nsequences used by other i.MX devices, while avoiding modifications to\ncritical registers that disrupt the PCIe functionality. It targets the\nsame problem as the following downstream commit:\n\n  https://github.com/nxp-imx/linux-imx/commit/4e92355e1f79d225ea842511fcfd42b343b32995\n\nUnlike the downstream commit, this patch also resets the connected PCIe\ndevice if possible. Without this reset, certain drivers, such as ath10k\nor iwlwifi, will crash on resume. The device reset is also done by the\ndriver on other i.MX platforms, making this patch consistent with\nexisting practices.\n\nUpon resuming, the kernel will hang and display an error. Here's an\nexample of the error encountered with the ath10k driver:\n\n  ath10k_pci 0000:01:00.0: Unable to change power state from D3hot to D0, device inaccessible\n  Unhandled fault: imprecise external abort (0x1406) at 0x0106f944\n\nWithout this patch, suspend/resume will fail on i.MX6QDL devices if a\nPCIe device is connected.\n\n[kwilczynski: commit log, added tag for stable releases]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ac43ea3d27a8f9beadf3af66c9ea4a566ebfff1f",
      "https://git.kernel.org/stable/c/0a726f542d7c8cc0f9c5ed7df5a4bd4b59ac21b3"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年01月11日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-57806",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix transaction atomicity bug when enabling simple quotas\n\nSet squota incompat bit before committing the transaction that enables\nthe feature.\n\nWith the config CONFIG_BTRFS_ASSERT enabled, an assertion\nfailure occurs regarding the simple quota feature.\n\n  [5.596534] assertion failed: btrfs_fs_incompat(fs_info, SIMPLE_QUOTA), in fs/btrfs/qgroup.c:365\n  [5.597098] ------------[ cut here ]------------\n  [5.597371] kernel BUG at fs/btrfs/qgroup.c:365!\n  [5.597946] CPU: 1 UID: 0 PID: 268 Comm: mount Not tainted 6.13.0-rc2-00031-gf92f4749861b #146\n  [5.598450] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\n  [5.599008] RIP: 0010:btrfs_read_qgroup_config+0x74d/0x7a0\n  [5.604303]  <TASK>\n  [5.605230]  ? btrfs_read_qgroup_config+0x74d/0x7a0\n  [5.605538]  ? exc_invalid_op+0x56/0x70\n  [5.605775]  ? btrfs_read_qgroup_config+0x74d/0x7a0\n  [5.606066]  ? asm_exc_invalid_op+0x1f/0x30\n  [5.606441]  ? btrfs_read_qgroup_config+0x74d/0x7a0\n  [5.606741]  ? btrfs_read_qgroup_config+0x74d/0x7a0\n  [5.607038]  ? try_to_wake_up+0x317/0x760\n  [5.607286]  open_ctree+0xd9c/0x1710\n  [5.607509]  btrfs_get_tree+0x58a/0x7e0\n  [5.608002]  vfs_get_tree+0x2e/0x100\n  [5.608224]  fc_mount+0x16/0x60\n  [5.608420]  btrfs_get_tree+0x2f8/0x7e0\n  [5.608897]  vfs_get_tree+0x2e/0x100\n  [5.609121]  path_mount+0x4c8/0xbc0\n  [5.609538]  __x64_sys_mount+0x10d/0x150\n\nThe issue can be easily reproduced using the following reproducer:\n\n  root@q:linux# cat repro.sh\n  set -e\n\n  mkfs.btrfs -q -f /dev/sdb\n  mount /dev/sdb /mnt/btrfs\n  btrfs quota enable -s /mnt/btrfs\n  umount /mnt/btrfs\n  mount /dev/sdb /mnt/btrfs\n\nThe issue is that when enabling quotas, at btrfs_quota_enable(), we set\nBTRFS_QGROUP_STATUS_FLAG_SIMPLE_MODE at fs_info->qgroup_flags and persist\nit in the quota root in the item with the key BTRFS_QGROUP_STATUS_KEY, but\nwe only set the incompat bit BTRFS_FEATURE_INCOMPAT_SIMPLE_QUOTA after we\ncommit the transaction used to enable simple quotas.\n\nThis means that if after that transaction commit we unmount the filesystem\nwithout starting and committing any other transaction, or we have a power\nfailure, the next time we mount the filesystem we will find the flag\nBTRFS_QGROUP_STATUS_FLAG_SIMPLE_MODE set in the item with the key\nBTRFS_QGROUP_STATUS_KEY but we will not find the incompat bit\nBTRFS_FEATURE_INCOMPAT_SIMPLE_QUOTA set in the superblock, triggering an\nassertion failure at:\n\n  btrfs_read_qgroup_config() -> qgroup_read_enable_gen()\n\nTo fix this issue, set the BTRFS_FEATURE_INCOMPAT_SIMPLE_QUOTA flag\nimmediately after setting the BTRFS_QGROUP_STATUS_FLAG_SIMPLE_MODE.\nThis ensures that both flags are flushed to disk within the same\ntransaction.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b87c9b9ba05ba6e8e2ee9ecd29a8c930b35648ed",
      "https://git.kernel.org/stable/c/f2363e6fcc7938c5f0f6ac066fad0dd247598b51"
    ],
    "受影响版本": [
      "182940f4f4dbd932776414744c8de64333957725",
      "182940f4f4dbd932776414744c8de64333957725"
    ],
    "公开日期": "2025年01月11日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56787",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoc: imx8m: Probe the SoC driver as platform driver\n\nWith driver_async_probe=* on kernel command line, the following trace is\nproduced because on i.MX8M Plus hardware because the soc-imx8m.c driver\ncalls of_clk_get_by_name() which returns -EPROBE_DEFER because the clock\ndriver is not yet probed. This was not detected during regular testing\nwithout driver_async_probe.\n\nConvert the SoC code to platform driver and instantiate a platform device\nin its current device_initcall() to probe the platform driver. Rework\n.soc_revision callback to always return valid error code and return SoC\nrevision via parameter. This way, if anything in the .soc_revision callback\nreturn -EPROBE_DEFER, it gets propagated to .probe and the .probe will get\nretried later.\n\n\"\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 1 at drivers/soc/imx/soc-imx8m.c:115 imx8mm_soc_revision+0xdc/0x180\nCPU: 1 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.11.0-next-20240924-00002-g2062bb554dea #603\nHardware name: DH electronics i.MX8M Plus DHCOM Premium Developer Kit (3) (DT)\npstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : imx8mm_soc_revision+0xdc/0x180\nlr : imx8mm_soc_revision+0xd0/0x180\nsp : ffff8000821fbcc0\nx29: ffff8000821fbce0 x28: 0000000000000000 x27: ffff800081810120\nx26: ffff8000818a9970 x25: 0000000000000006 x24: 0000000000824311\nx23: ffff8000817f42c8 x22: ffff0000df8be210 x21: fffffffffffffdfb\nx20: ffff800082780000 x19: 0000000000000001 x18: ffffffffffffffff\nx17: ffff800081fff418 x16: ffff8000823e1000 x15: ffff0000c03b65e8\nx14: ffff0000c00051b0 x13: ffff800082790000 x12: 0000000000000801\nx11: ffff80008278ffff x10: ffff80008209d3a6 x9 : ffff80008062e95c\nx8 : ffff8000821fb9a0 x7 : 0000000000000000 x6 : 00000000000080e3\nx5 : ffff0000df8c03d8 x4 : 0000000000000000 x3 : 0000000000000000\nx2 : 0000000000000000 x1 : fffffffffffffdfb x0 : fffffffffffffdfb\nCall trace:\n imx8mm_soc_revision+0xdc/0x180\n imx8_soc_init+0xb0/0x1e0\n do_one_initcall+0x94/0x1a8\n kernel_init_freeable+0x240/0x2a8\n kernel_init+0x28/0x140\n ret_from_fork+0x10/0x20\n---[ end trace 0000000000000000 ]---\nSoC: i.MX8MP revision 1.1\n\"",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e497edb8f31ec2c2b6f4ce930e175aa2da8be334",
      "https://git.kernel.org/stable/c/ea2ff66feb5f9b183f9e2f9d06c21340bd88de12",
      "https://git.kernel.org/stable/c/2129f6faa5dfe8c6b87aad11720bf75edd77d3e4",
      "https://git.kernel.org/stable/c/997a3c04d7fa3d1d385c14691350d096fada648c",
      "https://git.kernel.org/stable/c/9cc832d37799dbea950c4c8a34721b02b8b5a8ff"
    ],
    "受影响版本": [
      "a7e26f356ca12906a164d83c9e9f8527ee7da022",
      "a7e26f356ca12906a164d83c9e9f8527ee7da022",
      "a7e26f356ca12906a164d83c9e9f8527ee7da022",
      "a7e26f356ca12906a164d83c9e9f8527ee7da022",
      "a7e26f356ca12906a164d83c9e9f8527ee7da022"
    ],
    "公开日期": "2025年01月08日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56758",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: check folio mapping after unlock in relocate_one_folio()\n\nWhen we call btrfs_read_folio() to bring a folio uptodate, we unlock the\nfolio. The result of that is that a different thread can modify the\nmapping (like remove it with invalidate) before we call folio_lock().\nThis results in an invalid page and we need to try again.\n\nIn particular, if we are relocating concurrently with aborting a\ntransaction, this can result in a crash like the following:\n\n  BUG: kernel NULL pointer dereference, address: 0000000000000000\n  PGD 0 P4D 0\n  Oops: 0000 [#1] SMP\n  CPU: 76 PID: 1411631 Comm: kworker/u322:5\n  Workqueue: events_unbound btrfs_reclaim_bgs_work\n  RIP: 0010:set_page_extent_mapped+0x20/0xb0\n  RSP: 0018:ffffc900516a7be8 EFLAGS: 00010246\n  RAX: ffffea009e851d08 RBX: ffffea009e0b1880 RCX: 0000000000000000\n  RDX: 0000000000000000 RSI: ffffc900516a7b90 RDI: ffffea009e0b1880\n  RBP: 0000000003573000 R08: 0000000000000001 R09: ffff88c07fd2f3f0\n  R10: 0000000000000000 R11: 0000194754b575be R12: 0000000003572000\n  R13: 0000000003572fff R14: 0000000000100cca R15: 0000000005582fff\n  FS:  0000000000000000(0000) GS:ffff88c07fd00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000000 CR3: 000000407d00f002 CR4: 00000000007706f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  PKRU: 55555554\n  Call Trace:\n  <TASK>\n  ? __die+0x78/0xc0\n  ? page_fault_oops+0x2a8/0x3a0\n  ? __switch_to+0x133/0x530\n  ? wq_worker_running+0xa/0x40\n  ? exc_page_fault+0x63/0x130\n  ? asm_exc_page_fault+0x22/0x30\n  ? set_page_extent_mapped+0x20/0xb0\n  relocate_file_extent_cluster+0x1a7/0x940\n  relocate_data_extent+0xaf/0x120\n  relocate_block_group+0x20f/0x480\n  btrfs_relocate_block_group+0x152/0x320\n  btrfs_relocate_chunk+0x3d/0x120\n  btrfs_reclaim_bgs_work+0x2ae/0x4e0\n  process_scheduled_works+0x184/0x370\n  worker_thread+0xc6/0x3e0\n  ? blk_add_timer+0xb0/0xb0\n  kthread+0xae/0xe0\n  ? flush_tlb_kernel_range+0x90/0x90\n  ret_from_fork+0x2f/0x40\n  ? flush_tlb_kernel_range+0x90/0x90\n  ret_from_fork_asm+0x11/0x20\n  </TASK>\n\nThis occurs because cleanup_one_transaction() calls\ndestroy_delalloc_inodes() which calls invalidate_inode_pages2() which\ntakes the folio_lock before setting mapping to NULL. We fail to check\nthis, and subsequently call set_extent_mapping(), which assumes that\nmapping != NULL (in fact it asserts that in debug mode)\n\nNote that the \"fixes\" patch here is not the one that introduced the\nrace (the very first iteration of this code from 2009) but a more recent\nchange that made this particular crash happen in practice.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/36679fab54fa7bcffafd469e2c474c1fc4beaee0",
      "https://git.kernel.org/stable/c/c7b1bd52a031ad0144d42eef0ba8471ce75122dd",
      "https://git.kernel.org/stable/c/d508e56270389b3a16f5b3cf247f4eb1bbad1578",
      "https://git.kernel.org/stable/c/3e74859ee35edc33a022c3f3971df066ea0ca6b9"
    ],
    "受影响版本": [
      "08daa38ca212d87f77beae839bc9be71079c7abf",
      "e7f1326cc24e22b38afc3acd328480a1183f9e79",
      "e7f1326cc24e22b38afc3acd328480a1183f9e79",
      "e7f1326cc24e22b38afc3acd328480a1183f9e79",
      "9d1e020ed9649cf140fcfafd052cfdcce9e9d67d"
    ],
    "公开日期": "2025年01月06日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56718",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: protect link down work from execute after lgr freed\n\nlink down work may be scheduled before lgr freed but execute\nafter lgr freed, which may result in crash. So it is need to\nhold a reference before shedule link down work, and put the\nreference after work executed or canceled.\n\nThe relevant crash call stack as follows:\n list_del corruption. prev->next should be ffffb638c9c0fe20,\n    but was 0000000000000000\n ------------[ cut here ]------------\n kernel BUG at lib/list_debug.c:51!\n invalid opcode: 0000 [#1] SMP NOPTI\n CPU: 6 PID: 978112 Comm: kworker/6:119 Kdump: loaded Tainted: G #1\n Hardware name: Alibaba Cloud Alibaba Cloud ECS, BIOS 2221b89 04/01/2014\n Workqueue: events smc_link_down_work [smc]\n RIP: 0010:__list_del_entry_valid.cold+0x31/0x47\n RSP: 0018:ffffb638c9c0fdd8 EFLAGS: 00010086\n RAX: 0000000000000054 RBX: ffff942fb75e5128 RCX: 0000000000000000\n RDX: ffff943520930aa0 RSI: ffff94352091fc80 RDI: ffff94352091fc80\n RBP: 0000000000000000 R08: 0000000000000000 R09: ffffb638c9c0fc38\n R10: ffffb638c9c0fc30 R11: ffffffffa015eb28 R12: 0000000000000002\n R13: ffffb638c9c0fe20 R14: 0000000000000001 R15: ffff942f9cd051c0\n FS:  0000000000000000(0000) GS:ffff943520900000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007f4f25214000 CR3: 000000025fbae004 CR4: 00000000007706e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n PKRU: 55555554\n Call Trace:\n  rwsem_down_write_slowpath+0x17e/0x470\n  smc_link_down_work+0x3c/0x60 [smc]\n  process_one_work+0x1ac/0x350\n  worker_thread+0x49/0x2f0\n  ? rescuer_thread+0x360/0x360\n  kthread+0x118/0x140\n  ? __kthread_bind_mask+0x60/0x60\n  ret_from_fork+0x1f/0x30",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/bec2f52866d511e94c1c37cd962e4382b1b1a299",
      "https://git.kernel.org/stable/c/2627c3e8646932dfc7b9722c88c2e1ffcf7a9fb2",
      "https://git.kernel.org/stable/c/841b1824750d3b8d1dc0a96b14db4418b952abbc",
      "https://git.kernel.org/stable/c/2b33eb8f1b3e8c2f87cfdbc8cc117f6bdfabc6ec"
    ],
    "受影响版本": [
      "541afa10c126b6c22c2a805a559c70cc41fd156e",
      "541afa10c126b6c22c2a805a559c70cc41fd156e",
      "541afa10c126b6c22c2a805a559c70cc41fd156e",
      "541afa10c126b6c22c2a805a559c70cc41fd156e"
    ],
    "公开日期": "2024年12月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56717",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: mscc: ocelot: fix incorrect IFH SRC_PORT field in ocelot_ifh_set_basic()\n\nPackets injected by the CPU should have a SRC_PORT field equal to the\nCPU port module index in the Analyzer block (ocelot->num_phys_ports).\n\nThe blamed commit copied the ocelot_ifh_set_basic() call incorrectly\nfrom ocelot_xmit_common() in net/dsa/tag_ocelot.c. Instead of calling\nwith \"x\", it calls with BIT_ULL(x), but the field is not a port mask,\nbut rather a single port index.\n\n[ side note: this is the technical debt of code duplication :( ]\n\nThe error used to be silent and doesn't appear to have other\nuser-visible manifestations, but with new changes in the packing\nlibrary, it now fails loudly as follows:\n\n------------[ cut here ]------------\nCannot store 0x40 inside bits 46-43 - will truncate\nsja1105 spi2.0: xmit timed out\nWARNING: CPU: 1 PID: 102 at lib/packing.c:98 __pack+0x90/0x198\nsja1105 spi2.0: timed out polling for tstamp\nCPU: 1 UID: 0 PID: 102 Comm: felix_xmit\nTainted: G        W        N 6.13.0-rc1-00372-gf706b85d972d-dirty #2605\nCall trace:\n __pack+0x90/0x198 (P)\n __pack+0x90/0x198 (L)\n packing+0x78/0x98\n ocelot_ifh_set_basic+0x260/0x368\n ocelot_port_inject_frame+0xa8/0x250\n felix_port_deferred_xmit+0x14c/0x258\n kthread_worker_fn+0x134/0x350\n kthread+0x114/0x138\n\nThe code path pertains to the ocelot switchdev driver and to the felix\nsecondary DSA tag protocol, ocelot-8021q. Here seen with ocelot-8021q.\n\nThe messenger (packing) is not really to blame, so fix the original\ncommit instead.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/59c4ca8d8d7918eb6e2df91d2c254827264be309",
      "https://git.kernel.org/stable/c/2f3c62ffe88116cd2a39cd73e01103535599970f",
      "https://git.kernel.org/stable/c/a8836eae3288c351acd3b2743d2fad2a4ee2bd56",
      "https://git.kernel.org/stable/c/2d5df3a680ffdaf606baa10636bdb1daf757832e"
    ],
    "受影响版本": [
      "06bcb9032e05ad717f9fd0a6e2fd3ae7f430fa31",
      "ff7f554bbd75d5cbf00cded81d05147c6617e876",
      "e1b9e80236c540fa85d76e2d510d1b38e1968c5d",
      "e1b9e80236c540fa85d76e2d510d1b38e1968c5d",
      "be3a532167dd562ec38900c846e7ae6cc39aa2f1"
    ],
    "公开日期": "2024年12月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56692",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to do sanity check on node blkaddr in truncate_node()\n\nsyzbot reports a f2fs bug as below:\n\n------------[ cut here ]------------\nkernel BUG at fs/f2fs/segment.c:2534!\nRIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534\nCall Trace:\n truncate_node+0x1ae/0x8c0 fs/f2fs/node.c:909\n f2fs_remove_inode_page+0x5c2/0x870 fs/f2fs/node.c:1288\n f2fs_evict_inode+0x879/0x15c0 fs/f2fs/inode.c:856\n evict+0x4e8/0x9b0 fs/inode.c:723\n f2fs_handle_failed_inode+0x271/0x2e0 fs/f2fs/inode.c:986\n f2fs_create+0x357/0x530 fs/f2fs/namei.c:394\n lookup_open fs/namei.c:3595 [inline]\n open_last_lookups fs/namei.c:3694 [inline]\n path_openat+0x1c03/0x3590 fs/namei.c:3930\n do_filp_open+0x235/0x490 fs/namei.c:3960\n do_sys_openat2+0x13e/0x1d0 fs/open.c:1415\n do_sys_open fs/open.c:1430 [inline]\n __do_sys_openat fs/open.c:1446 [inline]\n __se_sys_openat fs/open.c:1441 [inline]\n __x64_sys_openat+0x247/0x2a0 fs/open.c:1441\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534\n\nThe root cause is: on a fuzzed image, blkaddr in nat entry may be\ncorrupted, then it will cause system panic when using it in\nf2fs_invalidate_blocks(), to avoid this, let's add sanity check on\nnat blkaddr in truncate_node().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/27d6e7eff07f8cce8e83b162d8f21a07458c860d",
      "https://git.kernel.org/stable/c/c1077078ce4589b5e5387f6b0aaa0d4534b9eb57",
      "https://git.kernel.org/stable/c/0a5c8b3fbf6200f1c66062d307c9a52084917788",
      "https://git.kernel.org/stable/c/6babe00ccd34fc65b78ef8b99754e32b4385f23d"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年12月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56677",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/fadump: Move fadump_cma_init to setup_arch() after initmem_init()\n\nDuring early init CMA_MIN_ALIGNMENT_BYTES can be PAGE_SIZE,\nsince pageblock_order is still zero and it gets initialized\nlater during initmem_init() e.g.\nsetup_arch() -> initmem_init() -> sparse_init() -> set_pageblock_order()\n\nOne such use case where this causes issue is -\nearly_setup() -> early_init_devtree() -> fadump_reserve_mem() -> fadump_cma_init()\n\nThis causes CMA memory alignment check to be bypassed in\ncma_init_reserved_mem(). Then later cma_activate_area() can hit\na VM_BUG_ON_PAGE(pfn & ((1 << order) - 1)) if the reserved memory\narea was not pageblock_order aligned.\n\nFix it by moving the fadump_cma_init() after initmem_init(),\nwhere other such cma reservations also gets called.\n\n<stack trace>\n==============\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10010\nflags: 0x13ffff800000000(node=1|zone=0|lastcpupid=0x7ffff) CMA\nraw: 013ffff800000000 5deadbeef0000100 5deadbeef0000122 0000000000000000\nraw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000\npage dumped because: VM_BUG_ON_PAGE(pfn & ((1 << order) - 1))\n------------[ cut here ]------------\nkernel BUG at mm/page_alloc.c:778!\n\nCall Trace:\n__free_one_page+0x57c/0x7b0 (unreliable)\nfree_pcppages_bulk+0x1a8/0x2c8\nfree_unref_page_commit+0x3d4/0x4e4\nfree_unref_page+0x458/0x6d0\ninit_cma_reserved_pageblock+0x114/0x198\ncma_init_reserved_areas+0x270/0x3e0\ndo_one_initcall+0x80/0x2f8\nkernel_init_freeable+0x33c/0x530\nkernel_init+0x34/0x26c\nret_from_kernel_user_thread+0x14/0x1c",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/aabef6301dcf410dfd2b8759cd413b2a003c7e3f",
      "https://git.kernel.org/stable/c/c5c1d1ef70834013fc3bd12b6a0f4664c6d75a74",
      "https://git.kernel.org/stable/c/f551637fe9bf863386309e03f9d148d97f535ad1",
      "https://git.kernel.org/stable/c/7351c5a6507b4401aeecadb5959131410a339520",
      "https://git.kernel.org/stable/c/05b94cae1c47f94588c3e7096963c1007c4d9c1d"
    ],
    "受影响版本": [
      "11ac3e87ce09c27f4587a8c4fe0829d814021a82",
      "11ac3e87ce09c27f4587a8c4fe0829d814021a82",
      "11ac3e87ce09c27f4587a8c4fe0829d814021a82",
      "11ac3e87ce09c27f4587a8c4fe0829d814021a82",
      "11ac3e87ce09c27f4587a8c4fe0829d814021a82"
    ],
    "公开日期": "2024年12月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56674",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio_net: correct netdev_tx_reset_queue() invocation point\n\nWhen virtnet_close is followed by virtnet_open, some TX completions can\npossibly remain unconsumed, until they are finally processed during the\nfirst NAPI poll after the netdev_tx_reset_queue(), resulting in a crash\n[1]. Commit b96ed2c97c79 (\"virtio_net: move netdev_tx_reset_queue() call\nbefore RX napi enable\") was not sufficient to eliminate all BQL crash\ncases for virtio-net.\n\nThis issue can be reproduced with the latest net-next master by running:\n`while :; do ip l set DEV down; ip l set DEV up; done` under heavy network\nTX load from inside the machine.\n\nnetdev_tx_reset_queue() can actually be dropped from virtnet_open path;\nthe device is not stopped in any case. For BQL core part, it's just like\ntraffic nearly ceases to exist for some period. For stall detector added\nto BQL, even if virtnet_close could somehow lead to some TX completions\ndelayed for long, followed by virtnet_open, we can just take it as stall\nas mentioned in commit 6025b9135f7a (\"net: dqs: add NIC stall detector\nbased on BQL\"). Note also that users can still reset stall_max via sysfs.\n\nSo, drop netdev_tx_reset_queue() from virtnet_enable_queue_pair(). This\neliminates the BQL crashes. As a result, netdev_tx_reset_queue() is now\nexplicitly required in freeze/restore path. This patch adds it to\nimmediately after free_unused_bufs(), following the rule of thumb:\nnetdev_tx_reset_queue() should follow any SKB freeing not followed by\nnetdev_tx_completed_queue(). This seems the most consistent and\nstreamlined approach, and now netdev_tx_reset_queue() runs whenever\nfree_unused_bufs() is done.\n\n[1]:\n------------[ cut here ]------------\nkernel BUG at lib/dynamic_queue_limits.c:99!\nOops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 7 UID: 0 PID: 1598 Comm: ip Tainted: G    N 6.12.0net-next_main+ #2\nTainted: [N]=TEST\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), \\\nBIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\nRIP: 0010:dql_completed+0x26b/0x290\nCode: b7 c2 49 89 e9 44 89 da 89 c6 4c 89 d7 e8 ed 17 47 00 58 65 ff 0d\n4d 27 90 7e 0f 85 fd fe ff ff e8 ea 53 8d ff e9 f3 fe ff ff <0f> 0b 01\nd2 44 89 d1 29 d1 ba 00 00 00 00 0f 48 ca e9 28 ff ff ff\nRSP: 0018:ffffc900002b0d08 EFLAGS: 00010297\nRAX: 0000000000000000 RBX: ffff888102398c80 RCX: 0000000080190009\nRDX: 0000000000000000 RSI: 000000000000006a RDI: 0000000000000000\nRBP: ffff888102398c00 R08: 0000000000000000 R09: 0000000000000000\nR10: 00000000000000ca R11: 0000000000015681 R12: 0000000000000001\nR13: ffffc900002b0d68 R14: ffff88811115e000 R15: ffff8881107aca40\nFS:  00007f41ded69500(0000) GS:ffff888667dc0000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000556ccc2dc1a0 CR3: 0000000104fd8003 CR4: 0000000000772ef0\nPKRU: 55555554\nCall Trace:\n <IRQ>\n ? die+0x32/0x80\n ? do_trap+0xd9/0x100\n ? dql_completed+0x26b/0x290\n ? dql_completed+0x26b/0x290\n ? do_error_trap+0x6d/0xb0\n ? dql_completed+0x26b/0x290\n ? exc_invalid_op+0x4c/0x60\n ? dql_completed+0x26b/0x290\n ? asm_exc_invalid_op+0x16/0x20\n ? dql_completed+0x26b/0x290\n __free_old_xmit+0xff/0x170 [virtio_net]\n free_old_xmit+0x54/0xc0 [virtio_net]\n virtnet_poll+0xf4/0xe30 [virtio_net]\n ? __update_load_avg_cfs_rq+0x264/0x2d0\n ? update_curr+0x35/0x260\n ? reweight_entity+0x1be/0x260\n __napi_poll.constprop.0+0x28/0x1c0\n net_rx_action+0x329/0x420\n ? enqueue_hrtimer+0x35/0x90\n ? trace_hardirqs_on+0x1d/0x80\n ? kvm_sched_clock_read+0xd/0x20\n ? sched_clock+0xc/0x30\n ? kvm_sched_clock_read+0xd/0x20\n ? sched_clock+0xc/0x30\n ? sched_clock_cpu+0xd/0x1a0\n handle_softirqs+0x138/0x3e0\n do_softirq.part.0+0x89/0xc0\n </IRQ>\n <TASK>\n __local_bh_enable_ip+0xa7/0xb0\n virtnet_open+0xc8/0x310 [virtio_net]\n __dev_open+0xfa/0x1b0\n __dev_change_flags+0x1de/0x250\n dev_change_flags+0x22/0x60\n do_setlink.isra.0+0x2df/0x10b0\n ? rtnetlink_rcv_msg+0x34f/0x3f0\n ? netlink_rcv_skb+0x54/0x100\n ? netlink_unicas\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b4294d4ac61fbb382811a1d64eaf81f446ce2af4",
      "https://git.kernel.org/stable/c/3ddccbefebdbe0c4c72a248676e4d39ac66a8e26"
    ],
    "受影响版本": [
      "c8bd1f7f3e61fc6c562c806045f3ccd2cc819c01",
      "c8bd1f7f3e61fc6c562c806045f3ccd2cc819c01"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56673",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: mm: Do not call pmd dtor on vmemmap page table teardown\n\nThe vmemmap's, which is used for RV64 with SPARSEMEM_VMEMMAP, page\ntables are populated using pmd (page middle directory) hugetables.\nHowever, the pmd allocation is not using the generic mechanism used by\nthe VMA code (e.g. pmd_alloc()), or the RISC-V specific\ncreate_pgd_mapping()/alloc_pmd_late(). Instead, the vmemmap page table\ncode allocates a page, and calls vmemmap_set_pmd(). This results in\nthat the pmd ctor is *not* called, nor would it make sense to do so.\n\nNow, when tearing down a vmemmap page table pmd, the cleanup code\nwould unconditionally, and incorrectly call the pmd dtor, which\nresults in a crash (best case).\n\nThis issue was found when running the HMM selftests:\n\n  | tools/testing/selftests/mm# ./test_hmm.sh smoke\n  | ... # when unloading the test_hmm.ko module\n  | page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10915b\n  | flags: 0x1000000000000000(node=0|zone=1)\n  | raw: 1000000000000000 0000000000000000 dead000000000122 0000000000000000\n  | raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000\n  | page dumped because: VM_BUG_ON_PAGE(ptdesc->pmd_huge_pte)\n  | ------------[ cut here ]------------\n  | kernel BUG at include/linux/mm.h:3080!\n  | Kernel BUG [#1]\n  | Modules linked in: test_hmm(-) sch_fq_codel fuse drm drm_panel_orientation_quirks backlight dm_mod\n  | CPU: 1 UID: 0 PID: 514 Comm: modprobe Tainted: G        W          6.12.0-00982-gf2a4f1682d07 #2\n  | Tainted: [W]=WARN\n  | Hardware name: riscv-virtio qemu/qemu, BIOS 2024.10 10/01/2024\n  | epc : remove_pgd_mapping+0xbec/0x1070\n  |  ra : remove_pgd_mapping+0xbec/0x1070\n  | epc : ffffffff80010a68 ra : ffffffff80010a68 sp : ff20000000a73940\n  |  gp : ffffffff827b2d88 tp : ff6000008785da40 t0 : ffffffff80fbce04\n  |  t1 : 0720072007200720 t2 : 706d756420656761 s0 : ff20000000a73a50\n  |  s1 : ff6000008915cff8 a0 : 0000000000000039 a1 : 0000000000000008\n  |  a2 : ff600003fff0de20 a3 : 0000000000000000 a4 : 0000000000000000\n  |  a5 : 0000000000000000 a6 : c0000000ffffefff a7 : ffffffff824469b8\n  |  s2 : ff1c0000022456c0 s3 : ff1ffffffdbfffff s4 : ff6000008915c000\n  |  s5 : ff6000008915c000 s6 : ff6000008915c000 s7 : ff1ffffffdc00000\n  |  s8 : 0000000000000001 s9 : ff1ffffffdc00000 s10: ffffffff819a31f0\n  |  s11: ffffffffffffffff t3 : ffffffff8000c950 t4 : ff60000080244f00\n  |  t5 : ff60000080244000 t6 : ff20000000a73708\n  | status: 0000000200000120 badaddr: ffffffff80010a68 cause: 0000000000000003\n  | [<ffffffff80010a68>] remove_pgd_mapping+0xbec/0x1070\n  | [<ffffffff80fd238e>] vmemmap_free+0x14/0x1e\n  | [<ffffffff8032e698>] section_deactivate+0x220/0x452\n  | [<ffffffff8032ef7e>] sparse_remove_section+0x4a/0x58\n  | [<ffffffff802f8700>] __remove_pages+0x7e/0xba\n  | [<ffffffff803760d8>] memunmap_pages+0x2bc/0x3fe\n  | [<ffffffff02a3ca28>] dmirror_device_remove_chunks+0x2ea/0x518 [test_hmm]\n  | [<ffffffff02a3e026>] hmm_dmirror_exit+0x3e/0x1018 [test_hmm]\n  | [<ffffffff80102c14>] __riscv_sys_delete_module+0x15a/0x2a6\n  | [<ffffffff80fd020c>] do_trap_ecall_u+0x1f2/0x266\n  | [<ffffffff80fde0a2>] _new_vmalloc_restore_context_a0+0xc6/0xd2\n  | Code: bf51 7597 0184 8593 76a5 854a 4097 0029 80e7 2c00 (9002) 7597\n  | ---[ end trace 0000000000000000 ]---\n  | Kernel panic - not syncing: Fatal exception in interrupt\n\nAdd a check to avoid calling the pmd dtor, if the calling context is\nvmemmap_free().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/344945806f2f7af68be98bac02836c867f223aa9",
      "https://git.kernel.org/stable/c/21f1b85c8912262adf51707e63614a114425eb10"
    ],
    "受影响版本": [
      "c75a74f4ba19c904c0ae1e011ae2568449409ae4",
      "c75a74f4ba19c904c0ae1e011ae2568449409ae4"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56660",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: DR, prevent potential error pointer dereference\n\nThe dr_domain_add_vport_cap() function generally returns NULL on error\nbut sometimes we want it to return ERR_PTR(-EBUSY) so the caller can\nretry.  The problem here is that \"ret\" can be either -EBUSY or -ENOMEM\nand if it's and -ENOMEM then the error pointer is propogated back and\neventually dereferenced in dr_ste_v0_build_src_gvmi_qpn_tag().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/61f720e801443d4e2a3c0261eda4ad8431458dca",
      "https://git.kernel.org/stable/c/325cf73a1b449fea3158ab99d03a7a717aad1618",
      "https://git.kernel.org/stable/c/a59c61a1869ceefc65ef02886f91e8cd0062211f",
      "https://git.kernel.org/stable/c/11776cff0b563c8b8a4fa76cab620bfb633a8cb8"
    ],
    "受影响版本": [
      "11a45def2e197532c46aa908dedd52bc1ee378a2",
      "11a45def2e197532c46aa908dedd52bc1ee378a2",
      "11a45def2e197532c46aa908dedd52bc1ee378a2",
      "11a45def2e197532c46aa908dedd52bc1ee378a2"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56659",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: lapb: increase LAPB_HEADER_LEN\n\nIt is unclear if net/lapb code is supposed to be ready for 8021q.\n\nWe can at least avoid crashes like the following :\n\nskbuff: skb_under_panic: text:ffffffff8aabe1f6 len:24 put:20 head:ffff88802824a400 data:ffff88802824a3fe tail:0x16 end:0x140 dev:nr0.2\n------------[ cut here ]------------\n kernel BUG at net/core/skbuff.c:206 !\nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI\nCPU: 1 UID: 0 PID: 5508 Comm: dhcpcd Not tainted 6.12.0-rc7-syzkaller-00144-g66418447d27b #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/30/2024\n RIP: 0010:skb_panic net/core/skbuff.c:206 [inline]\n RIP: 0010:skb_under_panic+0x14b/0x150 net/core/skbuff.c:216\nCode: 0d 8d 48 c7 c6 2e 9e 29 8e 48 8b 54 24 08 8b 0c 24 44 8b 44 24 04 4d 89 e9 50 41 54 41 57 41 56 e8 1a 6f 37 02 48 83 c4 20 90 <0f> 0b 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3\nRSP: 0018:ffffc90002ddf638 EFLAGS: 00010282\nRAX: 0000000000000086 RBX: dffffc0000000000 RCX: 7a24750e538ff600\nRDX: 0000000000000000 RSI: 0000000000000201 RDI: 0000000000000000\nRBP: ffff888034a86650 R08: ffffffff8174b13c R09: 1ffff920005bbe60\nR10: dffffc0000000000 R11: fffff520005bbe61 R12: 0000000000000140\nR13: ffff88802824a400 R14: ffff88802824a3fe R15: 0000000000000016\nFS:  00007f2a5990d740(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000000110c2631fd CR3: 0000000029504000 CR4: 00000000003526f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n  skb_push+0xe5/0x100 net/core/skbuff.c:2636\n  nr_header+0x36/0x320 net/netrom/nr_dev.c:69\n  dev_hard_header include/linux/netdevice.h:3148 [inline]\n  vlan_dev_hard_header+0x359/0x480 net/8021q/vlan_dev.c:83\n  dev_hard_header include/linux/netdevice.h:3148 [inline]\n  lapbeth_data_transmit+0x1f6/0x2a0 drivers/net/wan/lapbether.c:257\n  lapb_data_transmit+0x91/0xb0 net/lapb/lapb_iface.c:447\n  lapb_transmit_buffer+0x168/0x1f0 net/lapb/lapb_out.c:149\n lapb_establish_data_link+0x84/0xd0\n lapb_device_event+0x4e0/0x670\n  notifier_call_chain+0x19f/0x3e0 kernel/notifier.c:93\n __dev_notify_flags+0x207/0x400\n  dev_change_flags+0xf0/0x1a0 net/core/dev.c:8922\n  devinet_ioctl+0xa4e/0x1aa0 net/ipv4/devinet.c:1188\n  inet_ioctl+0x3d7/0x4f0 net/ipv4/af_inet.c:1003\n  sock_do_ioctl+0x158/0x460 net/socket.c:1227\n  sock_ioctl+0x626/0x8e0 net/socket.c:1346\n  vfs_ioctl fs/ioctl.c:51 [inline]\n  __do_sys_ioctl fs/ioctl.c:907 [inline]\n  __se_sys_ioctl+0xf9/0x170 fs/ioctl.c:893\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3aa2ef7ffd0451e8f81c249d2a2a68283c6bc700",
      "https://git.kernel.org/stable/c/76d856f03d0290cf5392364ecdf74c15ee16b8fd",
      "https://git.kernel.org/stable/c/c21c7c1c00bcc60cf752ec491bdfd47693f4d3c7",
      "https://git.kernel.org/stable/c/f0949199651bc87c5ed2c12a7323f441f1af6fe9",
      "https://git.kernel.org/stable/c/03e661b5e7aa1124f24054df9ab2ee5cb2178973",
      "https://git.kernel.org/stable/c/2b351355bbd50ae25d096785b6eb31998d2bf765",
      "https://git.kernel.org/stable/c/a6d75ecee2bf828ac6a1b52724aba0a977e4eaf4"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56643",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndccp: Fix memory leak in dccp_feat_change_recv\n\nIf dccp_feat_push_confirm() fails after new value for SP feature was accepted\nwithout reconciliation ('entry == NULL' branch), memory allocated for that value\nwith dccp_feat_clone_sp_val() is never freed.\n\nHere is the kmemleak stack for this:\n\nunreferenced object 0xffff88801d4ab488 (size 8):\n  comm \"syz-executor310\", pid 1127, jiffies 4295085598 (age 41.666s)\n  hex dump (first 8 bytes):\n    01 b4 4a 1d 80 88 ff ff                          ..J.....\n  backtrace:\n    [<00000000db7cabfe>] kmemdup+0x23/0x50 mm/util.c:128\n    [<0000000019b38405>] kmemdup include/linux/string.h:465 [inline]\n    [<0000000019b38405>] dccp_feat_clone_sp_val net/dccp/feat.c:371 [inline]\n    [<0000000019b38405>] dccp_feat_clone_sp_val net/dccp/feat.c:367 [inline]\n    [<0000000019b38405>] dccp_feat_change_recv net/dccp/feat.c:1145 [inline]\n    [<0000000019b38405>] dccp_feat_parse_options+0x1196/0x2180 net/dccp/feat.c:1416\n    [<00000000b1f6d94a>] dccp_parse_options+0xa2a/0x1260 net/dccp/options.c:125\n    [<0000000030d7b621>] dccp_rcv_state_process+0x197/0x13d0 net/dccp/input.c:650\n    [<000000001f74c72e>] dccp_v4_do_rcv+0xf9/0x1a0 net/dccp/ipv4.c:688\n    [<00000000a6c24128>] sk_backlog_rcv include/net/sock.h:1041 [inline]\n    [<00000000a6c24128>] __release_sock+0x139/0x3b0 net/core/sock.c:2570\n    [<00000000cf1f3a53>] release_sock+0x54/0x1b0 net/core/sock.c:3111\n    [<000000008422fa23>] inet_wait_for_connect net/ipv4/af_inet.c:603 [inline]\n    [<000000008422fa23>] __inet_stream_connect+0x5d0/0xf70 net/ipv4/af_inet.c:696\n    [<0000000015b6f64d>] inet_stream_connect+0x53/0xa0 net/ipv4/af_inet.c:735\n    [<0000000010122488>] __sys_connect_file+0x15c/0x1a0 net/socket.c:1865\n    [<00000000b4b70023>] __sys_connect+0x165/0x1a0 net/socket.c:1882\n    [<00000000f4cb3815>] __do_sys_connect net/socket.c:1892 [inline]\n    [<00000000f4cb3815>] __se_sys_connect net/socket.c:1889 [inline]\n    [<00000000f4cb3815>] __x64_sys_connect+0x6e/0xb0 net/socket.c:1889\n    [<00000000e7b1e839>] do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46\n    [<0000000055e91434>] entry_SYSCALL_64_after_hwframe+0x67/0xd1\n\nClean up the allocated memory in case of dccp_feat_push_confirm() failure\nand bail out with an error reset code.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/623be080ab3c13d71570bd32f7202a8efa8e2252",
      "https://git.kernel.org/stable/c/c99507fff94b926fc92279c92d80f229c91cb85d",
      "https://git.kernel.org/stable/c/bc3d4423def1a9412a0ae454cb4477089ab79276",
      "https://git.kernel.org/stable/c/6ff67909ee2ffad911e3122616df41dee23ff4f6",
      "https://git.kernel.org/stable/c/d3ec686a369fae5034303061f003cd3f94ddfd23",
      "https://git.kernel.org/stable/c/9ee68b0f23706a77f53c832457b9384178b76421",
      "https://git.kernel.org/stable/c/22be4727a8f898442066bcac34f8a1ad0bc72e14"
    ],
    "受影响版本": [
      "e77b8363b2ea7c0d89919547c1a8b0562f298b57",
      "e77b8363b2ea7c0d89919547c1a8b0562f298b57",
      "e77b8363b2ea7c0d89919547c1a8b0562f298b57",
      "e77b8363b2ea7c0d89919547c1a8b0562f298b57",
      "e77b8363b2ea7c0d89919547c1a8b0562f298b57",
      "e77b8363b2ea7c0d89919547c1a8b0562f298b57",
      "e77b8363b2ea7c0d89919547c1a8b0562f298b57"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56640",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: fix LGR and link use-after-free issue\n\nWe encountered a LGR/link use-after-free issue, which manifested as\nthe LGR/link refcnt reaching 0 early and entering the clear process,\nmaking resource access unsafe.\n\n refcount_t: addition on 0; use-after-free.\n WARNING: CPU: 14 PID: 107447 at lib/refcount.c:25 refcount_warn_saturate+0x9c/0x140\n Workqueue: events smc_lgr_terminate_work [smc]\n Call trace:\n  refcount_warn_saturate+0x9c/0x140\n  __smc_lgr_terminate.part.45+0x2a8/0x370 [smc]\n  smc_lgr_terminate_work+0x28/0x30 [smc]\n  process_one_work+0x1b8/0x420\n  worker_thread+0x158/0x510\n  kthread+0x114/0x118\n\nor\n\n refcount_t: underflow; use-after-free.\n WARNING: CPU: 6 PID: 93140 at lib/refcount.c:28 refcount_warn_saturate+0xf0/0x140\n Workqueue: smc_hs_wq smc_listen_work [smc]\n Call trace:\n  refcount_warn_saturate+0xf0/0x140\n  smcr_link_put+0x1cc/0x1d8 [smc]\n  smc_conn_free+0x110/0x1b0 [smc]\n  smc_conn_abort+0x50/0x60 [smc]\n  smc_listen_find_device+0x75c/0x790 [smc]\n  smc_listen_work+0x368/0x8a0 [smc]\n  process_one_work+0x1b8/0x420\n  worker_thread+0x158/0x510\n  kthread+0x114/0x118\n\nIt is caused by repeated release of LGR/link refcnt. One suspect is that\nsmc_conn_free() is called repeatedly because some smc_conn_free() from\nserver listening path are not protected by sock lock.\n\ne.g.\n\nCalls under socklock        | smc_listen_work\n-------------------------------------------------------\nlock_sock(sk)               | smc_conn_abort\nsmc_conn_free               | \\- smc_conn_free\n\\- smcr_link_put            |    \\- smcr_link_put (duplicated)\nrelease_sock(sk)\n\nSo here add sock lock protection in smc_listen_work() path, making it\nexclusive with other connection operations.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f502a88fdd415647a1f2dc45fac71b9c522a052b",
      "https://git.kernel.org/stable/c/0cf598548a6c36d90681d53c6b77d52363f2f295",
      "https://git.kernel.org/stable/c/673d606683ac70bc074ca6676b938bff18635226",
      "https://git.kernel.org/stable/c/6f0ae06a234a78ae137064f2c89135ac078a00eb",
      "https://git.kernel.org/stable/c/2c7f14ed9c19ec0f149479d1c2842ec1f9bf76d7"
    ],
    "受影响版本": [
      "3b2dec2603d5b06ad3af71c1164ca0b92df3d2a8",
      "3b2dec2603d5b06ad3af71c1164ca0b92df3d2a8",
      "3b2dec2603d5b06ad3af71c1164ca0b92df3d2a8",
      "3b2dec2603d5b06ad3af71c1164ca0b92df3d2a8",
      "3b2dec2603d5b06ad3af71c1164ca0b92df3d2a8"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56639",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hsr: must allocate more bytes for RedBox support\n\nBlamed commit forgot to change hsr_init_skb() to allocate\nlarger skb for RedBox case.\n\nIndeed, send_hsr_supervision_frame() will add\ntwo additional components (struct hsr_sup_tlv\nand struct hsr_sup_payload)\n\nsyzbot reported the following crash:\nskbuff: skb_over_panic: text:ffffffff8afd4b0a len:34 put:6 head:ffff88802ad29e00 data:ffff88802ad29f22 tail:0x144 end:0x140 dev:gretap0\n------------[ cut here ]------------\n kernel BUG at net/core/skbuff.c:206 !\nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI\nCPU: 2 UID: 0 PID: 7611 Comm: syz-executor Not tainted 6.12.0-syzkaller #0\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014\n RIP: 0010:skb_panic+0x157/0x1d0 net/core/skbuff.c:206\nCode: b6 04 01 84 c0 74 04 3c 03 7e 21 8b 4b 70 41 56 45 89 e8 48 c7 c7 a0 7d 9b 8c 41 57 56 48 89 ee 52 4c 89 e2 e8 9a 76 79 f8 90 <0f> 0b 4c 89 4c 24 10 48 89 54 24 08 48 89 34 24 e8 94 76 fb f8 4c\nRSP: 0018:ffffc90000858ab8 EFLAGS: 00010282\nRAX: 0000000000000087 RBX: ffff8880598c08c0 RCX: ffffffff816d3e69\nRDX: 0000000000000000 RSI: ffffffff816de786 RDI: 0000000000000005\nRBP: ffffffff8c9b91c0 R08: 0000000000000005 R09: 0000000000000000\nR10: 0000000000000302 R11: ffffffff961cc1d0 R12: ffffffff8afd4b0a\nR13: 0000000000000006 R14: ffff88804b938130 R15: 0000000000000140\nFS:  000055558a3d6500(0000) GS:ffff88806a800000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f1295974ff8 CR3: 000000002ab6e000 CR4: 0000000000352ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <IRQ>\n  skb_over_panic net/core/skbuff.c:211 [inline]\n  skb_put+0x174/0x1b0 net/core/skbuff.c:2617\n  send_hsr_supervision_frame+0x6fa/0x9e0 net/hsr/hsr_device.c:342\n  hsr_proxy_announce+0x1a3/0x4a0 net/hsr/hsr_device.c:436\n  call_timer_fn+0x1a0/0x610 kernel/time/timer.c:1794\n  expire_timers kernel/time/timer.c:1845 [inline]\n  __run_timers+0x6e8/0x930 kernel/time/timer.c:2419\n  __run_timer_base kernel/time/timer.c:2430 [inline]\n  __run_timer_base kernel/time/timer.c:2423 [inline]\n  run_timer_base+0x111/0x190 kernel/time/timer.c:2439\n  run_timer_softirq+0x1a/0x40 kernel/time/timer.c:2449\n  handle_softirqs+0x213/0x8f0 kernel/softirq.c:554\n  __do_softirq kernel/softirq.c:588 [inline]\n  invoke_softirq kernel/softirq.c:428 [inline]\n  __irq_exit_rcu kernel/softirq.c:637 [inline]\n  irq_exit_rcu+0xbb/0x120 kernel/softirq.c:649\n  instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline]\n  sysvec_apic_timer_interrupt+0xa4/0xc0 arch/x86/kernel/apic/apic.c:1049\n </IRQ>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/688842f47ee9fb392d1c3a1ced1d21d505b14968",
      "https://git.kernel.org/stable/c/af8edaeddbc52e53207d859c912b017fd9a77629"
    ],
    "受影响版本": [
      "5055cccfc2d1cc1a7306f6bcdcd0ee9521d707f5",
      "5055cccfc2d1cc1a7306f6bcdcd0ee9521d707f5"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56633",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp_bpf: Fix the sk_mem_uncharge logic in tcp_bpf_sendmsg\n\nThe current sk memory accounting logic in __SK_REDIRECT is pre-uncharging\ntosend bytes, which is either msg->sg.size or a smaller value apply_bytes.\n\nPotential problems with this strategy are as follows:\n\n- If the actual sent bytes are smaller than tosend, we need to charge some\n  bytes back, as in line 487, which is okay but seems not clean.\n\n- When tosend is set to apply_bytes, as in line 417, and (ret < 0), we may\n  miss uncharging (msg->sg.size - apply_bytes) bytes.\n\n[...]\n415 tosend = msg->sg.size;\n416 if (psock->apply_bytes && psock->apply_bytes < tosend)\n417   tosend = psock->apply_bytes;\n[...]\n443 sk_msg_return(sk, msg, tosend);\n444 release_sock(sk);\n446 origsize = msg->sg.size;\n447 ret = tcp_bpf_sendmsg_redir(sk_redir, redir_ingress,\n448                             msg, tosend, flags);\n449 sent = origsize - msg->sg.size;\n[...]\n454 lock_sock(sk);\n455 if (unlikely(ret < 0)) {\n456   int free = sk_msg_free_nocharge(sk, msg);\n458   if (!cork)\n459     *copied -= free;\n460 }\n[...]\n487 if (eval == __SK_REDIRECT)\n488   sk_mem_charge(sk, tosend - sent);\n[...]\n\nWhen running the selftest test_txmsg_redir_wait_sndmem with txmsg_apply,\nthe following warning will be reported:\n\n------------[ cut here ]------------\nWARNING: CPU: 6 PID: 57 at net/ipv4/af_inet.c:156 inet_sock_destruct+0x190/0x1a0\nModules linked in:\nCPU: 6 UID: 0 PID: 57 Comm: kworker/6:0 Not tainted 6.12.0-rc1.bm.1-amd64+ #43\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-1 04/01/2014\nWorkqueue: events sk_psock_destroy\nRIP: 0010:inet_sock_destruct+0x190/0x1a0\nRSP: 0018:ffffad0a8021fe08 EFLAGS: 00010206\nRAX: 0000000000000011 RBX: ffff9aab4475b900 RCX: ffff9aab481a0800\nRDX: 0000000000000303 RSI: 0000000000000011 RDI: ffff9aab4475b900\nRBP: ffff9aab4475b990 R08: 0000000000000000 R09: ffff9aab40050ec0\nR10: 0000000000000000 R11: ffff9aae6fdb1d01 R12: ffff9aab49c60400\nR13: ffff9aab49c60598 R14: ffff9aab49c60598 R15: dead000000000100\nFS:  0000000000000000(0000) GS:ffff9aae6fd80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffec7e47bd8 CR3: 00000001a1a1c004 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n<TASK>\n? __warn+0x89/0x130\n? inet_sock_destruct+0x190/0x1a0\n? report_bug+0xfc/0x1e0\n? handle_bug+0x5c/0xa0\n? exc_invalid_op+0x17/0x70\n? asm_exc_invalid_op+0x1a/0x20\n? inet_sock_destruct+0x190/0x1a0\n__sk_destruct+0x25/0x220\nsk_psock_destroy+0x2b2/0x310\nprocess_scheduled_works+0xa3/0x3e0\nworker_thread+0x117/0x240\n? __pfx_worker_thread+0x10/0x10\nkthread+0xcf/0x100\n? __pfx_kthread+0x10/0x10\nret_from_fork+0x31/0x40\n? __pfx_kthread+0x10/0x10\nret_from_fork_asm+0x1a/0x30\n</TASK>\n---[ end trace 0000000000000000 ]---\n\nIn __SK_REDIRECT, a more concise way is delaying the uncharging after sent\nbytes are finalized, and uncharge this value. When (ret < 0), we shall\ninvoke sk_msg_free.\n\nSame thing happens in case __SK_DROP, when tosend is set to apply_bytes,\nwe may miss uncharging (msg->sg.size - apply_bytes) bytes. The same\nwarning will be reported in selftest.\n\n[...]\n468 case __SK_DROP:\n469 default:\n470 sk_msg_free_partial(sk, msg, tosend);\n471 sk_msg_apply_bytes(psock, tosend);\n472 *copied -= (tosend + delta);\n473 return -EACCES;\n[...]\n\nSo instead of sk_msg_free_partial we can do sk_msg_free here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/905d82e6e77d16ec3e089c92b7b59a14899dfc1a",
      "https://git.kernel.org/stable/c/dbedc7e142df5ea238a46fdd7462c1c42cd36a10",
      "https://git.kernel.org/stable/c/0d6cd1151e26fc7c2d5daa85e8984aaa685a1a12",
      "https://git.kernel.org/stable/c/456f08d24afa51b5eb816c42e4ca1c44a247bd42",
      "https://git.kernel.org/stable/c/206d56f41a1509cadd06e2178c26cb830e45057d",
      "https://git.kernel.org/stable/c/5c9e3bb43a354a2245caebbbbb4a5b8c034fdd56",
      "https://git.kernel.org/stable/c/ca70b8baf2bd125b2a4d96e76db79375c07d7ff2"
    ],
    "受影响版本": [
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56632",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-tcp: fix the memleak while create new ctrl failed\n\nNow while we create new ctrl failed, we have not free the\ntagset occupied by admin_q, here try to fix it.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ceff9ac13a2478afddce85414d404e6aff6425f6",
      "https://git.kernel.org/stable/c/fec55c29e54d3ca6fe9d7d7d9266098b4514fd34"
    ],
    "受影响版本": [
      "fd1418de10b9ca03d78404cf00a95138689ea369",
      "fd1418de10b9ca03d78404cf00a95138689ea369"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56628",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nLoongArch: Add architecture specific huge_pte_clear()\n\nWhen executing mm selftests run_vmtests.sh, there is such an error:\n\n BUG: Bad page state in process uffd-unit-tests  pfn:00000\n page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x0\n flags: 0xffff0000002000(reserved|node=0|zone=0|lastcpupid=0xffff)\n raw: 00ffff0000002000 ffffbf0000000008 ffffbf0000000008 0000000000000000\n raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000\n page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set\n Modules linked in: snd_seq_dummy snd_seq snd_seq_device rfkill vfat fat\n    virtio_balloon efi_pstore virtio_net pstore net_failover failover fuse\n    nfnetlink virtio_scsi virtio_gpu virtio_dma_buf dm_multipath efivarfs\n CPU: 2 UID: 0 PID: 1913 Comm: uffd-unit-tests Not tainted 6.12.0 #184\n Hardware name: QEMU QEMU Virtual Machine, BIOS unknown 2/2/2022\n Stack : 900000047c8ac000 0000000000000000 9000000000223a7c 900000047c8ac000\n         900000047c8af690 900000047c8af698 0000000000000000 900000047c8af7d8\n         900000047c8af7d0 900000047c8af7d0 900000047c8af5b0 0000000000000001\n         0000000000000001 900000047c8af698 10b3c7d53da40d26 0000010000000000\n         0000000000000022 0000000fffffffff fffffffffe000000 ffff800000000000\n         000000000000002f 0000800000000000 000000017a6d4000 90000000028f8940\n         0000000000000000 0000000000000000 90000000025aa5e0 9000000002905000\n         0000000000000000 90000000028f8940 ffff800000000000 0000000000000000\n         0000000000000000 0000000000000000 9000000000223a94 000000012001839c\n         00000000000000b0 0000000000000004 0000000000000000 0000000000071c1d\n         ...\n Call Trace:\n [<9000000000223a94>] show_stack+0x5c/0x180\n [<9000000001c3fd64>] dump_stack_lvl+0x6c/0xa0\n [<900000000056aa08>] bad_page+0x1a0/0x1f0\n [<9000000000574978>] free_unref_folios+0xbf0/0xd20\n [<90000000004e65cc>] folios_put_refs+0x1a4/0x2b8\n [<9000000000599a0c>] free_pages_and_swap_cache+0x164/0x260\n [<9000000000547698>] tlb_batch_pages_flush+0xa8/0x1c0\n [<9000000000547f30>] tlb_finish_mmu+0xa8/0x218\n [<9000000000543cb8>] exit_mmap+0x1a0/0x360\n [<9000000000247658>] __mmput+0x78/0x200\n [<900000000025583c>] do_exit+0x43c/0xde8\n [<9000000000256490>] do_group_exit+0x68/0x110\n [<9000000000256554>] sys_exit_group+0x1c/0x20\n [<9000000001c413b4>] do_syscall+0x94/0x130\n [<90000000002216d8>] handle_syscall+0xb8/0x158\n Disabling lock debugging due to kernel taint\n BUG: non-zero pgtables_bytes on freeing mm: -16384\n\nOn LoongArch system, invalid huge pte entry should be invalid_pte_table\nor a single _PAGE_HUGE bit rather than a zero value. And it should be\nthe same with invalid pmd entry, since pmd_none() is called by function\nfree_pgd_range() and pmd_none() return 0 by huge_pte_clear(). So single\n_PAGE_HUGE bit is also treated as a valid pte table and free_pte_range()\nwill be called in free_pmd_range().\n\n  free_pmd_range()\n        pmd = pmd_offset(pud, addr);\n        do {\n                next = pmd_addr_end(addr, end);\n                if (pmd_none_or_clear_bad(pmd))\n                        continue;\n                free_pte_range(tlb, pmd, addr);\n        } while (pmd++, addr = next, addr != end);\n\nHere invalid_pte_table is used for both invalid huge pte entry and\npmd entry.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/dba3c45e333a3a2a01395b5f5e5f88f8baba74e4",
      "https://git.kernel.org/stable/c/7dfbf011a57b9e1a40f5ce8080a53c497e105c6c",
      "https://git.kernel.org/stable/c/9b602190cf2d8ac957be0011e418ed6c3b49b9a3",
      "https://git.kernel.org/stable/c/7cd1f5f77925ae905a57296932f0f9ef0dc364f8"
    ],
    "受影响版本": [
      "09cfefb7fa70c3af011b0db0a513fd80b2f18abc",
      "09cfefb7fa70c3af011b0db0a513fd80b2f18abc",
      "09cfefb7fa70c3af011b0db0a513fd80b2f18abc",
      "09cfefb7fa70c3af011b0db0a513fd80b2f18abc"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56618",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npmdomain: imx: gpcv2: Adjust delay after power up handshake\n\nThe udelay(5) is not enough, sometimes below kernel panic\nstill be triggered:\n\n[    4.012973] Kernel panic - not syncing: Asynchronous SError Interrupt\n[    4.012976] CPU: 2 UID: 0 PID: 186 Comm: (udev-worker) Not tainted 6.12.0-rc2-0.0.0-devel-00004-g8b1b79e88956 #1\n[    4.012982] Hardware name: Toradex Verdin iMX8M Plus WB on Dahlia Board (DT)\n[    4.012985] Call trace:\n[...]\n[    4.013029]  arm64_serror_panic+0x64/0x70\n[    4.013034]  do_serror+0x3c/0x70\n[    4.013039]  el1h_64_error_handler+0x30/0x54\n[    4.013046]  el1h_64_error+0x64/0x68\n[    4.013050]  clk_imx8mp_audiomix_runtime_resume+0x38/0x48\n[    4.013059]  __genpd_runtime_resume+0x30/0x80\n[    4.013066]  genpd_runtime_resume+0x114/0x29c\n[    4.013073]  __rpm_callback+0x48/0x1e0\n[    4.013079]  rpm_callback+0x68/0x80\n[    4.013084]  rpm_resume+0x3bc/0x6a0\n[    4.013089]  __pm_runtime_resume+0x50/0x9c\n[    4.013095]  pm_runtime_get_suppliers+0x60/0x8c\n[    4.013101]  __driver_probe_device+0x4c/0x14c\n[    4.013108]  driver_probe_device+0x3c/0x120\n[    4.013114]  __driver_attach+0xc4/0x200\n[    4.013119]  bus_for_each_dev+0x7c/0xe0\n[    4.013125]  driver_attach+0x24/0x30\n[    4.013130]  bus_add_driver+0x110/0x240\n[    4.013135]  driver_register+0x68/0x124\n[    4.013142]  __platform_driver_register+0x24/0x30\n[    4.013149]  sdma_driver_init+0x20/0x1000 [imx_sdma]\n[    4.013163]  do_one_initcall+0x60/0x1e0\n[    4.013168]  do_init_module+0x5c/0x21c\n[    4.013175]  load_module+0x1a98/0x205c\n[    4.013181]  init_module_from_file+0x88/0xd4\n[    4.013187]  __arm64_sys_finit_module+0x258/0x350\n[    4.013194]  invoke_syscall.constprop.0+0x50/0xe0\n[    4.013202]  do_el0_svc+0xa8/0xe0\n[    4.013208]  el0_svc+0x3c/0x140\n[    4.013215]  el0t_64_sync_handler+0x120/0x12c\n[    4.013222]  el0t_64_sync+0x190/0x194\n[    4.013228] SMP: stopping secondary CPUs\n\nThe correct way is to wait handshake, but it needs BUS clock of\nBLK-CTL be enabled, which is in separate driver. So delay is the\nonly option here. The udelay(10) is a data got by experiment.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a63907c8c712414643b597debcd09d16b6827b23",
      "https://git.kernel.org/stable/c/2379fb937de5333991c567eefd7d11b98977d059"
    ],
    "受影响版本": [
      "e8dc41afca161b988e6d462f4d0803d247e22250",
      "e8dc41afca161b988e6d462f4d0803d247e22250"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56617",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncacheinfo: Allocate memory during CPU hotplug if not done from the primary CPU\n\nCommit\n\n  5944ce092b97 (\"arch_topology: Build cacheinfo from primary CPU\")\n\nadds functionality that architectures can use to optionally allocate and\nbuild cacheinfo early during boot. Commit\n\n  6539cffa9495 (\"cacheinfo: Add arch specific early level initializer\")\n\nlets secondary CPUs correct (and reallocate memory) cacheinfo data if\nneeded.\n\nIf the early build functionality is not used and cacheinfo does not need\ncorrection, memory for cacheinfo is never allocated. x86 does not use\nthe early build functionality. Consequently, during the cacheinfo CPU\nhotplug callback, last_level_cache_is_valid() attempts to dereference\na NULL pointer:\n\n  BUG: kernel NULL pointer dereference, address: 0000000000000100\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not present page\n  PGD 0 P4D 0\n  Oops: 0000 [#1] PREEPMT SMP NOPTI\n  CPU: 0 PID 19 Comm: cpuhp/0 Not tainted 6.4.0-rc2 #1\n  RIP: 0010: last_level_cache_is_valid+0x95/0xe0a\n\nAllocate memory for cacheinfo during the cacheinfo CPU hotplug callback\nif not done earlier.\n\nMoreover, before determining the validity of the last-level cache info,\nensure that it has been allocated. Simply checking for non-zero\ncache_leaves() is not sufficient, as some architectures (e.g., Intel\nprocessors) have non-zero cache_leaves() before allocation.\n\nDereferencing NULL cacheinfo can occur in update_per_cpu_data_slice_size().\nThis function iterates over all online CPUs. However, a CPU may have come\nonline recently, but its cacheinfo may not have been allocated yet.\n\nWhile here, remove an unnecessary indentation in allocate_cache_info().\n\n  [ bp: Massage. ]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/23b5908b11b77ff8d7b8f7b8f11cbab2e1f4bfc2",
      "https://git.kernel.org/stable/c/95e197354e0de07e9a20819bdae6562e4dda0f20",
      "https://git.kernel.org/stable/c/b3fce429a1e030b50c1c91351d69b8667eef627b"
    ],
    "受影响版本": [
      "6539cffa94957241c096099a57d05fa4d8c7db8a",
      "6539cffa94957241c096099a57d05fa4d8c7db8a",
      "6539cffa94957241c096099a57d05fa4d8c7db8a"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56609",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw88: use ieee80211_purge_tx_queue() to purge TX skb\n\nWhen removing kernel modules by:\n   rmmod rtw88_8723cs rtw88_8703b rtw88_8723x rtw88_sdio rtw88_core\n\nDriver uses skb_queue_purge() to purge TX skb, but not report tx status\ncausing \"Have pending ack frames!\" warning. Use ieee80211_purge_tx_queue()\nto correct this.\n\nSince ieee80211_purge_tx_queue() doesn't take locks, to prevent racing\nbetween TX work and purge TX queue, flush and destroy TX work in advance.\n\n   wlan0: deauthenticating from aa:f5:fd:60:4c:a8 by local\n     choice (Reason: 3=DEAUTH_LEAVING)\n   ------------[ cut here ]------------\n   Have pending ack frames!\n   WARNING: CPU: 3 PID: 9232 at net/mac80211/main.c:1691\n       ieee80211_free_ack_frame+0x5c/0x90 [mac80211]\n   CPU: 3 PID: 9232 Comm: rmmod Tainted: G         C\n       6.10.1-200.fc40.aarch64 #1\n   Hardware name: pine64 Pine64 PinePhone Braveheart\n      (1.1)/Pine64 PinePhone Braveheart (1.1), BIOS 2024.01 01/01/2024\n   pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n   pc : ieee80211_free_ack_frame+0x5c/0x90 [mac80211]\n   lr : ieee80211_free_ack_frame+0x5c/0x90 [mac80211]\n   sp : ffff80008c1b37b0\n   x29: ffff80008c1b37b0 x28: ffff000003be8000 x27: 0000000000000000\n   x26: 0000000000000000 x25: ffff000003dc14b8 x24: ffff80008c1b37d0\n   x23: ffff000000ff9f80 x22: 0000000000000000 x21: 000000007fffffff\n   x20: ffff80007c7e93d8 x19: ffff00006e66f400 x18: 0000000000000000\n   x17: ffff7ffffd2b3000 x16: ffff800083fc0000 x15: 0000000000000000\n   x14: 0000000000000000 x13: 2173656d61726620 x12: 6b636120676e6964\n   x11: 0000000000000000 x10: 000000000000005d x9 : ffff8000802af2b0\n   x8 : ffff80008c1b3430 x7 : 0000000000000001 x6 : 0000000000000001\n   x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000\n   x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff000003be8000\n   Call trace:\n    ieee80211_free_ack_frame+0x5c/0x90 [mac80211]\n    idr_for_each+0x74/0x110\n    ieee80211_free_hw+0x44/0xe8 [mac80211]\n    rtw_sdio_remove+0x9c/0xc0 [rtw88_sdio]\n    sdio_bus_remove+0x44/0x180\n    device_remove+0x54/0x90\n    device_release_driver_internal+0x1d4/0x238\n    driver_detach+0x54/0xc0\n    bus_remove_driver+0x78/0x108\n    driver_unregister+0x38/0x78\n    sdio_unregister_driver+0x2c/0x40\n    rtw_8723cs_driver_exit+0x18/0x1000 [rtw88_8723cs]\n    __do_sys_delete_module.isra.0+0x190/0x338\n    __arm64_sys_delete_module+0x1c/0x30\n    invoke_syscall+0x74/0x100\n    el0_svc_common.constprop.0+0x48/0xf0\n    do_el0_svc+0x24/0x38\n    el0_svc+0x3c/0x158\n    el0t_64_sync_handler+0x120/0x138\n    el0t_64_sync+0x194/0x198\n   ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4e8ce3978d704cb28678355d294e10a008b6230a",
      "https://git.kernel.org/stable/c/3d94c4b21966b49c3e26ceeefacaa11ff7ee6d68",
      "https://git.kernel.org/stable/c/9bca6528f20325d30c22236b23116f161d418f6d",
      "https://git.kernel.org/stable/c/3e5e4a801aaf4283390cc34959c6c48f910ca5ea"
    ],
    "受影响版本": [
      "e3037485c68ec1a299ff41160d8fedbd4abc29b9",
      "e3037485c68ec1a299ff41160d8fedbd4abc29b9",
      "e3037485c68ec1a299ff41160d8fedbd4abc29b9",
      "e3037485c68ec1a299ff41160d8fedbd4abc29b9"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56608",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix out-of-bounds access in 'dcn21_link_encoder_create'\n\nAn issue was identified in the dcn21_link_encoder_create function where\nan out-of-bounds access could occur when the hpd_source index was used\nto reference the link_enc_hpd_regs array. This array has a fixed size\nand the index was not being checked against the array's bounds before\naccessing it.\n\nThis fix adds a conditional check to ensure that the hpd_source index is\nwithin the valid range of the link_enc_hpd_regs array. If the index is\nout of bounds, the function now returns NULL to prevent undefined\nbehavior.\n\nReferences:\n\n[   65.920507] ------------[ cut here ]------------\n[   65.920510] UBSAN: array-index-out-of-bounds in drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn21/dcn21_resource.c:1312:29\n[   65.920519] index 7 is out of range for type 'dcn10_link_enc_hpd_registers [5]'\n[   65.920523] CPU: 3 PID: 1178 Comm: modprobe Tainted: G           OE      6.8.0-cleanershaderfeatureresetasdntipmi200nv2132 #13\n[   65.920525] Hardware name: AMD Majolica-RN/Majolica-RN, BIOS WMJ0429N_Weekly_20_04_2 04/29/2020\n[   65.920527] Call Trace:\n[   65.920529]  <TASK>\n[   65.920532]  dump_stack_lvl+0x48/0x70\n[   65.920541]  dump_stack+0x10/0x20\n[   65.920543]  __ubsan_handle_out_of_bounds+0xa2/0xe0\n[   65.920549]  dcn21_link_encoder_create+0xd9/0x140 [amdgpu]\n[   65.921009]  link_create+0x6d3/0xed0 [amdgpu]\n[   65.921355]  create_links+0x18a/0x4e0 [amdgpu]\n[   65.921679]  dc_create+0x360/0x720 [amdgpu]\n[   65.921999]  ? dmi_matches+0xa0/0x220\n[   65.922004]  amdgpu_dm_init+0x2b6/0x2c90 [amdgpu]\n[   65.922342]  ? console_unlock+0x77/0x120\n[   65.922348]  ? dev_printk_emit+0x86/0xb0\n[   65.922354]  dm_hw_init+0x15/0x40 [amdgpu]\n[   65.922686]  amdgpu_device_init+0x26a8/0x33a0 [amdgpu]\n[   65.922921]  amdgpu_driver_load_kms+0x1b/0xa0 [amdgpu]\n[   65.923087]  amdgpu_pci_probe+0x1b7/0x630 [amdgpu]\n[   65.923087]  local_pci_probe+0x4b/0xb0\n[   65.923087]  pci_device_probe+0xc8/0x280\n[   65.923087]  really_probe+0x187/0x300\n[   65.923087]  __driver_probe_device+0x85/0x130\n[   65.923087]  driver_probe_device+0x24/0x110\n[   65.923087]  __driver_attach+0xac/0x1d0\n[   65.923087]  ? __pfx___driver_attach+0x10/0x10\n[   65.923087]  bus_for_each_dev+0x7d/0xd0\n[   65.923087]  driver_attach+0x1e/0x30\n[   65.923087]  bus_add_driver+0xf2/0x200\n[   65.923087]  driver_register+0x64/0x130\n[   65.923087]  ? __pfx_amdgpu_init+0x10/0x10 [amdgpu]\n[   65.923087]  __pci_register_driver+0x61/0x70\n[   65.923087]  amdgpu_init+0x7d/0xff0 [amdgpu]\n[   65.923087]  do_one_initcall+0x49/0x310\n[   65.923087]  ? kmalloc_trace+0x136/0x360\n[   65.923087]  do_init_module+0x6a/0x270\n[   65.923087]  load_module+0x1fce/0x23a0\n[   65.923087]  init_module_from_file+0x9c/0xe0\n[   65.923087]  ? init_module_from_file+0x9c/0xe0\n[   65.923087]  idempotent_init_module+0x179/0x230\n[   65.923087]  __x64_sys_finit_module+0x5d/0xa0\n[   65.923087]  do_syscall_64+0x76/0x120\n[   65.923087]  entry_SYSCALL_64_after_hwframe+0x6e/0x76\n[   65.923087] RIP: 0033:0x7f2d80f1e88d\n[   65.923087] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 b5 0f 00 f7 d8 64 89 01 48\n[   65.923087] RSP: 002b:00007ffc7bc1aa78 EFLAGS: 00000246 ORIG_RAX: 0000000000000139\n[   65.923087] RAX: ffffffffffffffda RBX: 0000564c9c1db130 RCX: 00007f2d80f1e88d\n[   65.923087] RDX: 0000000000000000 RSI: 0000564c9c1e5480 RDI: 000000000000000f\n[   65.923087] RBP: 0000000000040000 R08: 0000000000000000 R09: 0000000000000002\n[   65.923087] R10: 000000000000000f R11: 0000000000000246 R12: 0000564c9c1e5480\n[   65.923087] R13: 0000564c9c1db260 R14: 0000000000000000 R15: 0000564c9c1e54b0\n[   65.923087]  </TASK>\n[   65.923927] ---[ end trace ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/280f722601c8bf4d8a9c62dd727cf3a2fd0a47be",
      "https://git.kernel.org/stable/c/b19ca8425a4b86e8f0d7c33c4e87ef7b0ebdaa29",
      "https://git.kernel.org/stable/c/5bd410c21037107b83ffbb51dd2d6460f9de9ed1",
      "https://git.kernel.org/stable/c/08ac5fdb9c6dc34d0ed4bc64ce3c5c3d411b3b53",
      "https://git.kernel.org/stable/c/f01ddd589e162979421e6914b1c74018633f01e0",
      "https://git.kernel.org/stable/c/63de35a8fcfca59ae8750d469a7eb220c7557baf"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56586",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix f2fs_bug_on when uninstalling filesystem call f2fs_evict_inode.\n\ncreating a large files during checkpoint disable until it runs out of\nspace and then delete it, then remount to enable checkpoint again, and\nthen unmount the filesystem triggers the f2fs_bug_on as below:\n\n------------[ cut here ]------------\nkernel BUG at fs/f2fs/inode.c:896!\nCPU: 2 UID: 0 PID: 1286 Comm: umount Not tainted 6.11.0-rc7-dirty #360\nOops: invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nRIP: 0010:f2fs_evict_inode+0x58c/0x610\nCall Trace:\n __die_body+0x15/0x60\n die+0x33/0x50\n do_trap+0x10a/0x120\n f2fs_evict_inode+0x58c/0x610\n do_error_trap+0x60/0x80\n f2fs_evict_inode+0x58c/0x610\n exc_invalid_op+0x53/0x60\n f2fs_evict_inode+0x58c/0x610\n asm_exc_invalid_op+0x16/0x20\n f2fs_evict_inode+0x58c/0x610\n evict+0x101/0x260\n dispose_list+0x30/0x50\n evict_inodes+0x140/0x190\n generic_shutdown_super+0x2f/0x150\n kill_block_super+0x11/0x40\n kill_f2fs_super+0x7d/0x140\n deactivate_locked_super+0x2a/0x70\n cleanup_mnt+0xb3/0x140\n task_work_run+0x61/0x90\n\nThe root cause is: creating large files during disable checkpoint\nperiod results in not enough free segments, so when writing back root\ninode will failed in f2fs_enable_checkpoint. When umount the file\nsystem after enabling checkpoint, the root inode is dirty in\nf2fs_evict_inode function, which triggers BUG_ON. The steps to\nreproduce are as follows:\n\ndd if=/dev/zero of=f2fs.img bs=1M count=55\nmount f2fs.img f2fs_dir -o checkpoint=disable:10%\ndd if=/dev/zero of=big bs=1M count=50\nsync\nrm big\nmount -o remount,checkpoint=enable f2fs_dir\numount f2fs_dir\n\nLet's redirty inode when there is not free segments during checkpoint\nis disable.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ac8aaf78bd039fa1be0acaa8e84a56499f79d721",
      "https://git.kernel.org/stable/c/dff561e4060d28edc9a2960d4a87f3c945a96aa3",
      "https://git.kernel.org/stable/c/a365de2fbfbe1e6740bfb75ab5c3245cf7bbe4d7",
      "https://git.kernel.org/stable/c/ef517d2d21c3d8e2ad35b2bb728bd1c90a31e617",
      "https://git.kernel.org/stable/c/9669b28f81e0ec6305af7773846fbe2cef1e7d61",
      "https://git.kernel.org/stable/c/9e28513fd2858911dcf47b84160a8824587536b6",
      "https://git.kernel.org/stable/c/d5c367ef8287fb4d235c46a2f8c8d68715f3a0ca"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56576",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: i2c: tc358743: Fix crash in the probe error path when using polling\n\nIf an error occurs in the probe() function, we should remove the polling\ntimer that was alarmed earlier, otherwise the timer is called with\narguments that are already freed, which results in a crash.\n\n------------[ cut here ]------------\nWARNING: CPU: 3 PID: 0 at kernel/time/timer.c:1830 __run_timers+0x244/0x268\nModules linked in:\nCPU: 3 UID: 0 PID: 0 Comm: swapper/3 Not tainted 6.11.0 #226\nHardware name: Diasom DS-RK3568-SOM-EVB (DT)\npstate: 804000c9 (Nzcv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : __run_timers+0x244/0x268\nlr : __run_timers+0x1d4/0x268\nsp : ffffff80eff2baf0\nx29: ffffff80eff2bb50 x28: 7fffffffffffffff x27: ffffff80eff2bb00\nx26: ffffffc080f669c0 x25: ffffff80efef6bf0 x24: ffffff80eff2bb00\nx23: 0000000000000000 x22: dead000000000122 x21: 0000000000000000\nx20: ffffff80efef6b80 x19: ffffff80041c8bf8 x18: ffffffffffffffff\nx17: ffffffc06f146000 x16: ffffff80eff27dc0 x15: 000000000000003e\nx14: 0000000000000000 x13: 00000000000054da x12: 0000000000000000\nx11: 00000000000639c0 x10: 000000000000000c x9 : 0000000000000009\nx8 : ffffff80eff2cb40 x7 : ffffff80eff2cb40 x6 : ffffff8002bee480\nx5 : ffffffc080cb2220 x4 : ffffffc080cb2150 x3 : 00000000000f4240\nx2 : 0000000000000102 x1 : ffffff80eff2bb00 x0 : ffffff80041c8bf0\nCall trace:\n __run_timers+0x244/0x268\n timer_expire_remote+0x50/0x68\n tmigr_handle_remote+0x388/0x39c\n run_timer_softirq+0x38/0x44\n handle_softirqs+0x138/0x298\n __do_softirq+0x14/0x20\n ____do_softirq+0x10/0x1c\n call_on_irq_stack+0x24/0x4c\n do_softirq_own_stack+0x1c/0x2c\n irq_exit_rcu+0x9c/0xcc\n el1_interrupt+0x48/0xc0\n el1h_64_irq_handler+0x18/0x24\n el1h_64_irq+0x7c/0x80\n default_idle_call+0x34/0x68\n do_idle+0x23c/0x294\n cpu_startup_entry+0x38/0x3c\n secondary_start_kernel+0x128/0x160\n __secondary_switched+0xb8/0xbc\n---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/13193a97ddd5a6a5b11408ddbc1ae85588b1860c",
      "https://git.kernel.org/stable/c/5c9ab34c87af718bdbf9faa2b1a6ba41d15380ea",
      "https://git.kernel.org/stable/c/815d14147068347e88c258233eb951b41b2792a6",
      "https://git.kernel.org/stable/c/34a3466a92f50c51d984f0ec2e96864886d460eb",
      "https://git.kernel.org/stable/c/b59ab89bc83f7bff67f78c6caf484a84a6dd30f7",
      "https://git.kernel.org/stable/c/1def915b1564f4375330bd113ea1d768a569cfd8",
      "https://git.kernel.org/stable/c/869f38ae07f7df829da4951c3d1f7a2be09c2e9a"
    ],
    "受影响版本": [
      "4e66a52a2e4c832dfa35a39204d0f7ce717d4a4a",
      "4e66a52a2e4c832dfa35a39204d0f7ce717d4a4a",
      "4e66a52a2e4c832dfa35a39204d0f7ce717d4a4a",
      "4e66a52a2e4c832dfa35a39204d0f7ce717d4a4a",
      "4e66a52a2e4c832dfa35a39204d0f7ce717d4a4a",
      "4e66a52a2e4c832dfa35a39204d0f7ce717d4a4a",
      "4e66a52a2e4c832dfa35a39204d0f7ce717d4a4a"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56572",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: platform: allegro-dvt: Fix possible memory leak in allocate_buffers_internal()\n\nThe buffer in the loop should be released under the exception path,\notherwise there may be a memory leak here.\n\nTo mitigate this, free the buffer when allegro_alloc_buffer fails.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/cf642904be39ae0d441dbdfa8f485e0a46260be4",
      "https://git.kernel.org/stable/c/74a65313578b35e1239966adfa7ac2bdd60caf00",
      "https://git.kernel.org/stable/c/64f72a738864b506ab50b4a6cb3ce3c3e04b71af",
      "https://git.kernel.org/stable/c/17e5613666209be4e5be1f1894f1a6014a8a0658",
      "https://git.kernel.org/stable/c/6712a28a4f923ffdf51cff267ad05a634ee1babc",
      "https://git.kernel.org/stable/c/891b5790bee8fc6ddba17874dd87a646128d0b99",
      "https://git.kernel.org/stable/c/0f514068fbc5d4d189c817adc7c4e32cffdc2e47"
    ],
    "受影响版本": [
      "f20387dfd065693ba7ea2788a2f893bf653c9cb8",
      "f20387dfd065693ba7ea2788a2f893bf653c9cb8",
      "f20387dfd065693ba7ea2788a2f893bf653c9cb8",
      "f20387dfd065693ba7ea2788a2f893bf653c9cb8",
      "f20387dfd065693ba7ea2788a2f893bf653c9cb8",
      "f20387dfd065693ba7ea2788a2f893bf653c9cb8",
      "f20387dfd065693ba7ea2788a2f893bf653c9cb8"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56566",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slub: Avoid list corruption when removing a slab from the full list\n\nBoot with slub_debug=UFPZ.\n\nIf allocated object failed in alloc_consistency_checks, all objects of\nthe slab will be marked as used, and then the slab will be removed from\nthe partial list.\n\nWhen an object belonging to the slab got freed later, the remove_full()\nfunction is called. Because the slab is neither on the partial list nor\non the full list, it eventually lead to a list corruption (actually a\nlist poison being detected).\n\nSo we need to mark and isolate the slab page with metadata corruption,\ndo not put it back in circulation.\n\nBecause the debug caches avoid all the fastpaths, reusing the frozen bit\nto mark slab page with metadata corruption seems to be fine.\n\n[ 4277.385669] list_del corruption, ffffea00044b3e50->next is LIST_POISON1 (dead000000000100)\n[ 4277.387023] ------------[ cut here ]------------\n[ 4277.387880] kernel BUG at lib/list_debug.c:56!\n[ 4277.388680] invalid opcode: 0000 [#1] PREEMPT SMP PTI\n[ 4277.389562] CPU: 5 PID: 90 Comm: kworker/5:1 Kdump: loaded Tainted: G           OE      6.6.1-1 #1\n[ 4277.392113] Workqueue: xfs-inodegc/vda1 xfs_inodegc_worker [xfs]\n[ 4277.393551] RIP: 0010:__list_del_entry_valid_or_report+0x7b/0xc0\n[ 4277.394518] Code: 48 91 82 e8 37 f9 9a ff 0f 0b 48 89 fe 48 c7 c7 28 49 91 82 e8 26 f9 9a ff 0f 0b 48 89 fe 48 c7 c7 58 49 91\n[ 4277.397292] RSP: 0018:ffffc90000333b38 EFLAGS: 00010082\n[ 4277.398202] RAX: 000000000000004e RBX: ffffea00044b3e50 RCX: 0000000000000000\n[ 4277.399340] RDX: 0000000000000002 RSI: ffffffff828f8715 RDI: 00000000ffffffff\n[ 4277.400545] RBP: ffffea00044b3e40 R08: 0000000000000000 R09: ffffc900003339f0\n[ 4277.401710] R10: 0000000000000003 R11: ffffffff82d44088 R12: ffff888112cf9910\n[ 4277.402887] R13: 0000000000000001 R14: 0000000000000001 R15: ffff8881000424c0\n[ 4277.404049] FS:  0000000000000000(0000) GS:ffff88842fd40000(0000) knlGS:0000000000000000\n[ 4277.405357] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 4277.406389] CR2: 00007f2ad0b24000 CR3: 0000000102a3a006 CR4: 00000000007706e0\n[ 4277.407589] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 4277.408780] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ 4277.410000] PKRU: 55555554\n[ 4277.410645] Call Trace:\n[ 4277.411234]  <TASK>\n[ 4277.411777]  ? die+0x32/0x80\n[ 4277.412439]  ? do_trap+0xd6/0x100\n[ 4277.413150]  ? __list_del_entry_valid_or_report+0x7b/0xc0\n[ 4277.414158]  ? do_error_trap+0x6a/0x90\n[ 4277.414948]  ? __list_del_entry_valid_or_report+0x7b/0xc0\n[ 4277.415915]  ? exc_invalid_op+0x4c/0x60\n[ 4277.416710]  ? __list_del_entry_valid_or_report+0x7b/0xc0\n[ 4277.417675]  ? asm_exc_invalid_op+0x16/0x20\n[ 4277.418482]  ? __list_del_entry_valid_or_report+0x7b/0xc0\n[ 4277.419466]  ? __list_del_entry_valid_or_report+0x7b/0xc0\n[ 4277.420410]  free_to_partial_list+0x515/0x5e0\n[ 4277.421242]  ? xfs_iext_remove+0x41a/0xa10 [xfs]\n[ 4277.422298]  xfs_iext_remove+0x41a/0xa10 [xfs]\n[ 4277.423316]  ? xfs_inodegc_worker+0xb4/0x1a0 [xfs]\n[ 4277.424383]  xfs_bmap_del_extent_delay+0x4fe/0x7d0 [xfs]\n[ 4277.425490]  __xfs_bunmapi+0x50d/0x840 [xfs]\n[ 4277.426445]  xfs_itruncate_extents_flags+0x13a/0x490 [xfs]\n[ 4277.427553]  xfs_inactive_truncate+0xa3/0x120 [xfs]\n[ 4277.428567]  xfs_inactive+0x22d/0x290 [xfs]\n[ 4277.429500]  xfs_inodegc_worker+0xb4/0x1a0 [xfs]\n[ 4277.430479]  process_one_work+0x171/0x340\n[ 4277.431227]  worker_thread+0x277/0x390\n[ 4277.431962]  ? __pfx_worker_thread+0x10/0x10\n[ 4277.432752]  kthread+0xf0/0x120\n[ 4277.433382]  ? __pfx_kthread+0x10/0x10\n[ 4277.434134]  ret_from_fork+0x2d/0x50\n[ 4277.434837]  ? __pfx_kthread+0x10/0x10\n[ 4277.435566]  ret_from_fork_asm+0x1b/0x30\n[ 4277.436280]  </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/33a213c04faff6c3a7fe77e947db81bc7270fe32",
      "https://git.kernel.org/stable/c/943c0f601cd28c1073b92b5f944c6c6c2643e709",
      "https://git.kernel.org/stable/c/dbc16915279a548a204154368da23d402c141c81"
    ],
    "受影响版本": [
      "643b113849d8faa68c9f01c3c9d929bfbffd50bd",
      "643b113849d8faa68c9f01c3c9d929bfbffd50bd",
      "643b113849d8faa68c9f01c3c9d929bfbffd50bd"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56565",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to drop all discards after creating snapshot on lvm device\n\nPiergiorgio reported a bug in bugzilla as below:\n\n------------[ cut here ]------------\nWARNING: CPU: 2 PID: 969 at fs/f2fs/segment.c:1330\nRIP: 0010:__submit_discard_cmd+0x27d/0x400 [f2fs]\nCall Trace:\n __issue_discard_cmd+0x1ca/0x350 [f2fs]\n issue_discard_thread+0x191/0x480 [f2fs]\n kthread+0xcf/0x100\n ret_from_fork+0x31/0x50\n ret_from_fork_asm+0x1a/0x30\n\nw/ below testcase, it can reproduce this bug quickly:\n- pvcreate /dev/vdb\n- vgcreate myvg1 /dev/vdb\n- lvcreate -L 1024m -n mylv1 myvg1\n- mount /dev/myvg1/mylv1 /mnt/f2fs\n- dd if=/dev/zero of=/mnt/f2fs/file bs=1M count=20\n- sync\n- rm /mnt/f2fs/file\n- sync\n- lvcreate -L 1024m -s -n mylv1-snapshot /dev/myvg1/mylv1\n- umount /mnt/f2fs\n\nThe root cause is: it will update discard_max_bytes of mounted lvm\ndevice to zero after creating snapshot on this lvm device, then,\n__submit_discard_cmd() will pass parameter @nr_sects w/ zero value\nto __blkdev_issue_discard(), it returns a NULL bio pointer, result\nin panic.\n\nThis patch changes as below for fixing:\n1. Let's drop all remained discards in f2fs_unfreeze() if snapshot\nof lvm device is created.\n2. Checking discard_max_bytes before submitting discard during\n__submit_discard_cmd().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ed24ab98242f8d22b66fbe0452c97751b5ea4e22",
      "https://git.kernel.org/stable/c/15136c3861a3341db261ebdbb6ae4ae1765635e2",
      "https://git.kernel.org/stable/c/bc8aeb04fd80cb8cfae3058445c84410fd0beb5e"
    ],
    "受影响版本": [
      "35ec7d5748849762008e8ae9f8ad2766229d5794",
      "35ec7d5748849762008e8ae9f8ad2766229d5794",
      "35ec7d5748849762008e8ae9f8ad2766229d5794"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56562",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni3c: master: Fix miss free init_dyn_addr at i3c_master_put_i3c_addrs()\n\nif (dev->boardinfo && dev->boardinfo->init_dyn_addr)\n                                      ^^^ here check \"init_dyn_addr\"\n\ti3c_bus_set_addr_slot_status(&master->bus, dev->info.dyn_addr, ...)\n\t\t\t\t\t\t             ^^^^\n\t\t\t\t\t\t\tfree \"dyn_addr\"\nFix copy/paste error \"dyn_addr\" by replacing it with \"init_dyn_addr\".",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c2f0ce241154b04f2fc150ff16ad82d9b8fdfa4a",
      "https://git.kernel.org/stable/c/093ecc6d82ff1d2e0cbf6f2000438b6c698145cb",
      "https://git.kernel.org/stable/c/0cb21f1ea3a2e19ee314a8fcf95461b5c453c59e",
      "https://git.kernel.org/stable/c/991e33a99fd3b5d432f0629565f532f563fe019a",
      "https://git.kernel.org/stable/c/ce30d11b39e8d637fed4704a5b43e9d556990475",
      "https://git.kernel.org/stable/c/0e8ab955c6d06f9d907761c07c02d1492f0a8ac1",
      "https://git.kernel.org/stable/c/3082990592f7c6d7510a9133afa46e31bbe26533"
    ],
    "受影响版本": [
      "3a379bbcea0af6280e1ca0d1edfcf4e68cde6ee0",
      "3a379bbcea0af6280e1ca0d1edfcf4e68cde6ee0",
      "3a379bbcea0af6280e1ca0d1edfcf4e68cde6ee0",
      "3a379bbcea0af6280e1ca0d1edfcf4e68cde6ee0",
      "3a379bbcea0af6280e1ca0d1edfcf4e68cde6ee0",
      "3a379bbcea0af6280e1ca0d1edfcf4e68cde6ee0",
      "3a379bbcea0af6280e1ca0d1edfcf4e68cde6ee0"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56558",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: make sure exp active before svc_export_show\n\nThe function `e_show` was called with protection from RCU. This only\nensures that `exp` will not be freed. Therefore, the reference count for\n`exp` can drop to zero, which will trigger a refcount use-after-free\nwarning when `exp_get` is called. To resolve this issue, use\n`cache_get_rcu` to ensure that `exp` remains active.\n\n------------[ cut here ]------------\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 3 PID: 819 at lib/refcount.c:25\nrefcount_warn_saturate+0xb1/0x120\nCPU: 3 UID: 0 PID: 819 Comm: cat Not tainted 6.12.0-rc3+ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.1-2.fc37 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xb1/0x120\n...\nCall Trace:\n <TASK>\n e_show+0x20b/0x230 [nfsd]\n seq_read_iter+0x589/0x770\n seq_read+0x1e5/0x270\n vfs_read+0x125/0x530\n ksys_read+0xc1/0x160\n do_syscall_64+0x5f/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e2fa0d0e327279a8defb87b263cd0bf288fd9261",
      "https://git.kernel.org/stable/c/7fd29d284b55c2274f7a748e6c5f25b4758b8da5",
      "https://git.kernel.org/stable/c/6cefcadd34e3c71c81ea64b899a0daa86314a51a",
      "https://git.kernel.org/stable/c/7d8f7816bebcd2e7400bb4d786eccb8f33c9f9ec",
      "https://git.kernel.org/stable/c/1cecfdbc6bfc89c516d286884c7f29267b95de2b",
      "https://git.kernel.org/stable/c/7365d1f8de63cffdbbaa2287ce0205438e1a922f",
      "https://git.kernel.org/stable/c/be8f982c369c965faffa198b46060f8853e0f1f0"
    ],
    "受影响版本": [
      "bf18f163e89c52e09c96534db45c4274273a0b34",
      "bf18f163e89c52e09c96534db45c4274273a0b34",
      "bf18f163e89c52e09c96534db45c4274273a0b34",
      "bf18f163e89c52e09c96534db45c4274273a0b34",
      "bf18f163e89c52e09c96534db45c4274273a0b34",
      "bf18f163e89c52e09c96534db45c4274273a0b34",
      "bf18f163e89c52e09c96534db45c4274273a0b34"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56545",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: hyperv: streamline driver probe to avoid devres issues\n\nIt was found that unloading 'hid_hyperv' module results in a devres\ncomplaint:\n\n ...\n hv_vmbus: unregistering driver hid_hyperv\n ------------[ cut here ]------------\n WARNING: CPU: 2 PID: 3983 at drivers/base/devres.c:691 devres_release_group+0x1f2/0x2c0\n ...\n Call Trace:\n  <TASK>\n  ? devres_release_group+0x1f2/0x2c0\n  ? __warn+0xd1/0x1c0\n  ? devres_release_group+0x1f2/0x2c0\n  ? report_bug+0x32a/0x3c0\n  ? handle_bug+0x53/0xa0\n  ? exc_invalid_op+0x18/0x50\n  ? asm_exc_invalid_op+0x1a/0x20\n  ? devres_release_group+0x1f2/0x2c0\n  ? devres_release_group+0x90/0x2c0\n  ? rcu_is_watching+0x15/0xb0\n  ? __pfx_devres_release_group+0x10/0x10\n  hid_device_remove+0xf5/0x220\n  device_release_driver_internal+0x371/0x540\n  ? klist_put+0xf3/0x170\n  bus_remove_device+0x1f1/0x3f0\n  device_del+0x33f/0x8c0\n  ? __pfx_device_del+0x10/0x10\n  ? cleanup_srcu_struct+0x337/0x500\n  hid_destroy_device+0xc8/0x130\n  mousevsc_remove+0xd2/0x1d0 [hid_hyperv]\n  device_release_driver_internal+0x371/0x540\n  driver_detach+0xc5/0x180\n  bus_remove_driver+0x11e/0x2a0\n  ? __mutex_unlock_slowpath+0x160/0x5e0\n  vmbus_driver_unregister+0x62/0x2b0 [hv_vmbus]\n  ...\n\nAnd the issue seems to be that the corresponding devres group is not\nallocated. Normally, devres_open_group() is called from\n__hid_device_probe() but Hyper-V HID driver overrides 'hid_dev->driver'\nwith 'mousevsc_hid_driver' stub and basically re-implements\n__hid_device_probe() by calling hid_parse() and hid_hw_start() but not\ndevres_open_group(). hid_device_probe() does not call __hid_device_probe()\nfor it. Later, when the driver is removed, hid_device_remove() calls\ndevres_release_group() as it doesn't check whether hdev->driver was\ninitially overridden or not.\n\nThe issue seems to be related to the commit 62c68e7cee33 (\"HID: ensure\ntimely release of driver-allocated resources\") but the commit itself seems\nto be correct.\n\nFix the issue by dropping the 'hid_dev->driver' override and using\nhid_register_driver()/hid_unregister_driver() instead. Alternatively, it\nwould have been possible to rely on the default handling but\nHID_CONNECT_DEFAULT implies HID_CONNECT_HIDRAW and it doesn't seem to work\nfor mousevsc as-is.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b03e713a400aeb5f969bab4daf47a7402d0df814",
      "https://git.kernel.org/stable/c/19a9457e5e210e408c1f8865b5d93c5a2c90409d",
      "https://git.kernel.org/stable/c/3d48d0fbaaa74a04fb9092780a3f83dc4f3f8160",
      "https://git.kernel.org/stable/c/66ef47faa90d838cda131fe1f7776456cc3b59f2"
    ],
    "受影响版本": [
      "62c68e7cee332e08e625af3bca3318814086490d",
      "62c68e7cee332e08e625af3bca3318814086490d",
      "62c68e7cee332e08e625af3bca3318814086490d",
      "62c68e7cee332e08e625af3bca3318814086490d"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56544",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nudmabuf: change folios array from kmalloc to kvmalloc\n\nWhen PAGE_SIZE 4096, MAX_PAGE_ORDER 10, 64bit machine,\npage_alloc only support 4MB.\nIf above this, trigger this warn and return NULL.\n\nudmabuf can change size limit, if change it to 3072(3GB), and then alloc\n3GB udmabuf, will fail create.\n\n[ 4080.876581] ------------[ cut here ]------------\n[ 4080.876843] WARNING: CPU: 3 PID: 2015 at mm/page_alloc.c:4556 __alloc_pages+0x2c8/0x350\n[ 4080.878839] RIP: 0010:__alloc_pages+0x2c8/0x350\n[ 4080.879470] Call Trace:\n[ 4080.879473]  <TASK>\n[ 4080.879473]  ? __alloc_pages+0x2c8/0x350\n[ 4080.879475]  ? __warn.cold+0x8e/0xe8\n[ 4080.880647]  ? __alloc_pages+0x2c8/0x350\n[ 4080.880909]  ? report_bug+0xff/0x140\n[ 4080.881175]  ? handle_bug+0x3c/0x80\n[ 4080.881556]  ? exc_invalid_op+0x17/0x70\n[ 4080.881559]  ? asm_exc_invalid_op+0x1a/0x20\n[ 4080.882077]  ? udmabuf_create+0x131/0x400\n\nBecause MAX_PAGE_ORDER, kmalloc can max alloc 4096 * (1 << 10), 4MB\nmemory, each array entry is pointer(8byte), so can save 524288 pages(2GB).\n\nFurther more, costly order(order 3) may not be guaranteed that it can be\napplied for, due to fragmentation.\n\nThis patch change udmabuf array use kvmalloc_array, this can fallback\nalloc into vmalloc, which can guarantee allocation for any size and does\nnot affect the performance of kmalloc allocations.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2acc6192aa8570661ed37868c02c03002b1dc290",
      "https://git.kernel.org/stable/c/85bb72397cb63649fe493c96e27e1d0e4ed2ff63",
      "https://git.kernel.org/stable/c/1c0844c6184e658064e14c4335885785ad3bf84b"
    ],
    "受影响版本": [
      "fbb0de795078190a9834b3409e4b009cfb18a6d4",
      "fbb0de795078190a9834b3409e4b009cfb18a6d4",
      "fbb0de795078190a9834b3409e4b009cfb18a6d4"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-56539",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: Fix memcpy() field-spanning write warning in mwifiex_config_scan()\n\nReplace one-element array with a flexible-array member in `struct\nmwifiex_ie_types_wildcard_ssid_params` to fix the following warning\non a MT8173 Chromebook (mt8173-elm-hana):\n\n[  356.775250] ------------[ cut here ]------------\n[  356.784543] memcpy: detected field-spanning write (size 6) of single field \"wildcard_ssid_tlv->ssid\" at drivers/net/wireless/marvell/mwifiex/scan.c:904 (size 1)\n[  356.813403] WARNING: CPU: 3 PID: 742 at drivers/net/wireless/marvell/mwifiex/scan.c:904 mwifiex_scan_networks+0x4fc/0xf28 [mwifiex]\n\nThe \"(size 6)\" above is exactly the length of the SSID of the network\nthis device was connected to. The source of the warning looks like:\n\n    ssid_len = user_scan_in->ssid_list[i].ssid_len;\n    [...]\n    memcpy(wildcard_ssid_tlv->ssid,\n           user_scan_in->ssid_list[i].ssid, ssid_len);\n\nThere is a #define WILDCARD_SSID_TLV_MAX_SIZE that uses sizeof() on this\nstruct, but it already didn't account for the size of the one-element\narray, so it doesn't need to be changed.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a09760c513ae0f98c7082a1deace7fb6284ee866",
      "https://git.kernel.org/stable/c/1de0ca1d7320a645ba2ee5954f64be08935b002a",
      "https://git.kernel.org/stable/c/5fa329c44e1e635da2541eab28b6cdb8464fc8d1",
      "https://git.kernel.org/stable/c/581261b2d6fdb4237b24fa13f5a5f87bf2861f2c",
      "https://git.kernel.org/stable/c/b466746cfb6be43f9a1457bbee52ade397fb23ea",
      "https://git.kernel.org/stable/c/c4698ef8c42e02782604bf4f8a489dbf6b0c1365",
      "https://git.kernel.org/stable/c/e2de22e4b6213371d9e76f74a10ce817572a8d74",
      "https://git.kernel.org/stable/c/d7774910c5583e61c5fe2571280366624ef48036",
      "https://git.kernel.org/stable/c/d241a139c2e9f8a479f25c75ebd5391e6a448500"
    ],
    "受影响版本": [
      "5e6e3a92b9a4c9416b17f468fa5c7fa2233b8b4e",
      "5e6e3a92b9a4c9416b17f468fa5c7fa2233b8b4e",
      "5e6e3a92b9a4c9416b17f468fa5c7fa2233b8b4e",
      "5e6e3a92b9a4c9416b17f468fa5c7fa2233b8b4e",
      "5e6e3a92b9a4c9416b17f468fa5c7fa2233b8b4e",
      "5e6e3a92b9a4c9416b17f468fa5c7fa2233b8b4e",
      "5e6e3a92b9a4c9416b17f468fa5c7fa2233b8b4e",
      "5e6e3a92b9a4c9416b17f468fa5c7fa2233b8b4e",
      "5e6e3a92b9a4c9416b17f468fa5c7fa2233b8b4e"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "t2bot",
    "设备类型": "OTA",
    "产品型号": "matrix-media-repo",
    "CVE编号": "CVE-2024-56515",
    "漏洞描述": "Matrix Media Repo (MMR) is a highly configurable multi-homeserver media repository for Matrix. If SVG or JPEGXL thumbnailers are enabled (they are disabled by default), a user may upload a file which claims to be either of these types and request a thumbnail to invoke a different decoder in ImageMagick. In some ImageMagick installations, this includes the capability to run Ghostscript to decode the image/file. If MP4 thumbnailers are enabled (also disabled by default), the same issue as above may occur with the ffmpeg installation instead. MMR uses a number of other decoders for all other file types when preparing thumbnails. Theoretical issues are possible with these decoders, however in testing they were not possible to exploit. This is fixed in MMR v1.3.8. MMR now inspects the mimetype of media prior to thumbnailing, and picks a thumbnailer based on those results instead of relying on user-supplied values. This may lead to fewer thumbnails when obscure file shapes are used. This also helps narrow scope of theoretical issues with all decoders MMR uses for thumbnails. Users are advised to upgrade. Users unable to upgrade may disable the SVG, JPEGXL, and MP4 thumbnail types in the MMR config which prevents the decoders from being invoked. Further disabling uncommon file types on the server is recommended to limit risk surface. Containers and other similar technologies may also be used to limit the impact of vulnerabilities in external decoders, like ImageMagick and ffmpeg. Some installations of ImageMagick may disable \"unsafe\" file types, like PDFs, already. This option can be replicated to other environments as needed. ffmpeg may be compiled with limited decoders/codecs. The Docker image for MMR disables PDFs and similar formats by default.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/t2bot/matrix-media-repo/security/advisories/GHSA-rcxc-wjgw-579r",
      "https://github.com/t2bot/matrix-media-repo/releases/tag/v1.3.8"
    ],
    "受影响版本": [
      "< 1.3.8"
    ],
    "公开日期": "2025年01月16日"
  },
  {
    "设备品牌": "InseeFrLab",
    "设备类型": "OTA",
    "产品型号": "onyxia",
    "CVE编号": "CVE-2024-56333",
    "漏洞描述": "Onyxia is a web app that aims at being the glue between multiple open source backend technologies to provide a state of art working environment for data scientists. This critical vulnerability allows authenticated users to remotely execute code within the Onyxia-API, leading to potential consequences such as unauthorized access to other user environments and denial of service attacks. This issue has been patched in api versions 4.2.0, 3.1.1, and 2.8.2. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/InseeFrLab/onyxia/security/advisories/GHSA-qmcw-h4f9-j3h3",
      "https://docs.onyxia.sh/vulnerability-disclosure/known-vulnerabilities/vulnerability-20241219"
    ],
    "受影响版本": [
      "< 2.8.2",
      ">= 3.0.0, < 3.1.1",
      ">= 4.0.0, < 4.2.0"
    ],
    "公开日期": "2024年12月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-55881",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Play nice with protected guests in complete_hypercall_exit()\n\nUse is_64_bit_hypercall() instead of is_64_bit_mode() to detect a 64-bit\nhypercall when completing said hypercall.  For guests with protected state,\ne.g. SEV-ES and SEV-SNP, KVM must assume the hypercall was made in 64-bit\nmode as the vCPU state needed to detect 64-bit mode is unavailable.\n\nHacking the sev_smoke_test selftest to generate a KVM_HC_MAP_GPA_RANGE\nhypercall via VMGEXIT trips the WARN:\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 273 PID: 326626 at arch/x86/kvm/x86.h:180 complete_hypercall_exit+0x44/0xe0 [kvm]\n  Modules linked in: kvm_amd kvm ... [last unloaded: kvm]\n  CPU: 273 UID: 0 PID: 326626 Comm: sev_smoke_test Not tainted 6.12.0-smp--392e932fa0f3-feat #470\n  Hardware name: Google Astoria/astoria, BIOS 0.20240617.0-0 06/17/2024\n  RIP: 0010:complete_hypercall_exit+0x44/0xe0 [kvm]\n  Call Trace:\n   <TASK>\n   kvm_arch_vcpu_ioctl_run+0x2400/0x2720 [kvm]\n   kvm_vcpu_ioctl+0x54f/0x630 [kvm]\n   __se_sys_ioctl+0x6b/0xc0\n   do_syscall_64+0x83/0x160\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n   </TASK>\n  ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0840d360a8909c722fb62459f42836afe32ededb",
      "https://git.kernel.org/stable/c/7ed4db315094963de0678a8adfd43c46471b9349",
      "https://git.kernel.org/stable/c/3d2634ec0d1dbe8f4b511cf5261f327c6a76f4b6",
      "https://git.kernel.org/stable/c/22b5c2acd65dbe949032f619d4758a35a82fffc3",
      "https://git.kernel.org/stable/c/9b42d1e8e4fe9dc631162c04caa69b0d1860b0f0"
    ],
    "受影响版本": [
      "5969e2435cbd7f0ce8c28d717bfc39987ee8d8f1",
      "b5aead0064f33ae5e693a364e3204fe1c0ac9af2",
      "b5aead0064f33ae5e693a364e3204fe1c0ac9af2",
      "b5aead0064f33ae5e693a364e3204fe1c0ac9af2",
      "b5aead0064f33ae5e693a364e3204fe1c0ac9af2"
    ],
    "公开日期": "2025年01月11日"
  },
  {
    "设备品牌": "WebOccult Technologies Pvt Ltd",
    "设备类型": "OTA",
    "产品型号": "Wot Elementor Widgets",
    "CVE编号": "CVE-2024-54228",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in WebOccult Technologies Pvt Ltd Wot Elementor Widgets allows DOM-Based XSS.This issue affects Wot Elementor Widgets: from n/a through 1.0.1.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/wot-elementor-widgets/vulnerability/wordpress-wot-elementor-widgets-plugin-1-0-1-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年12月09日"
  },
  {
    "设备品牌": "pnpm",
    "设备类型": "OTA",
    "产品型号": "pnpm",
    "CVE编号": "CVE-2024-53866",
    "漏洞描述": "The package manager pnpm prior to version 9.15.0 seems to mishandle overrides and global cache: Overrides from one workspace leak into npm metadata saved in global cache; npm metadata from global cache affects other workspaces; and installs by default don't revalidate the data (including on first lockfile generation). This can make workspace A (even running with `ignore-scripts=true`) posion global cache and execute scripts in workspace B. Users generally expect `ignore-scripts` to be sufficient to prevent immediate code execution on install (e.g. when the tree is just repacked/bundled without executing it). Here, that expectation is broken. Global state integrity is lost via operations that one would expect to be secure, enabling subsequently running arbitrary code execution on installs. Version 9.15.0 fixes the issue. As a work-around, use separate cache and store dirs in each workspace.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/pnpm/pnpm/security/advisories/GHSA-vm32-9rqf-rh3r",
      "https://github.com/pnpm/pnpm/commit/11afcddea48f25ed5117a87dc1780a55222b9743"
    ],
    "受影响版本": [
      "< 9.15.0"
    ],
    "公开日期": "2024年12月10日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53220",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to account dirty data in __get_secs_required()\n\nIt will trigger system panic w/ testcase in [1]:\n\n------------[ cut here ]------------\nkernel BUG at fs/f2fs/segment.c:2752!\nRIP: 0010:new_curseg+0xc81/0x2110\nCall Trace:\n f2fs_allocate_data_block+0x1c91/0x4540\n do_write_page+0x163/0xdf0\n f2fs_outplace_write_data+0x1aa/0x340\n f2fs_do_write_data_page+0x797/0x2280\n f2fs_write_single_data_page+0x16cd/0x2190\n f2fs_write_cache_pages+0x994/0x1c80\n f2fs_write_data_pages+0x9cc/0xea0\n do_writepages+0x194/0x7a0\n filemap_fdatawrite_wbc+0x12b/0x1a0\n __filemap_fdatawrite_range+0xbb/0xf0\n file_write_and_wait_range+0xa1/0x110\n f2fs_do_sync_file+0x26f/0x1c50\n f2fs_sync_file+0x12b/0x1d0\n vfs_fsync_range+0xfa/0x230\n do_fsync+0x3d/0x80\n __x64_sys_fsync+0x37/0x50\n x64_sys_call+0x1e88/0x20d0\n do_syscall_64+0x4b/0x110\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nThe root cause is if checkpoint_disabling and lfs_mode are both on,\nit will trigger OPU for all overwritten data, it may cost more free\nsegment than expected, so f2fs must account those data correctly to\ncalculate cosumed free segments later, and return ENOSPC earlier to\navoid run out of free segment during block allocation.\n\n[1] https://lore.kernel.org/fstests/20241015025106.3203676-1-chao@kernel.org/",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6e58b2987960efcd917bc42da781cee256213618",
      "https://git.kernel.org/stable/c/f1b8bfe8d2f2fdf905d37c174d5bc1cd2b6910c5",
      "https://git.kernel.org/stable/c/9313b85ddc120e2d2f0efaf86d0204d4c98d60b1",
      "https://git.kernel.org/stable/c/e812871c068cc0f91ff9f5cee87d00df1c44aae4",
      "https://git.kernel.org/stable/c/1acd73edbbfef2c3c5b43cba4006a7797eca7050"
    ],
    "受影响版本": [
      "4354994f097d068a894aa1a0860da54571df3582",
      "4354994f097d068a894aa1a0860da54571df3582",
      "4354994f097d068a894aa1a0860da54571df3582",
      "4354994f097d068a894aa1a0860da54571df3582",
      "4354994f097d068a894aa1a0860da54571df3582"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53219",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtiofs: use pages instead of pointer for kernel direct IO\n\nWhen trying to insert a 10MB kernel module kept in a virtio-fs with cache\ndisabled, the following warning was reported:\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 1 PID: 404 at mm/page_alloc.c:4551 ......\n  Modules linked in:\n  CPU: 1 PID: 404 Comm: insmod Not tainted 6.9.0-rc5+ #123\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996) ......\n  RIP: 0010:__alloc_pages+0x2bf/0x380\n  ......\n  Call Trace:\n   <TASK>\n   ? __warn+0x8e/0x150\n   ? __alloc_pages+0x2bf/0x380\n   __kmalloc_large_node+0x86/0x160\n   __kmalloc+0x33c/0x480\n   virtio_fs_enqueue_req+0x240/0x6d0\n   virtio_fs_wake_pending_and_unlock+0x7f/0x190\n   queue_request_and_unlock+0x55/0x60\n   fuse_simple_request+0x152/0x2b0\n   fuse_direct_io+0x5d2/0x8c0\n   fuse_file_read_iter+0x121/0x160\n   __kernel_read+0x151/0x2d0\n   kernel_read+0x45/0x50\n   kernel_read_file+0x1a9/0x2a0\n   init_module_from_file+0x6a/0xe0\n   idempotent_init_module+0x175/0x230\n   __x64_sys_finit_module+0x5d/0xb0\n   x64_sys_call+0x1c3/0x9e0\n   do_syscall_64+0x3d/0xc0\n   entry_SYSCALL_64_after_hwframe+0x4b/0x53\n   ......\n   </TASK>\n  ---[ end trace 0000000000000000 ]---\n\nThe warning is triggered as follows:\n\n1) syscall finit_module() handles the module insertion and it invokes\nkernel_read_file() to read the content of the module first.\n\n2) kernel_read_file() allocates a 10MB buffer by using vmalloc() and\npasses it to kernel_read(). kernel_read() constructs a kvec iter by\nusing iov_iter_kvec() and passes it to fuse_file_read_iter().\n\n3) virtio-fs disables the cache, so fuse_file_read_iter() invokes\nfuse_direct_io(). As for now, the maximal read size for kvec iter is\nonly limited by fc->max_read. For virtio-fs, max_read is UINT_MAX, so\nfuse_direct_io() doesn't split the 10MB buffer. It saves the address and\nthe size of the 10MB-sized buffer in out_args[0] of a fuse request and\npasses the fuse request to virtio_fs_wake_pending_and_unlock().\n\n4) virtio_fs_wake_pending_and_unlock() uses virtio_fs_enqueue_req() to\nqueue the request. Because virtiofs need DMA-able address, so\nvirtio_fs_enqueue_req() uses kmalloc() to allocate a bounce buffer for\nall fuse args, copies these args into the bounce buffer and passed the\nphysical address of the bounce buffer to virtiofsd. The total length of\nthese fuse args for the passed fuse request is about 10MB, so\ncopy_args_to_argbuf() invokes kmalloc() with a 10MB size parameter and\nit triggers the warning in __alloc_pages():\n\n\tif (WARN_ON_ONCE_GFP(order > MAX_PAGE_ORDER, gfp))\n\t\treturn NULL;\n\n5) virtio_fs_enqueue_req() will retry the memory allocation in a\nkworker, but it won't help, because kmalloc() will always return NULL\ndue to the abnormal size and finit_module() will hang forever.\n\nA feasible solution is to limit the value of max_read for virtio-fs, so\nthe length passed to kmalloc() will be limited. However it will affect\nthe maximal read size for normal read. And for virtio-fs write initiated\nfrom kernel, it has the similar problem but now there is no way to limit\nfc->max_write in kernel.\n\nSo instead of limiting both the values of max_read and max_write in\nkernel, introducing use_pages_for_kvec_io in fuse_conn and setting it as\ntrue in virtiofs. When use_pages_for_kvec_io is enabled, fuse will use\npages instead of pointer to pass the KVEC_IO data.\n\nAfter switching to pages for KVEC_IO data, these pages will be used for\nDMA through virtio-fs. If these pages are backed by vmalloc(),\n{flush|invalidate}_kernel_vmap_range() are necessary to flush or\ninvalidate the cache before the DMA operation. So add two new fields in\nfuse_args_pages to record the base address of vmalloc area and the\ncondition indicating whether invalidation is needed. Perform the flush\nin fuse_get_user_pages() for write operations and the invalidation in\nfuse_release_user_pages() for read operations.\n\nIt may seem necessary to introduce another fie\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9a8fde56d4b6d51930936ed50f6370a9097328d1",
      "https://git.kernel.org/stable/c/2bc07714dc955a91d2923a440ea02c3cb3376b10",
      "https://git.kernel.org/stable/c/41748675c0bf252b3c5f600a95830f0936d366c1"
    ],
    "受影响版本": [
      "a62a8ef9d97da23762a588592c8b8eb50a8deb6a",
      "a62a8ef9d97da23762a588592c8b8eb50a8deb6a",
      "a62a8ef9d97da23762a588592c8b8eb50a8deb6a"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53202",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirmware_loader: Fix possible resource leak in fw_log_firmware_info()\n\nThe alg instance should be released under the exception path, otherwise\nthere may be resource leak here.\n\nTo mitigate this, free the alg instance with crypto_free_shash when kmalloc\nfails.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/789a72498d32f88d24371c10985aceb46397056c",
      "https://git.kernel.org/stable/c/eb5d67d00ad17a5bd0920f455160dc2ccbd2dc78",
      "https://git.kernel.org/stable/c/f380f895dbb2a11d62ca6df9e82d995f4bc26b84",
      "https://git.kernel.org/stable/c/369a9c046c2fdfe037f05b43b84c386bdbccc103"
    ],
    "受影响版本": [
      "02fe26f25325b547b7a31a65deb0326c04bb5174",
      "02fe26f25325b547b7a31a65deb0326c04bb5174",
      "02fe26f25325b547b7a31a65deb0326c04bb5174",
      "02fe26f25325b547b7a31a65deb0326c04bb5174"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53190",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtlwifi: Drastically reduce the attempts to read efuse in case of failures\n\nSyzkaller reported a hung task with uevent_show() on stack trace. That\nspecific issue was addressed by another commit [0], but even with that\nfix applied (for example, running v6.12-rc5) we face another type of hung\ntask that comes from the same reproducer [1]. By investigating that, we\ncould narrow it to the following path:\n\n(a) Syzkaller emulates a Realtek USB WiFi adapter using raw-gadget and\ndummy_hcd infrastructure.\n\n(b) During the probe of rtl8192cu, the driver ends-up performing an efuse\nread procedure (which is related to EEPROM load IIUC), and here lies the\nissue: the function read_efuse() calls read_efuse_byte() many times, as\nloop iterations depending on the efuse size (in our example, 512 in total).\n\nThis procedure for reading efuse bytes relies in a loop that performs an\nI/O read up to *10k* times in case of failures. We measured the time of\nthe loop inside read_efuse_byte() alone, and in this reproducer (which\ninvolves the dummy_hcd emulation layer), it takes 15 seconds each. As a\nconsequence, we have the driver stuck in its probe routine for big time,\nexposing a stack trace like below if we attempt to reboot the system, for\nexample:\n\ntask:kworker/0:3 state:D stack:0 pid:662 tgid:662 ppid:2 flags:0x00004000\nWorkqueue: usb_hub_wq hub_event\nCall Trace:\n __schedule+0xe22/0xeb6\n schedule_timeout+0xe7/0x132\n __wait_for_common+0xb5/0x12e\n usb_start_wait_urb+0xc5/0x1ef\n ? usb_alloc_urb+0x95/0xa4\n usb_control_msg+0xff/0x184\n _usbctrl_vendorreq_sync+0xa0/0x161\n _usb_read_sync+0xb3/0xc5\n read_efuse_byte+0x13c/0x146\n read_efuse+0x351/0x5f0\n efuse_read_all_map+0x42/0x52\n rtl_efuse_shadow_map_update+0x60/0xef\n rtl_get_hwinfo+0x5d/0x1c2\n rtl92cu_read_eeprom_info+0x10a/0x8d5\n ? rtl92c_read_chip_version+0x14f/0x17e\n rtl_usb_probe+0x323/0x851\n usb_probe_interface+0x278/0x34b\n really_probe+0x202/0x4a4\n __driver_probe_device+0x166/0x1b2\n driver_probe_device+0x2f/0xd8\n [...]\n\nWe propose hereby to drastically reduce the attempts of doing the I/O\nreads in case of failures, restricted to USB devices (given that\nthey're inherently slower than PCIe ones). By retrying up to 10 times\n(instead of 10000), we got reponsiveness in the reproducer, while seems\nreasonable to believe that there's no sane USB device implementation in\nthe field requiring this amount of retries at every I/O read in order\nto properly work. Based on that assumption, it'd be good to have it\nbackported to stable but maybe not since driver implementation (the 10k\nnumber comes from day 0), perhaps up to 6.x series makes sense.\n\n[0] Commit 15fffc6a5624 (\"driver core: Fix uevent_show() vs driver detach race\")\n\n[1] A note about that: this syzkaller report presents multiple reproducers\nthat differs by the type of emulated USB device. For this specific case,\ncheck the entry from 2024/08/08 06:23 in the list of crashes; the C repro\nis available at https://syzkaller.appspot.com/text?tag=ReproC&x=1521fc83980000.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c386fb76f01794f1023d01a6ec5f5c93d00acd3b",
      "https://git.kernel.org/stable/c/8f3551f67991652c83469c7dd51d7b9b187b265f",
      "https://git.kernel.org/stable/c/eeb0b9b9e66b0b54cdad8e1c1cf0f55e8ba4211c",
      "https://git.kernel.org/stable/c/ac064c656f105b9122bc43991a170f95f72b7a43",
      "https://git.kernel.org/stable/c/5c1b544563005a00591a3aa86ecff62ed4d11be3"
    ],
    "受影响版本": [
      "0c8173385e549f95cd80c3fff5aab87b4f881d8d",
      "0c8173385e549f95cd80c3fff5aab87b4f881d8d",
      "0c8173385e549f95cd80c3fff5aab87b4f881d8d",
      "0c8173385e549f95cd80c3fff5aab87b4f881d8d",
      "0c8173385e549f95cd80c3fff5aab87b4f881d8d"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53176",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: During unmount, ensure all cached dir instances drop their dentry\n\nThe unmount process (cifs_kill_sb() calling close_all_cached_dirs()) can\nrace with various cached directory operations, which ultimately results\nin dentries not being dropped and these kernel BUGs:\n\nBUG: Dentry ffff88814f37e358{i=1000000000080,n=/}  still in use (2) [unmount of cifs cifs]\nVFS: Busy inodes after unmount of cifs (cifs)\n------------[ cut here ]------------\nkernel BUG at fs/super.c:661!\n\nThis happens when a cfid is in the process of being cleaned up when, and\nhas been removed from the cfids->entries list, including:\n\n- Receiving a lease break from the server\n- Server reconnection triggers invalidate_all_cached_dirs(), which\n  removes all the cfids from the list\n- The laundromat thread decides to expire an old cfid.\n\nTo solve these problems, dropping the dentry is done in queued work done\nin a newly-added cfid_put_wq workqueue, and close_all_cached_dirs()\nflushes that workqueue after it drops all the dentries of which it's\naware. This is a global workqueue (rather than scoped to a mount), but\nthe queued work is minimal.\n\nThe final cleanup work for cleaning up a cfid is performed via work\nqueued in the serverclose_wq workqueue; this is done separate from\ndropping the dentries so that close_all_cached_dirs() doesn't block on\nany server operations.\n\nBoth of these queued works expect to invoked with a cfid reference and\na tcon reference to avoid those objects from being freed while the work\nis ongoing.\n\nWhile we're here, add proper locking to close_all_cached_dirs(), and\nlocking around the freeing of cfid->dentry.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/73934e535cffbda1490fa97d82690a0f9aa73e94",
      "https://git.kernel.org/stable/c/ff4528bbc82d0d90073751f7b49e7b9e9c7e5638",
      "https://git.kernel.org/stable/c/548812afd96982a76a93ba76c0582ea670c40d9e",
      "https://git.kernel.org/stable/c/3fa640d035e5ae526769615c35cb9ed4be6e3662"
    ],
    "受影响版本": [
      "ebe98f1447bbccf8228335c62d86af02a0ed23f7",
      "ebe98f1447bbccf8228335c62d86af02a0ed23f7",
      "ebe98f1447bbccf8228335c62d86af02a0ed23f7",
      "ebe98f1447bbccf8228335c62d86af02a0ed23f7"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53175",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nipc: fix memleak if msg_init_ns failed in create_ipc_ns\n\nPercpu memory allocation may failed during create_ipc_ns however this\nfail is not handled properly since ipc sysctls and mq sysctls is not\nreleased properly. Fix this by release these two resource when failure.\n\nHere is the kmemleak stack when percpu failed:\n\nunreferenced object 0xffff88819de2a600 (size 512):\n  comm \"shmem_2nstest\", pid 120711, jiffies 4300542254\n  hex dump (first 32 bytes):\n    60 aa 9d 84 ff ff ff ff fc 18 48 b2 84 88 ff ff  `.........H.....\n    04 00 00 00 a4 01 00 00 20 e4 56 81 ff ff ff ff  ........ .V.....\n  backtrace (crc be7cba35):\n    [<ffffffff81b43f83>] __kmalloc_node_track_caller_noprof+0x333/0x420\n    [<ffffffff81a52e56>] kmemdup_noprof+0x26/0x50\n    [<ffffffff821b2f37>] setup_mq_sysctls+0x57/0x1d0\n    [<ffffffff821b29cc>] copy_ipcs+0x29c/0x3b0\n    [<ffffffff815d6a10>] create_new_namespaces+0x1d0/0x920\n    [<ffffffff815d7449>] copy_namespaces+0x2e9/0x3e0\n    [<ffffffff815458f3>] copy_process+0x29f3/0x7ff0\n    [<ffffffff8154b080>] kernel_clone+0xc0/0x650\n    [<ffffffff8154b6b1>] __do_sys_clone+0xa1/0xe0\n    [<ffffffff843df8ff>] do_syscall_64+0xbf/0x1c0\n    [<ffffffff846000b0>] entry_SYSCALL_64_after_hwframe+0x4b/0x53",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3d230cfd4b9b0558c7b2039ba1def2ce6b6cd158",
      "https://git.kernel.org/stable/c/10209665b5bf199f8065b2e7d2b2dc6cdf227117",
      "https://git.kernel.org/stable/c/8fed302872e26c7bf44d855c53a1cde747172d58",
      "https://git.kernel.org/stable/c/928de5fcd462498b8334107035da8ab85e316d8a",
      "https://git.kernel.org/stable/c/bc8f5921cd69188627c08041276238de222ab466"
    ],
    "受影响版本": [
      "72d1e611082eda18689106a0c192f2827072713c",
      "72d1e611082eda18689106a0c192f2827072713c",
      "72d1e611082eda18689106a0c192f2827072713c",
      "72d1e611082eda18689106a0c192f2827072713c",
      "72d1e611082eda18689106a0c192f2827072713c"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53174",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: make sure cache entry active before cache_show\n\nThe function `c_show` was called with protection from RCU. This only\nensures that `cp` will not be freed. Therefore, the reference count for\n`cp` can drop to zero, which will trigger a refcount use-after-free\nwarning when `cache_get` is called. To resolve this issue, use\n`cache_get_rcu` to ensure that `cp` remains active.\n\n------------[ cut here ]------------\nrefcount_t: addition on 0; use-after-free.\nWARNING: CPU: 7 PID: 822 at lib/refcount.c:25\nrefcount_warn_saturate+0xb1/0x120\nCPU: 7 UID: 0 PID: 822 Comm: cat Not tainted 6.12.0-rc3+ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.16.1-2.fc37 04/01/2014\nRIP: 0010:refcount_warn_saturate+0xb1/0x120\n\nCall Trace:\n <TASK>\n c_show+0x2fc/0x380 [sunrpc]\n seq_read_iter+0x589/0x770\n seq_read+0x1e5/0x270\n proc_reg_read+0xe1/0x140\n vfs_read+0x125/0x530\n ksys_read+0xc1/0x160\n do_syscall_64+0x5f/0x170\n entry_SYSCALL_64_after_hwframe+0x76/0x7e",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e9be26735d055c42543a4d047a769cc6d0fb1504",
      "https://git.kernel.org/stable/c/02999e135b013d85c6df738746e8e24699befee4",
      "https://git.kernel.org/stable/c/c7dac3af57e38b2054f990e573256d90bf887958",
      "https://git.kernel.org/stable/c/068c0b50f3f700b94f78850834cd91ae3b34c2c1",
      "https://git.kernel.org/stable/c/acfaf37888e0f0732fb6a50ff093dce6d99994d0",
      "https://git.kernel.org/stable/c/ec305f303bf070b4f6896b7a76009f702956d402",
      "https://git.kernel.org/stable/c/d882e2b7fad3f5e5fac66184a347f408813f654a",
      "https://git.kernel.org/stable/c/2862eee078a4d2d1f584e7f24fa50dddfa5f3471"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53169",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-fabrics: fix kernel crash while shutting down controller\n\nThe nvme keep-alive operation, which executes at a periodic interval,\ncould potentially sneak in while shutting down a fabric controller.\nThis may lead to a race between the fabric controller admin queue\ndestroy code path (invoked while shutting down controller) and hw/hctx\nqueue dispatcher called from the nvme keep-alive async request queuing\noperation. This race could lead to the kernel crash shown below:\n\nCall Trace:\n    autoremove_wake_function+0x0/0xbc (unreliable)\n    __blk_mq_sched_dispatch_requests+0x114/0x24c\n    blk_mq_sched_dispatch_requests+0x44/0x84\n    blk_mq_run_hw_queue+0x140/0x220\n    nvme_keep_alive_work+0xc8/0x19c [nvme_core]\n    process_one_work+0x200/0x4e0\n    worker_thread+0x340/0x504\n    kthread+0x138/0x140\n    start_kernel_thread+0x14/0x18\n\nWhile shutting down fabric controller, if nvme keep-alive request sneaks\nin then it would be flushed off. The nvme_keep_alive_end_io function is\nthen invoked to handle the end of the keep-alive operation which\ndecrements the admin->q_usage_counter and assuming this is the last/only\nrequest in the admin queue then the admin->q_usage_counter becomes zero.\nIf that happens then blk-mq destroy queue operation (blk_mq_destroy_\nqueue()) which could be potentially running simultaneously on another\ncpu (as this is the controller shutdown code path) would forward\nprogress and deletes the admin queue. So, now from this point onward\nwe are not supposed to access the admin queue resources. However the\nissue here's that the nvme keep-alive thread running hw/hctx queue\ndispatch operation hasn't yet finished its work and so it could still\npotentially access the admin queue resource while the admin queue had\nbeen already deleted and that causes the above crash.\n\nThe above kernel crash is regression caused due to changes implemented\nin commit a54a93d0e359 (\"nvme: move stopping keep-alive into\nnvme_uninit_ctrl()\"). Ideally we should stop keep-alive before destroyin\ng the admin queue and freeing the admin tagset so that it wouldn't sneak\nin during the shutdown operation. However we removed the keep alive stop\noperation from the beginning of the controller shutdown code path in commit\na54a93d0e359 (\"nvme: move stopping keep-alive into nvme_uninit_ctrl()\")\nand added it under nvme_uninit_ctrl() which executes very late in the\nshutdown code path after the admin queue is destroyed and its tagset is\nremoved. So this change created the possibility of keep-alive sneaking in\nand interfering with the shutdown operation and causing observed kernel\ncrash.\n\nTo fix the observed crash, we decided to move nvme_stop_keep_alive() from\nnvme_uninit_ctrl() to nvme_remove_admin_tag_set(). This change would ensure\nthat we don't forward progress and delete the admin queue until the keep-\nalive operation is finished (if it's in-flight) or cancelled and that would\nhelp contain the race condition explained above and hence avoid the crash.\n\nMoving nvme_stop_keep_alive() to nvme_remove_admin_tag_set() instead of\nadding nvme_stop_keep_alive() to the beginning of the controller shutdown\ncode path in nvme_stop_ctrl(), as was the case earlier before commit\na54a93d0e359 (\"nvme: move stopping keep-alive into nvme_uninit_ctrl()\"),\nwould help save one callsite of nvme_stop_keep_alive().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/30794f4952decb2ec8efa42f704cac5304499a41",
      "https://git.kernel.org/stable/c/5416b76a8156c1b8491f78f8a728f422104bb919",
      "https://git.kernel.org/stable/c/e9869c85c81168a1275f909d5972a3fc435304be"
    ],
    "受影响版本": [
      "a54a93d0e3599b05856971734e15418ac551a14c",
      "a54a93d0e3599b05856971734e15418ac551a14c",
      "a54a93d0e3599b05856971734e15418ac551a14c",
      "4101af98ab573554c4225e328d506fec2a74bc54"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53168",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsunrpc: fix one UAF issue caused by sunrpc kernel tcp socket\n\nBUG: KASAN: slab-use-after-free in tcp_write_timer_handler+0x156/0x3e0\nRead of size 1 at addr ffff888111f322cd by task swapper/0/0\n\nCPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc4-dirty #7\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1\nCall Trace:\n <IRQ>\n dump_stack_lvl+0x68/0xa0\n print_address_description.constprop.0+0x2c/0x3d0\n print_report+0xb4/0x270\n kasan_report+0xbd/0xf0\n tcp_write_timer_handler+0x156/0x3e0\n tcp_write_timer+0x66/0x170\n call_timer_fn+0xfb/0x1d0\n __run_timers+0x3f8/0x480\n run_timer_softirq+0x9b/0x100\n handle_softirqs+0x153/0x390\n __irq_exit_rcu+0x103/0x120\n irq_exit_rcu+0xe/0x20\n sysvec_apic_timer_interrupt+0x76/0x90\n </IRQ>\n <TASK>\n asm_sysvec_apic_timer_interrupt+0x1a/0x20\nRIP: 0010:default_idle+0xf/0x20\nCode: 4c 01 c7 4c 29 c2 e9 72 ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90\n 90 90 90 90 f3 0f 1e fa 66 90 0f 00 2d 33 f8 25 00 fb f4 <fa> c3 cc cc cc\n cc 66 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90\nRSP: 0018:ffffffffa2007e28 EFLAGS: 00000242\nRAX: 00000000000f3b31 RBX: 1ffffffff4400fc7 RCX: ffffffffa09c3196\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff9f00590f\nRBP: 0000000000000000 R08: 0000000000000001 R09: ffffed102360835d\nR10: ffff88811b041aeb R11: 0000000000000001 R12: 0000000000000000\nR13: ffffffffa202d7c0 R14: 0000000000000000 R15: 00000000000147d0\n default_idle_call+0x6b/0xa0\n cpuidle_idle_call+0x1af/0x1f0\n do_idle+0xbc/0x130\n cpu_startup_entry+0x33/0x40\n rest_init+0x11f/0x210\n start_kernel+0x39a/0x420\n x86_64_start_reservations+0x18/0x30\n x86_64_start_kernel+0x97/0xa0\n common_startup_64+0x13e/0x141\n </TASK>\n\nAllocated by task 595:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n __kasan_slab_alloc+0x87/0x90\n kmem_cache_alloc_noprof+0x12b/0x3f0\n copy_net_ns+0x94/0x380\n create_new_namespaces+0x24c/0x500\n unshare_nsproxy_namespaces+0x75/0xf0\n ksys_unshare+0x24e/0x4f0\n __x64_sys_unshare+0x1f/0x30\n do_syscall_64+0x70/0x180\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nFreed by task 100:\n kasan_save_stack+0x24/0x50\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n __kasan_slab_free+0x54/0x70\n kmem_cache_free+0x156/0x5d0\n cleanup_net+0x5d3/0x670\n process_one_work+0x776/0xa90\n worker_thread+0x2e2/0x560\n kthread+0x1a8/0x1f0\n ret_from_fork+0x34/0x60\n ret_from_fork_asm+0x1a/0x30\n\nReproduction script:\n\nmkdir -p /mnt/nfsshare\nmkdir -p /mnt/nfs/netns_1\nmkfs.ext4 /dev/sdb\nmount /dev/sdb /mnt/nfsshare\nsystemctl restart nfs-server\nchmod 777 /mnt/nfsshare\nexportfs -i -o rw,no_root_squash *:/mnt/nfsshare\n\nip netns add netns_1\nip link add name veth_1_peer type veth peer veth_1\nifconfig veth_1_peer 11.11.0.254 up\nip link set veth_1 netns netns_1\nip netns exec netns_1 ifconfig veth_1 11.11.0.1\n\nip netns exec netns_1 /root/iptables -A OUTPUT -d 11.11.0.254 -p tcp \\\n\t--tcp-flags FIN FIN  -j DROP\n\n(note: In my environment, a DESTROY_CLIENTID operation is always sent\n immediately, breaking the nfs tcp connection.)\nip netns exec netns_1 timeout -s 9 300 mount -t nfs -o proto=tcp,vers=4.1 \\\n\t11.11.0.254:/mnt/nfsshare /mnt/nfs/netns_1\n\nip netns del netns_1\n\nThe reason here is that the tcp socket in netns_1 (nfs side) has been\nshutdown and closed (done in xs_destroy), but the FIN message (with ack)\nis discarded, and the nfsd side keeps sending retransmission messages.\nAs a result, when the tcp sock in netns_1 processes the received message,\nit sends the message (FIN message) in the sending queue, and the tcp timer\nis re-established. When the network namespace is deleted, the net structure\naccessed by tcp's timer handler function causes problems.\n\nTo fix this problem, let's hold netns refcnt for the tcp kernel socket as\ndone in other modules. This is an ugly hack which can easily be backported\nto earlier kernels. A proper fix which cleans up the interfaces will\nfollow, but may not be so easy to backport.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0ca87e5063757132a044d35baba40a7d4bb25394",
      "https://git.kernel.org/stable/c/694ccb05b79ee5f5a9f14c2f80d2635d3bb8bdc3",
      "https://git.kernel.org/stable/c/61c0a5eac96836de5e3a5897eccdc63162a94936",
      "https://git.kernel.org/stable/c/3f23f96528e8fcf8619895c4c916c52653892ec1"
    ],
    "受影响版本": [
      "26abe14379f8e2fa3fd1bcf97c9a7ad9364886fe",
      "26abe14379f8e2fa3fd1bcf97c9a7ad9364886fe",
      "26abe14379f8e2fa3fd1bcf97c9a7ad9364886fe",
      "26abe14379f8e2fa3fd1bcf97c9a7ad9364886fe"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53131",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix null-ptr-deref in block_touch_buffer tracepoint\n\nPatch series \"nilfs2: fix null-ptr-deref bugs on block tracepoints\".\n\nThis series fixes null pointer dereference bugs that occur when using\nnilfs2 and two block-related tracepoints.\n\n\nThis patch (of 2):\n\nIt has been reported that when using \"block:block_touch_buffer\"\ntracepoint, touch_buffer() called from __nilfs_get_folio_block() causes a\nNULL pointer dereference, or a general protection fault when KASAN is\nenabled.\n\nThis happens because since the tracepoint was added in touch_buffer(), it\nreferences the dev_t member bh->b_bdev->bd_dev regardless of whether the\nbuffer head has a pointer to a block_device structure.  In the current\nimplementation, the block_device structure is set after the function\nreturns to the caller.\n\nHere, touch_buffer() is used to mark the folio/page that owns the buffer\nhead as accessed, but the common search helper for folio/page used by the\ncaller function was optimized to mark the folio/page as accessed when it\nwas reimplemented a long time ago, eliminating the need to call\ntouch_buffer() here in the first place.\n\nSo this solves the issue by eliminating the touch_buffer() call itself.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/085556bf8c70e2629e02e79268dac3016a08b8bf",
      "https://git.kernel.org/stable/c/6438f3f42cda825f6f59b4e45ac3a1da28a6f2c9",
      "https://git.kernel.org/stable/c/b017697a517f8779ada4e8ce1c2c75dbf60a2636",
      "https://git.kernel.org/stable/c/19c71cdd77973f99a9adc3190130bc3aa7ae5423",
      "https://git.kernel.org/stable/c/3b2a4fd9bbee77afdd3ed5a05a0c02b6cde8d3b9",
      "https://git.kernel.org/stable/c/59b49ca67cca7b007a5afd3de0283c8008157665",
      "https://git.kernel.org/stable/c/77e47f89d32c2d72eb33d0becbce7abe14d061f4",
      "https://git.kernel.org/stable/c/cd45e963e44b0f10d90b9e6c0e8b4f47f3c92471"
    ],
    "受影响版本": [
      "5305cb830834549b9203ad4d009ad5483c5e293f",
      "5305cb830834549b9203ad4d009ad5483c5e293f",
      "5305cb830834549b9203ad4d009ad5483c5e293f",
      "5305cb830834549b9203ad4d009ad5483c5e293f",
      "5305cb830834549b9203ad4d009ad5483c5e293f",
      "5305cb830834549b9203ad4d009ad5483c5e293f",
      "5305cb830834549b9203ad4d009ad5483c5e293f",
      "5305cb830834549b9203ad4d009ad5483c5e293f"
    ],
    "公开日期": "2024年12月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53128",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched/task_stack: fix object_is_on_stack() for KASAN tagged pointers\n\nWhen CONFIG_KASAN_SW_TAGS and CONFIG_KASAN_STACK are enabled, the\nobject_is_on_stack() function may produce incorrect results due to the\npresence of tags in the obj pointer, while the stack pointer does not have\ntags.  This discrepancy can lead to incorrect stack object detection and\nsubsequently trigger warnings if CONFIG_DEBUG_OBJECTS is also enabled.\n\nExample of the warning:\n\nODEBUG: object 3eff800082ea7bb0 is NOT on stack ffff800082ea0000, but annotated.\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 1 at lib/debugobjects.c:557 __debug_object_init+0x330/0x364\nModules linked in:\nCPU: 0 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.0-rc5 #4\nHardware name: linux,dummy-virt (DT)\npstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : __debug_object_init+0x330/0x364\nlr : __debug_object_init+0x330/0x364\nsp : ffff800082ea7b40\nx29: ffff800082ea7b40 x28: 98ff0000c0164518 x27: 98ff0000c0164534\nx26: ffff800082d93ec8 x25: 0000000000000001 x24: 1cff0000c00172a0\nx23: 0000000000000000 x22: ffff800082d93ed0 x21: ffff800081a24418\nx20: 3eff800082ea7bb0 x19: efff800000000000 x18: 0000000000000000\nx17: 00000000000000ff x16: 0000000000000047 x15: 206b63617473206e\nx14: 0000000000000018 x13: ffff800082ea7780 x12: 0ffff800082ea78e\nx11: 0ffff800082ea790 x10: 0ffff800082ea79d x9 : 34d77febe173e800\nx8 : 34d77febe173e800 x7 : 0000000000000001 x6 : 0000000000000001\nx5 : feff800082ea74b8 x4 : ffff800082870a90 x3 : ffff80008018d3c4\nx2 : 0000000000000001 x1 : ffff800082858810 x0 : 0000000000000050\nCall trace:\n __debug_object_init+0x330/0x364\n debug_object_init_on_stack+0x30/0x3c\n schedule_hrtimeout_range_clock+0xac/0x26c\n schedule_hrtimeout+0x1c/0x30\n wait_task_inactive+0x1d4/0x25c\n kthread_bind_mask+0x28/0x98\n init_rescuer+0x1e8/0x280\n workqueue_init+0x1a0/0x3cc\n kernel_init_freeable+0x118/0x200\n kernel_init+0x28/0x1f0\n ret_from_fork+0x10/0x20\n---[ end trace 0000000000000000 ]---\nODEBUG: object 3eff800082ea7bb0 is NOT on stack ffff800082ea0000, but annotated.\n------------[ cut here ]------------",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/82e813b12b10ff705f3f5d600d8492fc5248618b",
      "https://git.kernel.org/stable/c/397383db9c69470642ac95beb04f2150928d663b",
      "https://git.kernel.org/stable/c/2d2b19ed4169c38dc6c61a186c5f7bdafc709691",
      "https://git.kernel.org/stable/c/fbfe23012cec509dfbe09852019c4e4bb84999d0",
      "https://git.kernel.org/stable/c/fd7b4f9f46d46acbc7af3a439bb0d869efdc5c58"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年12月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53124",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fix data-races around sk->sk_forward_alloc\n\nSyzkaller reported this warning:\n ------------[ cut here ]------------\n WARNING: CPU: 0 PID: 16 at net/ipv4/af_inet.c:156 inet_sock_destruct+0x1c5/0x1e0\n Modules linked in:\n CPU: 0 UID: 0 PID: 16 Comm: ksoftirqd/0 Not tainted 6.12.0-rc5 #26\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n RIP: 0010:inet_sock_destruct+0x1c5/0x1e0\n Code: 24 12 4c 89 e2 5b 48 c7 c7 98 ec bb 82 41 5c e9 d1 18 17 ff 4c 89 e6 5b 48 c7 c7 d0 ec bb 82 41 5c e9 bf 18 17 ff 0f 0b eb 83 <0f> 0b eb 97 0f 0b eb 87 0f 0b e9 68 ff ff ff 66 66 2e 0f 1f 84 00\n RSP: 0018:ffffc9000008bd90 EFLAGS: 00010206\n RAX: 0000000000000300 RBX: ffff88810b172a90 RCX: 0000000000000007\n RDX: 0000000000000002 RSI: 0000000000000300 RDI: ffff88810b172a00\n RBP: ffff88810b172a00 R08: ffff888104273c00 R09: 0000000000100007\n R10: 0000000000020000 R11: 0000000000000006 R12: ffff88810b172a00\n R13: 0000000000000004 R14: 0000000000000000 R15: ffff888237c31f78\n FS:  0000000000000000(0000) GS:ffff888237c00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007ffc63fecac8 CR3: 000000000342e000 CR4: 00000000000006f0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <TASK>\n  ? __warn+0x88/0x130\n  ? inet_sock_destruct+0x1c5/0x1e0\n  ? report_bug+0x18e/0x1a0\n  ? handle_bug+0x53/0x90\n  ? exc_invalid_op+0x18/0x70\n  ? asm_exc_invalid_op+0x1a/0x20\n  ? inet_sock_destruct+0x1c5/0x1e0\n  __sk_destruct+0x2a/0x200\n  rcu_do_batch+0x1aa/0x530\n  ? rcu_do_batch+0x13b/0x530\n  rcu_core+0x159/0x2f0\n  handle_softirqs+0xd3/0x2b0\n  ? __pfx_smpboot_thread_fn+0x10/0x10\n  run_ksoftirqd+0x25/0x30\n  smpboot_thread_fn+0xdd/0x1d0\n  kthread+0xd3/0x100\n  ? __pfx_kthread+0x10/0x10\n  ret_from_fork+0x34/0x50\n  ? __pfx_kthread+0x10/0x10\n  ret_from_fork_asm+0x1a/0x30\n  </TASK>\n ---[ end trace 0000000000000000 ]---\n\nIts possible that two threads call tcp_v6_do_rcv()/sk_forward_alloc_add()\nconcurrently when sk->sk_state == TCP_LISTEN with sk->sk_lock unlocked,\nwhich triggers a data-race around sk->sk_forward_alloc:\ntcp_v6_rcv\n    tcp_v6_do_rcv\n        skb_clone_and_charge_r\n            sk_rmem_schedule\n                __sk_mem_schedule\n                    sk_forward_alloc_add()\n            skb_set_owner_r\n                sk_mem_charge\n                    sk_forward_alloc_add()\n        __kfree_skb\n            skb_release_all\n                skb_release_head_state\n                    sock_rfree\n                        sk_mem_uncharge\n                            sk_forward_alloc_add()\n                            sk_mem_reclaim\n                                // set local var reclaimable\n                                __sk_mem_reclaim\n                                    sk_forward_alloc_add()\n\nIn this syzkaller testcase, two threads call\ntcp_v6_do_rcv() with skb->truesize=768, the sk_forward_alloc changes like\nthis:\n (cpu 1)             | (cpu 2)             | sk_forward_alloc\n ...                 | ...                 | 0\n __sk_mem_schedule() |                     | +4096 = 4096\n                     | __sk_mem_schedule() | +4096 = 8192\n sk_mem_charge()     |                     | -768  = 7424\n                     | sk_mem_charge()     | -768  = 6656\n ...                 |    ...              |\n sk_mem_uncharge()   |                     | +768  = 7424\n reclaimable=7424    |                     |\n                     | sk_mem_uncharge()   | +768  = 8192\n                     | reclaimable=8192    |\n __sk_mem_reclaim()  |                     | -4096 = 4096\n                     | __sk_mem_reclaim()  | -8192 = -4096 != 0\n\nThe skb_clone_and_charge_r() should not be called in tcp_v6_do_rcv() when\nsk->sk_state is TCP_LISTEN, it happens later in tcp_v6_syn_recv_sock().\nFix the same issue in dccp_v6_do_rcv().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/695fb0b9aecfd5dd5b2946ba8897ac2c1eef654d",
      "https://git.kernel.org/stable/c/fe2c0bd6d1e29ccefdc978b9a290571c93c27473",
      "https://git.kernel.org/stable/c/c3d052cae566ec2285f5999958a5deb415a0f59e",
      "https://git.kernel.org/stable/c/be7c61ea5f816168c38955eb4e898adc8b4b32fd",
      "https://git.kernel.org/stable/c/3f51f8c9d28954cf380100883a02eed35a8277e9",
      "https://git.kernel.org/stable/c/d285eb9d0641c8344f2836081b4ccb7b3c5cc1b6",
      "https://git.kernel.org/stable/c/073d89808c065ac4c672c0a613a71b27a80691cb"
    ],
    "受影响版本": [
      "e994b2f0fb9229aeff5eea9541320bd7b2ca8714",
      "e994b2f0fb9229aeff5eea9541320bd7b2ca8714",
      "e994b2f0fb9229aeff5eea9541320bd7b2ca8714",
      "e994b2f0fb9229aeff5eea9541320bd7b2ca8714",
      "e994b2f0fb9229aeff5eea9541320bd7b2ca8714",
      "e994b2f0fb9229aeff5eea9541320bd7b2ca8714",
      "e994b2f0fb9229aeff5eea9541320bd7b2ca8714"
    ],
    "公开日期": "2024年12月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53121",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: fs, lock FTE when checking if active\n\nThe referenced commits introduced a two-step process for deleting FTEs:\n\n- Lock the FTE, delete it from hardware, set the hardware deletion function\n  to NULL and unlock the FTE.\n- Lock the parent flow group, delete the software copy of the FTE, and\n  remove it from the xarray.\n\nHowever, this approach encounters a race condition if a rule with the same\nmatch value is added simultaneously. In this scenario, fs_core may set the\nhardware deletion function to NULL prematurely, causing a panic during\nsubsequent rule deletions.\n\nTo prevent this, ensure the active flag of the FTE is checked under a lock,\nwhich will prevent the fs_core layer from attaching a new steering rule to\nan FTE that is in the process of deletion.\n\n[  438.967589] MOSHE: 2496 mlx5_del_flow_rules del_hw_func\n[  438.968205] ------------[ cut here ]------------\n[  438.968654] refcount_t: decrement hit 0; leaking memory.\n[  438.969249] WARNING: CPU: 0 PID: 8957 at lib/refcount.c:31 refcount_warn_saturate+0xfb/0x110\n[  438.970054] Modules linked in: act_mirred cls_flower act_gact sch_ingress openvswitch nsh mlx5_vdpa vringh vhost_iotlb vdpa mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm ib_uverbs ib_core zram zsmalloc fuse [last unloaded: cls_flower]\n[  438.973288] CPU: 0 UID: 0 PID: 8957 Comm: tc Not tainted 6.12.0-rc1+ #8\n[  438.973888] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n[  438.974874] RIP: 0010:refcount_warn_saturate+0xfb/0x110\n[  438.975363] Code: 40 66 3b 82 c6 05 16 e9 4d 01 01 e8 1f 7c a0 ff 0f 0b c3 cc cc cc cc 48 c7 c7 10 66 3b 82 c6 05 fd e8 4d 01 01 e8 05 7c a0 ff <0f> 0b c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 90\n[  438.976947] RSP: 0018:ffff888124a53610 EFLAGS: 00010286\n[  438.977446] RAX: 0000000000000000 RBX: ffff888119d56de0 RCX: 0000000000000000\n[  438.978090] RDX: ffff88852c828700 RSI: ffff88852c81b3c0 RDI: ffff88852c81b3c0\n[  438.978721] RBP: ffff888120fa0e88 R08: 0000000000000000 R09: ffff888124a534b0\n[  438.979353] R10: 0000000000000001 R11: 0000000000000001 R12: ffff888119d56de0\n[  438.979979] R13: ffff888120fa0ec0 R14: ffff888120fa0ee8 R15: ffff888119d56de0\n[  438.980607] FS:  00007fe6dcc0f800(0000) GS:ffff88852c800000(0000) knlGS:0000000000000000\n[  438.983984] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  438.984544] CR2: 00000000004275e0 CR3: 0000000186982001 CR4: 0000000000372eb0\n[  438.985205] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  438.985842] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  438.986507] Call Trace:\n[  438.986799]  <TASK>\n[  438.987070]  ? __warn+0x7d/0x110\n[  438.987426]  ? refcount_warn_saturate+0xfb/0x110\n[  438.987877]  ? report_bug+0x17d/0x190\n[  438.988261]  ? prb_read_valid+0x17/0x20\n[  438.988659]  ? handle_bug+0x53/0x90\n[  438.989054]  ? exc_invalid_op+0x14/0x70\n[  438.989458]  ? asm_exc_invalid_op+0x16/0x20\n[  438.989883]  ? refcount_warn_saturate+0xfb/0x110\n[  438.990348]  mlx5_del_flow_rules+0x2f7/0x340 [mlx5_core]\n[  438.990932]  __mlx5_eswitch_del_rule+0x49/0x170 [mlx5_core]\n[  438.991519]  ? mlx5_lag_is_sriov+0x3c/0x50 [mlx5_core]\n[  438.992054]  ? xas_load+0x9/0xb0\n[  438.992407]  mlx5e_tc_rule_unoffload+0x45/0xe0 [mlx5_core]\n[  438.993037]  mlx5e_tc_del_fdb_flow+0x2a6/0x2e0 [mlx5_core]\n[  438.993623]  mlx5e_flow_put+0x29/0x60 [mlx5_core]\n[  438.994161]  mlx5e_delete_flower+0x261/0x390 [mlx5_core]\n[  438.994728]  tc_setup_cb_destroy+0xb9/0x190\n[  438.995150]  fl_hw_destroy_filter+0x94/0xc0 [cls_flower]\n[  438.995650]  fl_change+0x11a4/0x13c0 [cls_flower]\n[  438.996105]  tc_new_tfilter+0x347/0xbc0\n[  438.996503]  ? __\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0d568258f99f2076ab02e9234cbabbd43e12f30e",
      "https://git.kernel.org/stable/c/a508c74ceae2f5a4647f67c362126516d6404ed9",
      "https://git.kernel.org/stable/c/5b47c2f47c2fe921681f4a4fe2790375e6c04cdd",
      "https://git.kernel.org/stable/c/bfba288f53192db08c68d4c568db9783fb9cb838",
      "https://git.kernel.org/stable/c/094d1a2121cee1e85ab07d74388f94809dcfb5b9",
      "https://git.kernel.org/stable/c/933ef0d17f012b653e9e6006e3f50c8d0238b5ed",
      "https://git.kernel.org/stable/c/9ca314419930f9135727e39d77e66262d5f7bef6"
    ],
    "受影响版本": [
      "718ce4d601dbf73b5dbe024a88c9e34168fe87f2",
      "718ce4d601dbf73b5dbe024a88c9e34168fe87f2",
      "718ce4d601dbf73b5dbe024a88c9e34168fe87f2",
      "718ce4d601dbf73b5dbe024a88c9e34168fe87f2",
      "718ce4d601dbf73b5dbe024a88c9e34168fe87f2",
      "718ce4d601dbf73b5dbe024a88c9e34168fe87f2",
      "718ce4d601dbf73b5dbe024a88c9e34168fe87f2"
    ],
    "公开日期": "2024年12月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53096",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: resolve faulty mmap_region() error path behaviour\n\nThe mmap_region() function is somewhat terrifying, with spaghetti-like\ncontrol flow and numerous means by which issues can arise and incomplete\nstate, memory leaks and other unpleasantness can occur.\n\nA large amount of the complexity arises from trying to handle errors late\nin the process of mapping a VMA, which forms the basis of recently\nobserved issues with resource leaks and observable inconsistent state.\n\nTaking advantage of previous patches in this series we move a number of\nchecks earlier in the code, simplifying things by moving the core of the\nlogic into a static internal function __mmap_region().\n\nDoing this allows us to perform a number of checks up front before we do\nany real work, and allows us to unwind the writable unmap check\nunconditionally as required and to perform a CONFIG_DEBUG_VM_MAPLE_TREE\nvalidation unconditionally also.\n\nWe move a number of things here:\n\n1. We preallocate memory for the iterator before we call the file-backed\n   memory hook, allowing us to exit early and avoid having to perform\n   complicated and error-prone close/free logic. We carefully free\n   iterator state on both success and error paths.\n\n2. The enclosing mmap_region() function handles the mapping_map_writable()\n   logic early. Previously the logic had the mapping_map_writable() at the\n   point of mapping a newly allocated file-backed VMA, and a matching\n   mapping_unmap_writable() on success and error paths.\n\n   We now do this unconditionally if this is a file-backed, shared writable\n   mapping. If a driver changes the flags to eliminate VM_MAYWRITE, however\n   doing so does not invalidate the seal check we just performed, and we in\n   any case always decrement the counter in the wrapper.\n\n   We perform a debug assert to ensure a driver does not attempt to do the\n   opposite.\n\n3. We also move arch_validate_flags() up into the mmap_region()\n   function. This is only relevant on arm64 and sparc64, and the check is\n   only meaningful for SPARC with ADI enabled. We explicitly add a warning\n   for this arch if a driver invalidates this check, though the code ought\n   eventually to be fixed to eliminate the need for this.\n\nWith all of these measures in place, we no longer need to explicitly close\nthe VMA on error paths, as we place all checks which might fail prior to a\ncall to any driver mmap hook.\n\nThis eliminates an entire class of errors, makes the code easier to reason\nabout and more robust.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/43323a4e5b3f8ccc08e2f835abfdc7ee9da8f6ed",
      "https://git.kernel.org/stable/c/44f48eb9a6051826227bbd375446064fb2a43c6c",
      "https://git.kernel.org/stable/c/52c81fd0f5a8bf8032687b94ccf00d13b44cc5c8",
      "https://git.kernel.org/stable/c/bdc136e2b05fabcd780fe5f165d154eb779dfcb0",
      "https://git.kernel.org/stable/c/5de195060b2e251a835f622759550e6202167641",
      "https://project-zero.issues.chromium.org/issues/374117290"
    ],
    "受影响版本": [
      "a3c08c021778dad30f69895e378843e9f423d734",
      "43bed0a13a5cdbb314d14f28c2bf2c60eb4e6e1e",
      "deb0f6562884b5b4beb883d73e66a7d3a1b96d99",
      "deb0f6562884b5b4beb883d73e66a7d3a1b96d99",
      "deb0f6562884b5b4beb883d73e66a7d3a1b96d99",
      "6757330b1be5b0606125b65ed50caac69bccf9a5",
      "66f2ed0172af04a89677ae1898600e1264e25800"
    ],
    "公开日期": "2024年11月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53093",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-multipath: defer partition scanning\n\nWe need to suppress the partition scan from occuring within the\ncontroller's scan_work context. If a path error occurs here, the IO will\nwait until a path becomes available or all paths are torn down, but that\naction also occurs within scan_work, so it would deadlock. Defer the\npartion scan to a different context that does not block scan_work.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/60de2e03f984cfbcdc12fa552f95087c35a05a98",
      "https://git.kernel.org/stable/c/4a57f42e5ed42cb8f1beb262c4f6d3e698939e4e",
      "https://git.kernel.org/stable/c/a91b7eddf45afeeb9c5ece11dddff5de0921b00f",
      "https://git.kernel.org/stable/c/1f021341eef41e77a633186e9be5223de2ce5d48"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年11月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53079",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/thp: fix deferred split unqueue naming and locking\n\nRecent changes are putting more pressure on THP deferred split queues:\nunder load revealing long-standing races, causing list_del corruptions,\n\"Bad page state\"s and worse (I keep BUGs in both of those, so usually\ndon't get to see how badly they end up without).  The relevant recent\nchanges being 6.8's mTHP, 6.10's mTHP swapout, and 6.12's mTHP swapin,\nimproved swap allocation, and underused THP splitting.\n\nBefore fixing locking: rename misleading folio_undo_large_rmappable(),\nwhich does not undo large_rmappable, to folio_unqueue_deferred_split(),\nwhich is what it does.  But that and its out-of-line __callee are mm\ninternals of very limited usability: add comment and WARN_ON_ONCEs to\ncheck usage; and return a bool to say if a deferred split was unqueued,\nwhich can then be used in WARN_ON_ONCEs around safety checks (sparing\ncallers the arcane conditionals in __folio_unqueue_deferred_split()).\n\nJust omit the folio_unqueue_deferred_split() from free_unref_folios(), all\nof whose callers now call it beforehand (and if any forget then bad_page()\nwill tell) - except for its caller put_pages_list(), which itself no\nlonger has any callers (and will be deleted separately).\n\nSwapout: mem_cgroup_swapout() has been resetting folio->memcg_data 0\nwithout checking and unqueueing a THP folio from deferred split list;\nwhich is unfortunate, since the split_queue_lock depends on the memcg\n(when memcg is enabled); so swapout has been unqueueing such THPs later,\nwhen freeing the folio, using the pgdat's lock instead: potentially\ncorrupting the memcg's list.  __remove_mapping() has frozen refcount to 0\nhere, so no problem with calling folio_unqueue_deferred_split() before\nresetting memcg_data.\n\nThat goes back to 5.4 commit 87eaceb3faa5 (\"mm: thp: make deferred split\nshrinker memcg aware\"): which included a check on swapcache before adding\nto deferred queue, but no check on deferred queue before adding THP to\nswapcache.  That worked fine with the usual sequence of events in reclaim\n(though there were a couple of rare ways in which a THP on deferred queue\ncould have been swapped out), but 6.12 commit dafff3f4c850 (\"mm: split\nunderused THPs\") avoids splitting underused THPs in reclaim, which makes\nswapcache THPs on deferred queue commonplace.\n\nKeep the check on swapcache before adding to deferred queue?  Yes: it is\nno longer essential, but preserves the existing behaviour, and is likely\nto be a worthwhile optimization (vmstat showed much more traffic on the\nqueue under swapping load if the check was removed); update its comment.\n\nMemcg-v1 move (deprecated): mem_cgroup_move_account() has been changing\nfolio->memcg_data without checking and unqueueing a THP folio from the\ndeferred list, sometimes corrupting \"from\" memcg's list, like swapout. \nRefcount is non-zero here, so folio_unqueue_deferred_split() can only be\nused in a WARN_ON_ONCE to validate the fix, which must be done earlier:\nmem_cgroup_move_charge_pte_range() first try to split the THP (splitting\nof course unqueues), or skip it if that fails.  Not ideal, but moving\ncharge has been requested, and khugepaged should repair the THP later:\nnobody wants new custom unqueueing code just for this deprecated case.\n\nThe 87eaceb3faa5 commit did have the code to move from one deferred list\nto another (but was not conscious of its unsafety while refcount non-0);\nbut that was removed by 5.6 commit fac0516b5534 (\"mm: thp: don't need care\ndeferred split queue in memcg charge move path\"), which argued that the\nexistence of a PMD mapping guarantees that the THP cannot be on a deferred\nlist.  As above, false in rare cases, and now commonly false.\n\nBackport to 6.11 should be straightforward.  Earlier backports must take\ncare that other _deferred_list fixes and dependencies are included.  There\nis not a strong case for backports, but they can fix cornercases.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fc4951c3e3358dd82ea508e893695b916c813f17",
      "https://git.kernel.org/stable/c/afb1352d06b1b6b2cfd1f901c766a430c87078b3",
      "https://git.kernel.org/stable/c/f8f931bba0f92052cf842b7e30917b1afcc77d5a"
    ],
    "受影响版本": [
      "87eaceb3faa59b9b4d940ec9554ce251325d83fe",
      "87eaceb3faa59b9b4d940ec9554ce251325d83fe",
      "87eaceb3faa59b9b4d940ec9554ce251325d83fe"
    ],
    "公开日期": "2024年11月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53068",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfirmware: arm_scmi: Fix slab-use-after-free in scmi_bus_notifier()\n\nThe scmi_dev->name is released prematurely in __scmi_device_destroy(),\nwhich causes slab-use-after-free when accessing scmi_dev->name in\nscmi_bus_notifier(). So move the release of scmi_dev->name to\nscmi_device_release() to avoid slab-use-after-free.\n\n  |  BUG: KASAN: slab-use-after-free in strncmp+0xe4/0xec\n  |  Read of size 1 at addr ffffff80a482bcc0 by task swapper/0/1\n  |\n  |  CPU: 1 PID: 1 Comm: swapper/0 Not tainted 6.6.38-debug #1\n  |  Hardware name: Qualcomm Technologies, Inc. SA8775P Ride (DT)\n  |  Call trace:\n  |   dump_backtrace+0x94/0x114\n  |   show_stack+0x18/0x24\n  |   dump_stack_lvl+0x48/0x60\n  |   print_report+0xf4/0x5b0\n  |   kasan_report+0xa4/0xec\n  |   __asan_report_load1_noabort+0x20/0x2c\n  |   strncmp+0xe4/0xec\n  |   scmi_bus_notifier+0x5c/0x54c\n  |   notifier_call_chain+0xb4/0x31c\n  |   blocking_notifier_call_chain+0x68/0x9c\n  |   bus_notify+0x54/0x78\n  |   device_del+0x1bc/0x840\n  |   device_unregister+0x20/0xb4\n  |   __scmi_device_destroy+0xac/0x280\n  |   scmi_device_destroy+0x94/0xd0\n  |   scmi_chan_setup+0x524/0x750\n  |   scmi_probe+0x7fc/0x1508\n  |   platform_probe+0xc4/0x19c\n  |   really_probe+0x32c/0x99c\n  |   __driver_probe_device+0x15c/0x3c4\n  |   driver_probe_device+0x5c/0x170\n  |   __driver_attach+0x1c8/0x440\n  |   bus_for_each_dev+0xf4/0x178\n  |   driver_attach+0x3c/0x58\n  |   bus_add_driver+0x234/0x4d4\n  |   driver_register+0xf4/0x3c0\n  |   __platform_driver_register+0x60/0x88\n  |   scmi_driver_init+0xb0/0x104\n  |   do_one_initcall+0xb4/0x664\n  |   kernel_init_freeable+0x3c8/0x894\n  |   kernel_init+0x24/0x1e8\n  |   ret_from_fork+0x10/0x20\n  |\n  |  Allocated by task 1:\n  |   kasan_save_stack+0x2c/0x54\n  |   kasan_set_track+0x2c/0x40\n  |   kasan_save_alloc_info+0x24/0x34\n  |   __kasan_kmalloc+0xa0/0xb8\n  |   __kmalloc_node_track_caller+0x6c/0x104\n  |   kstrdup+0x48/0x84\n  |   kstrdup_const+0x34/0x40\n  |   __scmi_device_create.part.0+0x8c/0x408\n  |   scmi_device_create+0x104/0x370\n  |   scmi_chan_setup+0x2a0/0x750\n  |   scmi_probe+0x7fc/0x1508\n  |   platform_probe+0xc4/0x19c\n  |   really_probe+0x32c/0x99c\n  |   __driver_probe_device+0x15c/0x3c4\n  |   driver_probe_device+0x5c/0x170\n  |   __driver_attach+0x1c8/0x440\n  |   bus_for_each_dev+0xf4/0x178\n  |   driver_attach+0x3c/0x58\n  |   bus_add_driver+0x234/0x4d4\n  |   driver_register+0xf4/0x3c0\n  |   __platform_driver_register+0x60/0x88\n  |   scmi_driver_init+0xb0/0x104\n  |   do_one_initcall+0xb4/0x664\n  |   kernel_init_freeable+0x3c8/0x894\n  |   kernel_init+0x24/0x1e8\n  |   ret_from_fork+0x10/0x20\n  |\n  |  Freed by task 1:\n  |   kasan_save_stack+0x2c/0x54\n  |   kasan_set_track+0x2c/0x40\n  |   kasan_save_free_info+0x38/0x5c\n  |   __kasan_slab_free+0xe8/0x164\n  |   __kmem_cache_free+0x11c/0x230\n  |   kfree+0x70/0x130\n  |   kfree_const+0x20/0x40\n  |   __scmi_device_destroy+0x70/0x280\n  |   scmi_device_destroy+0x94/0xd0\n  |   scmi_chan_setup+0x524/0x750\n  |   scmi_probe+0x7fc/0x1508\n  |   platform_probe+0xc4/0x19c\n  |   really_probe+0x32c/0x99c\n  |   __driver_probe_device+0x15c/0x3c4\n  |   driver_probe_device+0x5c/0x170\n  |   __driver_attach+0x1c8/0x440\n  |   bus_for_each_dev+0xf4/0x178\n  |   driver_attach+0x3c/0x58\n  |   bus_add_driver+0x234/0x4d4\n  |   driver_register+0xf4/0x3c0\n  |   __platform_driver_register+0x60/0x88\n  |   scmi_driver_init+0xb0/0x104\n  |   do_one_initcall+0xb4/0x664\n  |   kernel_init_freeable+0x3c8/0x894\n  |   kernel_init+0x24/0x1e8\n  |   ret_from_fork+0x10/0x20",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/15b17bbcea07d49c43d21aa700485cbd9f9d00d8",
      "https://git.kernel.org/stable/c/1e1f523b185a8ccdcba625b31ff0312d052900e2",
      "https://git.kernel.org/stable/c/295416091e44806760ccf753aeafdafc0ae268f3"
    ],
    "受影响版本": [
      "ee7a9c9f67c59008b330deff2762bd8cf1407eec",
      "ee7a9c9f67c59008b330deff2762bd8cf1407eec",
      "ee7a9c9f67c59008b330deff2762bd8cf1407eec"
    ],
    "公开日期": "2024年11月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53065",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slab: fix warning caused by duplicate kmem_cache creation in kmem_buckets_create\n\nCommit b035f5a6d852 (\"mm: slab: reduce the kmalloc() minimum alignment\nif DMA bouncing possible\") reduced ARCH_KMALLOC_MINALIGN to 8 on arm64.\nHowever, with KASAN_HW_TAGS enabled, arch_slab_minalign() becomes 16.\nThis causes kmalloc_caches[*][8] to be aliased to kmalloc_caches[*][16],\nresulting in kmem_buckets_create() attempting to create a kmem_cache for\nsize 16 twice. This duplication triggers warnings on boot:\n\n[    2.325108] ------------[ cut here ]------------\n[    2.325135] kmem_cache of name 'memdup_user-16' already exists\n[    2.325783] WARNING: CPU: 0 PID: 1 at mm/slab_common.c:107 __kmem_cache_create_args+0xb8/0x3b0\n[    2.327957] Modules linked in:\n[    2.328550] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.0-rc5mm-unstable-arm64+ #12\n[    2.328683] Hardware name: QEMU QEMU Virtual Machine, BIOS 2024.02-2 03/11/2024\n[    2.328790] pstate: 61000009 (nZCv daif -PAN -UAO -TCO +DIT -SSBS BTYPE=--)\n[    2.328911] pc : __kmem_cache_create_args+0xb8/0x3b0\n[    2.328930] lr : __kmem_cache_create_args+0xb8/0x3b0\n[    2.328942] sp : ffff800083d6fc50\n[    2.328961] x29: ffff800083d6fc50 x28: f2ff0000c1674410 x27: ffff8000820b0598\n[    2.329061] x26: 000000007fffffff x25: 0000000000000010 x24: 0000000000002000\n[    2.329101] x23: ffff800083d6fce8 x22: ffff8000832222e8 x21: ffff800083222388\n[    2.329118] x20: f2ff0000c1674410 x19: f5ff0000c16364c0 x18: ffff800083d80030\n[    2.329135] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n[    2.329152] x14: 0000000000000000 x13: 0a73747369786520 x12: 79646165726c6120\n[    2.329169] x11: 656820747563205b x10: 2d2d2d2d2d2d2d2d x9 : 0000000000000000\n[    2.329194] x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000\n[    2.329210] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000\n[    2.329226] x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000\n[    2.329291] Call trace:\n[    2.329407]  __kmem_cache_create_args+0xb8/0x3b0\n[    2.329499]  kmem_buckets_create+0xfc/0x320\n[    2.329526]  init_user_buckets+0x34/0x78\n[    2.329540]  do_one_initcall+0x64/0x3c8\n[    2.329550]  kernel_init_freeable+0x26c/0x578\n[    2.329562]  kernel_init+0x3c/0x258\n[    2.329574]  ret_from_fork+0x10/0x20\n[    2.329698] ---[ end trace 0000000000000000 ]---\n\n[    2.403704] ------------[ cut here ]------------\n[    2.404716] kmem_cache of name 'msg_msg-16' already exists\n[    2.404801] WARNING: CPU: 2 PID: 1 at mm/slab_common.c:107 __kmem_cache_create_args+0xb8/0x3b0\n[    2.404842] Modules linked in:\n[    2.404971] CPU: 2 UID: 0 PID: 1 Comm: swapper/0 Tainted: G        W          6.12.0-rc5mm-unstable-arm64+ #12\n[    2.405026] Tainted: [W]=WARN\n[    2.405043] Hardware name: QEMU QEMU Virtual Machine, BIOS 2024.02-2 03/11/2024\n[    2.405057] pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    2.405079] pc : __kmem_cache_create_args+0xb8/0x3b0\n[    2.405100] lr : __kmem_cache_create_args+0xb8/0x3b0\n[    2.405111] sp : ffff800083d6fc50\n[    2.405115] x29: ffff800083d6fc50 x28: fbff0000c1674410 x27: ffff8000820b0598\n[    2.405135] x26: 000000000000ffd0 x25: 0000000000000010 x24: 0000000000006000\n[    2.405153] x23: ffff800083d6fce8 x22: ffff8000832222e8 x21: ffff800083222388\n[    2.405169] x20: fbff0000c1674410 x19: fdff0000c163d6c0 x18: ffff800083d80030\n[    2.405185] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n[    2.405201] x14: 0000000000000000 x13: 0a73747369786520 x12: 79646165726c6120\n[    2.405217] x11: 656820747563205b x10: 2d2d2d2d2d2d2d2d x9 : 0000000000000000\n[    2.405233] x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000\n[    2.405248] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000\n[    2.405271] x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000\n[    2.405287] Call trace:\n[    2\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1b47f9febf48641d3530ec877f4d0995c58e6b73",
      "https://git.kernel.org/stable/c/9c9201afebea1efc7ea4b8f721ee18a05bb8aca1"
    ],
    "受影响版本": [
      "b32801d1255be1da62ea8134df3ed9f3331fba12",
      "b32801d1255be1da62ea8134df3ed9f3331fba12"
    ],
    "公开日期": "2024年11月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53061",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: s5p-jpeg: prevent buffer overflows\n\nThe current logic allows word to be less than 2. If this happens,\nthere will be buffer overflows, as reported by smatch. Add extra\nchecks to prevent it.\n\nWhile here, remove an unused word = 0 assignment.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c5f6fefcda8fac8f082b6c5bf416567f4e100c51",
      "https://git.kernel.org/stable/c/e5117f6e7adcf9fd7546cdd0edc9abe4474bc98b",
      "https://git.kernel.org/stable/c/f54e8e1e39dacccebcfb9a9a36f0552a0a97e2ef",
      "https://git.kernel.org/stable/c/a930cddfd153b5d4401df0c01effa14c831ff21e",
      "https://git.kernel.org/stable/c/c85db2d4432de4ff9d97006691ce2dcb5bda660e",
      "https://git.kernel.org/stable/c/784bc785a453eb2f8433dd62075befdfa1b2d6fd",
      "https://git.kernel.org/stable/c/c951a0859fdacf49a2298b5551a7e52b95ff6f51",
      "https://git.kernel.org/stable/c/14a22762c3daeac59a5a534e124acbb4d7a79b3a"
    ],
    "受影响版本": [
      "6c96dbbc2aa9f5b4aed8792989d69eae22bf77c4",
      "6c96dbbc2aa9f5b4aed8792989d69eae22bf77c4",
      "6c96dbbc2aa9f5b4aed8792989d69eae22bf77c4",
      "6c96dbbc2aa9f5b4aed8792989d69eae22bf77c4",
      "6c96dbbc2aa9f5b4aed8792989d69eae22bf77c4",
      "6c96dbbc2aa9f5b4aed8792989d69eae22bf77c4",
      "6c96dbbc2aa9f5b4aed8792989d69eae22bf77c4",
      "6c96dbbc2aa9f5b4aed8792989d69eae22bf77c4"
    ],
    "公开日期": "2024年11月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-53046",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: dts: imx8ulp: correct the flexspi compatible string\n\nThe flexspi on imx8ulp only has 16 LUTs, and imx8mm flexspi has\n32 LUTs, so correct the compatible string here, otherwise will\nmeet below error:\n\n[    1.119072] ------------[ cut here ]------------\n[    1.123926] WARNING: CPU: 0 PID: 1 at drivers/spi/spi-nxp-fspi.c:855 nxp_fspi_exec_op+0xb04/0xb64\n[    1.133239] Modules linked in:\n[    1.136448] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.11.0-rc6-next-20240902-00001-g131bf9439dd9 #69\n[    1.146821] Hardware name: NXP i.MX8ULP EVK (DT)\n[    1.151647] pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    1.158931] pc : nxp_fspi_exec_op+0xb04/0xb64\n[    1.163496] lr : nxp_fspi_exec_op+0xa34/0xb64\n[    1.168060] sp : ffff80008002b2a0\n[    1.171526] x29: ffff80008002b2d0 x28: 0000000000000000 x27: 0000000000000000\n[    1.179002] x26: ffff2eb645542580 x25: ffff800080610014 x24: ffff800080610000\n[    1.186480] x23: ffff2eb645548080 x22: 0000000000000006 x21: ffff2eb6455425e0\n[    1.193956] x20: 0000000000000000 x19: ffff80008002b5e0 x18: ffffffffffffffff\n[    1.201432] x17: ffff2eb644467508 x16: 0000000000000138 x15: 0000000000000002\n[    1.208907] x14: 0000000000000000 x13: ffff2eb6400d8080 x12: 00000000ffffff00\n[    1.216378] x11: 0000000000000000 x10: ffff2eb6400d8080 x9 : ffff2eb697adca80\n[    1.223850] x8 : ffff2eb697ad3cc0 x7 : 0000000100000000 x6 : 0000000000000001\n[    1.231324] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 00000000000007a6\n[    1.238795] x2 : 0000000000000000 x1 : 00000000000001ce x0 : 00000000ffffff92\n[    1.246267] Call trace:\n[    1.248824]  nxp_fspi_exec_op+0xb04/0xb64\n[    1.253031]  spi_mem_exec_op+0x3a0/0x430\n[    1.257139]  spi_nor_read_id+0x80/0xcc\n[    1.261065]  spi_nor_scan+0x1ec/0xf10\n[    1.264901]  spi_nor_probe+0x108/0x2fc\n[    1.268828]  spi_mem_probe+0x6c/0xbc\n[    1.272574]  spi_probe+0x84/0xe4\n[    1.275958]  really_probe+0xbc/0x29c\n[    1.279713]  __driver_probe_device+0x78/0x12c\n[    1.284277]  driver_probe_device+0xd8/0x15c\n[    1.288660]  __device_attach_driver+0xb8/0x134\n[    1.293316]  bus_for_each_drv+0x88/0xe8\n[    1.297337]  __device_attach+0xa0/0x190\n[    1.301353]  device_initial_probe+0x14/0x20\n[    1.305734]  bus_probe_device+0xac/0xb0\n[    1.309752]  device_add+0x5d0/0x790\n[    1.313408]  __spi_add_device+0x134/0x204\n[    1.317606]  of_register_spi_device+0x3b4/0x590\n[    1.322348]  spi_register_controller+0x47c/0x754\n[    1.327181]  devm_spi_register_controller+0x4c/0xa4\n[    1.332289]  nxp_fspi_probe+0x1cc/0x2b0\n[    1.336307]  platform_probe+0x68/0xc4\n[    1.340145]  really_probe+0xbc/0x29c\n[    1.343893]  __driver_probe_device+0x78/0x12c\n[    1.348457]  driver_probe_device+0xd8/0x15c\n[    1.352838]  __driver_attach+0x90/0x19c\n[    1.356857]  bus_for_each_dev+0x7c/0xdc\n[    1.360877]  driver_attach+0x24/0x30\n[    1.364624]  bus_add_driver+0xe4/0x208\n[    1.368552]  driver_register+0x5c/0x124\n[    1.372573]  __platform_driver_register+0x28/0x34\n[    1.377497]  nxp_fspi_driver_init+0x1c/0x28\n[    1.381888]  do_one_initcall+0x80/0x1c8\n[    1.385908]  kernel_init_freeable+0x1c4/0x28c\n[    1.390472]  kernel_init+0x20/0x1d8\n[    1.394138]  ret_from_fork+0x10/0x20\n[    1.397885] ---[ end trace 0000000000000000 ]---\n[    1.407908] ------------[ cut here ]------------",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e3fb0e6afcc399660770428a35162b4880e2e14e",
      "https://git.kernel.org/stable/c/c3c02fa6a560b3af7999a067cd387970f4b3f1fa",
      "https://git.kernel.org/stable/c/409dc5196d5b6eb67468a06bf4d2d07d7225a67b"
    ],
    "受影响版本": [
      "ef89fd56bdfcf5d8039bb64c76d2f8c9ac908ca7",
      "ef89fd56bdfcf5d8039bb64c76d2f8c9ac908ca7",
      "ef89fd56bdfcf5d8039bb64c76d2f8c9ac908ca7"
    ],
    "公开日期": "2024年11月19日"
  },
  {
    "设备品牌": "Mindstien Technologies",
    "设备类型": "OTA",
    "产品型号": "My Geo Posts Free",
    "CVE编号": "CVE-2024-52433",
    "漏洞描述": "Deserialization of Untrusted Data vulnerability in Mindstien Technologies My Geo Posts Free allows Object Injection.This issue affects My Geo Posts Free: from n/a through 1.2.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/my-geo-posts-free/wordpress-my-geo-posts-free-plugin-1-2-php-object-injection-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年11月18日"
  },
  {
    "设备品牌": "Medma Technologies",
    "设备类型": "OTA",
    "产品型号": "Matix Popup Builder",
    "CVE编号": "CVE-2024-52382",
    "漏洞描述": "Missing Authorization vulnerability in Medma Technologies Matix Popup Builder allows Privilege Escalation.This issue affects Matix Popup Builder: from n/a through 1.0.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/medma-matix/wordpress-matix-popup-builder-plugin-1-0-0-arbitrary-option-update-to-privilege-escalation-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年11月14日"
  },
  {
    "设备品牌": "Kinetic Innovative Technologies Sdn Bhd",
    "设备类型": "OTA",
    "产品型号": "kineticPay for WooCommerce",
    "CVE编号": "CVE-2024-52379",
    "漏洞描述": "Unrestricted Upload of File with Dangerous Type vulnerability in Kinetic Innovative Technologies Sdn Bhd kineticPay for WooCommerce allows Upload a Web Shell to a Web Server.This issue affects kineticPay for WooCommerce: from n/a through 2.0.8.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/kineticpay-for-woocommerce/wordpress-kineticpay-for-woocommerce-plugin-2-0-8-arbitrary-file-upload-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年11月14日"
  },
  {
    "设备品牌": "Loop Now Technologies, Inc.",
    "设备类型": "OTA",
    "产品型号": "Firework Shoppable Live Video",
    "CVE编号": "CVE-2024-51781",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation (XSS or 'Cross-site Scripting') vulnerability in Loop Now Technologies, Inc. Firework Shoppable Live Video allows Reflected XSS.This issue affects Firework Shoppable Live Video: from n/a through 6.3.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/firework-videos/wordpress-firework-shoppable-live-video-plugin-6-3-reflected-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年11月09日"
  },
  {
    "设备品牌": "Elsner Technologies Pvt. Ltd.",
    "设备类型": "OTA",
    "产品型号": "Emoji Shortcode",
    "CVE编号": "CVE-2024-51609",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation (XSS or 'Cross-site Scripting') vulnerability in Elsner Technologies Pvt. Ltd. Emoji Shortcode allows Stored XSS.This issue affects Emoji Shortcode: from n/a through 1.0.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/emoji-shortcode/wordpress-emoji-shortcode-plugin-1-0-0-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年11月09日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2024-51399",
    "漏洞描述": "Altai Technologies Ltd Altai IX500 Indoor 22 802.11ac Wave 2 AP After login, there are file reads in the background, and attackers can obtain sensitive information such as user credentials, system configuration, and database connection strings, which can lead to data breaches and identity theft.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/HuhaiOvO/Altai/blob/main/Altai%20IX500%20Indoor%202%C3%972%20802.11ac%20Wave%202%20AP%20file%20read.docx"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年11月01日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2024-51398",
    "漏洞描述": "Altai Technologies Ltd Altai X500 Indoor 22 802.11ac Wave 2 AP web Management Weak password leakage in the background may lead to unauthorized access, data theft, and network attacks, seriously threatening network security.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/HuhaiOvO/Altai/blob/main/Altai%20IX500%20Indoor%202%C3%972%20802.11ac%20Wave%202%20AP%20wake%20password.docx",
      "https://github.com/HuhaiOvO/Altai/blob/main/Altai_IX500_Weak_Password.yaml"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年11月01日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "LiteSpeed Cache",
    "CVE编号": "CVE-2024-50550",
    "漏洞描述": "Incorrect Privilege Assignment vulnerability in LiteSpeed Technologies LiteSpeed Cache allows Privilege Escalation.This issue affects LiteSpeed Cache: from n/a through 6.5.1.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/litespeed-cache/wordpress-litespeed-cache-plugin-6-5-1-privilege-escalation-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年10月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50295",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: arc: fix the device for dma_map_single/dma_unmap_single\n\nThe ndev->dev and pdev->dev aren't the same device, use ndev->dev.parent\nwhich has dma_mask, ndev->dev.parent is just pdev->dev.\nOr it would cause the following issue:\n\n[   39.933526] ------------[ cut here ]------------\n[   39.938414] WARNING: CPU: 1 PID: 501 at kernel/dma/mapping.c:149 dma_map_page_attrs+0x90/0x1f8",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/30606ea3fae57f8e9f2467415389e988e3c53a18",
      "https://git.kernel.org/stable/c/3898393b5483c8aa2efd7cb13aa70e22078ab022",
      "https://git.kernel.org/stable/c/fd4e062fbc07156f8e9d73212d347c744572677e",
      "https://git.kernel.org/stable/c/8ed7a4a39c3f7cd9655af867e878fda512ae67ad",
      "https://git.kernel.org/stable/c/cd4706d9ac0d8d3bab8dc9e50cc1187f6cfa43dd",
      "https://git.kernel.org/stable/c/71803c1dfa29e0d13b99e48fda11107cc8caebc7"
    ],
    "受影响版本": [
      "f959dcd6ddfd29235030e8026471ac1b022ad2b0",
      "f959dcd6ddfd29235030e8026471ac1b022ad2b0",
      "f959dcd6ddfd29235030e8026471ac1b022ad2b0",
      "f959dcd6ddfd29235030e8026471ac1b022ad2b0",
      "f959dcd6ddfd29235030e8026471ac1b022ad2b0",
      "f959dcd6ddfd29235030e8026471ac1b022ad2b0",
      "4e57482e8440fac7137832629109730ea4b267aa"
    ],
    "公开日期": "2024年11月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50269",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: musb: sunxi: Fix accessing an released usb phy\n\nCommit 6ed05c68cbca (\"usb: musb: sunxi: Explicitly release USB PHY on\nexit\") will cause that usb phy @glue->xceiv is accessed after released.\n\n1) register platform driver @sunxi_musb_driver\n// get the usb phy @glue->xceiv\nsunxi_musb_probe() -> devm_usb_get_phy().\n\n2) register and unregister platform driver @musb_driver\nmusb_probe() -> sunxi_musb_init()\nuse the phy here\n//the phy is released here\nmusb_remove() -> sunxi_musb_exit() -> devm_usb_put_phy()\n\n3) register @musb_driver again\nmusb_probe() -> sunxi_musb_init()\nuse the phy here but the phy has been released at 2).\n...\n\nFixed by reverting the commit, namely, removing devm_usb_put_phy()\nfrom sunxi_musb_exit().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/721ddad945596220c123eb6f7126729fe277ee4f",
      "https://git.kernel.org/stable/c/4aa77d5ea9944468e16c3eed15e858fd5de44de1",
      "https://git.kernel.org/stable/c/6e2848d1c8c0139161e69ac0a94133e90e9988e8",
      "https://git.kernel.org/stable/c/63559ba8077cbadae1c92a65b73ea522bf377dd9",
      "https://git.kernel.org/stable/c/ccd811c304d2ee56189bfbc49302cb3c44361893",
      "https://git.kernel.org/stable/c/8a30da5aa9609663b3e05bcc91a916537f66a4cd",
      "https://git.kernel.org/stable/c/b08baa75b989cf779cbfa0969681f8ba2dc46569",
      "https://git.kernel.org/stable/c/498dbd9aea205db9da674994b74c7bf8e18448bd"
    ],
    "受影响版本": [
      "6ed05c68cbcae42cd52b8e53b66952bfa9c002ce",
      "6ed05c68cbcae42cd52b8e53b66952bfa9c002ce",
      "6ed05c68cbcae42cd52b8e53b66952bfa9c002ce",
      "6ed05c68cbcae42cd52b8e53b66952bfa9c002ce",
      "6ed05c68cbcae42cd52b8e53b66952bfa9c002ce",
      "6ed05c68cbcae42cd52b8e53b66952bfa9c002ce",
      "6ed05c68cbcae42cd52b8e53b66952bfa9c002ce",
      "6ed05c68cbcae42cd52b8e53b66952bfa9c002ce",
      "583a4219841d00e96b5de55be160aa7eb7721a4d",
      "b4ecc15d6f5a13c0bbe2777438e87e321f83faaa",
      "a2259ebaa933331c53904caf792b619ec42f0da5"
    ],
    "公开日期": "2024年11月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50234",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlegacy: Clear stale interrupts before resuming device\n\niwl4965 fails upon resume from hibernation on my laptop. The reason\nseems to be a stale interrupt which isn't being cleared out before\ninterrupts are enabled. We end up with a race beween the resume\ntrying to bring things back up, and the restart work (queued form\nthe interrupt handler) trying to bring things down. Eventually\nthe whole thing blows up.\n\nFix the problem by clearing out any stale interrupts before\ninterrupts get enabled during resume.\n\nHere's a debug log of the indicent:\n[   12.042589] ieee80211 phy0: il_isr ISR inta 0x00000080, enabled 0xaa00008b, fh 0x00000000\n[   12.042625] ieee80211 phy0: il4965_irq_tasklet inta 0x00000080, enabled 0x00000000, fh 0x00000000\n[   12.042651] iwl4965 0000:10:00.0: RF_KILL bit toggled to enable radio.\n[   12.042653] iwl4965 0000:10:00.0: On demand firmware reload\n[   12.042690] ieee80211 phy0: il4965_irq_tasklet End inta 0x00000000, enabled 0xaa00008b, fh 0x00000000, flags 0x00000282\n[   12.052207] ieee80211 phy0: il4965_mac_start enter\n[   12.052212] ieee80211 phy0: il_prep_station Add STA to driver ID 31: ff:ff:ff:ff:ff:ff\n[   12.052244] ieee80211 phy0: il4965_set_hw_ready hardware  ready\n[   12.052324] ieee80211 phy0: il_apm_init Init card's basic functions\n[   12.052348] ieee80211 phy0: il_apm_init L1 Enabled; Disabling L0S\n[   12.055727] ieee80211 phy0: il4965_load_bsm Begin load bsm\n[   12.056140] ieee80211 phy0: il4965_verify_bsm Begin verify bsm\n[   12.058642] ieee80211 phy0: il4965_verify_bsm BSM bootstrap uCode image OK\n[   12.058721] ieee80211 phy0: il4965_load_bsm BSM write complete, poll 1 iterations\n[   12.058734] ieee80211 phy0: __il4965_up iwl4965 is coming up\n[   12.058737] ieee80211 phy0: il4965_mac_start Start UP work done.\n[   12.058757] ieee80211 phy0: __il4965_down iwl4965 is going down\n[   12.058761] ieee80211 phy0: il_scan_cancel_timeout Scan cancel timeout\n[   12.058762] ieee80211 phy0: il_do_scan_abort Not performing scan to abort\n[   12.058765] ieee80211 phy0: il_clear_ucode_stations Clearing ucode stations in driver\n[   12.058767] ieee80211 phy0: il_clear_ucode_stations No active stations found to be cleared\n[   12.058819] ieee80211 phy0: _il_apm_stop Stop card, put in low power state\n[   12.058827] ieee80211 phy0: _il_apm_stop_master stop master\n[   12.058864] ieee80211 phy0: il4965_clear_free_frames 0 frames on pre-allocated heap on clear.\n[   12.058869] ieee80211 phy0: Hardware restart was requested\n[   16.132299] iwl4965 0000:10:00.0: START_ALIVE timeout after 4000ms.\n[   16.132303] ------------[ cut here ]------------\n[   16.132304] Hardware became unavailable upon resume. This could be a software issue prior to suspend or a hardware issue.\n[   16.132338] WARNING: CPU: 0 PID: 181 at net/mac80211/util.c:1826 ieee80211_reconfig+0x8f/0x14b0 [mac80211]\n[   16.132390] Modules linked in: ctr ccm sch_fq_codel xt_tcpudp xt_multiport xt_state iptable_filter iptable_nat nf_nat nf_conntrack nf_defrag_ipv4 ip_tables x_tables binfmt_misc joydev mousedev btusb btrtl btintel btbcm bluetooth ecdh_generic ecc iTCO_wdt i2c_dev iwl4965 iwlegacy coretemp snd_hda_codec_analog pcspkr psmouse mac80211 snd_hda_codec_generic libarc4 sdhci_pci cqhci sha256_generic sdhci libsha256 firewire_ohci snd_hda_intel snd_intel_dspcfg mmc_core snd_hda_codec snd_hwdep firewire_core led_class iosf_mbi snd_hda_core uhci_hcd lpc_ich crc_itu_t cfg80211 ehci_pci ehci_hcd snd_pcm usbcore mfd_core rfkill snd_timer snd usb_common soundcore video parport_pc parport intel_agp wmi intel_gtt backlight e1000e agpgart evdev\n[   16.132456] CPU: 0 UID: 0 PID: 181 Comm: kworker/u8:6 Not tainted 6.11.0-cl+ #143\n[   16.132460] Hardware name: Hewlett-Packard HP Compaq 6910p/30BE, BIOS 68MCU Ver. F.19 07/06/2010\n[   16.132463] Workqueue: async async_run_entry_fn\n[   16.132469] RIP: 0010:ieee80211_reconfig+0x8f/0x14b0 [mac80211]\n[   16.132501] Code: da 02 00 0\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/271d282ecc15d7012e71ca82c89a6c0e13a063dd",
      "https://git.kernel.org/stable/c/9d89941e51259c2b0b8e9c10c6f1f74200d7444f",
      "https://git.kernel.org/stable/c/d0231f43df473e2f80372d0ca150eb3619932ef9",
      "https://git.kernel.org/stable/c/8ac22fe1e2b104c37e4fecd97735f64bd6349ebc",
      "https://git.kernel.org/stable/c/23f9cef17ee315777dbe88d5c11ff6166e4d0699",
      "https://git.kernel.org/stable/c/cedf0f1db8d5f3524339c2c6e35a8505b0f1ab73",
      "https://git.kernel.org/stable/c/8af8294d369a871cdbcdbb4d13b87d2d6e490a1f",
      "https://git.kernel.org/stable/c/07c90acb071b9954e1fecb1e4f4f13d12c544b34"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年11月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50226",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncxl/port: Fix use-after-free, permit out-of-order decoder shutdown\n\nIn support of investigating an initialization failure report [1],\ncxl_test was updated to register mock memory-devices after the mock\nroot-port/bus device had been registered. That led to cxl_test crashing\nwith a use-after-free bug with the following signature:\n\n    cxl_port_attach_region: cxl region3: cxl_host_bridge.0:port3 decoder3.0 add: mem0:decoder7.0 @ 0 next: cxl_switch_uport.0 nr_eps: 1 nr_targets: 1\n    cxl_port_attach_region: cxl region3: cxl_host_bridge.0:port3 decoder3.0 add: mem4:decoder14.0 @ 1 next: cxl_switch_uport.0 nr_eps: 2 nr_targets: 1\n    cxl_port_setup_targets: cxl region3: cxl_switch_uport.0:port6 target[0] = cxl_switch_dport.0 for mem0:decoder7.0 @ 0\n1)  cxl_port_setup_targets: cxl region3: cxl_switch_uport.0:port6 target[1] = cxl_switch_dport.4 for mem4:decoder14.0 @ 1\n    [..]\n    cxld_unregister: cxl decoder14.0:\n    cxl_region_decode_reset: cxl_region region3:\n    mock_decoder_reset: cxl_port port3: decoder3.0 reset\n2)  mock_decoder_reset: cxl_port port3: decoder3.0: out of order reset, expected decoder3.1\n    cxl_endpoint_decoder_release: cxl decoder14.0:\n    [..]\n    cxld_unregister: cxl decoder7.0:\n3)  cxl_region_decode_reset: cxl_region region3:\n    Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6bc3: 0000 [#1] PREEMPT SMP PTI\n    [..]\n    RIP: 0010:to_cxl_port+0x8/0x60 [cxl_core]\n    [..]\n    Call Trace:\n     <TASK>\n     cxl_region_decode_reset+0x69/0x190 [cxl_core]\n     cxl_region_detach+0xe8/0x210 [cxl_core]\n     cxl_decoder_kill_region+0x27/0x40 [cxl_core]\n     cxld_unregister+0x5d/0x60 [cxl_core]\n\nAt 1) a region has been established with 2 endpoint decoders (7.0 and\n14.0). Those endpoints share a common switch-decoder in the topology\n(3.0). At teardown, 2), decoder14.0 is the first to be removed and hits\nthe \"out of order reset case\" in the switch decoder. The effect though\nis that region3 cleanup is aborted leaving it in-tact and\nreferencing decoder14.0. At 3) the second attempt to teardown region3\ntrips over the stale decoder14.0 object which has long since been\ndeleted.\n\nThe fix here is to recognize that the CXL specification places no\nmandate on in-order shutdown of switch-decoders, the driver enforces\nin-order allocation, and hardware enforces in-order commit. So, rather\nthan fail and leave objects dangling, always remove them.\n\nIn support of making cxl_region_decode_reset() always succeed,\ncxl_region_invalidate_memregion() failures are turned into warnings.\nCrashing the kernel is ok there since system integrity is at risk if\ncaches cannot be managed around physical address mutation events like\nCXL region destruction.\n\nA new device_for_each_child_reverse_from() is added to cleanup\nport->commit_end after all dependent decoders have been disabled. In\nother words if decoders are allocated 0->1->2 and disabled 1->2->0 then\nport->commit_end only decrements from 2 after 2 has been disabled, and\nit decrements all the way to zero since 1 was disabled previously.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8e1b52c15c81106456437f8e49575040e489e355",
      "https://git.kernel.org/stable/c/78c8454fdce0eeee962be004eb6d99860c80dad1",
      "https://git.kernel.org/stable/c/101c268bd2f37e965a5468353e62d154db38838e"
    ],
    "受影响版本": [
      "176baefb2eb5d7a3ddebe3ff803db1fce44574b5",
      "176baefb2eb5d7a3ddebe3ff803db1fce44574b5",
      "176baefb2eb5d7a3ddebe3ff803db1fce44574b5"
    ],
    "公开日期": "2024年11月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50223",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched/numa: Fix the potential null pointer dereference in task_numa_work()\n\nWhen running stress-ng-vm-segv test, we found a null pointer dereference\nerror in task_numa_work(). Here is the backtrace:\n\n  [323676.066985] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000020\n  ......\n  [323676.067108] CPU: 35 PID: 2694524 Comm: stress-ng-vm-se\n  ......\n  [323676.067113] pstate: 23401009 (nzCv daif +PAN -UAO +TCO +DIT +SSBS BTYPE=--)\n  [323676.067115] pc : vma_migratable+0x1c/0xd0\n  [323676.067122] lr : task_numa_work+0x1ec/0x4e0\n  [323676.067127] sp : ffff8000ada73d20\n  [323676.067128] x29: ffff8000ada73d20 x28: 0000000000000000 x27: 000000003e89f010\n  [323676.067130] x26: 0000000000080000 x25: ffff800081b5c0d8 x24: ffff800081b27000\n  [323676.067133] x23: 0000000000010000 x22: 0000000104d18cc0 x21: ffff0009f7158000\n  [323676.067135] x20: 0000000000000000 x19: 0000000000000000 x18: ffff8000ada73db8\n  [323676.067138] x17: 0001400000000000 x16: ffff800080df40b0 x15: 0000000000000035\n  [323676.067140] x14: ffff8000ada73cc8 x13: 1fffe0017cc72001 x12: ffff8000ada73cc8\n  [323676.067142] x11: ffff80008001160c x10: ffff000be639000c x9 : ffff8000800f4ba4\n  [323676.067145] x8 : ffff000810375000 x7 : ffff8000ada73974 x6 : 0000000000000001\n  [323676.067147] x5 : 0068000b33e26707 x4 : 0000000000000001 x3 : ffff0009f7158000\n  [323676.067149] x2 : 0000000000000041 x1 : 0000000000004400 x0 : 0000000000000000\n  [323676.067152] Call trace:\n  [323676.067153]  vma_migratable+0x1c/0xd0\n  [323676.067155]  task_numa_work+0x1ec/0x4e0\n  [323676.067157]  task_work_run+0x78/0xd8\n  [323676.067161]  do_notify_resume+0x1ec/0x290\n  [323676.067163]  el0_svc+0x150/0x160\n  [323676.067167]  el0t_64_sync_handler+0xf8/0x128\n  [323676.067170]  el0t_64_sync+0x17c/0x180\n  [323676.067173] Code: d2888001 910003fd f9000bf3 aa0003f3 (f9401000)\n  [323676.067177] SMP: stopping secondary CPUs\n  [323676.070184] Starting crashdump kernel...\n\nstress-ng-vm-segv in stress-ng is used to stress test the SIGSEGV error\nhandling function of the system, which tries to cause a SIGSEGV error on\nreturn from unmapping the whole address space of the child process.\n\nNormally this program will not cause kernel crashes. But before the\nmunmap system call returns to user mode, a potential task_numa_work()\nfor numa balancing could be added and executed. In this scenario, since the\nchild process has no vma after munmap, the vma_next() in task_numa_work()\nwill return a null pointer even if the vma iterator restarts from 0.\n\nRecheck the vma pointer before dereferencing it in task_numa_work().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ade91f6e9848b370add44d89c976e070ccb492ef",
      "https://git.kernel.org/stable/c/c60d98ef7078fc3e22b48e98eae7a897d88494ee",
      "https://git.kernel.org/stable/c/9c70b2a33cd2aa6a5a59c5523ef053bd42265209"
    ],
    "受影响版本": [
      "214dbc4281374cbbd833edd502d0ed1fd1b0e243",
      "214dbc4281374cbbd833edd502d0ed1fd1b0e243",
      "214dbc4281374cbbd833edd502d0ed1fd1b0e243"
    ],
    "公开日期": "2024年11月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50220",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfork: do not invoke uffd on fork if error occurs\n\nPatch series \"fork: do not expose incomplete mm on fork\".\n\nDuring fork we may place the virtual memory address space into an\ninconsistent state before the fork operation is complete.\n\nIn addition, we may encounter an error during the fork operation that\nindicates that the virtual memory address space is invalidated.\n\nAs a result, we should not be exposing it in any way to external machinery\nthat might interact with the mm or VMAs, machinery that is not designed to\ndeal with incomplete state.\n\nWe specifically update the fork logic to defer khugepaged and ksm to the\nend of the operation and only to be invoked if no error arose, and\ndisallow uffd from observing fork events should an error have occurred.\n\n\nThis patch (of 2):\n\nCurrently on fork we expose the virtual address space of a process to\nuserland unconditionally if uffd is registered in VMAs, regardless of\nwhether an error arose in the fork.\n\nThis is performed in dup_userfaultfd_complete() which is invoked\nunconditionally, and performs two duties - invoking registered handlers\nfor the UFFD_EVENT_FORK event via dup_fctx(), and clearing down\nuserfaultfd_fork_ctx objects established in dup_userfaultfd().\n\nThis is problematic, because the virtual address space may not yet be\ncorrectly initialised if an error arose.\n\nThe change in commit d24062914837 (\"fork: use __mt_dup() to duplicate\nmaple tree in dup_mmap()\") makes this more pertinent as we may be in a\nstate where entries in the maple tree are not yet consistent.\n\nWe address this by, on fork error, ensuring that we roll back state that\nwe would otherwise expect to clean up through the event being handled by\nuserland and perform the memory freeing duty otherwise performed by\ndup_userfaultfd_complete().\n\nWe do this by implementing a new function, dup_userfaultfd_fail(), which\nperforms the same loop, only decrementing reference counts.\n\nNote that we perform mmgrab() on the parent and child mm's, however\nuserfaultfd_ctx_put() will mmdrop() this once the reference count drops to\nzero, so we will avoid memory leaks correctly here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/92b472945dbf8abc020e9259c0088026f7027dfc",
      "https://git.kernel.org/stable/c/f64e67e5d3a45a4a04286c47afade4b518acd47b",
      "https://project-zero.issues.chromium.org/issues/373391951"
    ],
    "受影响版本": [
      "d2406291483775ecddaee929231a39c70c08fda2",
      "d2406291483775ecddaee929231a39c70c08fda2"
    ],
    "公开日期": "2024年11月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50212",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nlib: alloc_tag_module_unload must wait for pending kfree_rcu calls\n\nBen Greear reports following splat:\n ------------[ cut here ]------------\n net/netfilter/nf_nat_core.c:1114 module nf_nat func:nf_nat_register_fn has 256 allocated at module unload\n WARNING: CPU: 1 PID: 10421 at lib/alloc_tag.c:168 alloc_tag_module_unload+0x22b/0x3f0\n Modules linked in: nf_nat(-) btrfs ufs qnx4 hfsplus hfs minix vfat msdos fat\n...\n Hardware name: Default string Default string/SKYBAY, BIOS 5.12 08/04/2020\n RIP: 0010:alloc_tag_module_unload+0x22b/0x3f0\n  codetag_unload_module+0x19b/0x2a0\n  ? codetag_load_module+0x80/0x80\n\nnf_nat module exit calls kfree_rcu on those addresses, but the free\noperation is likely still pending by the time alloc_tag checks for leaks.\n\nWait for outstanding kfree_rcu operations to complete before checking\nresolves this warning.\n\nReproducer:\nunshare -n iptables-nft -t nat -A PREROUTING -p tcp\ngrep nf_nat /proc/allocinfo # will list 4 allocations\nrmmod nft_chain_nat\nrmmod nf_nat                # will WARN.\n\n[akpm@linux-foundation.org: add comment]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/24211fb49c9ac1b576470b7e393a5a0b50af2707",
      "https://git.kernel.org/stable/c/dc783ba4b9df3fb3e76e968b2cbeb9960069263c"
    ],
    "受影响版本": [
      "a473573964e51dcb6efc182f773cd3924be4a184",
      "a473573964e51dcb6efc182f773cd3924be4a184"
    ],
    "公开日期": "2024年11月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50169",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock: Update rx_bytes on read_skb()\n\nMake sure virtio_transport_inc_rx_pkt() and virtio_transport_dec_rx_pkt()\ncalls are balanced (i.e. virtio_vsock_sock::rx_bytes doesn't lie) after\nvsock_transport::read_skb().\n\nWhile here, also inform the peer that we've freed up space and it has more\ncredit.\n\nFailing to update rx_bytes after packet is dequeued leads to a warning on\nSOCK_STREAM recv():\n\n[  233.396654] rx_queue is empty, but rx_bytes is non-zero\n[  233.396702] WARNING: CPU: 11 PID: 40601 at net/vmw_vsock/virtio_transport_common.c:589",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/66cd51de31c682a311c2fa25c580b7ea45859dd9",
      "https://git.kernel.org/stable/c/e5ca2b98090b4bb1c393088c724af6c37812a829",
      "https://git.kernel.org/stable/c/3543152f2d330141d9394d28855cb90b860091d2"
    ],
    "受影响版本": [
      "634f1a7110b439c65fd8a809171c1d2d28bcea6f",
      "634f1a7110b439c65fd8a809171c1d2d28bcea6f",
      "634f1a7110b439c65fd8a809171c1d2d28bcea6f"
    ],
    "公开日期": "2024年11月07日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50161",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Check the remaining info_cnt before repeating btf fields\n\nWhen trying to repeat the btf fields for array of nested struct, it\ndoesn't check the remaining info_cnt. The following splat will be\nreported when the value of ret * nelems is greater than BTF_FIELDS_MAX:\n\n  ------------[ cut here ]------------\n  UBSAN: array-index-out-of-bounds in ../kernel/bpf/btf.c:3951:49\n  index 11 is out of range for type 'btf_field_info [11]'\n  CPU: 6 UID: 0 PID: 411 Comm: test_progs ...... 6.11.0-rc4+ #1\n  Tainted: [O]=OOT_MODULE\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ...\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x57/0x70\n   dump_stack+0x10/0x20\n   ubsan_epilogue+0x9/0x40\n   __ubsan_handle_out_of_bounds+0x6f/0x80\n   ? kallsyms_lookup_name+0x48/0xb0\n   btf_parse_fields+0x992/0xce0\n   map_create+0x591/0x770\n   __sys_bpf+0x229/0x2410\n   __x64_sys_bpf+0x1f/0x30\n   x64_sys_call+0x199/0x9f0\n   do_syscall_64+0x3b/0xc0\n   entry_SYSCALL_64_after_hwframe+0x4b/0x53\n  RIP: 0033:0x7fea56f2cc5d\n  ......\n   </TASK>\n  ---[ end trace ]---\n\nFix it by checking the remaining info_cnt in btf_repeat_fields() before\nrepeating the btf fields.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6f957d972feee9b385ea3ae6530310a84e55ba71",
      "https://git.kernel.org/stable/c/797d73ee232dd1833dec4824bc53a22032e97c1c"
    ],
    "受影响版本": [
      "64e8ee814819f21beeeda00d4119221443d77992",
      "64e8ee814819f21beeeda00d4119221443d77992"
    ],
    "公开日期": "2024年11月07日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50136",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Unregister notifier on eswitch init failure\n\nIt otherwise remains registered and a subsequent attempt at eswitch\nenabling might trigger warnings of the sort:\n\n[  682.589148] ------------[ cut here ]------------\n[  682.590204] notifier callback eswitch_vport_event [mlx5_core] already registered\n[  682.590256] WARNING: CPU: 13 PID: 2660 at kernel/notifier.c:31 notifier_chain_register+0x3e/0x90\n[...snipped]\n[  682.610052] Call Trace:\n[  682.610369]  <TASK>\n[  682.610663]  ? __warn+0x7c/0x110\n[  682.611050]  ? notifier_chain_register+0x3e/0x90\n[  682.611556]  ? report_bug+0x148/0x170\n[  682.611977]  ? handle_bug+0x36/0x70\n[  682.612384]  ? exc_invalid_op+0x13/0x60\n[  682.612817]  ? asm_exc_invalid_op+0x16/0x20\n[  682.613284]  ? notifier_chain_register+0x3e/0x90\n[  682.613789]  atomic_notifier_chain_register+0x25/0x40\n[  682.614322]  mlx5_eswitch_enable_locked+0x1d4/0x3b0 [mlx5_core]\n[  682.614965]  mlx5_eswitch_enable+0xc9/0x100 [mlx5_core]\n[  682.615551]  mlx5_device_enable_sriov+0x25/0x340 [mlx5_core]\n[  682.616170]  mlx5_core_sriov_configure+0x50/0x170 [mlx5_core]\n[  682.616789]  sriov_numvfs_store+0xb0/0x1b0\n[  682.617248]  kernfs_fop_write_iter+0x117/0x1a0\n[  682.617734]  vfs_write+0x231/0x3f0\n[  682.618138]  ksys_write+0x63/0xe0\n[  682.618536]  do_syscall_64+0x4c/0x100\n[  682.618958]  entry_SYSCALL_64_after_hwframe+0x4b/0x53",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e58fb7ddbab6635191c26dea1af26b91cce00866",
      "https://git.kernel.org/stable/c/9f2ccb6f3888bec45c00121ee43e4e72423b12c1",
      "https://git.kernel.org/stable/c/599147722c5778c96292e2fbff4103abbdb45b1f",
      "https://git.kernel.org/stable/c/1da9cfd6c41c2e6bbe624d0568644e1521c33e12"
    ],
    "受影响版本": [
      "0aa1e83a20f12e9eaad32f72212ebc7fe0c29c95",
      "7624e58a8b3a251e3e5108b32f2183b34453db32",
      "7624e58a8b3a251e3e5108b32f2183b34453db32",
      "7624e58a8b3a251e3e5108b32f2183b34453db32",
      "dc426bd9d813aa5754ce35adaa6f97f0585c06fc"
    ],
    "公开日期": "2024年11月05日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50128",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: wwan: fix global oob in wwan_rtnl_policy\n\nThe variable wwan_rtnl_link_ops assign a *bigger* maxtype which leads to\na global out-of-bounds read when parsing the netlink attributes. Exactly\nsame bug cause as the oob fixed in commit b33fb5b801c6 (\"net: qualcomm:\nrmnet: fix global oob in rmnet_policy\").\n\n==================================================================\nBUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:388 [inline]\nBUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x19d7/0x29a0 lib/nlattr.c:603\nRead of size 1 at addr ffffffff8b09cb60 by task syz.1.66276/323862\n\nCPU: 0 PID: 323862 Comm: syz.1.66276 Not tainted 6.1.70 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x177/0x231 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:284 [inline]\n print_report+0x14f/0x750 mm/kasan/report.c:395\n kasan_report+0x139/0x170 mm/kasan/report.c:495\n validate_nla lib/nlattr.c:388 [inline]\n __nla_validate_parse+0x19d7/0x29a0 lib/nlattr.c:603\n __nla_parse+0x3c/0x50 lib/nlattr.c:700\n nla_parse_nested_deprecated include/net/netlink.h:1269 [inline]\n __rtnl_newlink net/core/rtnetlink.c:3514 [inline]\n rtnl_newlink+0x7bc/0x1fd0 net/core/rtnetlink.c:3623\n rtnetlink_rcv_msg+0x794/0xef0 net/core/rtnetlink.c:6122\n netlink_rcv_skb+0x1de/0x420 net/netlink/af_netlink.c:2508\n netlink_unicast_kernel net/netlink/af_netlink.c:1326 [inline]\n netlink_unicast+0x74b/0x8c0 net/netlink/af_netlink.c:1352\n netlink_sendmsg+0x882/0xb90 net/netlink/af_netlink.c:1874\n sock_sendmsg_nosec net/socket.c:716 [inline]\n __sock_sendmsg net/socket.c:728 [inline]\n ____sys_sendmsg+0x5cc/0x8f0 net/socket.c:2499\n ___sys_sendmsg+0x21c/0x290 net/socket.c:2553\n __sys_sendmsg net/socket.c:2582 [inline]\n __do_sys_sendmsg net/socket.c:2591 [inline]\n __se_sys_sendmsg+0x19e/0x270 net/socket.c:2589\n do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n do_syscall_64+0x45/0x90 arch/x86/entry/common.c:81\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7f67b19a24ad\nRSP: 002b:00007f67b17febb8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007f67b1b45f80 RCX: 00007f67b19a24ad\nRDX: 0000000000000000 RSI: 0000000020005e40 RDI: 0000000000000004\nRBP: 00007f67b1a1e01d R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007ffd2513764f R14: 00007ffd251376e0 R15: 00007f67b17fed40\n </TASK>\n\nThe buggy address belongs to the variable:\n wwan_rtnl_policy+0x20/0x40\n\nThe buggy address belongs to the physical page:\npage:ffffea00002c2700 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0xb09c\nflags: 0xfff00000001000(reserved|node=0|zone=1|lastcpupid=0x7ff)\nraw: 00fff00000001000 ffffea00002c2708 ffffea00002c2708 0000000000000000\nraw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner info is not present (never set?)\n\nMemory state around the buggy address:\n ffffffff8b09ca00: 05 f9 f9 f9 05 f9 f9 f9 00 01 f9 f9 00 01 f9 f9\n ffffffff8b09ca80: 00 00 00 05 f9 f9 f9 f9 00 00 03 f9 f9 f9 f9 f9\n>ffffffff8b09cb00: 00 00 00 00 05 f9 f9 f9 00 00 00 00 f9 f9 f9 f9\n                                                       ^\n ffffffff8b09cb80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n==================================================================\n\nAccording to the comment of `nla_parse_nested_deprecated`, use correct size\n`IFLA_WWAN_MAX` here to fix this issue.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c9a0aed51977198df005d0a623090e38e2d77d7b",
      "https://git.kernel.org/stable/c/9683804e36668f6093fb06e202eed2f188ba437e",
      "https://git.kernel.org/stable/c/69076f8435c1c5dae5f814eaf4c361d1f00b22a3",
      "https://git.kernel.org/stable/c/a3ffce63dcc0c208edd4d196e17baed22ebcb643",
      "https://git.kernel.org/stable/c/47dd5447cab8ce30a847a0337d5341ae4c7476a7"
    ],
    "受影响版本": [
      "88b710532e53de2466d1033fb1d5125aabf3215a",
      "88b710532e53de2466d1033fb1d5125aabf3215a",
      "88b710532e53de2466d1033fb1d5125aabf3215a",
      "88b710532e53de2466d1033fb1d5125aabf3215a",
      "88b710532e53de2466d1033fb1d5125aabf3215a"
    ],
    "公开日期": "2024年11月05日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50092",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: netconsole: fix wrong warning\n\nA warning is triggered when there is insufficient space in the buffer\nfor userdata. However, this is not an issue since userdata will be sent\nin the next iteration.\n\nCurrent warning message:\n\n    ------------[ cut here ]------------\n     WARNING: CPU: 13 PID: 3013042 at drivers/net/netconsole.c:1122 write_ext_msg+0x3b6/0x3d0\n      ? write_ext_msg+0x3b6/0x3d0\n      console_flush_all+0x1e9/0x330\n\nThe code incorrectly issues a warning when this_chunk is zero, which is\na valid scenario. The warning should only be triggered when this_chunk\nis negative.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/712a3af3710263444217df54e7f337f99df198d2",
      "https://git.kernel.org/stable/c/d94785bb46b6167382b1de3290eccc91fa98df53"
    ],
    "受影响版本": [
      "1ec9daf950936c2a1c591596e83c09ce2eb12ade",
      "1ec9daf950936c2a1c591596e83c09ce2eb12ade"
    ],
    "公开日期": "2024年11月05日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50090",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe/oa: Fix overflow in oa batch buffer\n\nBy default xe_bb_create_job() appends a MI_BATCH_BUFFER_END to batch\nbuffer, this is not a problem if batch buffer is only used once but\noa reuses the batch buffer for the same metric and at each call\nit appends a MI_BATCH_BUFFER_END, printing the warning below and then\noverflowing.\n\n[  381.072016] ------------[ cut here ]------------\n[  381.072019] xe 0000:00:02.0: [drm] Assertion `bb->len * 4 + bb_prefetch(q->gt) <= size` failed!\n               platform: LUNARLAKE subplatform: 1\n               graphics: Xe2_LPG / Xe2_HPG 20.04 step B0\n               media: Xe2_LPM / Xe2_HPM 20.00 step B0\n               tile: 0 VRAM 0 B\n               GT: 0 type 1\n\nSo here checking if batch buffer already have MI_BATCH_BUFFER_END if\nnot append it.\n\nv2:\n- simply fix, suggestion from Ashutosh\n\n(cherry picked from commit 9ba0e0f30ca42a98af3689460063edfb6315718a)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/bcb5be3421705e682b0b32073ad627056d6bc2a2",
      "https://git.kernel.org/stable/c/6c10ba06bb1b48acce6d4d9c1e33beb9954f1788"
    ],
    "受影响版本": [
      "dd08ebf6c3525a7ea2186e636df064ea47281987",
      "dd08ebf6c3525a7ea2186e636df064ea47281987"
    ],
    "公开日期": "2024年11月05日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50083",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: fix mptcp DSS corruption due to large pmtu xmit\n\nSyzkaller was able to trigger a DSS corruption:\n\n  TCP: request_sock_subflow_v4: Possible SYN flooding on port [::]:20002. Sending cookies.\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 5227 at net/mptcp/protocol.c:695 __mptcp_move_skbs_from_subflow+0x20a9/0x21f0 net/mptcp/protocol.c:695\n  Modules linked in:\n  CPU: 0 UID: 0 PID: 5227 Comm: syz-executor350 Not tainted 6.11.0-syzkaller-08829-gaf9c191ac2a0 #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\n  RIP: 0010:__mptcp_move_skbs_from_subflow+0x20a9/0x21f0 net/mptcp/protocol.c:695\n  Code: 0f b6 dc 31 ff 89 de e8 b5 dd ea f5 89 d8 48 81 c4 50 01 00 00 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc e8 98 da ea f5 90 <0f> 0b 90 e9 47 ff ff ff e8 8a da ea f5 90 0f 0b 90 e9 99 e0 ff ff\n  RSP: 0018:ffffc90000006db8 EFLAGS: 00010246\n  RAX: ffffffff8ba9df18 RBX: 00000000000055f0 RCX: ffff888030023c00\n  RDX: 0000000000000100 RSI: 00000000000081e5 RDI: 00000000000055f0\n  RBP: 1ffff110062bf1ae R08: ffffffff8ba9cf12 R09: 1ffff110062bf1b8\n  R10: dffffc0000000000 R11: ffffed10062bf1b9 R12: 0000000000000000\n  R13: dffffc0000000000 R14: 00000000700cec61 R15: 00000000000081e5\n  FS:  000055556679c380(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000020287000 CR3: 0000000077892000 CR4: 00000000003506f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   <IRQ>\n   move_skbs_to_msk net/mptcp/protocol.c:811 [inline]\n   mptcp_data_ready+0x29c/0xa90 net/mptcp/protocol.c:854\n   subflow_data_ready+0x34a/0x920 net/mptcp/subflow.c:1490\n   tcp_data_queue+0x20fd/0x76c0 net/ipv4/tcp_input.c:5283\n   tcp_rcv_established+0xfba/0x2020 net/ipv4/tcp_input.c:6237\n   tcp_v4_do_rcv+0x96d/0xc70 net/ipv4/tcp_ipv4.c:1915\n   tcp_v4_rcv+0x2dc0/0x37f0 net/ipv4/tcp_ipv4.c:2350\n   ip_protocol_deliver_rcu+0x22e/0x440 net/ipv4/ip_input.c:205\n   ip_local_deliver_finish+0x341/0x5f0 net/ipv4/ip_input.c:233\n   NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314\n   NF_HOOK+0x3a4/0x450 include/linux/netfilter.h:314\n   __netif_receive_skb_one_core net/core/dev.c:5662 [inline]\n   __netif_receive_skb+0x2bf/0x650 net/core/dev.c:5775\n   process_backlog+0x662/0x15b0 net/core/dev.c:6107\n   __napi_poll+0xcb/0x490 net/core/dev.c:6771\n   napi_poll net/core/dev.c:6840 [inline]\n   net_rx_action+0x89b/0x1240 net/core/dev.c:6962\n   handle_softirqs+0x2c5/0x980 kernel/softirq.c:554\n   do_softirq+0x11b/0x1e0 kernel/softirq.c:455\n   </IRQ>\n   <TASK>\n   __local_bh_enable_ip+0x1bb/0x200 kernel/softirq.c:382\n   local_bh_enable include/linux/bottom_half.h:33 [inline]\n   rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline]\n   __dev_queue_xmit+0x1764/0x3e80 net/core/dev.c:4451\n   dev_queue_xmit include/linux/netdevice.h:3094 [inline]\n   neigh_hh_output include/net/neighbour.h:526 [inline]\n   neigh_output include/net/neighbour.h:540 [inline]\n   ip_finish_output2+0xd41/0x1390 net/ipv4/ip_output.c:236\n   ip_local_out net/ipv4/ip_output.c:130 [inline]\n   __ip_queue_xmit+0x118c/0x1b80 net/ipv4/ip_output.c:536\n   __tcp_transmit_skb+0x2544/0x3b30 net/ipv4/tcp_output.c:1466\n   tcp_transmit_skb net/ipv4/tcp_output.c:1484 [inline]\n   tcp_mtu_probe net/ipv4/tcp_output.c:2547 [inline]\n   tcp_write_xmit+0x641d/0x6bf0 net/ipv4/tcp_output.c:2752\n   __tcp_push_pending_frames+0x9b/0x360 net/ipv4/tcp_output.c:3015\n   tcp_push_pending_frames include/net/tcp.h:2107 [inline]\n   tcp_data_snd_check net/ipv4/tcp_input.c:5714 [inline]\n   tcp_rcv_established+0x1026/0x2020 net/ipv4/tcp_input.c:6239\n   tcp_v4_do_rcv+0x96d/0xc70 net/ipv4/tcp_ipv4.c:1915\n   sk_backlog_rcv include/net/sock.h:1113 [inline]\n   __release_sock+0x214/0x350 net/core/sock.c:3072\n   release_sock+0x61/0x1f0 net/core/sock.c:3626\n   mptcp_push_\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c38add9ac0e4d4f418e6443a688491499021add9",
      "https://git.kernel.org/stable/c/9729010a0ac5945c1bf6847dd0778d8a1a4b72ac",
      "https://git.kernel.org/stable/c/ba8e65814e519eeb17d086952bce7de93f7a40da",
      "https://git.kernel.org/stable/c/229dfdc36f31a8d47433438bc0e6e1662c4ab404",
      "https://git.kernel.org/stable/c/db04d1848777ae52a7ab93c4591e7c0bf8f55fb4",
      "https://git.kernel.org/stable/c/4dabcdf581217e60690467a37c956a5b8dbc6bd9"
    ],
    "受影响版本": [
      "85712484110df308215077be6ee21c4e57d7dec2",
      "85712484110df308215077be6ee21c4e57d7dec2",
      "85712484110df308215077be6ee21c4e57d7dec2",
      "85712484110df308215077be6ee21c4e57d7dec2",
      "85712484110df308215077be6ee21c4e57d7dec2",
      "85712484110df308215077be6ee21c4e57d7dec2"
    ],
    "公开日期": "2024年10月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50078",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Call iso_exit() on module unload\n\nIf iso_init() has been called, iso_exit() must be called on module\nunload. Without that, the struct proto that iso_init() registered with\nproto_register() becomes invalid, which could cause unpredictable\nproblems later. In my case, with CONFIG_LIST_HARDENED and\nCONFIG_BUG_ON_DATA_CORRUPTION enabled, loading the module again usually\ntriggers this BUG():\n\n  list_add corruption. next->prev should be prev (ffffffffb5355fd0),\n    but was 0000000000000068. (next=ffffffffc0a010d0).\n  ------------[ cut here ]------------\n  kernel BUG at lib/list_debug.c:29!\n  Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI\n  CPU: 1 PID: 4159 Comm: modprobe Not tainted 6.10.11-4+bt2-ao-desktop #1\n  RIP: 0010:__list_add_valid_or_report+0x61/0xa0\n  ...\n    __list_add_valid_or_report+0x61/0xa0\n    proto_register+0x299/0x320\n    hci_sock_init+0x16/0xc0 [bluetooth]\n    bt_init+0x68/0xd0 [bluetooth]\n    __pfx_bt_init+0x10/0x10 [bluetooth]\n    do_one_initcall+0x80/0x2f0\n    do_init_module+0x8b/0x230\n    __do_sys_init_module+0x15f/0x190\n    do_syscall_64+0x68/0x110\n  ...",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4af7ba39a1a02e16ee8cd0d3b6c6657f51b8ad7a",
      "https://git.kernel.org/stable/c/05f84d86169b2ebac185c5736a256823d42c425b",
      "https://git.kernel.org/stable/c/f905a7d95091e0d2605a3a1a157a9351f09ab2e1",
      "https://git.kernel.org/stable/c/d458cd1221e9e56da3b2cc5518ad3225caa91f20"
    ],
    "受影响版本": [
      "ccf74f2390d60a2f9a75ef496d2564abb478f46a",
      "ccf74f2390d60a2f9a75ef496d2564abb478f46a",
      "ccf74f2390d60a2f9a75ef496d2564abb478f46a",
      "ccf74f2390d60a2f9a75ef496d2564abb478f46a"
    ],
    "公开日期": "2024年10月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50077",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: ISO: Fix multiple init when debugfs is disabled\n\nIf bt_debugfs is not created successfully, which happens if either\nCONFIG_DEBUG_FS or CONFIG_DEBUG_FS_ALLOW_ALL is unset, then iso_init()\nreturns early and does not set iso_inited to true. This means that a\nsubsequent call to iso_init() will result in duplicate calls to\nproto_register(), bt_sock_register(), etc.\n\nWith CONFIG_LIST_HARDENED and CONFIG_BUG_ON_DATA_CORRUPTION enabled, the\nduplicate call to proto_register() triggers this BUG():\n\n  list_add double add: new=ffffffffc0b280d0, prev=ffffffffbab56250,\n    next=ffffffffc0b280d0.\n  ------------[ cut here ]------------\n  kernel BUG at lib/list_debug.c:35!\n  Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI\n  CPU: 2 PID: 887 Comm: bluetoothd Not tainted 6.10.11-1-ao-desktop #1\n  RIP: 0010:__list_add_valid_or_report+0x9a/0xa0\n  ...\n    __list_add_valid_or_report+0x9a/0xa0\n    proto_register+0x2b5/0x340\n    iso_init+0x23/0x150 [bluetooth]\n    set_iso_socket_func+0x68/0x1b0 [bluetooth]\n    kmem_cache_free+0x308/0x330\n    hci_sock_sendmsg+0x990/0x9e0 [bluetooth]\n    __sock_sendmsg+0x7b/0x80\n    sock_write_iter+0x9a/0x110\n    do_iter_readv_writev+0x11d/0x220\n    vfs_writev+0x180/0x3e0\n    do_writev+0xca/0x100\n  ...\n\nThis change removes the early return. The check for iso_debugfs being\nNULL was unnecessary, it is always NULL when iso_inited is false.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fa4b832c5a6ec35023a1b997cf658c436619c752",
      "https://git.kernel.org/stable/c/8fb8e912afb4c47dec12ea9a5853e7a8db95816f",
      "https://git.kernel.org/stable/c/adf1b179c2ff8073c24bf87e5a605fcc5a09798b",
      "https://git.kernel.org/stable/c/a9b7b535ba192c6b77e6c15a4c82d853163eab8c"
    ],
    "受影响版本": [
      "ccf74f2390d60a2f9a75ef496d2564abb478f46a",
      "ccf74f2390d60a2f9a75ef496d2564abb478f46a",
      "ccf74f2390d60a2f9a75ef496d2564abb478f46a",
      "ccf74f2390d60a2f9a75ef496d2564abb478f46a"
    ],
    "公开日期": "2024年10月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50048",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbcon: Fix a NULL pointer dereference issue in fbcon_putcs\n\nsyzbot has found a NULL pointer dereference bug in fbcon.\nHere is the simplified C reproducer:\n\nstruct param {\n\tuint8_t type;\n\tstruct tiocl_selection ts;\n};\n\nint main()\n{\n\tstruct fb_con2fbmap con2fb;\n\tstruct param param;\n\n\tint fd = open(\"/dev/fb1\", 0, 0);\n\n\tcon2fb.console = 0x19;\n\tcon2fb.framebuffer = 0;\n\tioctl(fd, FBIOPUT_CON2FBMAP, &con2fb);\n\n\tparam.type = 2;\n\tparam.ts.xs = 0; param.ts.ys = 0;\n\tparam.ts.xe = 0; param.ts.ye = 0;\n\tparam.ts.sel_mode = 0;\n\n\tint fd1 = open(\"/dev/tty1\", O_RDWR, 0);\n\tioctl(fd1, TIOCLINUX, &param);\n\n\tcon2fb.console = 1;\n\tcon2fb.framebuffer = 0;\n\tioctl(fd, FBIOPUT_CON2FBMAP, &con2fb);\n\n\treturn 0;\n}\n\nAfter calling ioctl(fd1, TIOCLINUX, &param), the subsequent ioctl(fd, FBIOPUT_CON2FBMAP, &con2fb)\ncauses the kernel to follow a different execution path:\n\n set_con2fb_map\n  -> con2fb_init_display\n   -> fbcon_set_disp\n    -> redraw_screen\n     -> hide_cursor\n      -> clear_selection\n       -> highlight\n        -> invert_screen\n         -> do_update_region\n          -> fbcon_putcs\n           -> ops->putcs\n\nSince ops->putcs is a NULL pointer, this leads to a kernel panic.\nTo prevent this, we need to call set_blitting_type() within set_con2fb_map()\nto properly initialize ops->putcs.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8266ae6eafdcd5a3136592445ff4038bbc7ee80e",
      "https://git.kernel.org/stable/c/f7fb5dda555344529ce584ff7a28b109528d2f1b",
      "https://git.kernel.org/stable/c/e5c2dba62996a3a6eeb34bd248b90fc69c5a6a1b",
      "https://git.kernel.org/stable/c/5b97eebcce1b4f3f07a71f635d6aa3af96c236e7"
    ],
    "受影响版本": [
      "b07db39584856e16814e2f065380e533a001535d",
      "b07db39584856e16814e2f065380e533a001535d",
      "b07db39584856e16814e2f065380e533a001535d",
      "b07db39584856e16814e2f065380e533a001535d"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50040",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nigb: Do not bring the device up after non-fatal error\n\nCommit 004d25060c78 (\"igb: Fix igb_down hung on surprise removal\")\nchanged igb_io_error_detected() to ignore non-fatal pcie errors in order\nto avoid hung task that can happen when igb_down() is called multiple\ntimes. This caused an issue when processing transient non-fatal errors.\nigb_io_resume(), which is called after igb_io_error_detected(), assumes\nthat device is brought down by igb_io_error_detected() if the interface\nis up. This resulted in panic with stacktrace below.\n\n[ T3256] igb 0000:09:00.0 haeth0: igb: haeth0 NIC Link is Down\n[  T292] pcieport 0000:00:1c.5: AER: Uncorrected (Non-Fatal) error received: 0000:09:00.0\n[  T292] igb 0000:09:00.0: PCIe Bus Error: severity=Uncorrected (Non-Fatal), type=Transaction Layer, (Requester ID)\n[  T292] igb 0000:09:00.0:   device [8086:1537] error status/mask=00004000/00000000\n[  T292] igb 0000:09:00.0:    [14] CmpltTO [  200.105524,009][  T292] igb 0000:09:00.0: AER:   TLP Header: 00000000 00000000 00000000 00000000\n[  T292] pcieport 0000:00:1c.5: AER: broadcast error_detected message\n[  T292] igb 0000:09:00.0: Non-correctable non-fatal error reported.\n[  T292] pcieport 0000:00:1c.5: AER: broadcast mmio_enabled message\n[  T292] pcieport 0000:00:1c.5: AER: broadcast resume message\n[  T292] ------------[ cut here ]------------\n[  T292] kernel BUG at net/core/dev.c:6539!\n[  T292] invalid opcode: 0000 [#1] PREEMPT SMP\n[  T292] RIP: 0010:napi_enable+0x37/0x40\n[  T292] Call Trace:\n[  T292]  <TASK>\n[  T292]  ? die+0x33/0x90\n[  T292]  ? do_trap+0xdc/0x110\n[  T292]  ? napi_enable+0x37/0x40\n[  T292]  ? do_error_trap+0x70/0xb0\n[  T292]  ? napi_enable+0x37/0x40\n[  T292]  ? napi_enable+0x37/0x40\n[  T292]  ? exc_invalid_op+0x4e/0x70\n[  T292]  ? napi_enable+0x37/0x40\n[  T292]  ? asm_exc_invalid_op+0x16/0x20\n[  T292]  ? napi_enable+0x37/0x40\n[  T292]  igb_up+0x41/0x150\n[  T292]  igb_io_resume+0x25/0x70\n[  T292]  report_resume+0x54/0x70\n[  T292]  ? report_frozen_detected+0x20/0x20\n[  T292]  pci_walk_bus+0x6c/0x90\n[  T292]  ? aer_print_port_info+0xa0/0xa0\n[  T292]  pcie_do_recovery+0x22f/0x380\n[  T292]  aer_process_err_devices+0x110/0x160\n[  T292]  aer_isr+0x1c1/0x1e0\n[  T292]  ? disable_irq_nosync+0x10/0x10\n[  T292]  irq_thread_fn+0x1a/0x60\n[  T292]  irq_thread+0xe3/0x1a0\n[  T292]  ? irq_set_affinity_notifier+0x120/0x120\n[  T292]  ? irq_affinity_notify+0x100/0x100\n[  T292]  kthread+0xe2/0x110\n[  T292]  ? kthread_complete_and_exit+0x20/0x20\n[  T292]  ret_from_fork+0x2d/0x50\n[  T292]  ? kthread_complete_and_exit+0x20/0x20\n[  T292]  ret_from_fork_asm+0x11/0x20\n[  T292]  </TASK>\n\nTo fix this issue igb_io_resume() checks if the interface is running and\nthe device is not down this means igb_io_error_detected() did not bring\nthe device down and there is no need to bring it up.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/dca2ca65a8695d9593e2cf1b40848e073ad75413",
      "https://git.kernel.org/stable/c/c92cbd283ddcf55fd85a9a9b0ba13298213f3dd7",
      "https://git.kernel.org/stable/c/d79af3af2f49c6aae9add3d492c04d60c1b85ce4",
      "https://git.kernel.org/stable/c/0a94079e3841d00ea5abb05e3233d019a86745f6",
      "https://git.kernel.org/stable/c/6a39c8f5c8aae74c5ab2ba466791f59ffaab0178",
      "https://git.kernel.org/stable/c/57c5053eaa5f9a8a99e34732e37a86615318e464",
      "https://git.kernel.org/stable/c/500be93c5d53b7e2c5314292012185f0207bad0c",
      "https://git.kernel.org/stable/c/330a699ecbfc9c26ec92c6310686da1230b4e7eb"
    ],
    "受影响版本": [
      "124e39a734cb90658b8f0dc110847bbfc6e33792",
      "c9f56f3c7bc908caa772112d3ae71cdd5d18c257",
      "994c2ceb70ea99264ccc6f09e6703ca267dad63c",
      "fa92c463eba75dcedbd8d689ffdcb83293aaa0c3",
      "39695e87d86f0e7d897fba1d2559f825aa20caeb",
      "004d25060c78fc31f66da0fa439c544dda1ac9d5",
      "004d25060c78fc31f66da0fa439c544dda1ac9d5",
      "004d25060c78fc31f66da0fa439c544dda1ac9d5",
      "c2312e1d12b1c3ee4100c173131b102e2aed4d04",
      "41f63b72a01c0e0ac59ab83fd2d921fcce0f602d"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50037",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/fbdev-dma: Only cleanup deferred I/O if necessary\n\nCommit 5a498d4d06d6 (\"drm/fbdev-dma: Only install deferred I/O if\nnecessary\") initializes deferred I/O only if it is used.\ndrm_fbdev_dma_fb_destroy() however calls fb_deferred_io_cleanup()\nunconditionally with struct fb_info.fbdefio == NULL. KASAN with the\nout-of-tree Apple silicon display driver posts following warning from\n__flush_work() of a random struct work_struct instead of the expected\nNULL pointer derefs.\n\n[   22.053799] ------------[ cut here ]------------\n[   22.054832] WARNING: CPU: 2 PID: 1 at kernel/workqueue.c:4177 __flush_work+0x4d8/0x580\n[   22.056597] Modules linked in: uhid bnep uinput nls_ascii ip6_tables ip_tables i2c_dev loop fuse dm_multipath nfnetlink zram hid_magicmouse btrfs xor xor_neon brcmfmac_wcc raid6_pq hci_bcm4377 bluetooth brcmfmac hid_apple brcmutil nvmem_spmi_mfd simple_mfd_spmi dockchannel_hid cfg80211 joydev regmap_spmi nvme_apple ecdh_generic ecc macsmc_hid rfkill dwc3 appledrm snd_soc_macaudio macsmc_power nvme_core apple_isp phy_apple_atc apple_sart apple_rtkit_helper apple_dockchannel tps6598x macsmc_hwmon snd_soc_cs42l84 videobuf2_v4l2 spmi_apple_controller nvmem_apple_efuses videobuf2_dma_sg apple_z2 videobuf2_memops spi_nor panel_summit videobuf2_common asahi videodev pwm_apple apple_dcp snd_soc_apple_mca apple_admac spi_apple clk_apple_nco i2c_pasemi_platform snd_pcm_dmaengine mc i2c_pasemi_core mux_core ofpart adpdrm drm_dma_helper apple_dart apple_soc_cpufreq leds_pwm phram\n[   22.073768] CPU: 2 UID: 0 PID: 1 Comm: systemd-shutdow Not tainted 6.11.2-asahi+ #asahi-dev\n[   22.075612] Hardware name: Apple MacBook Pro (13-inch, M2, 2022) (DT)\n[   22.077032] pstate: 01400005 (nzcv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)\n[   22.078567] pc : __flush_work+0x4d8/0x580\n[   22.079471] lr : __flush_work+0x54/0x580\n[   22.080345] sp : ffffc000836ef820\n[   22.081089] x29: ffffc000836ef880 x28: 0000000000000000 x27: ffff80002ddb7128\n[   22.082678] x26: dfffc00000000000 x25: 1ffff000096f0c57 x24: ffffc00082d3e358\n[   22.084263] x23: ffff80004b7862b8 x22: dfffc00000000000 x21: ffff80005aa1d470\n[   22.085855] x20: ffff80004b786000 x19: ffff80004b7862a0 x18: 0000000000000000\n[   22.087439] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000005\n[   22.089030] x14: 1ffff800106ddf0a x13: 0000000000000000 x12: 0000000000000000\n[   22.090618] x11: ffffb800106ddf0f x10: dfffc00000000000 x9 : 1ffff800106ddf0e\n[   22.092206] x8 : 0000000000000000 x7 : aaaaaaaaaaaaaaaa x6 : 0000000000000001\n[   22.093790] x5 : ffffc000836ef728 x4 : 0000000000000000 x3 : 0000000000000020\n[   22.095368] x2 : 0000000000000008 x1 : 00000000000000aa x0 : 0000000000000000\n[   22.096955] Call trace:\n[   22.097505]  __flush_work+0x4d8/0x580\n[   22.098330]  flush_delayed_work+0x80/0xb8\n[   22.099231]  fb_deferred_io_cleanup+0x3c/0x130\n[   22.100217]  drm_fbdev_dma_fb_destroy+0x6c/0xe0 [drm_dma_helper]\n[   22.101559]  unregister_framebuffer+0x210/0x2f0\n[   22.102575]  drm_fb_helper_unregister_info+0x48/0x60\n[   22.103683]  drm_fbdev_dma_client_unregister+0x4c/0x80 [drm_dma_helper]\n[   22.105147]  drm_client_dev_unregister+0x1cc/0x230\n[   22.106217]  drm_dev_unregister+0x58/0x570\n[   22.107125]  apple_drm_unbind+0x50/0x98 [appledrm]\n[   22.108199]  component_del+0x1f8/0x3a8\n[   22.109042]  dcp_platform_shutdown+0x24/0x38 [apple_dcp]\n[   22.110357]  platform_shutdown+0x70/0x90\n[   22.111219]  device_shutdown+0x368/0x4d8\n[   22.112095]  kernel_restart+0x6c/0x1d0\n[   22.112946]  __arm64_sys_reboot+0x1c8/0x328\n[   22.113868]  invoke_syscall+0x78/0x1a8\n[   22.114703]  do_el0_svc+0x124/0x1a0\n[   22.115498]  el0_svc+0x3c/0xe0\n[   22.116181]  el0t_64_sync_handler+0x70/0xc0\n[   22.117110]  el0t_64_sync+0x190/0x198\n[   22.117931] ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5a4a8ea14c54c651ec532a480bd560d0c6e52f3d",
      "https://git.kernel.org/stable/c/fcddc71ec7ecf15b4df3c41288c9cf0b8e886111"
    ],
    "受影响版本": [
      "5a498d4d06d6d9bad76d8a50a7f8fe01670ad46f",
      "5a498d4d06d6d9bad76d8a50a7f8fe01670ad46f"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50010",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nexec: don't WARN for racy path_noexec check\n\nBoth i_mode and noexec checks wrapped in WARN_ON stem from an artifact\nof the previous implementation. They used to legitimately check for the\ncondition, but that got moved up in two commits:\n633fb6ac3980 (\"exec: move S_ISREG() check earlier\")\n0fd338b2d2cd (\"exec: move path_noexec() check earlier\")\n\nInstead of being removed said checks are WARN_ON'ed instead, which\nhas some debug value.\n\nHowever, the spurious path_noexec check is racy, resulting in\nunwarranted warnings should someone race with setting the noexec flag.\n\nOne can note there is more to perm-checking whether execve is allowed\nand none of the conditions are guaranteed to still hold after they were\ntested for.\n\nAdditionally this does not validate whether the code path did any perm\nchecking to begin with -- it will pass if the inode happens to be\nregular.\n\nKeep the redundant path_noexec() check even though it's mindless\nnonsense checking for guarantee that isn't given so drop the WARN.\n\nReword the commentary and do small tidy ups while here.\n\n[brauner: keep redundant path_noexec() check]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c9b77438077d5a20c79ead95bcdaf9bd4797baaf",
      "https://git.kernel.org/stable/c/b723f96407a0a078cf75970e4dbf16b46d286a61",
      "https://git.kernel.org/stable/c/0bdf77be2330062b3a64f2bec39f62ab874a6796",
      "https://git.kernel.org/stable/c/0d16f53c91111cec914f0811fcc526a2ba77b20d",
      "https://git.kernel.org/stable/c/0d196e7589cefe207d5d41f37a0a28a1fdeeb7c6"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50008",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: Fix memcpy() field-spanning write warning in mwifiex_cmd_802_11_scan_ext()\n\nReplace one-element array with a flexible-array member in\n`struct host_cmd_ds_802_11_scan_ext`.\n\nWith this, fix the following warning:\n\nelo 16 17:51:58 surfacebook kernel: ------------[ cut here ]------------\nelo 16 17:51:58 surfacebook kernel: memcpy: detected field-spanning write (size 243) of single field \"ext_scan->tlv_buffer\" at drivers/net/wireless/marvell/mwifiex/scan.c:2239 (size 1)\nelo 16 17:51:58 surfacebook kernel: WARNING: CPU: 0 PID: 498 at drivers/net/wireless/marvell/mwifiex/scan.c:2239 mwifiex_cmd_802_11_scan_ext+0x83/0x90 [mwifiex]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b55c8848fdc81514ec047b2a0ec782ffe9ab5323",
      "https://git.kernel.org/stable/c/f9310a6704bf52e2493480edea896e1f9b795d40",
      "https://git.kernel.org/stable/c/1756918f51e9ab247a0f4782cc28853c2bb457c1",
      "https://git.kernel.org/stable/c/e59bdb1ba594104cd0ee0af3ee9e4435d842a8fe",
      "https://git.kernel.org/stable/c/17199b69a84798efffc475040fbef44374ef1de1",
      "https://git.kernel.org/stable/c/fef7b51f22cf2049b0ca6740adeb0ba6f2e671dc",
      "https://git.kernel.org/stable/c/71267bd4e8c752d7af6c6b96bb83984a6a95273d",
      "https://git.kernel.org/stable/c/a3a12c30f9510f3753286fadbc6cdb7dad78c1d5",
      "https://git.kernel.org/stable/c/498365e52bebcbc36a93279fe7e9d6aec8479cee"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49976",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/timerlat: Drop interface_lock in stop_kthread()\n\nstop_kthread() is the offline callback for \"trace/osnoise:online\", since\ncommit 5bfbcd1ee57b (\"tracing/timerlat: Add interface_lock around clearing\nof kthread in stop_kthread()\"), the following ABBA deadlock scenario is\nintroduced:\n\nT1                            | T2 [BP]               | T3 [AP]\nosnoise_hotplug_workfn()      | work_for_cpu_fn()     | cpuhp_thread_fun()\n                              |   _cpu_down()         |   osnoise_cpu_die()\n  mutex_lock(&interface_lock) |                       |     stop_kthread()\n                              |     cpus_write_lock() |       mutex_lock(&interface_lock)\n  cpus_read_lock()            |     cpuhp_kick_ap()   |\n\nAs the interface_lock here in just for protecting the \"kthread\" field of\nthe osn_var, use xchg() instead to fix this issue. Also use\nfor_each_online_cpu() back in stop_per_cpu_kthreads() as it can take\ncpu_read_lock() again.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a4a05ceffe8fad68b45de38fe2311bda619e76e2",
      "https://git.kernel.org/stable/c/09cb44cc3d3df7ade2cebc939d6257a2fa8afc7a",
      "https://git.kernel.org/stable/c/db8571a9a098086608c11a15856ff585789e67e8",
      "https://git.kernel.org/stable/c/b484a02c9cedf8703eff8f0756f94618004bd165"
    ],
    "受影响版本": [
      "b4fdabffae14cca2c80d99bd81f3f27239ac7f5e",
      "4679272d5252720746fd9c5465352cbc5665f230",
      "5bfbcd1ee57b607fd29e4645c7f350dd385dd9ad",
      "5bfbcd1ee57b607fd29e4645c7f350dd385dd9ad"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49970",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Implement bounds check for stream encoder creation in DCN401\n\n'stream_enc_regs' array is an array of dcn10_stream_enc_registers\nstructures. The array is initialized with four elements, corresponding\nto the four calls to stream_enc_regs() in the array initializer. This\nmeans that valid indices for this array are 0, 1, 2, and 3.\n\nThe error message 'stream_enc_regs' 4 <= 5 below, is indicating that\nthere is an attempt to access this array with an index of 5, which is\nout of bounds. This could lead to undefined behavior\n\nHere, eng_id is used as an index to access the stream_enc_regs array. If\neng_id is 5, this would result in an out-of-bounds access on the\nstream_enc_regs array.\n\nThus fixing Buffer overflow error in dcn401_stream_encoder_create\n\nFound by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn401/dcn401_resource.c:1209 dcn401_stream_encoder_create() error: buffer overflow 'stream_enc_regs' 4 <= 5",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b219b46ad42df1dea9258788bcfea37181f3ccb2",
      "https://git.kernel.org/stable/c/bdf606810210e8e07a0cdf1af3c467291363b295"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49961",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: i2c: ar0521: Use cansleep version of gpiod_set_value()\n\nIf we use GPIO reset from I2C port expander, we must use *_cansleep()\nvariant of GPIO functions.\nThis was not done in ar0521_power_on()/ar0521_power_off() functions.\nLet's fix that.\n\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 11 at drivers/gpio/gpiolib.c:3496 gpiod_set_value+0x74/0x7c\nModules linked in:\nCPU: 0 PID: 11 Comm: kworker/u16:0 Not tainted 6.10.0 #53\nHardware name: Diasom DS-RK3568-SOM-EVB (DT)\nWorkqueue: events_unbound deferred_probe_work_func\npstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : gpiod_set_value+0x74/0x7c\nlr : ar0521_power_on+0xcc/0x290\nsp : ffffff8001d7ab70\nx29: ffffff8001d7ab70 x28: ffffff80027dcc90 x27: ffffff8003c82000\nx26: ffffff8003ca9250 x25: ffffffc080a39c60 x24: ffffff8003ca9088\nx23: ffffff8002402720 x22: ffffff8003ca9080 x21: ffffff8003ca9088\nx20: 0000000000000000 x19: ffffff8001eb2a00 x18: ffffff80efeeac80\nx17: 756d2d6332692f30 x16: 0000000000000000 x15: 0000000000000000\nx14: ffffff8001d91d40 x13: 0000000000000016 x12: ffffffc080e98930\nx11: ffffff8001eb2880 x10: 0000000000000890 x9 : ffffff8001d7a9f0\nx8 : ffffff8001d92570 x7 : ffffff80efeeac80 x6 : 000000003fc6e780\nx5 : ffffff8001d91c80 x4 : 0000000000000002 x3 : 0000000000000000\nx2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000001\nCall trace:\n gpiod_set_value+0x74/0x7c\n ar0521_power_on+0xcc/0x290\n...",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9f08876d766755a92f1b9543ae3ee21bfc596fb8",
      "https://git.kernel.org/stable/c/625a77b68c96349c16fcc1faa42784313e0b1a85",
      "https://git.kernel.org/stable/c/2423b60a2d6d27e5f66c5021b494463aef2db212",
      "https://git.kernel.org/stable/c/3cf00ecfbf11ee8e6afff306a5bdcff4bf95d2cf",
      "https://git.kernel.org/stable/c/bee1aed819a8cda47927436685d216906ed17f62"
    ],
    "受影响版本": [
      "852b50aeed153b513c0b36298559114fab0fab80",
      "852b50aeed153b513c0b36298559114fab0fab80",
      "852b50aeed153b513c0b36298559114fab0fab80",
      "852b50aeed153b513c0b36298559114fab0fab80",
      "852b50aeed153b513c0b36298559114fab0fab80"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49959",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\njbd2: stop waiting for space when jbd2_cleanup_journal_tail() returns error\n\nIn __jbd2_log_wait_for_space(), we might call jbd2_cleanup_journal_tail()\nto recover some journal space. But if an error occurs while executing\njbd2_cleanup_journal_tail() (e.g., an EIO), we don't stop waiting for free\nspace right away, we try other branches, and if j_committing_transaction\nis NULL (i.e., the tid is 0), we will get the following complain:\n\n============================================\nJBD2: I/O error when updating journal superblock for sdd-8.\n__jbd2_log_wait_for_space: needed 256 blocks and only had 217 space available\n__jbd2_log_wait_for_space: no way to get more journal space in sdd-8\n------------[ cut here ]------------\nWARNING: CPU: 2 PID: 139804 at fs/jbd2/checkpoint.c:109 __jbd2_log_wait_for_space+0x251/0x2e0\nModules linked in:\nCPU: 2 PID: 139804 Comm: kworker/u8:3 Not tainted 6.6.0+ #1\nRIP: 0010:__jbd2_log_wait_for_space+0x251/0x2e0\nCall Trace:\n <TASK>\n add_transaction_credits+0x5d1/0x5e0\n start_this_handle+0x1ef/0x6a0\n jbd2__journal_start+0x18b/0x340\n ext4_dirty_inode+0x5d/0xb0\n __mark_inode_dirty+0xe4/0x5d0\n generic_update_time+0x60/0x70\n[...]\n============================================\n\nSo only if jbd2_cleanup_journal_tail() returns 1, i.e., there is nothing to\nclean up at the moment, continue to try to reclaim free space in other ways.\n\nNote that this fix relies on commit 6f6a6fda2945 (\"jbd2: fix ocfs2 corrupt\nwhen updating journal superblock fails\") to make jbd2_cleanup_journal_tail\nreturn the correct error code.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/801a35dfef6996f3d5eaa96a59caf00440d9165e",
      "https://git.kernel.org/stable/c/d5dc65370a746750dbb2f03eabcf86b18db65f32",
      "https://git.kernel.org/stable/c/481e8f18a290e39e04ddb7feb2bb2a2cc3b213ed",
      "https://git.kernel.org/stable/c/ec7f8337c98ad281020ad1f11ba492462d80737a",
      "https://git.kernel.org/stable/c/70bae48377a2c4296fd3caf4caf8f11079111019",
      "https://git.kernel.org/stable/c/1c62dc0d82c62f0dc8fcdc4843208e522acccaf5",
      "https://git.kernel.org/stable/c/3ced0fe6c0eff032733ea8b38778b34707270138",
      "https://git.kernel.org/stable/c/c6bf043b210eac67d35a114e345c4e5585672913",
      "https://git.kernel.org/stable/c/f5cacdc6f2bb2a9bf214469dd7112b43dd2dd68a"
    ],
    "受影响版本": [
      "8c3f25d8950c3e9fe6c9849f88679b3f2a071550",
      "8c3f25d8950c3e9fe6c9849f88679b3f2a071550",
      "8c3f25d8950c3e9fe6c9849f88679b3f2a071550",
      "8c3f25d8950c3e9fe6c9849f88679b3f2a071550",
      "8c3f25d8950c3e9fe6c9849f88679b3f2a071550",
      "8c3f25d8950c3e9fe6c9849f88679b3f2a071550",
      "8c3f25d8950c3e9fe6c9849f88679b3f2a071550",
      "8c3f25d8950c3e9fe6c9849f88679b3f2a071550",
      "8c3f25d8950c3e9fe6c9849f88679b3f2a071550"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49947",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: test for not too small csum_start in virtio_net_hdr_to_skb()\n\nsyzbot was able to trigger this warning [1], after injecting a\nmalicious packet through af_packet, setting skb->csum_start and thus\nthe transport header to an incorrect value.\n\nWe can at least make sure the transport header is after\nthe end of the network header (with a estimated minimal size).\n\n[1]\n[   67.873027] skb len=4096 headroom=16 headlen=14 tailroom=0\nmac=(-1,-1) mac_len=0 net=(16,-6) trans=10\nshinfo(txflags=0 nr_frags=1 gso(size=0 type=0 segs=0))\ncsum(0xa start=10 offset=0 ip_summed=3 complete_sw=0 valid=0 level=0)\nhash(0x0 sw=0 l4=0) proto=0x0800 pkttype=0 iif=0\npriority=0x0 mark=0x0 alloc_cpu=10 vlan_all=0x0\nencapsulation=0 inner(proto=0x0000, mac=0, net=0, trans=0)\n[   67.877172] dev name=veth0_vlan feat=0x000061164fdd09e9\n[   67.877764] sk family=17 type=3 proto=0\n[   67.878279] skb linear:   00000000: 00 00 10 00 00 00 00 00 0f 00 00 00 08 00\n[   67.879128] skb frag:     00000000: 0e 00 07 00 00 00 28 00 08 80 1c 00 04 00 00 02\n[   67.879877] skb frag:     00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.880647] skb frag:     00000020: 00 00 02 00 00 00 08 00 1b 00 00 00 00 00 00 00\n[   67.881156] skb frag:     00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.881753] skb frag:     00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.882173] skb frag:     00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.882790] skb frag:     00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.883171] skb frag:     00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.883733] skb frag:     00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.884206] skb frag:     00000090: 00 00 00 00 00 00 00 00 00 00 69 70 76 6c 61 6e\n[   67.884704] skb frag:     000000a0: 31 00 00 00 00 00 00 00 00 00 2b 00 00 00 00 00\n[   67.885139] skb frag:     000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.885677] skb frag:     000000c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.886042] skb frag:     000000d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.886408] skb frag:     000000e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.887020] skb frag:     000000f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.887384] skb frag:     00000100: 00 00\n[   67.887878] ------------[ cut here ]------------\n[   67.887908] offset (-6) >= skb_headlen() (14)\n[   67.888445] WARNING: CPU: 10 PID: 2088 at net/core/dev.c:3332 skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.889353] Modules linked in: macsec macvtap macvlan hsr wireguard curve25519_x86_64 libcurve25519_generic libchacha20poly1305 chacha_x86_64 libchacha poly1305_x86_64 dummy bridge sr_mod cdrom evdev pcspkr i2c_piix4 9pnet_virtio 9p 9pnet netfs\n[   67.890111] CPU: 10 UID: 0 PID: 2088 Comm: b363492833 Not tainted 6.11.0-virtme #1011\n[   67.890183] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[   67.890309] RIP: 0010:skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.891043] Call Trace:\n[   67.891173]  <TASK>\n[   67.891274] ? __warn (kernel/panic.c:741)\n[   67.891320] ? skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.891333] ? report_bug (lib/bug.c:180 lib/bug.c:219)\n[   67.891348] ? handle_bug (arch/x86/kernel/traps.c:239)\n[   67.891363] ? exc_invalid_op (arch/x86/kernel/traps.c:260 (discriminator 1))\n[   67.891372] ? asm_exc_invalid_op (./arch/x86/include/asm/idtentry.h:621)\n[   67.891388] ? skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.891399] ? skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.891416] ip_do_fragment (net/ipv4/ip_output.c:777 (discriminator 1))\n[   67.891448] ? __ip_local_out (./include/linux/skbuff.h:1146 ./include/net/l3mdev.h:196 ./include/net/l3mdev.h:213 ne\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d9dfd41e32ccc5198033ddd1ff1516822dfefa5a",
      "https://git.kernel.org/stable/c/4cc0648e9e3240496835dc698ace1d046d8d57ea",
      "https://git.kernel.org/stable/c/7711c419a915ee0dd91c125d2b967bbf2a72e9ac",
      "https://git.kernel.org/stable/c/49d14b54a527289d09a9480f214b8c586322310a"
    ],
    "受影响版本": [
      "342c88f406c2acd3dd00767aeacafe883cebb374",
      "9181d6f8a2bb32d158de66a84164fac05e3ddd18",
      "9181d6f8a2bb32d158de66a84164fac05e3ddd18",
      "9181d6f8a2bb32d158de66a84164fac05e3ddd18",
      "765290b628c2fb764bdfaf8088754439665751e8"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49943",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe/guc_submit: add missing locking in wedged_fini\n\nAny non-wedged queue can have a zero refcount here and can be running\nconcurrently with an async queue destroy, therefore dereferencing the\nqueue ptr to check wedge status after the lookup can trigger UAF if\nqueue is not wedged.  Fix this by keeping the submission_state lock held\naround the check to postpone the free and make the check safe, before\ndropping again around the put() to avoid the deadlock.\n\n(cherry picked from commit d28af0b6b9580b9f90c265a7da0315b0ad20bbfd)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d88f9bab7e62dd0dbe983fa70cf040042a60cc84",
      "https://git.kernel.org/stable/c/790533e44bfc7af929842fccd9674c9f424d4627"
    ],
    "受影响版本": [
      "8ed9aaae39f39130b7a3eb2726be05d7f64b344c",
      "8ed9aaae39f39130b7a3eb2726be05d7f64b344c"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49939",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw89: avoid to add interface to list twice when SER\n\nIf SER L2 occurs during the WoWLAN resume flow, the add interface flow\nis triggered by ieee80211_reconfig(). However, due to\nrtw89_wow_resume() return failure, it will cause the add interface flow\nto be executed again, resulting in a double add list and causing a kernel\npanic. Therefore, we have added a check to prevent double adding of the\nlist.\n\nlist_add double add: new=ffff99d6992e2010, prev=ffff99d6992e2010, next=ffff99d695302628.\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:37!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 0 PID: 9 Comm: kworker/0:1 Tainted: G        W  O       6.6.30-02659-gc18865c4dfbd #1 770df2933251a0e3c888ba69d1053a817a6376a7\nHardware name: HP Grunt/Grunt, BIOS Google_Grunt.11031.169.0 06/24/2021\nWorkqueue: events_freezable ieee80211_restart_work [mac80211]\nRIP: 0010:__list_add_valid_or_report+0x5e/0xb0\nCode: c7 74 18 48 39 ce 74 13 b0 01 59 5a 5e 5f 41 58 41 59 41 5a 5d e9 e2 d6 03 00 cc 48 c7 c7 8d 4f 17 83 48 89 c2 e8 02 c0 00 00 <0f> 0b 48 c7 c7 aa 8c 1c 83 e8 f4 bf 00 00 0f 0b 48 c7 c7 c8 bc 12\nRSP: 0018:ffffa91b8007bc50 EFLAGS: 00010246\nRAX: 0000000000000058 RBX: ffff99d6992e0900 RCX: a014d76c70ef3900\nRDX: ffffa91b8007bae8 RSI: 00000000ffffdfff RDI: 0000000000000001\nRBP: ffffa91b8007bc88 R08: 0000000000000000 R09: ffffa91b8007bae0\nR10: 00000000ffffdfff R11: ffffffff83a79800 R12: ffff99d695302060\nR13: ffff99d695300900 R14: ffff99d6992e1be0 R15: ffff99d6992e2010\nFS:  0000000000000000(0000) GS:ffff99d6aac00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000078fbdba43480 CR3: 000000010e464000 CR4: 00000000001506f0\nCall Trace:\n <TASK>\n ? __die_body+0x1f/0x70\n ? die+0x3d/0x60\n ? do_trap+0xa4/0x110\n ? __list_add_valid_or_report+0x5e/0xb0\n ? do_error_trap+0x6d/0x90\n ? __list_add_valid_or_report+0x5e/0xb0\n ? handle_invalid_op+0x30/0x40\n ? __list_add_valid_or_report+0x5e/0xb0\n ? exc_invalid_op+0x3c/0x50\n ? asm_exc_invalid_op+0x16/0x20\n ? __list_add_valid_or_report+0x5e/0xb0\n rtw89_ops_add_interface+0x309/0x310 [rtw89_core 7c32b1ee6854761c0321027c8a58c5160e41f48f]\n drv_add_interface+0x5c/0x130 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc]\n ieee80211_reconfig+0x241/0x13d0 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc]\n ? finish_wait+0x3e/0x90\n ? synchronize_rcu_expedited+0x174/0x260\n ? sync_rcu_exp_done_unlocked+0x50/0x50\n ? wake_bit_function+0x40/0x40\n ieee80211_restart_work+0xf0/0x140 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc]\n process_scheduled_works+0x1e5/0x480\n worker_thread+0xea/0x1e0\n kthread+0xdb/0x110\n ? move_linked_works+0x90/0x90\n ? kthread_associate_blkcg+0xa0/0xa0\n ret_from_fork+0x3b/0x50\n ? kthread_associate_blkcg+0xa0/0xa0\n ret_from_fork_asm+0x11/0x20\n </TASK>\nModules linked in: dm_integrity async_xor xor async_tx lz4 lz4_compress zstd zstd_compress zram zsmalloc rfcomm cmac uinput algif_hash algif_skcipher af_alg btusb btrtl iio_trig_hrtimer industrialio_sw_trigger btmtk industrialio_configfs btbcm btintel uvcvideo videobuf2_vmalloc iio_trig_sysfs videobuf2_memops videobuf2_v4l2 videobuf2_common uvc snd_hda_codec_hdmi veth snd_hda_intel snd_intel_dspcfg acpi_als snd_hda_codec industrialio_triggered_buffer kfifo_buf snd_hwdep industrialio i2c_piix4 snd_hda_core designware_i2s ip6table_nat snd_soc_max98357a xt_MASQUERADE xt_cgroup snd_soc_acp_rt5682_mach fuse rtw89_8922ae(O) rtw89_8922a(O) rtw89_pci(O) rtw89_core(O) 8021q mac80211(O) bluetooth ecdh_generic ecc cfg80211 r8152 mii joydev\ngsmi: Log Shutdown Reason 0x03\n---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b04650b5a9990cf5c0de480e62c68199f1396a04",
      "https://git.kernel.org/stable/c/fdc73f2cfbe897f4733156df211d79ced649b23c",
      "https://git.kernel.org/stable/c/37c319503023de49a4c87301c8998c8d928112cb",
      "https://git.kernel.org/stable/c/490eddc836b2a6ec286e5df14bed4c7cf5e1f475",
      "https://git.kernel.org/stable/c/7dd5d2514a8ea58f12096e888b0bd050d7eae20a"
    ],
    "受影响版本": [
      "e3ec7017f6a20d12ddd9fe23d345ebb7b8c104dd",
      "e3ec7017f6a20d12ddd9fe23d345ebb7b8c104dd",
      "e3ec7017f6a20d12ddd9fe23d345ebb7b8c104dd",
      "e3ec7017f6a20d12ddd9fe23d345ebb7b8c104dd",
      "e3ec7017f6a20d12ddd9fe23d345ebb7b8c104dd"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49938",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k_htc: Use __skb_set_length() for resetting urb before resubmit\n\nSyzbot points out that skb_trim() has a sanity check on the existing length of\nthe skb, which can be uninitialised in some error paths. The intent here is\nclearly just to reset the length to zero before resubmitting, so switch to\ncalling __skb_set_length(skb, 0) directly. In addition, __skb_set_length()\nalready contains a call to skb_reset_tail_pointer(), so remove the redundant\ncall.\n\nThe syzbot report came from ath9k_hif_usb_reg_in_cb(), but there's a similar\nusage of skb_trim() in ath9k_hif_usb_rx_cb(), change both while we're at it.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e6b9bf32e0695e4f374674002de0527d2a6768eb",
      "https://git.kernel.org/stable/c/d1f2fbc6a769081503f6ffedbb5cd1ac497f0e77",
      "https://git.kernel.org/stable/c/b02eb7c86ff2ef1411c3095ec8a52b13f68db04f",
      "https://git.kernel.org/stable/c/012ae530afa0785102360de452745d33c99a321b",
      "https://git.kernel.org/stable/c/6a875220670475d9247e576c15dc29823100a4e4",
      "https://git.kernel.org/stable/c/e37e348835032d6940ec89308cc8996ded691d2d",
      "https://git.kernel.org/stable/c/2c230210ec0ae6ed08306ac70dc21c24b817bb95",
      "https://git.kernel.org/stable/c/a9f4e28e8adaf0715bd4e01462af0a52ee46b01f",
      "https://git.kernel.org/stable/c/94745807f3ebd379f23865e6dab196f220664179"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49934",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/inode: Prevent dump_mapping() accessing invalid dentry.d_name.name\n\nIt's observed that a crash occurs during hot-remove a memory device,\nin which user is accessing the hugetlb. See calltrace as following:\n\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 14045 at arch/x86/mm/fault.c:1278 do_user_addr_fault+0x2a0/0x790\nModules linked in: kmem device_dax cxl_mem cxl_pmem cxl_port cxl_pci dax_hmem dax_pmem nd_pmem cxl_acpi nd_btt cxl_core crc32c_intel nvme virtiofs fuse nvme_core nfit libnvdimm dm_multipath scsi_dh_rdac scsi_dh_emc s\nmirror dm_region_hash dm_log dm_mod\nCPU: 1 PID: 14045 Comm: daxctl Not tainted 6.10.0-rc2-lizhijian+ #492\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\nRIP: 0010:do_user_addr_fault+0x2a0/0x790\nCode: 48 8b 00 a8 04 0f 84 b5 fe ff ff e9 1c ff ff ff 4c 89 e9 4c 89 e2 be 01 00 00 00 bf 02 00 00 00 e8 b5 ef 24 00 e9 42 fe ff ff <0f> 0b 48 83 c4 08 4c 89 ea 48 89 ee 4c 89 e7 5b 5d 41 5c 41 5d 41\nRSP: 0000:ffffc90000a575f0 EFLAGS: 00010046\nRAX: ffff88800c303600 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000001000 RSI: ffffffff82504162 RDI: ffffffff824b2c36\nRBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000000 R12: ffffc90000a57658\nR13: 0000000000001000 R14: ffff88800bc2e040 R15: 0000000000000000\nFS:  00007f51cb57d880(0000) GS:ffff88807fd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000001000 CR3: 00000000072e2004 CR4: 00000000001706f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n ? __warn+0x8d/0x190\n ? do_user_addr_fault+0x2a0/0x790\n ? report_bug+0x1c3/0x1d0\n ? handle_bug+0x3c/0x70\n ? exc_invalid_op+0x14/0x70\n ? asm_exc_invalid_op+0x16/0x20\n ? do_user_addr_fault+0x2a0/0x790\n ? exc_page_fault+0x31/0x200\n exc_page_fault+0x68/0x200\n<...snip...>\nBUG: unable to handle page fault for address: 0000000000001000\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0\n Oops: Oops: 0000 [#1] PREEMPT SMP PTI\n ---[ end trace 0000000000000000 ]---\n BUG: unable to handle page fault for address: 0000000000001000\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0\n Oops: Oops: 0000 [#1] PREEMPT SMP PTI\n CPU: 1 PID: 14045 Comm: daxctl Kdump: loaded Tainted: G        W          6.10.0-rc2-lizhijian+ #492\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n RIP: 0010:dentry_name+0x1f4/0x440\n<...snip...>\n? dentry_name+0x2fa/0x440\nvsnprintf+0x1f3/0x4f0\nvprintk_store+0x23a/0x540\nvprintk_emit+0x6d/0x330\n_printk+0x58/0x80\ndump_mapping+0x10b/0x1a0\n? __pfx_free_object_rcu+0x10/0x10\n__dump_page+0x26b/0x3e0\n? vprintk_emit+0xe0/0x330\n? _printk+0x58/0x80\n? dump_page+0x17/0x50\ndump_page+0x17/0x50\ndo_migrate_range+0x2f7/0x7f0\n? do_migrate_range+0x42/0x7f0\n? offline_pages+0x2f4/0x8c0\noffline_pages+0x60a/0x8c0\nmemory_subsys_offline+0x9f/0x1c0\n? lockdep_hardirqs_on+0x77/0x100\n? _raw_spin_unlock_irqrestore+0x38/0x60\ndevice_offline+0xe3/0x110\nstate_store+0x6e/0xc0\nkernfs_fop_write_iter+0x143/0x200\nvfs_write+0x39f/0x560\nksys_write+0x65/0xf0\ndo_syscall_64+0x62/0x130\n\nPreviously, some sanity check have been done in dump_mapping() before\nthe print facility parsing '%pd' though, it's still possible to run into\nan invalid dentry.d_name.name.\n\nSince dump_mapping() only needs to dump the filename only, retrieve it\nby itself in a safer way to prevent an unnecessary crash.\n\nNote that either retrieving the filename with '%pd' or\nstrncpy_from_kernel_nofault(), the filename could be unreliable.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1a4159138e718db6199f0abf376ad52f726dcc5c",
      "https://git.kernel.org/stable/c/e0f6ee75f50476607ca82fc7c3711c795ce09b52",
      "https://git.kernel.org/stable/c/f92b8829c6e75632de4e2b9f70e7a7e6c5c2ba98",
      "https://git.kernel.org/stable/c/ef921bc72328b577cb45772ff7921cba4773b74a",
      "https://git.kernel.org/stable/c/7f7b850689ac06a62befe26e1fd1806799e7f152"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49932",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: don't readahead the relocation inode on RST\n\nOn relocation we're doing readahead on the relocation inode, but if the\nfilesystem is backed by a RAID stripe tree we can get ENOENT (e.g. due to\npreallocated extents not being mapped in the RST) from the lookup.\n\nBut readahead doesn't handle the error and submits invalid reads to the\ndevice, causing an assertion in the scatter-gather list code:\n\n  BTRFS info (device nvme1n1): balance: start -d -m -s\n  BTRFS info (device nvme1n1): relocating block group 6480920576 flags data|raid0\n  BTRFS error (device nvme1n1): cannot find raid-stripe for logical [6481928192, 6481969152] devid 2, profile raid0\n  ------------[ cut here ]------------\n  kernel BUG at include/linux/scatterlist.h:115!\n  Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI\n  CPU: 0 PID: 1012 Comm: btrfs Not tainted 6.10.0-rc7+ #567\n  RIP: 0010:__blk_rq_map_sg+0x339/0x4a0\n  RSP: 0018:ffffc90001a43820 EFLAGS: 00010202\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802\n  RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000\n  RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8\n  R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000\n  FS:  00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 000000002cd11000 CR3: 00000001109ea001 CR4: 0000000000370eb0\n  Call Trace:\n   <TASK>\n   ? __die_body.cold+0x14/0x25\n   ? die+0x2e/0x50\n   ? do_trap+0xca/0x110\n   ? do_error_trap+0x65/0x80\n   ? __blk_rq_map_sg+0x339/0x4a0\n   ? exc_invalid_op+0x50/0x70\n   ? __blk_rq_map_sg+0x339/0x4a0\n   ? asm_exc_invalid_op+0x1a/0x20\n   ? __blk_rq_map_sg+0x339/0x4a0\n   nvme_prep_rq.part.0+0x9d/0x770\n   nvme_queue_rq+0x7d/0x1e0\n   __blk_mq_issue_directly+0x2a/0x90\n   ? blk_mq_get_budget_and_tag+0x61/0x90\n   blk_mq_try_issue_list_directly+0x56/0xf0\n   blk_mq_flush_plug_list.part.0+0x52b/0x5d0\n   __blk_flush_plug+0xc6/0x110\n   blk_finish_plug+0x28/0x40\n   read_pages+0x160/0x1c0\n   page_cache_ra_unbounded+0x109/0x180\n   relocate_file_extent_cluster+0x611/0x6a0\n   ? btrfs_search_slot+0xba4/0xd20\n   ? balance_dirty_pages_ratelimited_flags+0x26/0xb00\n   relocate_data_extent.constprop.0+0x134/0x160\n   relocate_block_group+0x3f2/0x500\n   btrfs_relocate_block_group+0x250/0x430\n   btrfs_relocate_chunk+0x3f/0x130\n   btrfs_balance+0x71b/0xef0\n   ? kmalloc_trace_noprof+0x13b/0x280\n   btrfs_ioctl+0x2c2e/0x3030\n   ? kvfree_call_rcu+0x1e6/0x340\n   ? list_lru_add_obj+0x66/0x80\n   ? mntput_no_expire+0x3a/0x220\n   __x64_sys_ioctl+0x96/0xc0\n   do_syscall_64+0x54/0x110\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n  RIP: 0033:0x7fcc04514f9b\n  Code: Unable to access opcode bytes at 0x7fcc04514f71.\n  RSP: 002b:00007ffeba923370 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n  RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fcc04514f9b\n  RDX: 00007ffeba923460 RSI: 00000000c4009420 RDI: 0000000000000003\n  RBP: 0000000000000000 R08: 0000000000000013 R09: 0000000000000001\n  R10: 00007fcc043fbba8 R11: 0000000000000246 R12: 00007ffeba924fc5\n  R13: 00007ffeba923460 R14: 0000000000000002 R15: 00000000004d4bb0\n   </TASK>\n  Modules linked in:\n  ---[ end trace 0000000000000000 ]---\n  RIP: 0010:__blk_rq_map_sg+0x339/0x4a0\n  RSP: 0018:ffffc90001a43820 EFLAGS: 00010202\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802\n  RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000\n  RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8\n  R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000\n  FS:  00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007fcc04514f71 CR3: 00000001109ea001 CR4: 0000000000370eb0\n  Kernel p\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f7a1218a983ab98aba140dc20b25f60b39ee4033",
      "https://git.kernel.org/stable/c/04915240e2c3a018e4c7f23418478d27226c8957"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49887",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to don't panic system for no free segment fault injection\n\nf2fs: fix to don't panic system for no free segment fault injection\n\nsyzbot reports a f2fs bug as below:\n\nF2FS-fs (loop0): inject no free segment in get_new_segment of __allocate_new_segment+0x1ce/0x940 fs/f2fs/segment.c:3167\nF2FS-fs (loop0): Stopped filesystem due to reason: 7\n------------[ cut here ]------------\nkernel BUG at fs/f2fs/segment.c:2748!\nCPU: 0 UID: 0 PID: 5109 Comm: syz-executor304 Not tainted 6.11.0-rc6-syzkaller-00363-g89f5e14d05b4 #0\nRIP: 0010:get_new_segment fs/f2fs/segment.c:2748 [inline]\nRIP: 0010:new_curseg+0x1f61/0x1f70 fs/f2fs/segment.c:2836\nCall Trace:\n __allocate_new_segment+0x1ce/0x940 fs/f2fs/segment.c:3167\n f2fs_allocate_new_section fs/f2fs/segment.c:3181 [inline]\n f2fs_allocate_pinning_section+0xfa/0x4e0 fs/f2fs/segment.c:3195\n f2fs_expand_inode_data+0x5d6/0xbb0 fs/f2fs/file.c:1799\n f2fs_fallocate+0x448/0x960 fs/f2fs/file.c:1903\n vfs_fallocate+0x553/0x6c0 fs/open.c:334\n do_vfs_ioctl+0x2592/0x2e50 fs/ioctl.c:886\n __do_sys_ioctl fs/ioctl.c:905 [inline]\n __se_sys_ioctl+0x81/0x170 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0010:get_new_segment fs/f2fs/segment.c:2748 [inline]\nRIP: 0010:new_curseg+0x1f61/0x1f70 fs/f2fs/segment.c:2836\n\nThe root cause is when we inject no free segment fault into f2fs,\nwe should not panic system, fix it.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9f6e7a0512a57387d36f5e9e9635d6668cac13dd",
      "https://git.kernel.org/stable/c/645ec43760e86d3079fee2e8b51fde7060a540d0",
      "https://git.kernel.org/stable/c/65a6ce4726c27b45600303f06496fef46d00b57f"
    ],
    "受影响版本": [
      "8b10d3653735e117bc1954ade80d75ad7b46b801",
      "8b10d3653735e117bc1954ade80d75ad7b46b801",
      "8b10d3653735e117bc1954ade80d75ad7b46b801"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49883",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: aovid use-after-free in ext4_ext_insert_extent()\n\nAs Ojaswin mentioned in Link, in ext4_ext_insert_extent(), if the path is\nreallocated in ext4_ext_create_new_leaf(), we'll use the stale path and\ncause UAF. Below is a sample trace with dummy values:\n\next4_ext_insert_extent\n  path = *ppath = 2000\n  ext4_ext_create_new_leaf(ppath)\n    ext4_find_extent(ppath)\n      path = *ppath = 2000\n      if (depth > path[0].p_maxdepth)\n            kfree(path = 2000);\n            *ppath = path = NULL;\n      path = kcalloc() = 3000\n      *ppath = 3000;\n      return path;\n  /* here path is still 2000, UAF! */\n  eh = path[depth].p_hdr\n\n==================================================================\nBUG: KASAN: slab-use-after-free in ext4_ext_insert_extent+0x26d4/0x3330\nRead of size 8 at addr ffff8881027bf7d0 by task kworker/u36:1/179\nCPU: 3 UID: 0 PID: 179 Comm: kworker/u6:1 Not tainted 6.11.0-rc2-dirty #866\nCall Trace:\n <TASK>\n ext4_ext_insert_extent+0x26d4/0x3330\n ext4_ext_map_blocks+0xe22/0x2d40\n ext4_map_blocks+0x71e/0x1700\n ext4_do_writepages+0x1290/0x2800\n[...]\n\nAllocated by task 179:\n ext4_find_extent+0x81c/0x1f70\n ext4_ext_map_blocks+0x146/0x2d40\n ext4_map_blocks+0x71e/0x1700\n ext4_do_writepages+0x1290/0x2800\n ext4_writepages+0x26d/0x4e0\n do_writepages+0x175/0x700\n[...]\n\nFreed by task 179:\n kfree+0xcb/0x240\n ext4_find_extent+0x7c0/0x1f70\n ext4_ext_insert_extent+0xa26/0x3330\n ext4_ext_map_blocks+0xe22/0x2d40\n ext4_map_blocks+0x71e/0x1700\n ext4_do_writepages+0x1290/0x2800\n ext4_writepages+0x26d/0x4e0\n do_writepages+0x175/0x700\n[...]\n==================================================================\n\nSo use *ppath to update the path to avoid the above problem.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e17ebe4fdd7665c93ae9459ba40fcdfb76769ac1",
      "https://git.kernel.org/stable/c/975ca06f3fd154c5f7742083e7b2574c57d1c0c3",
      "https://git.kernel.org/stable/c/5e811066c5ab709b070659197dccfb80ab650ddd",
      "https://git.kernel.org/stable/c/9df59009dfc6d9fc1bd9ddf6c5ab6e56d6ed887a",
      "https://git.kernel.org/stable/c/51db04892a993cace63415be99848970a0f15ef2",
      "https://git.kernel.org/stable/c/8162ee5d94b8c0351be0a9321be134872a7654a1",
      "https://git.kernel.org/stable/c/beb7b66fb489041c50c6473100b383f7a51648fc",
      "https://git.kernel.org/stable/c/bfed082ce4b1ce6349b05c09a0fa4f3da35ecb1b",
      "https://git.kernel.org/stable/c/a164f3a432aae62ca23d03e6d926b122ee5b860d"
    ],
    "受影响版本": [
      "10809df84a4d868db61af621bae3658494165279",
      "10809df84a4d868db61af621bae3658494165279",
      "10809df84a4d868db61af621bae3658494165279",
      "10809df84a4d868db61af621bae3658494165279",
      "10809df84a4d868db61af621bae3658494165279",
      "10809df84a4d868db61af621bae3658494165279",
      "10809df84a4d868db61af621bae3658494165279",
      "10809df84a4d868db61af621bae3658494165279",
      "10809df84a4d868db61af621bae3658494165279"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49882",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix double brelse() the buffer of the extents path\n\nIn ext4_ext_try_to_merge_up(), set path[1].p_bh to NULL after it has been\nreleased, otherwise it may be released twice. An example of what triggers\nthis is as follows:\n\n  split2    map    split1\n|--------|-------|--------|\n\next4_ext_map_blocks\n ext4_ext_handle_unwritten_extents\n  ext4_split_convert_extents\n   // path->p_depth == 0\n   ext4_split_extent\n     // 1. do split1\n     ext4_split_extent_at\n       |ext4_ext_insert_extent\n       |  ext4_ext_create_new_leaf\n       |    ext4_ext_grow_indepth\n       |      le16_add_cpu(&neh->eh_depth, 1)\n       |    ext4_find_extent\n       |      // return -ENOMEM\n       |// get error and try zeroout\n       |path = ext4_find_extent\n       |  path->p_depth = 1\n       |ext4_ext_try_to_merge\n       |  ext4_ext_try_to_merge_up\n       |    path->p_depth = 0\n       |    brelse(path[1].p_bh)  ---> not set to NULL here\n       |// zeroout success\n     // 2. update path\n     ext4_find_extent\n     // 3. do split2\n     ext4_split_extent_at\n       ext4_ext_insert_extent\n         ext4_ext_create_new_leaf\n           ext4_ext_grow_indepth\n             le16_add_cpu(&neh->eh_depth, 1)\n           ext4_find_extent\n             path[0].p_bh = NULL;\n             path->p_depth = 1\n             read_extent_tree_block  ---> return err\n             // path[1].p_bh is still the old value\n             ext4_free_ext_path\n               ext4_ext_drop_refs\n                 // path->p_depth == 1\n                 brelse(path[1].p_bh)  ---> brelse a buffer twice\n\nFinally got the following WARRNING when removing the buffer from lru:\n\n============================================\nVFS: brelse: Trying to free free buffer\nWARNING: CPU: 2 PID: 72 at fs/buffer.c:1241 __brelse+0x58/0x90\nCPU: 2 PID: 72 Comm: kworker/u19:1 Not tainted 6.9.0-dirty #716\nRIP: 0010:__brelse+0x58/0x90\nCall Trace:\n <TASK>\n __find_get_block+0x6e7/0x810\n bdev_getblk+0x2b/0x480\n __ext4_get_inode_loc+0x48a/0x1240\n ext4_get_inode_loc+0xb2/0x150\n ext4_reserve_inode_write+0xb7/0x230\n __ext4_mark_inode_dirty+0x144/0x6a0\n ext4_ext_insert_extent+0x9c8/0x3230\n ext4_ext_map_blocks+0xf45/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n============================================",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d4574bda63906bf69660e001470bfe1a0ac524ae",
      "https://git.kernel.org/stable/c/f9fd47c9d9548f9e47fa60098eab99dde175401d",
      "https://git.kernel.org/stable/c/b6c29c8f3d7cb67b505f3b2f6c242d52298d1f2e",
      "https://git.kernel.org/stable/c/32bbb59e3f18facd7201bef110010bf35819b8c3",
      "https://git.kernel.org/stable/c/78bbc3d15b6f443acb26e94418c445bac940d414",
      "https://git.kernel.org/stable/c/68a69cf60660c73990c1875f94a5551600b04775",
      "https://git.kernel.org/stable/c/7633407ca4ab8be2916ab214eb44ccebc6a50e1a",
      "https://git.kernel.org/stable/c/230ee0535d01478bad9a3037292043f39b9be10b",
      "https://git.kernel.org/stable/c/dcaa6c31134c0f515600111c38ed7750003e1b9c"
    ],
    "受影响版本": [
      "ecb94f5fdf4b72547fca022421a9dca1672bddd4",
      "ecb94f5fdf4b72547fca022421a9dca1672bddd4",
      "ecb94f5fdf4b72547fca022421a9dca1672bddd4",
      "ecb94f5fdf4b72547fca022421a9dca1672bddd4",
      "ecb94f5fdf4b72547fca022421a9dca1672bddd4",
      "ecb94f5fdf4b72547fca022421a9dca1672bddd4",
      "ecb94f5fdf4b72547fca022421a9dca1672bddd4",
      "ecb94f5fdf4b72547fca022421a9dca1672bddd4",
      "ecb94f5fdf4b72547fca022421a9dca1672bddd4"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49880",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix off by one issue in alloc_flex_gd()\n\nWesley reported an issue:\n\n==================================================================\nEXT4-fs (dm-5): resizing filesystem from 7168 to 786432 blocks\n------------[ cut here ]------------\nkernel BUG at fs/ext4/resize.c:324!\nCPU: 9 UID: 0 PID: 3576 Comm: resize2fs Not tainted 6.11.0+ #27\nRIP: 0010:ext4_resize_fs+0x1212/0x12d0\nCall Trace:\n __ext4_ioctl+0x4e0/0x1800\n ext4_ioctl+0x12/0x20\n __x64_sys_ioctl+0x99/0xd0\n x64_sys_call+0x1206/0x20d0\n do_syscall_64+0x72/0x110\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n==================================================================\n\nWhile reviewing the patch, Honza found that when adjusting resize_bg in\nalloc_flex_gd(), it was possible for flex_gd->resize_bg to be bigger than\nflexbg_size.\n\nThe reproduction of the problem requires the following:\n\n o_group = flexbg_size * 2 * n;\n o_size = (o_group + 1) * group_size;\n n_group: [o_group + flexbg_size, o_group + flexbg_size * 2)\n o_size = (n_group + 1) * group_size;\n\nTake n=0,flexbg_size=16 as an example:\n\n              last:15\n|o---------------|--------------n-|\no_group:0    resize to      n_group:30\n\nThe corresponding reproducer is:\n\nimg=test.img\nrm -f $img\ntruncate -s 600M $img\nmkfs.ext4 -F $img -b 1024 -G 16 8M\ndev=`losetup -f --show $img`\nmkdir -p /tmp/test\nmount $dev /tmp/test\nresize2fs $dev 248M\n\nDelete the problematic plus 1 to fix the issue, and add a WARN_ON_ONCE()\nto prevent the issue from happening again.\n\n[ Note: another reproucer which this commit fixes is:\n\n  img=test.img\n  rm -f $img\n  truncate -s 25MiB $img\n  mkfs.ext4 -b 4096 -E nodiscard,lazy_itable_init=0,lazy_journal_init=0 $img\n  truncate -s 3GiB $img\n  dev=`losetup -f --show $img`\n  mkdir -p /tmp/test\n  mount $dev /tmp/test\n  resize2fs $dev 3G\n  umount $dev\n  losetup -d $dev\n\n  -- TYT ]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0d80d2b8bf613398baf7185009e35f9d0459ecb0",
      "https://git.kernel.org/stable/c/acb559d6826116cc113598640d105094620c2526",
      "https://git.kernel.org/stable/c/6121258c2b33ceac3d21f6a221452692c465df88"
    ],
    "受影响版本": [
      "665d3e0af4d35acf9a5f58dfd471bc27dbf55880",
      "665d3e0af4d35acf9a5f58dfd471bc27dbf55880",
      "665d3e0af4d35acf9a5f58dfd471bc27dbf55880"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49875",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: map the EBADMSG to nfserr_io to avoid warning\n\nExt4 will throw -EBADMSG through ext4_readdir when a checksum error\noccurs, resulting in the following WARNING.\n\nFix it by mapping EBADMSG to nfserr_io.\n\nnfsd_buffered_readdir\n iterate_dir // -EBADMSG -74\n  ext4_readdir // .iterate_shared\n   ext4_dx_readdir\n    ext4_htree_fill_tree\n     htree_dirblock_to_tree\n      ext4_read_dirblock\n       __ext4_read_dirblock\n        ext4_dirblock_csum_verify\n         warn_no_space_for_csum\n          __warn_no_space_for_csum\n        return ERR_PTR(-EFSBADCRC) // -EBADMSG -74\n nfserrno // WARNING\n\n[  161.115610] ------------[ cut here ]------------\n[  161.116465] nfsd: non-standard errno: -74\n[  161.117315] WARNING: CPU: 1 PID: 780 at fs/nfsd/nfsproc.c:878 nfserrno+0x9d/0xd0\n[  161.118596] Modules linked in:\n[  161.119243] CPU: 1 PID: 780 Comm: nfsd Not tainted 5.10.0-00014-g79679361fd5d #138\n[  161.120684] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qe\nmu.org 04/01/2014\n[  161.123601] RIP: 0010:nfserrno+0x9d/0xd0\n[  161.124676] Code: 0f 87 da 30 dd 00 83 e3 01 b8 00 00 00 05 75 d7 44 89 ee 48 c7 c7 c0 57 24 98 89 44 24 04 c6\n 05 ce 2b 61 03 01 e8 99 20 d8 00 <0f> 0b 8b 44 24 04 eb b5 4c 89 e6 48 c7 c7 a0 6d a4 99 e8 cc 15 33\n[  161.127797] RSP: 0018:ffffc90000e2f9c0 EFLAGS: 00010286\n[  161.128794] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n[  161.130089] RDX: 1ffff1103ee16f6d RSI: 0000000000000008 RDI: fffff520001c5f2a\n[  161.131379] RBP: 0000000000000022 R08: 0000000000000001 R09: ffff8881f70c1827\n[  161.132664] R10: ffffed103ee18304 R11: 0000000000000001 R12: 0000000000000021\n[  161.133949] R13: 00000000ffffffb6 R14: ffff8881317c0000 R15: ffffc90000e2fbd8\n[  161.135244] FS:  0000000000000000(0000) GS:ffff8881f7080000(0000) knlGS:0000000000000000\n[  161.136695] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  161.137761] CR2: 00007fcaad70b348 CR3: 0000000144256006 CR4: 0000000000770ee0\n[  161.139041] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  161.140291] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  161.141519] PKRU: 55555554\n[  161.142076] Call Trace:\n[  161.142575]  ? __warn+0x9b/0x140\n[  161.143229]  ? nfserrno+0x9d/0xd0\n[  161.143872]  ? report_bug+0x125/0x150\n[  161.144595]  ? handle_bug+0x41/0x90\n[  161.145284]  ? exc_invalid_op+0x14/0x70\n[  161.146009]  ? asm_exc_invalid_op+0x12/0x20\n[  161.146816]  ? nfserrno+0x9d/0xd0\n[  161.147487]  nfsd_buffered_readdir+0x28b/0x2b0\n[  161.148333]  ? nfsd4_encode_dirent_fattr+0x380/0x380\n[  161.149258]  ? nfsd_buffered_filldir+0xf0/0xf0\n[  161.150093]  ? wait_for_concurrent_writes+0x170/0x170\n[  161.151004]  ? generic_file_llseek_size+0x48/0x160\n[  161.151895]  nfsd_readdir+0x132/0x190\n[  161.152606]  ? nfsd4_encode_dirent_fattr+0x380/0x380\n[  161.153516]  ? nfsd_unlink+0x380/0x380\n[  161.154256]  ? override_creds+0x45/0x60\n[  161.155006]  nfsd4_encode_readdir+0x21a/0x3d0\n[  161.155850]  ? nfsd4_encode_readlink+0x210/0x210\n[  161.156731]  ? write_bytes_to_xdr_buf+0x97/0xe0\n[  161.157598]  ? __write_bytes_to_xdr_buf+0xd0/0xd0\n[  161.158494]  ? lock_downgrade+0x90/0x90\n[  161.159232]  ? nfs4svc_decode_voidarg+0x10/0x10\n[  161.160092]  nfsd4_encode_operation+0x15a/0x440\n[  161.160959]  nfsd4_proc_compound+0x718/0xe90\n[  161.161818]  nfsd_dispatch+0x18e/0x2c0\n[  161.162586]  svc_process_common+0x786/0xc50\n[  161.163403]  ? nfsd_svc+0x380/0x380\n[  161.164137]  ? svc_printk+0x160/0x160\n[  161.164846]  ? svc_xprt_do_enqueue.part.0+0x365/0x380\n[  161.165808]  ? nfsd_svc+0x380/0x380\n[  161.166523]  ? rcu_is_watching+0x23/0x40\n[  161.167309]  svc_process+0x1a5/0x200\n[  161.168019]  nfsd+0x1f5/0x380\n[  161.168663]  ? nfsd_shutdown_threads+0x260/0x260\n[  161.169554]  kthread+0x1c4/0x210\n[  161.170224]  ? kthread_insert_work_sanity_check+0x80/0x80\n[  161.171246]  ret_from_fork+0x1f/0x30",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0ea4333c679f333e23956de743ad17387819d3f2",
      "https://git.kernel.org/stable/c/825789ca94602543101045ad3aad19b2b60c6b2a",
      "https://git.kernel.org/stable/c/6fe058502f8864649c3d614b06b2235223798f48",
      "https://git.kernel.org/stable/c/f7d8ee9db94372b8235f5f22bb24381891594c42",
      "https://git.kernel.org/stable/c/c76005adfa93d1a027433331252422078750321f",
      "https://git.kernel.org/stable/c/e9cfecca22a36b927a440abc6307efb9e138fed5",
      "https://git.kernel.org/stable/c/340e61e44c1d2a15c42ec72ade9195ad525fd048"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49873",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/filemap: fix filemap_get_folios_contig THP panic\n\nPatch series \"memfd-pin huge page fixes\".\n\nFix multiple bugs that occur when using memfd_pin_folios with hugetlb\npages and THP.  The hugetlb bugs only bite when the page is not yet\nfaulted in when memfd_pin_folios is called.  The THP bug bites when the\nstarting offset passed to memfd_pin_folios is not huge page aligned.  See\nthe commit messages for details.\n\n\nThis patch (of 5):\n\nmemfd_pin_folios on memory backed by THP panics if the requested start\noffset is not huge page aligned:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000036\nRIP: 0010:filemap_get_folios_contig+0xdf/0x290\nRSP: 0018:ffffc9002092fbe8 EFLAGS: 00010202\nRAX: 0000000000000002 RBX: 0000000000000002 RCX: 0000000000000002\n\nThe fault occurs here, because xas_load returns a folio with value 2:\n\n    filemap_get_folios_contig()\n        for (folio = xas_load(&xas); folio && xas.xa_index <= end;\n                        folio = xas_next(&xas)) {\n                ...\n                if (!folio_try_get(folio))   <-- BOOM\n\n\"2\" is an xarray sibling entry.  We get it because memfd_pin_folios does\nnot round the indices passed to filemap_get_folios_contig to huge page\nboundaries for THP, so we load from the middle of a huge page range see a\nsibling.  (It does round for hugetlbfs, at the is_file_hugepages test).\n\nTo fix, if the folio is a sibling, then return the next index as the\nstarting point for the next call to filemap_get_folios_contig.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/570dd14bfecf281fa467c80f8ec92b26370ee36a",
      "https://git.kernel.org/stable/c/c225c4f6056b46a8a5bf2ed35abf17a2d6887691"
    ],
    "受影响版本": [
      "89c1905d9c140372b7f50ef48f42378cf85d9bc5",
      "89c1905d9c140372b7f50ef48f42378cf85d9bc5"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49872",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/gup: fix memfd_pin_folios alloc race panic\n\nIf memfd_pin_folios tries to create a hugetlb page, but someone else\nalready did, then folio gets the value -EEXIST here:\n\n        folio = memfd_alloc_folio(memfd, start_idx);\n        if (IS_ERR(folio)) {\n                ret = PTR_ERR(folio);\n                if (ret != -EEXIST)\n                        goto err;\n\nthen on the next trip through the \"while start_idx\" loop we panic here:\n\n        if (folio) {\n                folio_put(folio);\n\nTo fix, set the folio to NULL on error.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e28f39b359c0cfdcc011603e51187085a5f1e5e3",
      "https://git.kernel.org/stable/c/ce645b9fdc78ec5d28067286e92871ddae6817d5"
    ],
    "受影响版本": [
      "89c1905d9c140372b7f50ef48f42378cf85d9bc5",
      "89c1905d9c140372b7f50ef48f42378cf85d9bc5"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49858",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nefistub/tpm: Use ACPI reclaim memory for event log to avoid corruption\n\nThe TPM event log table is a Linux specific construct, where the data\nproduced by the GetEventLog() boot service is cached in memory, and\npassed on to the OS using an EFI configuration table.\n\nThe use of EFI_LOADER_DATA here results in the region being left\nunreserved in the E820 memory map constructed by the EFI stub, and this\nis the memory description that is passed on to the incoming kernel by\nkexec, which is therefore unaware that the region should be reserved.\n\nEven though the utility of the TPM2 event log after a kexec is\nquestionable, any corruption might send the parsing code off into the\nweeds and crash the kernel. So let's use EFI_ACPI_RECLAIM_MEMORY\ninstead, which is always treated as reserved by the E820 conversion\nlogic.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f76b69ab9cf04358266e3cea5748c0c2791fbb08",
      "https://git.kernel.org/stable/c/11690d7e76842f29b60fbb5b35bc97d206ea0e83",
      "https://git.kernel.org/stable/c/5b22c038fb2757c652642933de5664da471f8cb7",
      "https://git.kernel.org/stable/c/19fd2f2c5fb36b61506d3208474bfd8fdf1cada3",
      "https://git.kernel.org/stable/c/38d9b07d99b789efb6d8dda21f1aaad636c38993",
      "https://git.kernel.org/stable/c/2e6871a632a99d9b9e2ce3a7847acabe99e5a26e",
      "https://git.kernel.org/stable/c/77d48d39e99170b528e4f2e9fc5d1d64cdedd386"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-49569",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-rdma: unquiesce admin_q before destroy it\n\nKernel will hang on destroy admin_q while we create ctrl failed, such\nas following calltrace:\n\nPID: 23644    TASK: ff2d52b40f439fc0  CPU: 2    COMMAND: \"nvme\"\n #0 [ff61d23de260fb78] __schedule at ffffffff8323bc15\n #1 [ff61d23de260fc08] schedule at ffffffff8323c014\n #2 [ff61d23de260fc28] blk_mq_freeze_queue_wait at ffffffff82a3dba1\n #3 [ff61d23de260fc78] blk_freeze_queue at ffffffff82a4113a\n #4 [ff61d23de260fc90] blk_cleanup_queue at ffffffff82a33006\n #5 [ff61d23de260fcb0] nvme_rdma_destroy_admin_queue at ffffffffc12686ce\n #6 [ff61d23de260fcc8] nvme_rdma_setup_ctrl at ffffffffc1268ced\n #7 [ff61d23de260fd28] nvme_rdma_create_ctrl at ffffffffc126919b\n #8 [ff61d23de260fd68] nvmf_dev_write at ffffffffc024f362\n #9 [ff61d23de260fe38] vfs_write at ffffffff827d5f25\n    RIP: 00007fda7891d574  RSP: 00007ffe2ef06958  RFLAGS: 00000202\n    RAX: ffffffffffffffda  RBX: 000055e8122a4d90  RCX: 00007fda7891d574\n    RDX: 000000000000012b  RSI: 000055e8122a4d90  RDI: 0000000000000004\n    RBP: 00007ffe2ef079c0   R8: 000000000000012b   R9: 000055e8122a4d90\n    R10: 0000000000000000  R11: 0000000000000202  R12: 0000000000000004\n    R13: 000055e8122923c0  R14: 000000000000012b  R15: 00007fda78a54500\n    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b\n\nThis due to we have quiesced admi_q before cancel requests, but forgot\nto unquiesce before destroy it, as a result we fail to drain the\npending requests, and hang on blk_mq_freeze_queue_wait() forever. Here\ntry to reuse nvme_rdma_teardown_admin_queue() to fix this issue and\nsimplify the code.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/427036030f4d796533dcadba9b845896cb6c10a7",
      "https://git.kernel.org/stable/c/05b436f3cf65c957eff86c5ea5ddfa2604b32c63",
      "https://git.kernel.org/stable/c/5858b687559809f05393af745cbadf06dee61295"
    ],
    "受影响版本": [
      "958dc1d32c80566f58d18f05ef1f05bd32d172c1",
      "958dc1d32c80566f58d18f05ef1f05bd32d172c1",
      "958dc1d32c80566f58d18f05ef1f05bd32d172c1",
      "a9ea34d2717a8c8892d3c5677329de9485e325ac",
      "7da81eaf8710130a9e63d7429627183be5a93787",
      "caed0b3851a4f52afd1ef77a27b30410fe7b68c7"
    ],
    "公开日期": "2025年01月11日"
  },
  {
    "设备品牌": "Teplitsa of social technologies",
    "设备类型": "OTA",
    "产品型号": "Leyka",
    "CVE编号": "CVE-2024-49252",
    "漏洞描述": ": Exposure of Sensitive System Information to an Unauthorized Control Sphere vulnerability in Teplitsa of social technologies Leyka.This issue affects Leyka: from n/a through 3.31.6.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/leyka/wordpress-leyka-plugin-3-31-6-broken-access-control-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年10月16日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2024-48145",
    "漏洞描述": "A prompt injection vulnerability in the chatbox of Netangular Technologies ChatNet AI Version v1.0 allows attackers to access and exfiltrate all previous and subsequent chat data between the user and the AI assistant via a crafted message.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://apps.microsoft.com/detail/9n3zxd05895t?hl=en-us&gl=US",
      "https://github.com/soursec/CVEs/tree/main/CVE-2024-48145"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年10月24日"
  },
  {
    "设备品牌": "bytecodealliance",
    "设备类型": "OTA",
    "产品型号": "wasmtime",
    "CVE编号": "CVE-2024-47813",
    "漏洞描述": "Wasmtime is an open source runtime for WebAssembly. Under certain concurrent event orderings, a `wasmtime::Engine`'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use `wasmtime::Engine` across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected. Reproducing this bug requires creating and dropping multiple type instances (such as `wasmtime::FuncType` or `wasmtime::ArrayType`) concurrently on multiple threads, where all types are associated with the same `wasmtime::Engine`. **Wasm guests cannot trigger this bug.** See the \"References\" section below for a list of Wasmtime types-related APIs that are affected. Wasmtime maintains an internal registry of types within a `wasmtime::Engine` and an engine is shareable across threads. Types can be created and referenced through creation of a `wasmtime::Module`, creation of `wasmtime::FuncType`, or a number of other APIs where the host creates a function (see \"References\" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's `call_indirect` function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state. Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered. This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug: * 21.0.2 * 22.0.1 * 23.0.3 * 24.0.1 * 25.0.2. If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m",
      "https://github.com/bytecodealliance/wasmtime/pull/7969"
    ],
    "受影响版本": [
      ">= 19.0.0, < 21.0.2",
      ">= 22.0.0, < 22.0.1",
      ">= 23.0.0, < 23.0.3",
      ">= 24.0.0, < 24.0.1",
      ">= 25.0.0, < 25.0.2"
    ],
    "公开日期": "2024年10月09日"
  },
  {
    "设备品牌": "idurar",
    "设备类型": "OTA",
    "产品型号": "idurar-erp-crm",
    "CVE编号": "CVE-2024-47769",
    "漏洞描述": "IDURAR is open source ERP CRM accounting invoicing software. The vulnerability exists in the corePublicRouter.js file. Using the reference usage here, it is identified that the public endpoint is accessible to an unauthenticated user. The user's input is directly appended to the join statement without additional checks. This allows an attacker to send URL encoded malicious payload. The directory structure can be escaped to read system files by adding an encoded string (payload) at subpath location.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/idurar/idurar-erp-crm/security/advisories/GHSA-948g-2vm7-mfv7",
      "https://github.com/idurar/idurar-erp-crm/commit/949bc6fe31f3175c9e1864d30cf6c8110179ac14"
    ],
    "受影响版本": [
      "<= 4.1.0"
    ],
    "公开日期": "2024年10月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47737",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: call cache_put if xdr_reserve_space returns NULL\n\nIf not enough buffer space available, but idmap_lookup has triggered\nlookup_fn which calls cache_get and returns successfully. Then we\nmissed to call cache_put here which pairs with cache_get.\n\nReviwed-by: Jeff Layton <jlayton@kernel.org>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3e8081ebff12bec1347deaceb6bce0765cce54df",
      "https://git.kernel.org/stable/c/c6b16e700cf4d959af524bd9d3978407ff7ce462",
      "https://git.kernel.org/stable/c/9f03f0016ff797932551881c7e06ae50e9c39134",
      "https://git.kernel.org/stable/c/9803ab882d565a8fb2dde5999d98866d1c499dfd",
      "https://git.kernel.org/stable/c/81821617312988096f5deccf0f7da6f888e98056",
      "https://git.kernel.org/stable/c/a1afbbb5276f943ad7173d0b4c626b8c75a260da",
      "https://git.kernel.org/stable/c/e32ee6a61041925d1a05c14d10352dcfce9ef029",
      "https://git.kernel.org/stable/c/8d0765f86135e27f0bb5c950c136495719b4c834",
      "https://git.kernel.org/stable/c/d078cbf5c38de83bc31f83c47dcd2184c04a50c7"
    ],
    "受影响版本": [
      "ddd1ea56367202f6c99135cd59de7a97af4c4ffd",
      "ddd1ea56367202f6c99135cd59de7a97af4c4ffd",
      "ddd1ea56367202f6c99135cd59de7a97af4c4ffd",
      "ddd1ea56367202f6c99135cd59de7a97af4c4ffd",
      "ddd1ea56367202f6c99135cd59de7a97af4c4ffd",
      "ddd1ea56367202f6c99135cd59de7a97af4c4ffd",
      "ddd1ea56367202f6c99135cd59de7a97af4c4ffd",
      "ddd1ea56367202f6c99135cd59de7a97af4c4ffd",
      "ddd1ea56367202f6c99135cd59de7a97af4c4ffd"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47736",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nerofs: handle overlapped pclusters out of crafted images properly\n\nsyzbot reported a task hang issue due to a deadlock case where it is\nwaiting for the folio lock of a cached folio that will be used for\ncache I/Os.\n\nAfter looking into the crafted fuzzed image, I found it's formed with\nseveral overlapped big pclusters as below:\n\n Ext:   logical offset   |  length :     physical offset    |  length\n   0:        0..   16384 |   16384 :     151552..    167936 |   16384\n   1:    16384..   32768 |   16384 :     155648..    172032 |   16384\n   2:    32768..   49152 |   16384 :  537223168.. 537239552 |   16384\n...\n\nHere, extent 0/1 are physically overlapped although it's entirely\n_impossible_ for normal filesystem images generated by mkfs.\n\nFirst, managed folios containing compressed data will be marked as\nup-to-date and then unlocked immediately (unlike in-place folios) when\ncompressed I/Os are complete.  If physical blocks are not submitted in\nthe incremental order, there should be separate BIOs to avoid dependency\nissues.  However, the current code mis-arranges z_erofs_fill_bio_vec()\nand BIO submission which causes unexpected BIO waits.\n\nSecond, managed folios will be connected to their own pclusters for\nefficient inter-queries.  However, this is somewhat hard to implement\neasily if overlapped big pclusters exist.  Again, these only appear in\nfuzzed images so let's simply fall back to temporary short-lived pages\nfor correctness.\n\nAdditionally, it justifies that referenced managed folios cannot be\ntruncated for now and reverts part of commit 2080ca1ed3e4 (\"erofs: tidy\nup `struct z_erofs_bvec`\") for simplicity although it shouldn't be any\ndifference.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1bf7e414cac303c9aec1be67872e19be8b64980c",
      "https://git.kernel.org/stable/c/b9b30af0e86ffb485301ecd83b9129c9dfb7ebf8",
      "https://git.kernel.org/stable/c/9cfa199bcbbbba31cbf97b2786f44f4464f3f29a",
      "https://git.kernel.org/stable/c/9e2f9d34dd12e6e5b244ec488bcebd0c2d566c50"
    ],
    "受影响版本": [
      "8e6c8fa9f2e95c88a642521a5da19a8e31748846",
      "8e6c8fa9f2e95c88a642521a5da19a8e31748846",
      "8e6c8fa9f2e95c88a642521a5da19a8e31748846",
      "8e6c8fa9f2e95c88a642521a5da19a8e31748846"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47729",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe: Use reserved copy engine for user binds on faulting devices\n\nUser binds map to engines with can fault, faults depend on user binds\ncompletion, thus we can deadlock. Avoid this by using reserved copy\nengine for user binds on faulting devices.\n\nWhile we are here, normalize bind queue creation with a helper.\n\nv2:\n - Pass in extensions to bind queue creation (CI)\nv3:\n - s/resevered/reserved (Lucas)\n - Fix NULL hwe check (Jonathan)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/439fc1e569c57669dbb842d0a77c7ba0a82a9f5d",
      "https://git.kernel.org/stable/c/852856e3b6f679c694dd5ec41e5a3c11aa46640b"
    ],
    "受影响版本": [
      "dd08ebf6c3525a7ea2186e636df064ea47281987",
      "dd08ebf6c3525a7ea2186e636df064ea47281987"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47728",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Zero former ARG_PTR_TO_{LONG,INT} args in case of error\n\nFor all non-tracing helpers which formerly had ARG_PTR_TO_{LONG,INT} as input\narguments, zero the value for the case of an error as otherwise it could leak\nmemory. For tracing, it is not needed given CAP_PERFMON can already read all\nkernel memory anyway hence bpf_get_func_arg() and bpf_get_func_ret() is skipped\nin here.\n\nAlso, the MTU helpers mtu_len pointer value is being written but also read.\nTechnically, the MEM_UNINIT should not be there in order to always force init.\nRemoving MEM_UNINIT needs more verifier rework though: MEM_UNINIT right now\nimplies two things actually: i) write into memory, ii) memory does not have\nto be initialized. If we lift MEM_UNINIT, it then becomes: i) read into memory,\nii) memory must be initialized. This means that for bpf_*_check_mtu() we're\nreadding the issue we're trying to fix, that is, it would then be able to\nwrite back into things like .rodata BPF maps. Follow-up work will rework the\nMEM_UNINIT semantics such that the intent can be better expressed. For now\njust clear the *mtu_len on error path which can be lifted later again.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8397bf78988f3ae9dbebb0200189a62a57264980",
      "https://git.kernel.org/stable/c/a634fa8e480ac2423f86311a602f6295df2c8ed0",
      "https://git.kernel.org/stable/c/599d15b6d03356a97bff7a76155c5604c42a2962",
      "https://git.kernel.org/stable/c/594a9f5a8d2de2573a856e506f77ba7dd2cefc6a",
      "https://git.kernel.org/stable/c/4b3786a6c5397dc220b1483d8e2f4867743e966f"
    ],
    "受影响版本": [
      "d7a4cb9b6705a89937d12c8158a35a3145dc967a",
      "d7a4cb9b6705a89937d12c8158a35a3145dc967a",
      "d7a4cb9b6705a89937d12c8158a35a3145dc967a",
      "d7a4cb9b6705a89937d12c8158a35a3145dc967a",
      "d7a4cb9b6705a89937d12c8158a35a3145dc967a"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47706",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock, bfq: fix possible UAF for bfqq->bic with merge chain\n\n1) initial state, three tasks:\n\n\t\tProcess 1       Process 2\tProcess 3\n\t\t (BIC1)          (BIC2)\t\t (BIC3)\n\t\t  |  Λ            |  Λ\t\t  |  Λ\n\t\t  |  |            |  |\t\t  |  |\n\t\t  V  |            V  |\t\t  V  |\n\t\t  bfqq1           bfqq2\t\t  bfqq3\nprocess ref:\t   1\t\t    1\t\t    1\n\n2) bfqq1 merged to bfqq2:\n\n\t\tProcess 1       Process 2\tProcess 3\n\t\t (BIC1)          (BIC2)\t\t (BIC3)\n\t\t  |               |\t\t  |  Λ\n\t\t  \\--------------\\|\t\t  |  |\n\t\t                  V\t\t  V  |\n\t\t  bfqq1--------->bfqq2\t\t  bfqq3\nprocess ref:\t   0\t\t    2\t\t    1\n\n3) bfqq2 merged to bfqq3:\n\n\t\tProcess 1       Process 2\tProcess 3\n\t\t (BIC1)          (BIC2)\t\t (BIC3)\n\t here -> Λ                |\t\t  |\n\t\t  \\--------------\\ \\-------------\\|\n\t\t                  V\t\t  V\n\t\t  bfqq1--------->bfqq2---------->bfqq3\nprocess ref:\t   0\t\t    1\t\t    3\n\nIn this case, IO from Process 1 will get bfqq2 from BIC1 first, and then\nget bfqq3 through merge chain, and finially handle IO by bfqq3.\nHowerver, current code will think bfqq2 is owned by BIC1, like initial\nstate, and set bfqq2->bic to BIC1.\n\nbfq_insert_request\n-> by Process 1\n bfqq = bfq_init_rq(rq)\n  bfqq = bfq_get_bfqq_handle_split\n   bfqq = bic_to_bfqq\n   -> get bfqq2 from BIC1\n bfqq->ref++\n rq->elv.priv[0] = bic\n rq->elv.priv[1] = bfqq\n if (bfqq_process_refs(bfqq) == 1)\n  bfqq->bic = bic\n  -> record BIC1 to bfqq2\n\n  __bfq_insert_request\n   new_bfqq = bfq_setup_cooperator\n   -> get bfqq3 from bfqq2->new_bfqq\n   bfqq_request_freed(bfqq)\n   new_bfqq->ref++\n   rq->elv.priv[1] = new_bfqq\n   -> handle IO by bfqq3\n\nFix the problem by checking bfqq is from merge chain fist. And this\nmight fix a following problem reported by our syzkaller(unreproducible):\n\n==================================================================\nBUG: KASAN: slab-use-after-free in bfq_do_early_stable_merge block/bfq-iosched.c:5692 [inline]\nBUG: KASAN: slab-use-after-free in bfq_do_or_sched_stable_merge block/bfq-iosched.c:5805 [inline]\nBUG: KASAN: slab-use-after-free in bfq_get_queue+0x25b0/0x2610 block/bfq-iosched.c:5889\nWrite of size 1 at addr ffff888123839eb8 by task kworker/0:1H/18595\n\nCPU: 0 PID: 18595 Comm: kworker/0:1H Tainted: G             L     6.6.0-07439-gba2303cacfda #6\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014\nWorkqueue: kblockd blk_mq_requeue_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x91/0xf0 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:364 [inline]\n print_report+0x10d/0x610 mm/kasan/report.c:475\n kasan_report+0x8e/0xc0 mm/kasan/report.c:588\n bfq_do_early_stable_merge block/bfq-iosched.c:5692 [inline]\n bfq_do_or_sched_stable_merge block/bfq-iosched.c:5805 [inline]\n bfq_get_queue+0x25b0/0x2610 block/bfq-iosched.c:5889\n bfq_get_bfqq_handle_split+0x169/0x5d0 block/bfq-iosched.c:6757\n bfq_init_rq block/bfq-iosched.c:6876 [inline]\n bfq_insert_request block/bfq-iosched.c:6254 [inline]\n bfq_insert_requests+0x1112/0x5cf0 block/bfq-iosched.c:6304\n blk_mq_insert_request+0x290/0x8d0 block/blk-mq.c:2593\n blk_mq_requeue_work+0x6bc/0xa70 block/blk-mq.c:1502\n process_one_work kernel/workqueue.c:2627 [inline]\n process_scheduled_works+0x432/0x13f0 kernel/workqueue.c:2700\n worker_thread+0x6f2/0x1160 kernel/workqueue.c:2781\n kthread+0x33c/0x440 kernel/kthread.c:388\n ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1b/0x30 arch/x86/entry/entry_64.S:305\n </TASK>\n\nAllocated by task 20776:\n kasan_save_stack+0x20/0x40 mm/kasan/common.c:45\n kasan_set_track+0x25/0x30 mm/kasan/common.c:52\n __kasan_slab_alloc+0x87/0x90 mm/kasan/common.c:328\n kasan_slab_alloc include/linux/kasan.h:188 [inline]\n slab_post_alloc_hook mm/slab.h:763 [inline]\n slab_alloc_node mm/slub.c:3458 [inline]\n kmem_cache_alloc_node+0x1a4/0x6f0 mm/slub.c:3503\n ioc_create_icq block/blk-ioc.c:370 [inline]\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a9bdd5b36887d2bacb8bc777fd18317c99fc2587",
      "https://git.kernel.org/stable/c/bc2140534b2aae752e4f7cb4489642dbb5ec4777",
      "https://git.kernel.org/stable/c/e1277ae780cca4e69ef5468d4582dfd48f0b8320",
      "https://git.kernel.org/stable/c/8aa9de02a4be2e7006e636816ce19b0d667ceaa3",
      "https://git.kernel.org/stable/c/ddbdaad123254fb53e32480cb74a486a6868b1e0",
      "https://git.kernel.org/stable/c/7faed2896d78e48ec96229e73b30b0af6c00a9aa",
      "https://git.kernel.org/stable/c/880692ee233ba63808182705b3333403413b58f5",
      "https://git.kernel.org/stable/c/6d130db286ad0ea392c96ebb2551acf0d7308048",
      "https://git.kernel.org/stable/c/18ad4df091dd5d067d2faa8fce1180b79f7041a7"
    ],
    "受影响版本": [
      "36eca894832351feed9072d0f97eb06fc9482ca4",
      "36eca894832351feed9072d0f97eb06fc9482ca4",
      "36eca894832351feed9072d0f97eb06fc9482ca4",
      "36eca894832351feed9072d0f97eb06fc9482ca4",
      "36eca894832351feed9072d0f97eb06fc9482ca4",
      "36eca894832351feed9072d0f97eb06fc9482ca4",
      "36eca894832351feed9072d0f97eb06fc9482ca4",
      "36eca894832351feed9072d0f97eb06fc9482ca4",
      "36eca894832351feed9072d0f97eb06fc9482ca4"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47689",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to don't set SB_RDONLY in f2fs_handle_critical_error()\n\nsyzbot reports a f2fs bug as below:\n\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 58 at kernel/rcu/sync.c:177 rcu_sync_dtor+0xcd/0x180 kernel/rcu/sync.c:177\nCPU: 1 UID: 0 PID: 58 Comm: kworker/1:2 Not tainted 6.10.0-syzkaller-12562-g1722389b0d86 #0\nWorkqueue: events destroy_super_work\nRIP: 0010:rcu_sync_dtor+0xcd/0x180 kernel/rcu/sync.c:177\nCall Trace:\n percpu_free_rwsem+0x41/0x80 kernel/locking/percpu-rwsem.c:42\n destroy_super_work+0xec/0x130 fs/super.c:282\n process_one_work kernel/workqueue.c:3231 [inline]\n process_scheduled_works+0xa2c/0x1830 kernel/workqueue.c:3312\n worker_thread+0x86d/0xd40 kernel/workqueue.c:3390\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\nAs Christian Brauner pointed out [1]: the root cause is f2fs sets\nSB_RDONLY flag in internal function, rather than setting the flag\ncovered w/ sb->s_umount semaphore via remount procedure, then below\nrace condition causes this bug:\n\n- freeze_super()\n - sb_wait_write(sb, SB_FREEZE_WRITE)\n - sb_wait_write(sb, SB_FREEZE_PAGEFAULT)\n - sb_wait_write(sb, SB_FREEZE_FS)\n\t\t\t\t\t- f2fs_handle_critical_error\n\t\t\t\t\t - sb->s_flags |= SB_RDONLY\n- thaw_super\n - thaw_super_locked\n  - sb_rdonly() is true, so it skips\n    sb_freeze_unlock(sb, SB_FREEZE_FS)\n  - deactivate_locked_super\n\nSince f2fs has almost the same logic as ext4 [2] when handling critical\nerror in filesystem if it mounts w/ errors=remount-ro option:\n- set CP_ERROR_FLAG flag which indicates filesystem is stopped\n- record errors to superblock\n- set SB_RDONLY falg\nOnce we set CP_ERROR_FLAG flag, all writable interfaces can detect the\nflag and stop any further updates on filesystem. So, it is safe to not\nset SB_RDONLY flag, let's remove the logic and keep in line w/ ext4 [3].\n\n[1] https://lore.kernel.org/all/20240729-himbeeren-funknetz-96e62f9c7aee@brauner\n[2] https://lore.kernel.org/all/20240729132721.hxih6ehigadqf7wx@quack3\n[3] https://lore.kernel.org/linux-ext4/20240805201241.27286-1-jack@suse.cz",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/649ec8b30df113042588bd3d3cd4e98bcb1091e0",
      "https://git.kernel.org/stable/c/de43021c72993877a8f86f9fddfa0687609da5a4",
      "https://git.kernel.org/stable/c/1f63f405c1a1a64b9c310388aad7055fb86b245c",
      "https://git.kernel.org/stable/c/930c6ab93492c4b15436524e704950b364b2930c"
    ],
    "受影响版本": [
      "b62e71be2110d8b52bf5faf3c3ed7ca1a0c113a5",
      "b62e71be2110d8b52bf5faf3c3ed7ca1a0c113a5",
      "b62e71be2110d8b52bf5faf3c3ed7ca1a0c113a5",
      "b62e71be2110d8b52bf5faf3c3ed7ca1a0c113a5",
      "ed1d478bf838820201f3fb67a1748fdf15954ea4"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47684",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: check skb is non-NULL in tcp_rto_delta_us()\n\nWe have some machines running stock Ubuntu 20.04.6 which is their 5.4.0-174-generic\nkernel that are running ceph and recently hit a null ptr dereference in\ntcp_rearm_rto(). Initially hitting it from the TLP path, but then later we also\nsaw it getting hit from the RACK case as well. Here are examples of the oops\nmessages we saw in each of those cases:\n\nJul 26 15:05:02 rx [11061395.780353] BUG: kernel NULL pointer dereference, address: 0000000000000020\nJul 26 15:05:02 rx [11061395.787572] #PF: supervisor read access in kernel mode\nJul 26 15:05:02 rx [11061395.792971] #PF: error_code(0x0000) - not-present page\nJul 26 15:05:02 rx [11061395.798362] PGD 0 P4D 0\nJul 26 15:05:02 rx [11061395.801164] Oops: 0000 [#1] SMP NOPTI\nJul 26 15:05:02 rx [11061395.805091] CPU: 0 PID: 9180 Comm: msgr-worker-1 Tainted: G W 5.4.0-174-generic #193-Ubuntu\nJul 26 15:05:02 rx [11061395.814996] Hardware name: Supermicro SMC 2x26 os-gen8 64C NVME-Y 256G/H12SSW-NTR, BIOS 2.5.V1.2U.NVMe.UEFI 05/09/2023\nJul 26 15:05:02 rx [11061395.825952] RIP: 0010:tcp_rearm_rto+0xe4/0x160\nJul 26 15:05:02 rx [11061395.830656] Code: 87 ca 04 00 00 00 5b 41 5c 41 5d 5d c3 c3 49 8b bc 24 40 06 00 00 eb 8d 48 bb cf f7 53 e3 a5 9b c4 20 4c 89 ef e8 0c fe 0e 00 <48> 8b 78 20 48 c1 ef 03 48 89 f8 41 8b bc 24 80 04 00 00 48 f7 e3\nJul 26 15:05:02 rx [11061395.849665] RSP: 0018:ffffb75d40003e08 EFLAGS: 00010246\nJul 26 15:05:02 rx [11061395.855149] RAX: 0000000000000000 RBX: 20c49ba5e353f7cf RCX: 0000000000000000\nJul 26 15:05:02 rx [11061395.862542] RDX: 0000000062177c30 RSI: 000000000000231c RDI: ffff9874ad283a60\nJul 26 15:05:02 rx [11061395.869933] RBP: ffffb75d40003e20 R08: 0000000000000000 R09: ffff987605e20aa8\nJul 26 15:05:02 rx [11061395.877318] R10: ffffb75d40003f00 R11: ffffb75d4460f740 R12: ffff9874ad283900\nJul 26 15:05:02 rx [11061395.884710] R13: ffff9874ad283a60 R14: ffff9874ad283980 R15: ffff9874ad283d30\nJul 26 15:05:02 rx [11061395.892095] FS: 00007f1ef4a2e700(0000) GS:ffff987605e00000(0000) knlGS:0000000000000000\nJul 26 15:05:02 rx [11061395.900438] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nJul 26 15:05:02 rx [11061395.906435] CR2: 0000000000000020 CR3: 0000003e450ba003 CR4: 0000000000760ef0\nJul 26 15:05:02 rx [11061395.913822] PKRU: 55555554\nJul 26 15:05:02 rx [11061395.916786] Call Trace:\nJul 26 15:05:02 rx [11061395.919488]\nJul 26 15:05:02 rx [11061395.921765] ? show_regs.cold+0x1a/0x1f\nJul 26 15:05:02 rx [11061395.925859] ? __die+0x90/0xd9\nJul 26 15:05:02 rx [11061395.929169] ? no_context+0x196/0x380\nJul 26 15:05:02 rx [11061395.933088] ? ip6_protocol_deliver_rcu+0x4e0/0x4e0\nJul 26 15:05:02 rx [11061395.938216] ? ip6_sublist_rcv_finish+0x3d/0x50\nJul 26 15:05:02 rx [11061395.943000] ? __bad_area_nosemaphore+0x50/0x1a0\nJul 26 15:05:02 rx [11061395.947873] ? bad_area_nosemaphore+0x16/0x20\nJul 26 15:05:02 rx [11061395.952486] ? do_user_addr_fault+0x267/0x450\nJul 26 15:05:02 rx [11061395.957104] ? ipv6_list_rcv+0x112/0x140\nJul 26 15:05:02 rx [11061395.961279] ? __do_page_fault+0x58/0x90\nJul 26 15:05:02 rx [11061395.965458] ? do_page_fault+0x2c/0xe0\nJul 26 15:05:02 rx [11061395.969465] ? page_fault+0x34/0x40\nJul 26 15:05:02 rx [11061395.973217] ? tcp_rearm_rto+0xe4/0x160\nJul 26 15:05:02 rx [11061395.977313] ? tcp_rearm_rto+0xe4/0x160\nJul 26 15:05:02 rx [11061395.981408] tcp_send_loss_probe+0x10b/0x220\nJul 26 15:05:02 rx [11061395.985937] tcp_write_timer_handler+0x1b4/0x240\nJul 26 15:05:02 rx [11061395.990809] tcp_write_timer+0x9e/0xe0\nJul 26 15:05:02 rx [11061395.994814] ? tcp_write_timer_handler+0x240/0x240\nJul 26 15:05:02 rx [11061395.999866] call_timer_fn+0x32/0x130\nJul 26 15:05:02 rx [11061396.003782] __run_timers.part.0+0x180/0x280\nJul 26 15:05:02 rx [11061396.008309] ? recalibrate_cpu_khz+0x10/0x10\nJul 26 15:05:02 rx [11061396.012841] ? native_x2apic_icr_write+0x30/0x30\nJul 26 15:05:02 rx [11061396.017718] ? lapic_next_even\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ad4f0a14d6856e68f023fc4e5017cfd881a3dfbc",
      "https://git.kernel.org/stable/c/16e0387d87fc858e34449fdf2b14ed5837f761db",
      "https://git.kernel.org/stable/c/ec31cf42fc4e35bb1248ce6eb1de6de9f851ac86",
      "https://git.kernel.org/stable/c/5c4c03288a4aea705e36aa44119c13d7ee4dce99",
      "https://git.kernel.org/stable/c/96c4983eab2a5da235f7fff90beaf17b008ba029",
      "https://git.kernel.org/stable/c/570f7d8c9bf14f041152ba8353d4330ef7575915",
      "https://git.kernel.org/stable/c/81d18c152e3f82bacadf83bc0a471b2363b9cc18",
      "https://git.kernel.org/stable/c/09aea49fbc7e755a915c405644f347137cdb62b0",
      "https://git.kernel.org/stable/c/c8770db2d54437a5f49417ae7b46f7de23d14db6"
    ],
    "受影响版本": [
      "e1a10ef7fa876f8510aaec36ea5c0cf34baba410",
      "e1a10ef7fa876f8510aaec36ea5c0cf34baba410",
      "e1a10ef7fa876f8510aaec36ea5c0cf34baba410",
      "e1a10ef7fa876f8510aaec36ea5c0cf34baba410",
      "e1a10ef7fa876f8510aaec36ea5c0cf34baba410",
      "e1a10ef7fa876f8510aaec36ea5c0cf34baba410",
      "e1a10ef7fa876f8510aaec36ea5c0cf34baba410",
      "e1a10ef7fa876f8510aaec36ea5c0cf34baba410",
      "e1a10ef7fa876f8510aaec36ea5c0cf34baba410",
      "42a858e036bb26cb559157393b7890cabe70bfc2"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47679",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvfs: fix race between evice_inodes() and find_inode()&iput()\n\nHi, all\n\nRecently I noticed a bug[1] in btrfs, after digged it into\nand I believe it'a race in vfs.\n\nLet's assume there's a inode (ie ino 261) with i_count 1 is\ncalled by iput(), and there's a concurrent thread calling\ngeneric_shutdown_super().\n\ncpu0:                              cpu1:\niput() // i_count is 1\n  ->spin_lock(inode)\n  ->dec i_count to 0\n  ->iput_final()                    generic_shutdown_super()\n    ->__inode_add_lru()               ->evict_inodes()\n      // cause some reason[2]           ->if (atomic_read(inode->i_count)) continue;\n      // return before                  // inode 261 passed the above check\n      // list_lru_add_obj()             // and then schedule out\n   ->spin_unlock()\n// note here: the inode 261\n// was still at sb list and hash list,\n// and I_FREEING|I_WILL_FREE was not been set\n\nbtrfs_iget()\n  // after some function calls\n  ->find_inode()\n    // found the above inode 261\n    ->spin_lock(inode)\n   // check I_FREEING|I_WILL_FREE\n   // and passed\n      ->__iget()\n    ->spin_unlock(inode)                // schedule back\n                                        ->spin_lock(inode)\n                                        // check (I_NEW|I_FREEING|I_WILL_FREE) flags,\n                                        // passed and set I_FREEING\niput()                                  ->spin_unlock(inode)\n  ->spin_lock(inode)\t\t\t  ->evict()\n  // dec i_count to 0\n  ->iput_final()\n    ->spin_unlock()\n    ->evict()\n\nNow, we have two threads simultaneously evicting\nthe same inode, which may trigger the BUG(inode->i_state & I_CLEAR)\nstatement both within clear_inode() and iput().\n\nTo fix the bug, recheck the inode->i_count after holding i_lock.\nBecause in the most scenarios, the first check is valid, and\nthe overhead of spin_lock() can be reduced.\n\nIf there is any misunderstanding, please let me know, thanks.\n\n[1]: https://lore.kernel.org/linux-btrfs/000000000000eabe1d0619c48986@google.com/\n[2]: The reason might be 1. SB_ACTIVE was removed or 2. mapping_shrinkable()\nreturn false when I reproduced the bug.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6cc13a80a26e6b48f78c725c01b91987d61563ef",
      "https://git.kernel.org/stable/c/489faddb1ae75b0e1a741fe5ca2542a2b5e794a5",
      "https://git.kernel.org/stable/c/47a68c75052a660e4c37de41e321582ec9496195",
      "https://git.kernel.org/stable/c/3721a69403291e2514d13a7c3af50a006ea1153b",
      "https://git.kernel.org/stable/c/540fb13120c9eab3ef203f90c00c8e69f37449d1",
      "https://git.kernel.org/stable/c/0eed942bc65de1f93eca7bda51344290f9c573bb",
      "https://git.kernel.org/stable/c/0f8a5b6d0dafa4f533ac82e98f8b812073a7c9d1",
      "https://git.kernel.org/stable/c/6c857fb12b9137fee574443385d53914356bbe11",
      "https://git.kernel.org/stable/c/88b1afbf0f6b221f6c5bb66cc80cd3b38d696687"
    ],
    "受影响版本": [
      "63997e98a3be68d7cec806d22bf9b02b2e1daabb",
      "63997e98a3be68d7cec806d22bf9b02b2e1daabb",
      "63997e98a3be68d7cec806d22bf9b02b2e1daabb",
      "63997e98a3be68d7cec806d22bf9b02b2e1daabb",
      "63997e98a3be68d7cec806d22bf9b02b2e1daabb",
      "63997e98a3be68d7cec806d22bf9b02b2e1daabb",
      "63997e98a3be68d7cec806d22bf9b02b2e1daabb",
      "63997e98a3be68d7cec806d22bf9b02b2e1daabb",
      "63997e98a3be68d7cec806d22bf9b02b2e1daabb"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47677",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nexfat: resolve memory leak from exfat_create_upcase_table()\n\nIf exfat_load_upcase_table reaches end and returns -EINVAL,\nallocated memory doesn't get freed and while\nexfat_load_default_upcase_table allocates more memory, leading to a\nmemory leak.\n\nHere's link to syzkaller crash report illustrating this issue:\nhttps://syzkaller.appspot.com/text?tag=CrashReport&x=1406c201980000",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f9835aec49670c46ebe2973032caaa1043b3d4da",
      "https://git.kernel.org/stable/c/331ed2c739ce656a67865f6b3ee0a478349d78cb",
      "https://git.kernel.org/stable/c/c290fe508eee36df1640c3cb35dc8f89e073c8a8"
    ],
    "受影响版本": [
      "a13d1a4de3b0fe3c41d818697d691c886c5585fa",
      "a13d1a4de3b0fe3c41d818697d691c886c5585fa",
      "a13d1a4de3b0fe3c41d818697d691c886c5585fa"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47667",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: keystone: Add workaround for Errata #i2037 (AM65x SR 1.0)\n\nErrata #i2037 in AM65x/DRA80xM Processors Silicon Revision 1.0\n(SPRZ452D_July 2018_Revised December 2019 [1]) mentions when an\ninbound PCIe TLP spans more than two internal AXI 128-byte bursts,\nthe bus may corrupt the packet payload and the corrupt data may\ncause associated applications or the processor to hang.\n\nThe workaround for Errata #i2037 is to limit the maximum read\nrequest size and maximum payload size to 128 bytes. Add workaround\nfor Errata #i2037 here.\n\nThe errata and workaround is applicable only to AM65x SR 1.0 and\nlater versions of the silicon will have this fixed.\n\n[1] -> https://www.ti.com/lit/er/sprz452i/sprz452i.pdf",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/cfb006e185f64edbbdf7869eac352442bc76b8f6",
      "https://git.kernel.org/stable/c/ebbdbbc580c1695dec283d0ba6448729dc993246",
      "https://git.kernel.org/stable/c/135843c351c08df72bdd4b4ebea53c8052a76881",
      "https://git.kernel.org/stable/c/af218c803fe298ddf00abef331aa526b20d7ea61",
      "https://git.kernel.org/stable/c/576d0fb6f8d4bd4695e70eee173a1b9c7bae9572",
      "https://git.kernel.org/stable/c/dd47051c76c8acd8cb983f01b4d1265da29cb66a",
      "https://git.kernel.org/stable/c/86f271f22bbb6391410a07e08d6ca3757fda01fa"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47664",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: hisi-kunpeng: Add verification for the max_frequency provided by the firmware\n\nIf the value of max_speed_hz is 0, it may cause a division by zero\nerror in hisi_calc_effective_speed().\nThe value of max_speed_hz is provided by firmware.\nFirmware is generally considered as a trusted domain. However, as\ndivision by zero errors can cause system failure, for defense measure,\nthe value of max_speed is validated here. So 0 is regarded as invalid\nand an error code is returned.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/16ccaf581da4fcf1e4d66086cf37263f9a656d43",
      "https://git.kernel.org/stable/c/ee73a15d4a8ce8fb02d7866f7cf78fcdd16f0fcc",
      "https://git.kernel.org/stable/c/5127c42c77de18651aa9e8e0a3ced190103b449c"
    ],
    "受影响版本": [
      "c770d8631e1810d8f1ce21b18ad5dd67eeb39e5c",
      "c770d8631e1810d8f1ce21b18ad5dd67eeb39e5c",
      "c770d8631e1810d8f1ce21b18ad5dd67eeb39e5c"
    ],
    "公开日期": "2024年10月09日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-47659",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmack: tcp: ipv4, fix incorrect labeling\n\nCurrently, Smack mirrors the label of incoming tcp/ipv4 connections:\nwhen a label 'foo' connects to a label 'bar' with tcp/ipv4,\n'foo' always gets 'foo' in returned ipv4 packets. So,\n1) returned packets are incorrectly labeled ('foo' instead of 'bar')\n2) 'bar' can write to 'foo' without being authorized to write.\n\nHere is a scenario how to see this:\n\n* Take two machines, let's call them C and S,\n   with active Smack in the default state\n   (no settings, no rules, no labeled hosts, only builtin labels)\n\n* At S, add Smack rule 'foo bar w'\n   (labels 'foo' and 'bar' are instantiated at S at this moment)\n\n* At S, at label 'bar', launch a program\n   that listens for incoming tcp/ipv4 connections\n\n* From C, at label 'foo', connect to the listener at S.\n   (label 'foo' is instantiated at C at this moment)\n   Connection succeedes and works.\n\n* Send some data in both directions.\n* Collect network traffic of this connection.\n\nAll packets in both directions are labeled with the CIPSO\nof the label 'foo'. Hence, label 'bar' writes to 'foo' without\nbeing authorized, and even without ever being known at C.\n\nIf anybody cares: exactly the same happens with DCCP.\n\nThis behavior 1st manifested in release 2.6.29.4 (see Fixes below)\nand it looks unintentional. At least, no explanation was provided.\n\nI changed returned packes label into the 'bar',\nto bring it into line with the Smack documentation claims.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d3f56c653c65f170b172d3c23120bc64ada645d8",
      "https://git.kernel.org/stable/c/5b4b304f196c070342e32a4752e1fa2e22fc0671",
      "https://git.kernel.org/stable/c/a948ec993541db4ef392b555c37a1186f4d61670",
      "https://git.kernel.org/stable/c/0aea09e82eafa50a373fc8a4b84c1d4734751e2c",
      "https://git.kernel.org/stable/c/0776bcf9cb6de46fdd94d10118de1cf9b05f83b9",
      "https://git.kernel.org/stable/c/4be9fd15c3c88775bdf6fa37acabe6de85beebff",
      "https://git.kernel.org/stable/c/d3703fa94116fed91f64c7d1c7d284fb4369070f",
      "https://git.kernel.org/stable/c/2fe209d0ad2e2729f7e22b9b31a86cc3ff0db550"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年10月09日"
  },
  {
    "设备品牌": "Copyscape / Indigo Stream Technologies",
    "设备类型": "OTA",
    "产品型号": "Copyscape Premium",
    "CVE编号": "CVE-2024-47644",
    "漏洞描述": "Cross-Site Request Forgery (CSRF) vulnerability in Copyscape / Indigo Stream Technologies Copyscape Premium allows Stored XSS.This issue affects Copyscape Premium: from n/a through 1.3.6.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/copyscape-premium/wordpress-copyscape-premium-plugin-1-3-6-csrf-to-stored-cross-site-scripting-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年10月05日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "LiteSpeed Cache",
    "CVE编号": "CVE-2024-47637",
    "漏洞描述": ": Relative Path Traversal vulnerability in LiteSpeed Technologies LiteSpeed Cache allows Path Traversal.This issue affects LiteSpeed Cache: from n/a through 6.4.1.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/litespeed-cache/wordpress-litespeed-cache-plugin-6-4-1-path-traversal-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年10月16日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "LiteSpeed Cache",
    "CVE编号": "CVE-2024-47374",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation (XSS or 'Cross-site Scripting') vulnerability in LiteSpeed Technologies LiteSpeed Cache allows Stored XSS.This issue affects LiteSpeed Cache: from n/a through 6.5.0.2.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/litespeed-cache/wordpress-litespeed-cache-plugin-6-5-0-2-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年10月05日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "LiteSpeed Cache",
    "CVE编号": "CVE-2024-47373",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation (XSS or 'Cross-site Scripting') vulnerability in LiteSpeed Technologies LiteSpeed Cache allows Stored XSS.This issue affects LiteSpeed Cache: from n/a through 6.5.0.2.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/litespeed-cache/wordpress-litespeed-cache-plugin-6-5-0-2-cross-site-scripting-xss-vulnerability-2?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年10月05日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46867",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe/client: fix deadlock in show_meminfo()\n\nThere is a real deadlock as well as sleeping in atomic() bug in here, if\nthe bo put happens to be the last ref, since bo destruction wants to\ngrab the same spinlock and sleeping locks.  Fix that by dropping the ref\nusing xe_bo_put_deferred(), and moving the final commit outside of the\nlock. Dropping the lock around the put is tricky since the bo can go\nout of scope and delete itself from the list, making it difficult to\nnavigate to the next list entry.\n\n(cherry picked from commit 0083b8e6f11d7662283a267d4ce7c966812ffd8a)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9d3de463e23bfb1ff1567a32b099b1b3e5286a48",
      "https://git.kernel.org/stable/c/9bd7ff293fc84792514aeafa06c5a17f05cb5f4b"
    ],
    "受影响版本": [
      "0845233388f8a26d00acf9bf230cfd4f36aa4c30",
      "0845233388f8a26d00acf9bf230cfd4f36aa4c30"
    ],
    "公开日期": "2024年09月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46860",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt76: mt7921: fix NULL pointer access in mt7921_ipv6_addr_change\n\nWhen disabling wifi mt7921_ipv6_addr_change() is called as a notifier.\nAt this point mvif->phy is already NULL so we cannot use it here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4bfee9346d8c17d928ef6da2b8bffab88fa2a553",
      "https://git.kernel.org/stable/c/8d92bafd4c67efb692f722d73a07412b5f88c6d6",
      "https://git.kernel.org/stable/c/479ffee68d59c599f8aed8fa2dcc8e13e7bd13c3"
    ],
    "受影响版本": [
      "7bc04215a66b60e198aecaee8418f6d79fa19faa",
      "7bc04215a66b60e198aecaee8418f6d79fa19faa",
      "7bc04215a66b60e198aecaee8418f6d79fa19faa"
    ],
    "公开日期": "2024年09月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46841",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: don't BUG_ON on ENOMEM from btrfs_lookup_extent_info() in walk_down_proc()\n\nWe handle errors here properly, ENOMEM isn't fatal, return the error.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c1406d8329f500e4594cd9730cd313aebc3a4333",
      "https://git.kernel.org/stable/c/6a0648f96c3ca647c71c6c1ddbc7c353bab79f64",
      "https://git.kernel.org/stable/c/44a2c518ab221c0cadcb8c45ca86f83a52dd4da6",
      "https://git.kernel.org/stable/c/135b4819f6fba87fd5a2693023133e78ac73f1d3",
      "https://git.kernel.org/stable/c/704c359b4093a2af650a20eaa030c435d7c30f91",
      "https://git.kernel.org/stable/c/a580fb2c3479d993556e1c31b237c9e5be4944a3"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年09月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46790",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncodetag: debug: mark codetags for poisoned page as empty\n\nWhen PG_hwpoison pages are freed they are treated differently in\nfree_pages_prepare() and instead of being released they are isolated.\n\nPage allocation tag counters are decremented at this point since the page\nis considered not in use.  Later on when such pages are released by\nunpoison_memory(), the allocation tag counters will be decremented again\nand the following warning gets reported:\n\n[  113.930443][ T3282] ------------[ cut here ]------------\n[  113.931105][ T3282] alloc_tag was not set\n[  113.931576][ T3282] WARNING: CPU: 2 PID: 3282 at ./include/linux/alloc_tag.h:130 pgalloc_tag_sub.part.66+0x154/0x164\n[  113.932866][ T3282] Modules linked in: hwpoison_inject fuse ip6t_rpfilter ip6t_REJECT nf_reject_ipv6 ipt_REJECT nf_reject_ipv4 xt_conntrack ebtable_nat ebtable_broute ip6table_nat ip6table_man4\n[  113.941638][ T3282] CPU: 2 UID: 0 PID: 3282 Comm: madvise11 Kdump: loaded Tainted: G        W          6.11.0-rc4-dirty #18\n[  113.943003][ T3282] Tainted: [W]=WARN\n[  113.943453][ T3282] Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n[  113.944378][ T3282] pstate: 40400005 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  113.945319][ T3282] pc : pgalloc_tag_sub.part.66+0x154/0x164\n[  113.946016][ T3282] lr : pgalloc_tag_sub.part.66+0x154/0x164\n[  113.946706][ T3282] sp : ffff800087093a10\n[  113.947197][ T3282] x29: ffff800087093a10 x28: ffff0000d7a9d400 x27: ffff80008249f0a0\n[  113.948165][ T3282] x26: 0000000000000000 x25: ffff80008249f2b0 x24: 0000000000000000\n[  113.949134][ T3282] x23: 0000000000000001 x22: 0000000000000001 x21: 0000000000000000\n[  113.950597][ T3282] x20: ffff0000c08fcad8 x19: ffff80008251e000 x18: ffffffffffffffff\n[  113.952207][ T3282] x17: 0000000000000000 x16: 0000000000000000 x15: ffff800081746210\n[  113.953161][ T3282] x14: 0000000000000000 x13: 205d323832335420 x12: 5b5d353031313339\n[  113.954120][ T3282] x11: ffff800087093500 x10: 000000000000005d x9 : 00000000ffffffd0\n[  113.955078][ T3282] x8 : 7f7f7f7f7f7f7f7f x7 : ffff80008236ba90 x6 : c0000000ffff7fff\n[  113.956036][ T3282] x5 : ffff000b34bf4dc8 x4 : ffff8000820aba90 x3 : 0000000000000001\n[  113.956994][ T3282] x2 : ffff800ab320f000 x1 : 841d1e35ac932e00 x0 : 0000000000000000\n[  113.957962][ T3282] Call trace:\n[  113.958350][ T3282]  pgalloc_tag_sub.part.66+0x154/0x164\n[  113.959000][ T3282]  pgalloc_tag_sub+0x14/0x1c\n[  113.959539][ T3282]  free_unref_page+0xf4/0x4b8\n[  113.960096][ T3282]  __folio_put+0xd4/0x120\n[  113.960614][ T3282]  folio_put+0x24/0x50\n[  113.961103][ T3282]  unpoison_memory+0x4f0/0x5b0\n[  113.961678][ T3282]  hwpoison_unpoison+0x30/0x48 [hwpoison_inject]\n[  113.962436][ T3282]  simple_attr_write_xsigned.isra.34+0xec/0x1cc\n[  113.963183][ T3282]  simple_attr_write+0x38/0x48\n[  113.963750][ T3282]  debugfs_attr_write+0x54/0x80\n[  113.964330][ T3282]  full_proxy_write+0x68/0x98\n[  113.964880][ T3282]  vfs_write+0xdc/0x4d0\n[  113.965372][ T3282]  ksys_write+0x78/0x100\n[  113.965875][ T3282]  __arm64_sys_write+0x24/0x30\n[  113.966440][ T3282]  invoke_syscall+0x7c/0x104\n[  113.966984][ T3282]  el0_svc_common.constprop.1+0x88/0x104\n[  113.967652][ T3282]  do_el0_svc+0x2c/0x38\n[  113.968893][ T3282]  el0_svc+0x3c/0x1b8\n[  113.969379][ T3282]  el0t_64_sync_handler+0x98/0xbc\n[  113.969980][ T3282]  el0t_64_sync+0x19c/0x1a0\n[  113.970511][ T3282] ---[ end trace 0000000000000000 ]---\n\nTo fix this, clear the page tag reference after the page got isolated\nand accounted for.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/16ad36c8e66a26626e7d0224100b433483a2acef",
      "https://git.kernel.org/stable/c/5e9784e997620af7c1399029282f5d6964b41942"
    ],
    "受影响版本": [
      "d224eb0287fbd84f4f13eca042c7f08f87138f3b",
      "d224eb0287fbd84f4f13eca042c7f08f87138f3b"
    ],
    "公开日期": "2024年09月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46789",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slub: add check for s->flags in the alloc_tagging_slab_free_hook\n\nWhen enable CONFIG_MEMCG & CONFIG_KFENCE & CONFIG_KMEMLEAK, the following\nwarning always occurs,This is because the following call stack occurred:\nmem_pool_alloc\n    kmem_cache_alloc_noprof\n        slab_alloc_node\n            kfence_alloc\n\nOnce the kfence allocation is successful,slab->obj_exts will not be empty,\nbecause it has already been assigned a value in kfence_init_pool.\n\nSince in the prepare_slab_obj_exts_hook function,we perform a check for\ns->flags & (SLAB_NO_OBJ_EXT | SLAB_NOLEAKTRACE),the alloc_tag_add function\nwill not be called as a result.Therefore,ref->ct remains NULL.\n\nHowever,when we call mem_pool_free,since obj_ext is not empty, it\neventually leads to the alloc_tag_sub scenario being invoked.  This is\nwhere the warning occurs.\n\nSo we should add corresponding checks in the alloc_tagging_slab_free_hook.\nFor __GFP_NO_OBJ_EXT case,I didn't see the specific case where it's using\nkfence,so I won't add the corresponding check in\nalloc_tagging_slab_free_hook for now.\n\n[    3.734349] ------------[ cut here ]------------\n[    3.734807] alloc_tag was not set\n[    3.735129] WARNING: CPU: 4 PID: 40 at ./include/linux/alloc_tag.h:130 kmem_cache_free+0x444/0x574\n[    3.735866] Modules linked in: autofs4\n[    3.736211] CPU: 4 UID: 0 PID: 40 Comm: ksoftirqd/4 Tainted: G        W          6.11.0-rc3-dirty #1\n[    3.736969] Tainted: [W]=WARN\n[    3.737258] Hardware name: QEMU KVM Virtual Machine, BIOS unknown 2/2/2022\n[    3.737875] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    3.738501] pc : kmem_cache_free+0x444/0x574\n[    3.738951] lr : kmem_cache_free+0x444/0x574\n[    3.739361] sp : ffff80008357bb60\n[    3.739693] x29: ffff80008357bb70 x28: 0000000000000000 x27: 0000000000000000\n[    3.740338] x26: ffff80008207f000 x25: ffff000b2eb2fd60 x24: ffff0000c0005700\n[    3.740982] x23: ffff8000804229e4 x22: ffff800082080000 x21: ffff800081756000\n[    3.741630] x20: fffffd7ff8253360 x19: 00000000000000a8 x18: ffffffffffffffff\n[    3.742274] x17: ffff800ab327f000 x16: ffff800083398000 x15: ffff800081756df0\n[    3.742919] x14: 0000000000000000 x13: 205d344320202020 x12: 5b5d373038343337\n[    3.743560] x11: ffff80008357b650 x10: 000000000000005d x9 : 00000000ffffffd0\n[    3.744231] x8 : 7f7f7f7f7f7f7f7f x7 : ffff80008237bad0 x6 : c0000000ffff7fff\n[    3.744907] x5 : ffff80008237ba78 x4 : ffff8000820bbad0 x3 : 0000000000000001\n[    3.745580] x2 : 68d66547c09f7800 x1 : 68d66547c09f7800 x0 : 0000000000000000\n[    3.746255] Call trace:\n[    3.746530]  kmem_cache_free+0x444/0x574\n[    3.746931]  mem_pool_free+0x44/0xf4\n[    3.747306]  free_object_rcu+0xc8/0xdc\n[    3.747693]  rcu_do_batch+0x234/0x8a4\n[    3.748075]  rcu_core+0x230/0x3e4\n[    3.748424]  rcu_core_si+0x14/0x1c\n[    3.748780]  handle_softirqs+0x134/0x378\n[    3.749189]  run_ksoftirqd+0x70/0x9c\n[    3.749560]  smpboot_thread_fn+0x148/0x22c\n[    3.749978]  kthread+0x10c/0x118\n[    3.750323]  ret_from_fork+0x10/0x20\n[    3.750696] ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2d476c86ba4745fcbc912ce4627df4fa80caa9ad",
      "https://git.kernel.org/stable/c/ab7ca09520e9c41c219a4427fe0dae24024bfe7f"
    ],
    "受影响版本": [
      "4b8736964640fe160724e7135dc62883bddcdace",
      "4b8736964640fe160724e7135dc62883bddcdace"
    ],
    "公开日期": "2024年09月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46783",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp_bpf: fix return value of tcp_bpf_sendmsg()\n\nWhen we cork messages in psock->cork, the last message triggers the\nflushing will result in sending a sk_msg larger than the current\nmessage size. In this case, in tcp_bpf_send_verdict(), 'copied' becomes\nnegative at least in the following case:\n\n468         case __SK_DROP:\n469         default:\n470                 sk_msg_free_partial(sk, msg, tosend);\n471                 sk_msg_apply_bytes(psock, tosend);\n472                 *copied -= (tosend + delta); // <==== HERE\n473                 return -EACCES;\n\nTherefore, it could lead to the following BUG with a proper value of\n'copied' (thanks to syzbot). We should not use negative 'copied' as a\nreturn value here.\n\n  ------------[ cut here ]------------\n  kernel BUG at net/socket.c:733!\n  Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\n  Modules linked in:\n  CPU: 0 UID: 0 PID: 3265 Comm: syz-executor510 Not tainted 6.11.0-rc3-syzkaller-00060-gd07b43284ab3 #0\n  Hardware name: linux,dummy-virt (DT)\n  pstate: 61400009 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)\n  pc : sock_sendmsg_nosec net/socket.c:733 [inline]\n  pc : sock_sendmsg_nosec net/socket.c:728 [inline]\n  pc : __sock_sendmsg+0x5c/0x60 net/socket.c:745\n  lr : sock_sendmsg_nosec net/socket.c:730 [inline]\n  lr : __sock_sendmsg+0x54/0x60 net/socket.c:745\n  sp : ffff800088ea3b30\n  x29: ffff800088ea3b30 x28: fbf00000062bc900 x27: 0000000000000000\n  x26: ffff800088ea3bc0 x25: ffff800088ea3bc0 x24: 0000000000000000\n  x23: f9f00000048dc000 x22: 0000000000000000 x21: ffff800088ea3d90\n  x20: f9f00000048dc000 x19: ffff800088ea3d90 x18: 0000000000000001\n  x17: 0000000000000000 x16: 0000000000000000 x15: 000000002002ffaf\n  x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000\n  x11: 0000000000000000 x10: ffff8000815849c0 x9 : ffff8000815b49c0\n  x8 : 0000000000000000 x7 : 000000000000003f x6 : 0000000000000000\n  x5 : 00000000000007e0 x4 : fff07ffffd239000 x3 : fbf00000062bc900\n  x2 : 0000000000000000 x1 : 0000000000000000 x0 : 00000000fffffdef\n  Call trace:\n   sock_sendmsg_nosec net/socket.c:733 [inline]\n   __sock_sendmsg+0x5c/0x60 net/socket.c:745\n   ____sys_sendmsg+0x274/0x2ac net/socket.c:2597\n   ___sys_sendmsg+0xac/0x100 net/socket.c:2651\n   __sys_sendmsg+0x84/0xe0 net/socket.c:2680\n   __do_sys_sendmsg net/socket.c:2689 [inline]\n   __se_sys_sendmsg net/socket.c:2687 [inline]\n   __arm64_sys_sendmsg+0x24/0x30 net/socket.c:2687\n   __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n   invoke_syscall+0x48/0x110 arch/arm64/kernel/syscall.c:49\n   el0_svc_common.constprop.0+0x40/0xe0 arch/arm64/kernel/syscall.c:132\n   do_el0_svc+0x1c/0x28 arch/arm64/kernel/syscall.c:151\n   el0_svc+0x34/0xec arch/arm64/kernel/entry-common.c:712\n   el0t_64_sync_handler+0x100/0x12c arch/arm64/kernel/entry-common.c:730\n   el0t_64_sync+0x19c/0x1a0 arch/arm64/kernel/entry.S:598\n  Code: f9404463 d63f0060 3108441f 54fffe81 (d4210000)\n  ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6f9fdf5806cced888c43512bccbdf7fefd50f510",
      "https://git.kernel.org/stable/c/3efe53eb221a38e207c1e3f81c51e4ca057d50c2",
      "https://git.kernel.org/stable/c/78bb38d9c5a311c5f8bdef7c9557d7d81ca30e4a",
      "https://git.kernel.org/stable/c/810a4e7d92dea4074cb04c25758320909d752193",
      "https://git.kernel.org/stable/c/c8219a27fa43a2cbf99f5176f6dddfe73e7a24ae",
      "https://git.kernel.org/stable/c/126d72b726c4cf1119f3a7fe413a78d341c3fea9",
      "https://git.kernel.org/stable/c/fe1910f9337bd46a9343967b547ccab26b4b2c6e"
    ],
    "受影响版本": [
      "4f738adba30a7cfc006f605707e7aee847ffefa0",
      "4f738adba30a7cfc006f605707e7aee847ffefa0",
      "4f738adba30a7cfc006f605707e7aee847ffefa0",
      "4f738adba30a7cfc006f605707e7aee847ffefa0",
      "4f738adba30a7cfc006f605707e7aee847ffefa0",
      "4f738adba30a7cfc006f605707e7aee847ffefa0",
      "4f738adba30a7cfc006f605707e7aee847ffefa0"
    ],
    "公开日期": "2024年09月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46782",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nila: call nf_unregister_net_hooks() sooner\n\nsyzbot found an use-after-free Read in ila_nf_input [1]\n\nIssue here is that ila_xlat_exit_net() frees the rhashtable,\nthen call nf_unregister_net_hooks().\n\nIt should be done in the reverse way, with a synchronize_rcu().\n\nThis is a good match for a pre_exit() method.\n\n[1]\n BUG: KASAN: use-after-free in rht_key_hashfn include/linux/rhashtable.h:159 [inline]\n BUG: KASAN: use-after-free in __rhashtable_lookup include/linux/rhashtable.h:604 [inline]\n BUG: KASAN: use-after-free in rhashtable_lookup include/linux/rhashtable.h:646 [inline]\n BUG: KASAN: use-after-free in rhashtable_lookup_fast+0x77a/0x9b0 include/linux/rhashtable.h:672\nRead of size 4 at addr ffff888064620008 by task ksoftirqd/0/16\n\nCPU: 0 UID: 0 PID: 16 Comm: ksoftirqd/0 Not tainted 6.11.0-rc4-syzkaller-00238-g2ad6d23f465a #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nCall Trace:\n <TASK>\n  __dump_stack lib/dump_stack.c:93 [inline]\n  dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n  print_address_description mm/kasan/report.c:377 [inline]\n  print_report+0x169/0x550 mm/kasan/report.c:488\n  kasan_report+0x143/0x180 mm/kasan/report.c:601\n  rht_key_hashfn include/linux/rhashtable.h:159 [inline]\n  __rhashtable_lookup include/linux/rhashtable.h:604 [inline]\n  rhashtable_lookup include/linux/rhashtable.h:646 [inline]\n  rhashtable_lookup_fast+0x77a/0x9b0 include/linux/rhashtable.h:672\n  ila_lookup_wildcards net/ipv6/ila/ila_xlat.c:132 [inline]\n  ila_xlat_addr net/ipv6/ila/ila_xlat.c:652 [inline]\n  ila_nf_input+0x1fe/0x3c0 net/ipv6/ila/ila_xlat.c:190\n  nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]\n  nf_hook_slow+0xc3/0x220 net/netfilter/core.c:626\n  nf_hook include/linux/netfilter.h:269 [inline]\n  NF_HOOK+0x29e/0x450 include/linux/netfilter.h:312\n  __netif_receive_skb_one_core net/core/dev.c:5661 [inline]\n  __netif_receive_skb+0x1ea/0x650 net/core/dev.c:5775\n  process_backlog+0x662/0x15b0 net/core/dev.c:6108\n  __napi_poll+0xcb/0x490 net/core/dev.c:6772\n  napi_poll net/core/dev.c:6841 [inline]\n  net_rx_action+0x89b/0x1240 net/core/dev.c:6963\n  handle_softirqs+0x2c4/0x970 kernel/softirq.c:554\n  run_ksoftirqd+0xca/0x130 kernel/softirq.c:928\n  smpboot_thread_fn+0x544/0xa30 kernel/smpboot.c:164\n  kthread+0x2f0/0x390 kernel/kthread.c:389\n  ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\n\nThe buggy address belongs to the physical page:\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x64620\nflags: 0xfff00000000000(node=0|zone=1|lastcpupid=0x7ff)\npage_type: 0xbfffffff(buddy)\nraw: 00fff00000000000 ffffea0000959608 ffffea00019d9408 0000000000000000\nraw: 0000000000000000 0000000000000003 00000000bfffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as freed\npage last allocated via order 3, migratetype Unmovable, gfp_mask 0x52dc0(GFP_KERNEL|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_ZERO), pid 5242, tgid 5242 (syz-executor), ts 73611328570, free_ts 618981657187\n  set_page_owner include/linux/page_owner.h:32 [inline]\n  post_alloc_hook+0x1f3/0x230 mm/page_alloc.c:1493\n  prep_new_page mm/page_alloc.c:1501 [inline]\n  get_page_from_freelist+0x2e4c/0x2f10 mm/page_alloc.c:3439\n  __alloc_pages_noprof+0x256/0x6c0 mm/page_alloc.c:4695\n  __alloc_pages_node_noprof include/linux/gfp.h:269 [inline]\n  alloc_pages_node_noprof include/linux/gfp.h:296 [inline]\n  ___kmalloc_large_node+0x8b/0x1d0 mm/slub.c:4103\n  __kmalloc_large_node_noprof+0x1a/0x80 mm/slub.c:4130\n  __do_kmalloc_node mm/slub.c:4146 [inline]\n  __kmalloc_node_noprof+0x2d2/0x440 mm/slub.c:4164\n  __kvmalloc_node_noprof+0x72/0x190 mm/util.c:650\n  bucket_table_alloc lib/rhashtable.c:186 [inline]\n  rhashtable_init_noprof+0x534/0xa60 lib/rhashtable.c:1071\n  ila_xlat_init_net+0xa0/0x110 net/ipv6/ila/ila_xlat.c:613\n  ops_ini\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/43d34110882b97ba1ec66cc8234b18983efb9abf",
      "https://git.kernel.org/stable/c/dcaf4e2216824839d26727a15b638c6a677bd9fc",
      "https://git.kernel.org/stable/c/93ee345ba349922834e6a9d1dadabaedcc12dce6",
      "https://git.kernel.org/stable/c/bda4d84ac0d5421b346faee720011f58bdb99673",
      "https://git.kernel.org/stable/c/925c18a7cff93d8a4320d652351294ff7d0ac93c",
      "https://git.kernel.org/stable/c/18a5a16940464b301ea91bf5da3a324aedb347b2",
      "https://git.kernel.org/stable/c/47abd8adddbc0aecb8f231269ef659148d5dabe4",
      "https://git.kernel.org/stable/c/031ae72825cef43e4650140b800ad58bf7a6a466"
    ],
    "受影响版本": [
      "7f00feaf107645d95a6d87e99b4d141ac0a08efd",
      "7f00feaf107645d95a6d87e99b4d141ac0a08efd",
      "7f00feaf107645d95a6d87e99b4d141ac0a08efd",
      "7f00feaf107645d95a6d87e99b4d141ac0a08efd",
      "7f00feaf107645d95a6d87e99b4d141ac0a08efd",
      "7f00feaf107645d95a6d87e99b4d141ac0a08efd",
      "7f00feaf107645d95a6d87e99b4d141ac0a08efd",
      "7f00feaf107645d95a6d87e99b4d141ac0a08efd"
    ],
    "公开日期": "2024年09月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46753",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: handle errors from btrfs_dec_ref() properly\n\nIn walk_up_proc() we BUG_ON(ret) from btrfs_dec_ref().  This is\nincorrect, we have proper error handling here, return the error.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0e4840ae09f375381167000ce47424818fcbcc7c",
      "https://git.kernel.org/stable/c/2c4fe45351e544da4b8f10c74b277117a4fa7869",
      "https://git.kernel.org/stable/c/9c8237021b53d52357c0de07a768582fafb2791d",
      "https://git.kernel.org/stable/c/67e4ca7ddc67ef949326b4dc404a9678bbe67d72",
      "https://git.kernel.org/stable/c/a7f16a7a709845855cb5a0e080a52bda5873f9de",
      "https://git.kernel.org/stable/c/5eb178f373b4f16f3b42d55ff88fc94dd95b93b1"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年09月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46734",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix race between direct IO write and fsync when using same fd\n\nIf we have 2 threads that are using the same file descriptor and one of\nthem is doing direct IO writes while the other is doing fsync, we have a\nrace where we can end up either:\n\n1) Attempt a fsync without holding the inode's lock, triggering an\n   assertion failures when assertions are enabled;\n\n2) Do an invalid memory access from the fsync task because the file private\n   points to memory allocated on stack by the direct IO task and it may be\n   used by the fsync task after the stack was destroyed.\n\nThe race happens like this:\n\n1) A user space program opens a file descriptor with O_DIRECT;\n\n2) The program spawns 2 threads using libpthread for example;\n\n3) One of the threads uses the file descriptor to do direct IO writes,\n   while the other calls fsync using the same file descriptor.\n\n4) Call task A the thread doing direct IO writes and task B the thread\n   doing fsyncs;\n\n5) Task A does a direct IO write, and at btrfs_direct_write() sets the\n   file's private to an on stack allocated private with the member\n   'fsync_skip_inode_lock' set to true;\n\n6) Task B enters btrfs_sync_file() and sees that there's a private\n   structure associated to the file which has 'fsync_skip_inode_lock' set\n   to true, so it skips locking the inode's VFS lock;\n\n7) Task A completes the direct IO write, and resets the file's private to\n   NULL since it had no prior private and our private was stack allocated.\n   Then it unlocks the inode's VFS lock;\n\n8) Task B enters btrfs_get_ordered_extents_for_logging(), then the\n   assertion that checks the inode's VFS lock is held fails, since task B\n   never locked it and task A has already unlocked it.\n\nThe stack trace produced is the following:\n\n   assertion failed: inode_is_locked(&inode->vfs_inode), in fs/btrfs/ordered-data.c:983\n   ------------[ cut here ]------------\n   kernel BUG at fs/btrfs/ordered-data.c:983!\n   Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI\n   CPU: 9 PID: 5072 Comm: worker Tainted: G     U     OE      6.10.5-1-default #1 openSUSE Tumbleweed 69f48d427608e1c09e60ea24c6c55e2ca1b049e8\n   Hardware name: Acer Predator PH315-52/Covini_CFS, BIOS V1.12 07/28/2020\n   RIP: 0010:btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs]\n   Code: 50 d6 86 c0 e8 (...)\n   RSP: 0018:ffff9e4a03dcfc78 EFLAGS: 00010246\n   RAX: 0000000000000054 RBX: ffff9078a9868e98 RCX: 0000000000000000\n   RDX: 0000000000000000 RSI: ffff907dce4a7800 RDI: ffff907dce4a7800\n   RBP: ffff907805518800 R08: 0000000000000000 R09: ffff9e4a03dcfb38\n   R10: ffff9e4a03dcfb30 R11: 0000000000000003 R12: ffff907684ae7800\n   R13: 0000000000000001 R14: ffff90774646b600 R15: 0000000000000000\n   FS:  00007f04b96006c0(0000) GS:ffff907dce480000(0000) knlGS:0000000000000000\n   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n   CR2: 00007f32acbfc000 CR3: 00000001fd4fa005 CR4: 00000000003726f0\n   Call Trace:\n    <TASK>\n    ? __die_body.cold+0x14/0x24\n    ? die+0x2e/0x50\n    ? do_trap+0xca/0x110\n    ? do_error_trap+0x6a/0x90\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? exc_invalid_op+0x50/0x70\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? asm_exc_invalid_op+0x1a/0x20\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    btrfs_sync_file+0x21a/0x4d0 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? __seccomp_filter+0x31d/0x4f0\n    __x64_sys_fdatasync+0x4f/0x90\n    do_syscall_64+0x82/0x160\n    ? do_futex+0xcb/0x190\n    ? __x64_sys_futex+0x10e/0x1d0\n    ? switch_fpu_return+0x4f/0xd0\n    ? syscall_exit_to_user_mode+0x72/0x220\n    ? do_syscall_64+0x8e/0x160\n    ? syscall_exit_to_user_mod\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d116a0b0e02f395cedfb8c725bd67480aa7c428c",
      "https://git.kernel.org/stable/c/cd3087582e4fa36e89be4e6f859e75a4400292b4",
      "https://git.kernel.org/stable/c/7b5595f33c3c273613b590892a578d78186bb400",
      "https://git.kernel.org/stable/c/01681aa609b5f110502f56c4e3b2938efcf4a5bc",
      "https://git.kernel.org/stable/c/cd9253c23aedd61eb5ff11f37a36247cd46faf86"
    ],
    "受影响版本": [
      "4e17707035a65f6e5b2a4d987a308cf8ed8c5ad1",
      "6cae8d04d8b3d1ecfadcaa989e673f6f73349ed5",
      "0a108bde616a7017653385b5a12111015051a294",
      "3831170f740685fddc8f6aa57a83ad0fef4711bf",
      "939b656bc8ab203fdbde26ccac22bcb7f0985be5"
    ],
    "公开日期": "2024年09月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-46733",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix qgroup reserve leaks in cow_file_range\n\nIn the buffered write path, the dirty page owns the qgroup reserve until\nit creates an ordered_extent.\n\nTherefore, any errors that occur before the ordered_extent is created\nmust free that reservation, or else the space is leaked. The fstest\ngeneric/475 exercises various IO error paths, and is able to trigger\nerrors in cow_file_range where we fail to get to allocating the ordered\nextent. Note that because we *do* clear delalloc, we are likely to\nremove the inode from the delalloc list, so the inodes/pages to not have\ninvalidate/launder called on them in the commit abort path.\n\nThis results in failures at the unmount stage of the test that look like:\n\n  BTRFS: error (device dm-8 state EA) in cleanup_transaction:2018: errno=-5 IO failure\n  BTRFS: error (device dm-8 state EA) in btrfs_replace_file_extents:2416: errno=-5 IO failure\n  BTRFS warning (device dm-8 state EA): qgroup 0/5 has unreleased space, type 0 rsv 28672\n  ------------[ cut here ]------------\n  WARNING: CPU: 3 PID: 22588 at fs/btrfs/disk-io.c:4333 close_ctree+0x222/0x4d0 [btrfs]\n  Modules linked in: btrfs blake2b_generic libcrc32c xor zstd_compress raid6_pq\n  CPU: 3 PID: 22588 Comm: umount Kdump: loaded Tainted: G W          6.10.0-rc7-gab56fde445b8 #21\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014\n  RIP: 0010:close_ctree+0x222/0x4d0 [btrfs]\n  RSP: 0018:ffffb4465283be00 EFLAGS: 00010202\n  RAX: 0000000000000001 RBX: ffffa1a1818e1000 RCX: 0000000000000001\n  RDX: 0000000000000000 RSI: ffffb4465283bbe0 RDI: ffffa1a19374fcb8\n  RBP: ffffa1a1818e13c0 R08: 0000000100028b16 R09: 0000000000000000\n  R10: 0000000000000003 R11: 0000000000000003 R12: ffffa1a18ad7972c\n  R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n  FS:  00007f9168312b80(0000) GS:ffffa1a4afcc0000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f91683c9140 CR3: 000000010acaa000 CR4: 00000000000006f0\n  Call Trace:\n   <TASK>\n   ? close_ctree+0x222/0x4d0 [btrfs]\n   ? __warn.cold+0x8e/0xea\n   ? close_ctree+0x222/0x4d0 [btrfs]\n   ? report_bug+0xff/0x140\n   ? handle_bug+0x3b/0x70\n   ? exc_invalid_op+0x17/0x70\n   ? asm_exc_invalid_op+0x1a/0x20\n   ? close_ctree+0x222/0x4d0 [btrfs]\n   generic_shutdown_super+0x70/0x160\n   kill_anon_super+0x11/0x40\n   btrfs_kill_super+0x11/0x20 [btrfs]\n   deactivate_locked_super+0x2e/0xa0\n   cleanup_mnt+0xb5/0x150\n   task_work_run+0x57/0x80\n   syscall_exit_to_user_mode+0x121/0x130\n   do_syscall_64+0xab/0x1a0\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f\n  RIP: 0033:0x7f916847a887\n  ---[ end trace 0000000000000000 ]---\n  BTRFS error (device dm-8 state EA): qgroup reserved space leaked\n\nCases 2 and 3 in the out_reserve path both pertain to this type of leak\nand must free the reserved qgroup data. Because it is already an error\npath, I opted not to handle the possible errors in\nbtrfs_free_qgroup_data.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/159f0f61b283ea71e827dd0c18c5dce197de1fa2",
      "https://git.kernel.org/stable/c/84464db2ec2a55b9313d5f264da196a37ec80994",
      "https://git.kernel.org/stable/c/e42ef22bc10f0309c0c65d8d6ca8b4127a674b7f",
      "https://git.kernel.org/stable/c/30479f31d44d47ed00ae0c7453d9b253537005b2"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年09月18日"
  },
  {
    "设备品牌": "Xen",
    "设备类型": "OTA",
    "产品型号": "Xen",
    "CVE编号": "CVE-2024-45818",
    "漏洞描述": "The hypervisor contains code to accelerate VGA memory accesses for HVM\nguests, when the (virtual) VGA is in \"standard\" mode.  Locking involved\nthere has an unusual discipline, leaving a lock acquired past the\nreturn from the function that acquired it.  This behavior results in a\nproblem when emulating an instruction with two memory accesses, both of\nwhich touch VGA memory (plus some further constraints which aren't\nrelevant here).  When emulating the 2nd access, the lock that is already\nbeing held would be attempted to be re-acquired, resulting in a\ndeadlock.\n\nThis deadlock was already found when the code was first introduced, but\nwas analysed incorrectly and the fix was incomplete.  Analysis in light\nof the new finding cannot find a way to make the existing locking\ndiscipline work.\n\nIn staging, this logic has all been removed because it was discovered\nto be accidentally disabled since Xen 4.7.  Therefore, we are fixing the\nlocking problem by backporting the removal of most of the feature.  Note\nthat even with the feature disabled, the lock would still be acquired\nfor any accesses to the VGA MMIO region.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://xenbits.xenproject.org/xsa/advisory-463.html"
    ],
    "受影响版本": [
      "consult Xen advisory XSA-463"
    ],
    "公开日期": "2024年12月19日"
  },
  {
    "设备品牌": "matter-labs",
    "设备类型": "OTA",
    "产品型号": "era-compiler-solidity",
    "CVE编号": "CVE-2024-45056",
    "漏洞描述": "zksolc is a Solidity compiler for ZKsync. All LLVM versions since 2015 fold `(xor (shl 1, x), -1)` to `(rotl ~1, x)` if run with optimizations enabled. Here `~1` is generated as an unsigned 64 bits number (`2^64-1`). This number is zero-extended to 256 bits on EraVM target while it should have been sign-extended. Thus instead of producing `roti 2^256 - 1, x` the compiler produces `rotl 2^64 - 1, x`. Analysis has shown that no contracts were affected by the date of publishing this advisory. This issue has been addressed in version 1.5.3. Users are advised to upgrade and redeploy all contracts. There are no known workarounds for this vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/matter-labs/era-compiler-solidity/security/advisories/GHSA-fpx7-8vc6-frjj",
      "https://github.com/llvm/llvm-project/commit/e48237df95b49a36b8ffceb78c8a58f4be1b4344"
    ],
    "受影响版本": [
      "< 1.5.3"
    ],
    "公开日期": "2024年08月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-45024",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/hugetlb: fix hugetlb vs. core-mm PT locking\n\nWe recently made GUP's common page table walking code to also walk hugetlb\nVMAs without most hugetlb special-casing, preparing for the future of\nhaving less hugetlb-specific page table walking code in the codebase. \nTurns out that we missed one page table locking detail: page table locking\nfor hugetlb folios that are not mapped using a single PMD/PUD.\n\nAssume we have hugetlb folio that spans multiple PTEs (e.g., 64 KiB\nhugetlb folios on arm64 with 4 KiB base page size).  GUP, as it walks the\npage tables, will perform a pte_offset_map_lock() to grab the PTE table\nlock.\n\nHowever, hugetlb that concurrently modifies these page tables would\nactually grab the mm->page_table_lock: with USE_SPLIT_PTE_PTLOCKS, the\nlocks would differ.  Something similar can happen right now with hugetlb\nfolios that span multiple PMDs when USE_SPLIT_PMD_PTLOCKS.\n\nThis issue can be reproduced [1], for example triggering:\n\n[ 3105.936100] ------------[ cut here ]------------\n[ 3105.939323] WARNING: CPU: 31 PID: 2732 at mm/gup.c:142 try_grab_folio+0x11c/0x188\n[ 3105.944634] Modules linked in: [...]\n[ 3105.974841] CPU: 31 PID: 2732 Comm: reproducer Not tainted 6.10.0-64.eln141.aarch64 #1\n[ 3105.980406] Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-4.fc40 05/24/2024\n[ 3105.986185] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[ 3105.991108] pc : try_grab_folio+0x11c/0x188\n[ 3105.994013] lr : follow_page_pte+0xd8/0x430\n[ 3105.996986] sp : ffff80008eafb8f0\n[ 3105.999346] x29: ffff80008eafb900 x28: ffffffe8d481f380 x27: 00f80001207cff43\n[ 3106.004414] x26: 0000000000000001 x25: 0000000000000000 x24: ffff80008eafba48\n[ 3106.009520] x23: 0000ffff9372f000 x22: ffff7a54459e2000 x21: ffff7a546c1aa978\n[ 3106.014529] x20: ffffffe8d481f3c0 x19: 0000000000610041 x18: 0000000000000001\n[ 3106.019506] x17: 0000000000000001 x16: ffffffffffffffff x15: 0000000000000000\n[ 3106.024494] x14: ffffb85477fdfe08 x13: 0000ffff9372ffff x12: 0000000000000000\n[ 3106.029469] x11: 1fffef4a88a96be1 x10: ffff7a54454b5f0c x9 : ffffb854771b12f0\n[ 3106.034324] x8 : 0008000000000000 x7 : ffff7a546c1aa980 x6 : 0008000000000080\n[ 3106.038902] x5 : 00000000001207cf x4 : 0000ffff9372f000 x3 : ffffffe8d481f000\n[ 3106.043420] x2 : 0000000000610041 x1 : 0000000000000001 x0 : 0000000000000000\n[ 3106.047957] Call trace:\n[ 3106.049522]  try_grab_folio+0x11c/0x188\n[ 3106.051996]  follow_pmd_mask.constprop.0.isra.0+0x150/0x2e0\n[ 3106.055527]  follow_page_mask+0x1a0/0x2b8\n[ 3106.058118]  __get_user_pages+0xf0/0x348\n[ 3106.060647]  faultin_page_range+0xb0/0x360\n[ 3106.063651]  do_madvise+0x340/0x598\n\nLet's make huge_pte_lockptr() effectively use the same PT locks as any\ncore-mm page table walker would.  Add ptep_lockptr() to obtain the PTE\npage table lock using a pte pointer -- unfortunately we cannot convert\npte_lockptr() because virt_to_page() doesn't work with kmap'ed page tables\nwe can have with CONFIG_HIGHPTE.\n\nHandle CONFIG_PGTABLE_LEVELS correctly by checking in reverse order, such\nthat when e.g., CONFIG_PGTABLE_LEVELS==2 with\nPGDIR_SIZE==P4D_SIZE==PUD_SIZE==PMD_SIZE will work as expected.  Document\nwhy that works.\n\nThere is one ugly case: powerpc 8xx, whereby we have an 8 MiB hugetlb\nfolio being mapped using two PTE page tables.  While hugetlb wants to take\nthe PMD table lock, core-mm would grab the PTE table lock of one of both\nPTE page tables.  In such corner cases, we have to make sure that both\nlocks match, which is (fortunately!) currently guaranteed for 8xx as it\ndoes not support SMP and consequently doesn't use split PT locks.\n\n[1] https://lore.kernel.org/all/1bbfcc7f-f222-45a5-ac44-c5a1381c596d@redhat.com/",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7300dadba49e531af2d890ae4e34c9b115384a62",
      "https://git.kernel.org/stable/c/5f75cfbd6bb02295ddaed48adf667b6c828ce07b"
    ],
    "受影响版本": [
      "9cb28da54643ad464c47585cd5866c30b0218e67",
      "9cb28da54643ad464c47585cd5866c30b0218e67"
    ],
    "公开日期": "2024年09月11日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-45022",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/vmalloc: fix page mapping if vm_area_alloc_pages() with high order fallback to order 0\n\nThe __vmap_pages_range_noflush() assumes its argument pages** contains\npages with the same page shift.  However, since commit e9c3cda4d86e (\"mm,\nvmalloc: fix high order __GFP_NOFAIL allocations\"), if gfp_flags includes\n__GFP_NOFAIL with high order in vm_area_alloc_pages() and page allocation\nfailed for high order, the pages** may contain two different page shifts\n(high order and order-0).  This could lead __vmap_pages_range_noflush() to\nperform incorrect mappings, potentially resulting in memory corruption.\n\nUsers might encounter this as follows (vmap_allow_huge = true, 2M is for\nPMD_SIZE):\n\nkvmalloc(2M, __GFP_NOFAIL|GFP_X)\n    __vmalloc_node_range_noprof(vm_flags=VM_ALLOW_HUGE_VMAP)\n        vm_area_alloc_pages(order=9) ---> order-9 allocation failed and fallback to order-0\n            vmap_pages_range()\n                vmap_pages_range_noflush()\n                    __vmap_pages_range_noflush(page_shift = 21) ----> wrong mapping happens\n\nWe can remove the fallback code because if a high-order allocation fails,\n__vmalloc_node_range_noprof() will retry with order-0.  Therefore, it is\nunnecessary to fallback to order-0 here.  Therefore, fix this by removing\nthe fallback code.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fd1ffbb50ef4da5e1378a46616b6d7407dc795da",
      "https://git.kernel.org/stable/c/de7bad86345c43cd040ed43e20d9fad78a3ee59f",
      "https://git.kernel.org/stable/c/c91618816f4d21fc574d7577a37722adcd4075b2",
      "https://git.kernel.org/stable/c/61ebe5a747da649057c37be1c37eb934b4af79ca"
    ],
    "受影响版本": [
      "fe5c2bdcb14c8612eb5e7a09159801c7219e9ac4",
      "e9c3cda4d86e56bf7fe403729f38c4f0f65d3860",
      "e9c3cda4d86e56bf7fe403729f38c4f0f65d3860",
      "e9c3cda4d86e56bf7fe403729f38c4f0f65d3860"
    ],
    "公开日期": "2024年09月11日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-45010",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: pm: only mark 'subflow' endp as available\n\nAdding the following warning ...\n\n  WARN_ON_ONCE(msk->pm.local_addr_used == 0)\n\n... before decrementing the local_addr_used counter helped to find a bug\nwhen running the \"remove single address\" subtest from the mptcp_join.sh\nselftests.\n\nRemoving a 'signal' endpoint will trigger the removal of all subflows\nlinked to this endpoint via mptcp_pm_nl_rm_addr_or_subflow() with\nrm_type == MPTCP_MIB_RMSUBFLOW. This will decrement the local_addr_used\ncounter, which is wrong in this case because this counter is linked to\n'subflow' endpoints, and here it is a 'signal' endpoint that is being\nremoved.\n\nNow, the counter is decremented, only if the ID is being used outside\nof mptcp_pm_nl_rm_addr_or_subflow(), only for 'subflow' endpoints, and\nif the ID is not 0 -- local_addr_used is not taking into account these\nones. This marking of the ID as being available, and the decrement is\ndone no matter if a subflow using this ID is currently available,\nbecause the subflow could have been closed before.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7fdc870d08960961408a44c569f20f50940e7d4f",
      "https://git.kernel.org/stable/c/43cf912b0b0fc7b4fd12cbc735d1f5afb8e1322d",
      "https://git.kernel.org/stable/c/9849cfc67383ceb167155186f8f8fe8a896b60b3",
      "https://git.kernel.org/stable/c/322ea3778965da72862cca2a0c50253aacf65fe6"
    ],
    "受影响版本": [
      "06faa22710342bca5e9c249634199c650799fce6",
      "06faa22710342bca5e9c249634199c650799fce6",
      "06faa22710342bca5e9c249634199c650799fce6",
      "06faa22710342bca5e9c249634199c650799fce6"
    ],
    "公开日期": "2024年09月11日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-45006",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nxhci: Fix Panther point NULL pointer deref at full-speed re-enumeration\n\nre-enumerating full-speed devices after a failed address device command\ncan trigger a NULL pointer dereference.\n\nFull-speed devices may need to reconfigure the endpoint 0 Max Packet Size\nvalue during enumeration. Usb core calls usb_ep0_reinit() in this case,\nwhich ends up calling xhci_configure_endpoint().\n\nOn Panther point xHC the xhci_configure_endpoint() function will\nadditionally check and reserve bandwidth in software. Other hosts do\nthis in hardware\n\nIf xHC address device command fails then a new xhci_virt_device structure\nis allocated as part of re-enabling the slot, but the bandwidth table\npointers are not set up properly here.\nThis triggers the NULL pointer dereference the next time usb_ep0_reinit()\nis called and xhci_configure_endpoint() tries to check and reserve\nbandwidth\n\n[46710.713538] usb 3-1: new full-speed USB device number 5 using xhci_hcd\n[46710.713699] usb 3-1: Device not responding to setup address.\n[46710.917684] usb 3-1: Device not responding to setup address.\n[46711.125536] usb 3-1: device not accepting address 5, error -71\n[46711.125594] BUG: kernel NULL pointer dereference, address: 0000000000000008\n[46711.125600] #PF: supervisor read access in kernel mode\n[46711.125603] #PF: error_code(0x0000) - not-present page\n[46711.125606] PGD 0 P4D 0\n[46711.125610] Oops: Oops: 0000 [#1] PREEMPT SMP PTI\n[46711.125615] CPU: 1 PID: 25760 Comm: kworker/1:2 Not tainted 6.10.3_2 #1\n[46711.125620] Hardware name: Gigabyte Technology Co., Ltd.\n[46711.125623] Workqueue: usb_hub_wq hub_event [usbcore]\n[46711.125668] RIP: 0010:xhci_reserve_bandwidth (drivers/usb/host/xhci.c\n\nFix this by making sure bandwidth table pointers are set up correctly\nafter a failed address device command, and additionally by avoiding\nchecking for bandwidth in cases like this where no actual endpoints are\nadded or removed, i.e. only context for default control endpoint 0 is\nevaluated.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ef0a0e616b2789bb804a0ce5e161db03170a85b6",
      "https://git.kernel.org/stable/c/a57b0ebabe6862dce0a2e0f13e17941ad72fc56b",
      "https://git.kernel.org/stable/c/0f0654318e25b2c185e245ba4a591e42fabb5e59",
      "https://git.kernel.org/stable/c/365ef7c4277fdd781a695c3553fa157d622d805d",
      "https://git.kernel.org/stable/c/5ad898ae82412f8a689d59829804bff2999dd0ea",
      "https://git.kernel.org/stable/c/6b99de301d78e1f5249e57ef2c32e1dec3df2bb1",
      "https://git.kernel.org/stable/c/8fb9d412ebe2f245f13481e4624b40e651570cbd",
      "https://git.kernel.org/stable/c/af8e119f52e9c13e556be9e03f27957554a84656"
    ],
    "受影响版本": [
      "651aaf36a7d7b36a58980e70133f9437d4f6d312",
      "651aaf36a7d7b36a58980e70133f9437d4f6d312",
      "651aaf36a7d7b36a58980e70133f9437d4f6d312",
      "651aaf36a7d7b36a58980e70133f9437d4f6d312",
      "651aaf36a7d7b36a58980e70133f9437d4f6d312",
      "651aaf36a7d7b36a58980e70133f9437d4f6d312",
      "651aaf36a7d7b36a58980e70133f9437d4f6d312",
      "651aaf36a7d7b36a58980e70133f9437d4f6d312"
    ],
    "公开日期": "2024年09月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-44979",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe: Fix missing workqueue destroy in xe_gt_pagefault\n\nOn driver reload we never free up the memory for the pagefault and\naccess counter workqueues. Add those destroy calls here.\n\n(cherry picked from commit 7586fc52b14e0b8edd0d1f8a434e0de2078b7b2b)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b09ef3b762a7fc641fb2f89afd3ebdb65b8ba1b9",
      "https://git.kernel.org/stable/c/a6f78359ac75f24cac3c1bdd753c49c1877bcd82"
    ],
    "受影响版本": [
      "dd08ebf6c3525a7ea2186e636df064ea47281987",
      "dd08ebf6c3525a7ea2186e636df064ea47281987"
    ],
    "公开日期": "2024年09月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-44972",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: do not clear page dirty inside extent_write_locked_range()\n\n[BUG]\nFor subpage + zoned case, the following workload can lead to rsv data\nleak at unmount time:\n\n  # mkfs.btrfs -f -s 4k $dev\n  # mount $dev $mnt\n  # fsstress -w -n 8 -d $mnt -s 1709539240\n  0/0: fiemap - no filename\n  0/1: copyrange read - no filename\n  0/2: write - no filename\n  0/3: rename - no source filename\n  0/4: creat f0 x:0 0 0\n  0/4: creat add id=0,parent=-1\n  0/5: writev f0[259 1 0 0 0 0] [778052,113,965] 0\n  0/6: ioctl(FIEMAP) f0[259 1 0 0 224 887097] [1294220,2291618343991484791,0x10000] -1\n  0/7: dwrite - xfsctl(XFS_IOC_DIOINFO) f0[259 1 0 0 224 887097] return 25, fallback to stat()\n  0/7: dwrite f0[259 1 0 0 224 887097] [696320,102400] 0\n  # umount $mnt\n\nThe dmesg includes the following rsv leak detection warning (all call\ntrace skipped):\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8653 btrfs_destroy_inode+0x1e0/0x200 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  ------------[ cut here ]------------\n  WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8654 btrfs_destroy_inode+0x1a8/0x200 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  ------------[ cut here ]------------\n  WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8660 btrfs_destroy_inode+0x1a0/0x200 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  BTRFS info (device sda): last unmount of filesystem 1b4abba9-de34-4f07-9e7f-157cf12a18d6\n  ------------[ cut here ]------------\n  WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  BTRFS info (device sda): space_info DATA has 268218368 free, is not full\n  BTRFS info (device sda): space_info total=268435456, used=204800, pinned=0, reserved=0, may_use=12288, readonly=0 zone_unusable=0\n  BTRFS info (device sda): global_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): trans_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0\n  ------------[ cut here ]------------\n  WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs]\n  ---[ end trace 0000000000000000 ]---\n  BTRFS info (device sda): space_info METADATA has 267796480 free, is not full\n  BTRFS info (device sda): space_info total=268435456, used=131072, pinned=0, reserved=0, may_use=262144, readonly=0 zone_unusable=245760\n  BTRFS info (device sda): global_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): trans_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0\n  BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0\n\nAbove $dev is a tcmu-runner emulated zoned HDD, which has a max zone\nappend size of 64K, and the system has 64K page size.\n\n[CAUSE]\nI have added several trace_printk() to show the events (header skipped):\n\n  > btrfs_dirty_pages: r/i=5/259 dirty start=774144 len=114688\n  > btrfs_dirty_pages: r/i=5/259 dirty part of page=720896 off_in_page=53248 len_in_page=12288\n  > btrfs_dirty_pages: r/i=5/259 dirty part of page=786432 off_in_page=0 len_in_page=65536\n  > btrfs_dirty_pages: r/i=5/259 dirty part of page=851968 off_in_page=0 len_in_page=36864\n\nThe above lines show our buffered write has dirtied 3 pages of inode\n259 of root 5:\n\n  704K             768K              832K              896K\n  I           |////I/////////////////I///////////|     I\n              756K                               868K\n\n  |///| is the dirtied range using subpage bitmaps. and 'I' is the page\n  boundary.\n\n  Meanwhile all three pages (704K, 768K, 832K) have their PageDirty\n  flag set.\n\n  > btrfs_direct_write: r/i=5/259 start dio filepos=696320 len=102400\n\nThen direct IO writ\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ba4dedb71356638d8284e34724daca944be70368",
      "https://git.kernel.org/stable/c/d3b403209f767e5857c1b9fda66726e6e6ffc99f",
      "https://git.kernel.org/stable/c/97713b1a2ced1e4a2a6c40045903797ebd44d7e0"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年09月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-44964",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nidpf: fix memory leaks and crashes while performing a soft reset\n\nThe second tagged commit introduced a UAF, as it removed restoring\nq_vector->vport pointers after reinitializating the structures.\nThis is due to that all queue allocation functions are performed here\nwith the new temporary vport structure and those functions rewrite\nthe backpointers to the vport. Then, this new struct is freed and\nthe pointers start leading to nowhere.\n\nBut generally speaking, the current logic is very fragile. It claims\nto be more reliable when the system is low on memory, but in fact, it\nconsumes two times more memory as at the moment of running this\nfunction, there are two vports allocated with their queues and vectors.\nMoreover, it claims to prevent the driver from running into \"bad state\",\nbut in fact, any error during the rebuild leaves the old vport in the\npartially allocated state.\nFinally, if the interface is down when the function is called, it always\nallocates a new queue set, but when the user decides to enable the\ninterface later on, vport_open() allocates them once again, IOW there's\na clear memory leak here.\n\nJust don't allocate a new queue set when performing a reset, that solves\ncrashes and memory leaks. Readd the old queue number and reopen the\ninterface on rollback - that solves limbo states when the device is left\ndisabled and/or without HW queues enabled.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6b289f8d91537ec1e4f9c7b38b31b90d93b1419b",
      "https://git.kernel.org/stable/c/f01032a2ca099ec8d619aaa916c3762aa62495df"
    ],
    "受影响版本": [
      "02cbfba1add5bd9088c7d14c6b93b77a6ea8f3bb",
      "02cbfba1add5bd9088c7d14c6b93b77a6ea8f3bb"
    ],
    "公开日期": "2024年09月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-44959",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracefs: Use generic inode RCU for synchronizing freeing\n\nWith structure layout randomization enabled for 'struct inode' we need to\navoid overlapping any of the RCU-used / initialized-only-once members,\ne.g. i_lru or i_sb_list to not corrupt related list traversals when making\nuse of the rcu_head.\n\nFor an unlucky structure layout of 'struct inode' we may end up with the\nfollowing splat when running the ftrace selftests:\n\n[<...>] list_del corruption, ffff888103ee2cb0->next (tracefs_inode_cache+0x0/0x4e0 [slab object]) is NULL (prev is tracefs_inode_cache+0x78/0x4e0 [slab object])\n[<...>] ------------[ cut here ]------------\n[<...>] kernel BUG at lib/list_debug.c:54!\n[<...>] invalid opcode: 0000 [#1] PREEMPT SMP KASAN\n[<...>] CPU: 3 PID: 2550 Comm: mount Tainted: G                 N  6.8.12-grsec+ #122 ed2f536ca62f28b087b90e3cc906a8d25b3ddc65\n[<...>] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014\n[<...>] RIP: 0010:[<ffffffff84656018>] __list_del_entry_valid_or_report+0x138/0x3e0\n[<...>] Code: 48 b8 99 fb 65 f2 ff ff ff ff e9 03 5c d9 fc cc 48 b8 99 fb 65 f2 ff ff ff ff e9 33 5a d9 fc cc 48 b8 99 fb 65 f2 ff ff ff ff <0f> 0b 4c 89 e9 48 89 ea 48 89 ee 48 c7 c7 60 8f dd 89 31 c0 e8 2f\n[<...>] RSP: 0018:fffffe80416afaf0 EFLAGS: 00010283\n[<...>] RAX: 0000000000000098 RBX: ffff888103ee2cb0 RCX: 0000000000000000\n[<...>] RDX: ffffffff84655fe8 RSI: ffffffff89dd8b60 RDI: 0000000000000001\n[<...>] RBP: ffff888103ee2cb0 R08: 0000000000000001 R09: fffffbd0082d5f25\n[<...>] R10: fffffe80416af92f R11: 0000000000000001 R12: fdf99c16731d9b6d\n[<...>] R13: 0000000000000000 R14: ffff88819ad4b8b8 R15: 0000000000000000\n[<...>] RBX: tracefs_inode_cache+0x0/0x4e0 [slab object]\n[<...>] RDX: __list_del_entry_valid_or_report+0x108/0x3e0\n[<...>] RSI: __func__.47+0x4340/0x4400\n[<...>] RBP: tracefs_inode_cache+0x0/0x4e0 [slab object]\n[<...>] RSP: process kstack fffffe80416afaf0+0x7af0/0x8000 [mount 2550 2550]\n[<...>] R09: kasan shadow of process kstack fffffe80416af928+0x7928/0x8000 [mount 2550 2550]\n[<...>] R10: process kstack fffffe80416af92f+0x792f/0x8000 [mount 2550 2550]\n[<...>] R14: tracefs_inode_cache+0x78/0x4e0 [slab object]\n[<...>] FS:  00006dcb380c1840(0000) GS:ffff8881e0600000(0000) knlGS:0000000000000000\n[<...>] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[<...>] CR2: 000076ab72b30e84 CR3: 000000000b088004 CR4: 0000000000360ef0 shadow CR4: 0000000000360ef0\n[<...>] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[<...>] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[<...>] ASID: 0003\n[<...>] Stack:\n[<...>]  ffffffff818a2315 00000000f5c856ee ffffffff896f1840 ffff888103ee2cb0\n[<...>]  ffff88812b6b9750 0000000079d714b6 fffffbfff1e9280b ffffffff8f49405f\n[<...>]  0000000000000001 0000000000000000 ffff888104457280 ffffffff8248b392\n[<...>] Call Trace:\n[<...>]  <TASK>\n[<...>]  [<ffffffff818a2315>] ? lock_release+0x175/0x380 fffffe80416afaf0\n[<...>]  [<ffffffff8248b392>] list_lru_del+0x152/0x740 fffffe80416afb48\n[<...>]  [<ffffffff8248ba93>] list_lru_del_obj+0x113/0x280 fffffe80416afb88\n[<...>]  [<ffffffff8940fd19>] ? _atomic_dec_and_lock+0x119/0x200 fffffe80416afb90\n[<...>]  [<ffffffff8295b244>] iput_final+0x1c4/0x9a0 fffffe80416afbb8\n[<...>]  [<ffffffff8293a52b>] dentry_unlink_inode+0x44b/0xaa0 fffffe80416afbf8\n[<...>]  [<ffffffff8293fefc>] __dentry_kill+0x23c/0xf00 fffffe80416afc40\n[<...>]  [<ffffffff8953a85f>] ? __this_cpu_preempt_check+0x1f/0xa0 fffffe80416afc48\n[<...>]  [<ffffffff82949ce5>] ? shrink_dentry_list+0x1c5/0x760 fffffe80416afc70\n[<...>]  [<ffffffff82949b71>] ? shrink_dentry_list+0x51/0x760 fffffe80416afc78\n[<...>]  [<ffffffff82949da8>] shrink_dentry_list+0x288/0x760 fffffe80416afc80\n[<...>]  [<ffffffff8294ae75>] shrink_dcache_sb+0x155/0x420 fffffe80416afcc8\n[<...>]  [<ffffffff8953a7c3>] ? debug_smp_processor_id+0x23/0xa0 fffffe80416afce0\n[<...>]  [<ffffffff8294ad20>] ? do_one_tre\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/726f4c241e17be75a9cf6870d80cd7479dc89e8f",
      "https://git.kernel.org/stable/c/061da60716ce0cde99f62f31937b81e1c03acef6",
      "https://git.kernel.org/stable/c/0b6743bd60a56a701070b89fb80c327a44b7b3e2"
    ],
    "受影响版本": [
      "5f91fc82794d4a6e41cdcd02d00baa377d94ca78",
      "baa23a8d4360d981a49913841a726edede5cdd54",
      "baa23a8d4360d981a49913841a726edede5cdd54",
      "414fb08628143203d29ccd0264b5a83fb9523c03"
    ],
    "公开日期": "2024年09月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-44957",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nxen: privcmd: Switch from mutex to spinlock for irqfds\n\nirqfd_wakeup() gets EPOLLHUP, when it is called by\neventfd_release() by way of wake_up_poll(&ctx->wqh, EPOLLHUP), which\ngets called under spin_lock_irqsave(). We can't use a mutex here as it\nwill lead to a deadlock.\n\nFix it by switching over to a spin lock.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c2775ae4d9227729f8ca9ee2a068f62a00d5ea9c",
      "https://git.kernel.org/stable/c/49f2a5da6785b2dbde93e291cae037662440346e",
      "https://git.kernel.org/stable/c/1c682593096a487fd9aebc079a307ff7a6d054a3"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年09月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-44954",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: line6: Fix racy access to midibuf\n\nThere can be concurrent accesses to line6 midibuf from both the URB\ncompletion callback and the rawmidi API access.  This could be a cause\nof KMSAN warning triggered by syzkaller below (so put as reported-by\nhere).\n\nThis patch protects the midibuf call of the former code path with a\nspinlock for avoiding the possible races.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/643293b68fbb6c03f5e907736498da17d43f0d81",
      "https://git.kernel.org/stable/c/40f3d5cb0e0cbf7fa697913a27d5d361373bdcf5",
      "https://git.kernel.org/stable/c/e7e7d2b180d8f297cea6db43ea72402fd33e1a29",
      "https://git.kernel.org/stable/c/a54da4b787dcac60b598da69c9c0072812b8282d",
      "https://git.kernel.org/stable/c/c80f454a805443c274394b1db0d1ebf477abd94e",
      "https://git.kernel.org/stable/c/535df7f896a568a8a1564114eaea49d002cb1747",
      "https://git.kernel.org/stable/c/51d87f11dd199bbc6a85982b088ff27bde53b48a",
      "https://git.kernel.org/stable/c/15b7a03205b31bc5623378c190d22b7ff60026f1"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年09月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-44953",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: ufs: core: Fix deadlock during RTC update\n\nThere is a deadlock when runtime suspend waits for the flush of RTC work,\nand the RTC work calls ufshcd_rpm_get_sync() to wait for runtime resume.\n\nHere is deadlock backtrace:\n\nkworker/0:1     D 4892.876354 10 10971 4859 0x4208060 0x8 10 0 120 670730152367\nptr            f0ffff80c2e40000 0 1 0x00000001 0x000000ff 0x000000ff 0x000000ff\n<ffffffee5e71ddb0> __switch_to+0x1a8/0x2d4\n<ffffffee5e71e604> __schedule+0x684/0xa98\n<ffffffee5e71ea60> schedule+0x48/0xc8\n<ffffffee5e725f78> schedule_timeout+0x48/0x170\n<ffffffee5e71fb74> do_wait_for_common+0x108/0x1b0\n<ffffffee5e71efe0> wait_for_completion+0x44/0x60\n<ffffffee5d6de968> __flush_work+0x39c/0x424\n<ffffffee5d6decc0> __cancel_work_sync+0xd8/0x208\n<ffffffee5d6dee2c> cancel_delayed_work_sync+0x14/0x28\n<ffffffee5e2551b8> __ufshcd_wl_suspend+0x19c/0x480\n<ffffffee5e255fb8> ufshcd_wl_runtime_suspend+0x3c/0x1d4\n<ffffffee5dffd80c> scsi_runtime_suspend+0x78/0xc8\n<ffffffee5df93580> __rpm_callback+0x94/0x3e0\n<ffffffee5df90b0c> rpm_suspend+0x2d4/0x65c\n<ffffffee5df91448> __pm_runtime_suspend+0x80/0x114\n<ffffffee5dffd95c> scsi_runtime_idle+0x38/0x6c\n<ffffffee5df912f4> rpm_idle+0x264/0x338\n<ffffffee5df90f14> __pm_runtime_idle+0x80/0x110\n<ffffffee5e24ce44> ufshcd_rtc_work+0x128/0x1e4\n<ffffffee5d6e3a40> process_one_work+0x26c/0x650\n<ffffffee5d6e65c8> worker_thread+0x260/0x3d8\n<ffffffee5d6edec8> kthread+0x110/0x134\n<ffffffee5d616b18> ret_from_fork+0x10/0x20\n\nSkip updating RTC if RPM state is not RPM_ACTIVE.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a4921b76bc9421d3838e167f6a17ea3112d8fe62",
      "https://git.kernel.org/stable/c/f13f1858a28c68b7fc0d72c2008d5c1f80d2e8d5",
      "https://git.kernel.org/stable/c/3911af778f208e5f49d43ce739332b91e26bc48e"
    ],
    "受影响版本": [
      "06701a545e9a3c4e007cff6872a074bf97c40619",
      "6bf999e0eb41850d5c857102535d5c53b2ede224",
      "6bf999e0eb41850d5c857102535d5c53b2ede224"
    ],
    "公开日期": "2024年09月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-44943",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: gup: stop abusing try_grab_folio\n\nA kernel warning was reported when pinning folio in CMA memory when\nlaunching SEV virtual machine.  The splat looks like:\n\n[  464.325306] WARNING: CPU: 13 PID: 6734 at mm/gup.c:1313 __get_user_pages+0x423/0x520\n[  464.325464] CPU: 13 PID: 6734 Comm: qemu-kvm Kdump: loaded Not tainted 6.6.33+ #6\n[  464.325477] RIP: 0010:__get_user_pages+0x423/0x520\n[  464.325515] Call Trace:\n[  464.325520]  <TASK>\n[  464.325523]  ? __get_user_pages+0x423/0x520\n[  464.325528]  ? __warn+0x81/0x130\n[  464.325536]  ? __get_user_pages+0x423/0x520\n[  464.325541]  ? report_bug+0x171/0x1a0\n[  464.325549]  ? handle_bug+0x3c/0x70\n[  464.325554]  ? exc_invalid_op+0x17/0x70\n[  464.325558]  ? asm_exc_invalid_op+0x1a/0x20\n[  464.325567]  ? __get_user_pages+0x423/0x520\n[  464.325575]  __gup_longterm_locked+0x212/0x7a0\n[  464.325583]  internal_get_user_pages_fast+0xfb/0x190\n[  464.325590]  pin_user_pages_fast+0x47/0x60\n[  464.325598]  sev_pin_memory+0xca/0x170 [kvm_amd]\n[  464.325616]  sev_mem_enc_register_region+0x81/0x130 [kvm_amd]\n\nPer the analysis done by yangge, when starting the SEV virtual machine, it\nwill call pin_user_pages_fast(..., FOLL_LONGTERM, ...) to pin the memory. \nBut the page is in CMA area, so fast GUP will fail then fallback to the\nslow path due to the longterm pinnalbe check in try_grab_folio().\n\nThe slow path will try to pin the pages then migrate them out of CMA area.\nBut the slow path also uses try_grab_folio() to pin the page, it will\nalso fail due to the same check then the above warning is triggered.\n\nIn addition, the try_grab_folio() is supposed to be used in fast path and\nit elevates folio refcount by using add ref unless zero.  We are guaranteed\nto have at least one stable reference in slow path, so the simple atomic add\ncould be used.  The performance difference should be trivial, but the\nmisuse may be confusing and misleading.\n\nRedefined try_grab_folio() to try_grab_folio_fast(), and try_grab_page()\nto try_grab_folio(), and use them in the proper paths.  This solves both\nthe abuse and the kernel warning.\n\nThe proper naming makes their usecase more clear and should prevent from\nabusing in the future.\n\npeterx said:\n\n: The user will see the pin fails, for gpu-slow it further triggers the WARN\n: right below that failure (as in the original report):\n: \n:         folio = try_grab_folio(page, page_increm - 1,\n:                                 foll_flags);\n:         if (WARN_ON_ONCE(!folio)) { <------------------------ here\n:                 /*\n:                         * Release the 1st page ref if the\n:                         * folio is problematic, fail hard.\n:                         */\n:                 gup_put_folio(page_folio(page), 1,\n:                                 foll_flags);\n:                 ret = -EFAULT;\n:                 goto out;\n:         }\n\n[1] https://lore.kernel.org/linux-mm/1719478388-31917-1-git-send-email-yangge1116@126.com/\n\n[shy828301@gmail.com: fix implicit declaration of function try_grab_folio_fast]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/26273f5f4cf68b29414e403837093408a9c98e1f",
      "https://git.kernel.org/stable/c/f442fa6141379a20b48ae3efabee827a3d260787"
    ],
    "受影响版本": [
      "57edfcfd3419b4799353d8cbd6ce49da075cfdbd",
      "57edfcfd3419b4799353d8cbd6ce49da075cfdbd"
    ],
    "公开日期": "2024年08月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-44942",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to do sanity check on F2FS_INLINE_DATA flag in inode during GC\n\nsyzbot reports a f2fs bug as below:\n\n------------[ cut here ]------------\nkernel BUG at fs/f2fs/inline.c:258!\nCPU: 1 PID: 34 Comm: kworker/u8:2 Not tainted 6.9.0-rc6-syzkaller-00012-g9e4bc4bcae01 #0\nRIP: 0010:f2fs_write_inline_data+0x781/0x790 fs/f2fs/inline.c:258\nCall Trace:\n f2fs_write_single_data_page+0xb65/0x1d60 fs/f2fs/data.c:2834\n f2fs_write_cache_pages fs/f2fs/data.c:3133 [inline]\n __f2fs_write_data_pages fs/f2fs/data.c:3288 [inline]\n f2fs_write_data_pages+0x1efe/0x3a90 fs/f2fs/data.c:3315\n do_writepages+0x35b/0x870 mm/page-writeback.c:2612\n __writeback_single_inode+0x165/0x10b0 fs/fs-writeback.c:1650\n writeback_sb_inodes+0x905/0x1260 fs/fs-writeback.c:1941\n wb_writeback+0x457/0xce0 fs/fs-writeback.c:2117\n wb_do_writeback fs/fs-writeback.c:2264 [inline]\n wb_workfn+0x410/0x1090 fs/fs-writeback.c:2304\n process_one_work kernel/workqueue.c:3254 [inline]\n process_scheduled_works+0xa12/0x17c0 kernel/workqueue.c:3335\n worker_thread+0x86d/0xd70 kernel/workqueue.c:3416\n kthread+0x2f2/0x390 kernel/kthread.c:388\n ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\nThe root cause is: inline_data inode can be fuzzed, so that there may\nbe valid blkaddr in its direct node, once f2fs triggers background GC\nto migrate the block, it will hit f2fs_bug_on() during dirty page\nwriteback.\n\nLet's add sanity check on F2FS_INLINE_DATA flag in inode during GC,\nso that, it can forbid migrating inline_data inode's data block for\nfixing.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ae00e6536a2dd54b64b39e9a39548870cf835745",
      "https://git.kernel.org/stable/c/26c07775fb5dc74351d1c3a2bc3cdf609b03e49f",
      "https://git.kernel.org/stable/c/fc01008c92f40015aeeced94750855a7111b6929"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年08月26日"
  },
  {
    "设备品牌": "Menulux Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Managment Portal",
    "CVE编号": "CVE-2024-4428",
    "漏洞描述": "Improper Privilege Management vulnerability in Menulux Information Technologies Managment Portal allows Collect Data as Provided by Users.This issue affects Managment Portal: through 21.05.2024.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-24-1356"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年08月29日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "LiteSpeed Cache",
    "CVE编号": "CVE-2024-44000",
    "漏洞描述": "Insufficiently Protected Credentials vulnerability in LiteSpeed Technologies LiteSpeed Cache allows Authentication Bypass.This issue affects LiteSpeed Cache: from n/a before 6.5.0.1.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/litespeed-cache/wordpress-litespeed-cache-plugin-6-5-0-1-unauthenticated-account-takeover-vulnerability?_s_id=cve",
      "https://patchstack.com/articles/critical-account-takeover-vulnerability-patched-in-litespeed-cache-plugin?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年10月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-43887",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/tcp: Disable TCP-AO static key after RCU grace period\n\nThe lifetime of TCP-AO static_key is the same as the last\ntcp_ao_info. On the socket destruction tcp_ao_info ceases to be\nwith RCU grace period, while tcp-ao static branch is currently deferred\ndestructed. The static key definition is\n: DEFINE_STATIC_KEY_DEFERRED_FALSE(tcp_ao_needed, HZ);\n\nwhich means that if RCU grace period is delayed by more than a second\nand tcp_ao_needed is in the process of disablement, other CPUs may\nyet see tcp_ao_info which atent dead, but soon-to-be.\nAnd that breaks the assumption of static_key_fast_inc_not_disabled().\n\nSee the comment near the definition:\n> * The caller must make sure that the static key can't get disabled while\n> * in this function. It doesn't patch jump labels, only adds a user to\n> * an already enabled static key.\n\nOriginally it was introduced in commit eb8c507296f6 (\"jump_label:\nPrevent key->enabled int overflow\"), which is needed for the atomic\ncontexts, one of which would be the creation of a full socket from a\nrequest socket. In that atomic context, it's known by the presence\nof the key (md5/ao) that the static branch is already enabled.\nSo, the ref counter for that static branch is just incremented\ninstead of holding the proper mutex.\nstatic_key_fast_inc_not_disabled() is just a helper for such usage\ncase. But it must not be used if the static branch could get disabled\nin parallel as it's not protected by jump_label_mutex and as a result,\nraces with jump_label_update() implementation details.\n\nHappened on netdev test-bot[1], so not a theoretical issue:\n\n[] jump_label: Fatal kernel bug, unexpected op at tcp_inbound_hash+0x1a7/0x870 [ffffffffa8c4e9b7] (eb 50 0f 1f 44 != 66 90 0f 1f 00)) size:2 type:1\n[] ------------[ cut here ]------------\n[] kernel BUG at arch/x86/kernel/jump_label.c:73!\n[] Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI\n[] CPU: 3 PID: 243 Comm: kworker/3:3 Not tainted 6.10.0-virtme #1\n[] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n[] Workqueue: events jump_label_update_timeout\n[] RIP: 0010:__jump_label_patch+0x2f6/0x350\n...\n[] Call Trace:\n[]  <TASK>\n[]  arch_jump_label_transform_queue+0x6c/0x110\n[]  __jump_label_update+0xef/0x350\n[]  __static_key_slow_dec_cpuslocked.part.0+0x3c/0x60\n[]  jump_label_update_timeout+0x2c/0x40\n[]  process_one_work+0xe3b/0x1670\n[]  worker_thread+0x587/0xce0\n[]  kthread+0x28a/0x350\n[]  ret_from_fork+0x31/0x70\n[]  ret_from_fork_asm+0x1a/0x30\n[]  </TASK>\n[] Modules linked in: veth\n[] ---[ end trace 0000000000000000 ]---\n[] RIP: 0010:__jump_label_patch+0x2f6/0x350\n\n[1]: https://netdev-3.bots.linux.dev/vmksft-tcp-ao-dbg/results/696681/5-connect-deny-ipv6/stderr",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/954d55a59b2501f4a9bd693b40ce45a1c46cb2b3",
      "https://git.kernel.org/stable/c/14ab4792ee120c022f276a7e4768f4dcb08f0cdd"
    ],
    "受影响版本": [
      "67fa83f7c86a86913ab9cd5a13b4bebd8d2ebb43",
      "67fa83f7c86a86913ab9cd5a13b4bebd8d2ebb43"
    ],
    "公开日期": "2024年08月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-43880",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum_acl_erp: Fix object nesting warning\n\nACLs in Spectrum-2 and newer ASICs can reside in the algorithmic TCAM\n(A-TCAM) or in the ordinary circuit TCAM (C-TCAM). The former can\ncontain more ACLs (i.e., tc filters), but the number of masks in each\nregion (i.e., tc chain) is limited.\n\nIn order to mitigate the effects of the above limitation, the device\nallows filters to share a single mask if their masks only differ in up\nto 8 consecutive bits. For example, dst_ip/25 can be represented using\ndst_ip/24 with a delta of 1 bit. The C-TCAM does not have a limit on the\nnumber of masks being used (and therefore does not support mask\naggregation), but can contain a limited number of filters.\n\nThe driver uses the \"objagg\" library to perform the mask aggregation by\npassing it objects that consist of the filter's mask and whether the\nfilter is to be inserted into the A-TCAM or the C-TCAM since filters in\ndifferent TCAMs cannot share a mask.\n\nThe set of created objects is dependent on the insertion order of the\nfilters and is not necessarily optimal. Therefore, the driver will\nperiodically ask the library to compute a more optimal set (\"hints\") by\nlooking at all the existing objects.\n\nWhen the library asks the driver whether two objects can be aggregated\nthe driver only compares the provided masks and ignores the A-TCAM /\nC-TCAM indication. This is the right thing to do since the goal is to\nmove as many filters as possible to the A-TCAM. The driver also forbids\ntwo identical masks from being aggregated since this can only happen if\none was intentionally put in the C-TCAM to avoid a conflict in the\nA-TCAM.\n\nThe above can result in the following set of hints:\n\nH1: {mask X, A-TCAM} -> H2: {mask Y, A-TCAM} // X is Y + delta\nH3: {mask Y, C-TCAM} -> H4: {mask Z, A-TCAM} // Y is Z + delta\n\nAfter getting the hints from the library the driver will start migrating\nfilters from one region to another while consulting the computed hints\nand instructing the device to perform a lookup in both regions during\nthe transition.\n\nAssuming a filter with mask X is being migrated into the A-TCAM in the\nnew region, the hints lookup will return H1. Since H2 is the parent of\nH1, the library will try to find the object associated with it and\ncreate it if necessary in which case another hints lookup (recursive)\nwill be performed. This hints lookup for {mask Y, A-TCAM} will either\nreturn H2 or H3 since the driver passes the library an object comparison\nfunction that ignores the A-TCAM / C-TCAM indication.\n\nThis can eventually lead to nested objects which are not supported by\nthe library [1].\n\nFix by removing the object comparison function from both the driver and\nthe library as the driver was the only user. That way the lookup will\nonly return exact matches.\n\nI do not have a reliable reproducer that can reproduce the issue in a\ntimely manner, but before the fix the issue would reproduce in several\nminutes and with the fix it does not reproduce in over an hour.\n\nNote that the current usefulness of the hints is limited because they\ninclude the C-TCAM indication and represent aggregation that cannot\nactually happen. This will be addressed in net-next.\n\n[1]\nWARNING: CPU: 0 PID: 153 at lib/objagg.c:170 objagg_obj_parent_assign+0xb5/0xd0\nModules linked in:\nCPU: 0 PID: 153 Comm: kworker/0:18 Not tainted 6.9.0-rc6-custom-g70fbc2c1c38b #42\nHardware name: Mellanox Technologies Ltd. MSN3700C/VMOD0008, BIOS 5.11 10/10/2018\nWorkqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work\nRIP: 0010:objagg_obj_parent_assign+0xb5/0xd0\n[...]\nCall Trace:\n <TASK>\n __objagg_obj_get+0x2bb/0x580\n objagg_obj_get+0xe/0x80\n mlxsw_sp_acl_erp_mask_get+0xb5/0xf0\n mlxsw_sp_acl_atcam_entry_add+0xe8/0x3c0\n mlxsw_sp_acl_tcam_entry_create+0x5e/0xa0\n mlxsw_sp_acl_tcam_vchunk_migrate_one+0x16b/0x270\n mlxsw_sp_acl_tcam_vregion_rehash_work+0xbe/0x510\n process_one_work+0x151/0x370",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4dc09f6f260db3c4565a4ec52ba369393598f2fb",
      "https://git.kernel.org/stable/c/36a9996e020dd5aa325e0ecc55eb2328288ea6bb",
      "https://git.kernel.org/stable/c/9a5261a984bba4f583d966c550fa72c33ff3714e",
      "https://git.kernel.org/stable/c/25c6fd9648ad05da493a5d30881896a78a08b624",
      "https://git.kernel.org/stable/c/0e59c2d22853266704e127915653598f7f104037",
      "https://git.kernel.org/stable/c/fb5d4fc578e655d113f09565f6f047e15f7ab578",
      "https://git.kernel.org/stable/c/97d833ceb27dc19f8777d63f90be4a27b5daeedf"
    ],
    "受影响版本": [
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130"
    ],
    "公开日期": "2024年08月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-43850",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoc: qcom: icc-bwmon: Fix refcount imbalance seen during bwmon_remove\n\nThe following warning is seen during bwmon_remove due to refcount\nimbalance, fix this by releasing the OPPs after use.\n\nLogs:\nWARNING: at drivers/opp/core.c:1640 _opp_table_kref_release+0x150/0x158\nHardware name: Qualcomm Technologies, Inc. X1E80100 CRD (DT)\n...\nCall trace:\n_opp_table_kref_release+0x150/0x158\ndev_pm_opp_remove_table+0x100/0x1b4\ndevm_pm_opp_of_table_release+0x10/0x1c\ndevm_action_release+0x14/0x20\ndevres_release_all+0xa4/0x104\ndevice_unbind_cleanup+0x18/0x60\ndevice_release_driver_internal+0x1ec/0x228\ndriver_detach+0x50/0x98\nbus_remove_driver+0x6c/0xbc\ndriver_unregister+0x30/0x60\nplatform_driver_unregister+0x14/0x20\nbwmon_driver_exit+0x18/0x524 [icc_bwmon]\n__arm64_sys_delete_module+0x184/0x264\ninvoke_syscall+0x48/0x118\nel0_svc_common.constprop.0+0xc8/0xe8\ndo_el0_svc+0x20/0x2c\nel0_svc+0x34/0xdc\nel0t_64_sync_handler+0x13c/0x158\nel0t_64_sync+0x190/0x194\n--[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/aad41f4c169bcb800ae88123799bdf8cdec3d366",
      "https://git.kernel.org/stable/c/4100d4d019f8e140be1d4d3a9d8d93c1285f5d1c",
      "https://git.kernel.org/stable/c/24086640ab39396eb1a92d1cb1cd2f31b2677c52"
    ],
    "受影响版本": [
      "b9c2ae6cac403dee3195fda9eb28d8ee733b225b",
      "b9c2ae6cac403dee3195fda9eb28d8ee733b225b",
      "b9c2ae6cac403dee3195fda9eb28d8ee733b225b"
    ],
    "公开日期": "2024年08月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-43846",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nlib: objagg: Fix general protection fault\n\nThe library supports aggregation of objects into other objects only if\nthe parent object does not have a parent itself. That is, nesting is not\nsupported.\n\nAggregation happens in two cases: Without and with hints, where hints\nare a pre-computed recommendation on how to aggregate the provided\nobjects.\n\nNesting is not possible in the first case due to a check that prevents\nit, but in the second case there is no check because the assumption is\nthat nesting cannot happen when creating objects based on hints. The\nviolation of this assumption leads to various warnings and eventually to\na general protection fault [1].\n\nBefore fixing the root cause, error out when nesting happens and warn.\n\n[1]\ngeneral protection fault, probably for non-canonical address 0xdead000000000d90: 0000 [#1] PREEMPT SMP PTI\nCPU: 1 PID: 1083 Comm: kworker/1:9 Tainted: G        W          6.9.0-rc6-custom-gd9b4f1cca7fb #7\nHardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019\nWorkqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work\nRIP: 0010:mlxsw_sp_acl_erp_bf_insert+0x25/0x80\n[...]\nCall Trace:\n <TASK>\n mlxsw_sp_acl_atcam_entry_add+0x256/0x3c0\n mlxsw_sp_acl_tcam_entry_create+0x5e/0xa0\n mlxsw_sp_acl_tcam_vchunk_migrate_one+0x16b/0x270\n mlxsw_sp_acl_tcam_vregion_rehash_work+0xbe/0x510\n process_one_work+0x151/0x370\n worker_thread+0x2cb/0x3e0\n kthread+0xd0/0x100\n ret_from_fork+0x34/0x50\n ret_from_fork_asm+0x1a/0x30\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8161263362154cbebfbf4808097b956a6a8cb98a",
      "https://git.kernel.org/stable/c/22ae17a267f4812861f0c644186c3421ff97dbfc",
      "https://git.kernel.org/stable/c/565213e005557eb6cc4e42189d26eb300e02f170",
      "https://git.kernel.org/stable/c/5adc61d29bbb461d7f7c2b48dceaa90ecd182eb7",
      "https://git.kernel.org/stable/c/1936fa05a180834c3b52e0439a6bddc07814d3eb",
      "https://git.kernel.org/stable/c/499f742fed42e74f1321f4b12ca196a66a2b49fc",
      "https://git.kernel.org/stable/c/b4a3a89fffcdf09702b1f161b914e52abca1894d"
    ],
    "受影响版本": [
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130",
      "9069a3817d82b01b3a55da382c774e3575946130"
    ],
    "公开日期": "2024年08月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-43844",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw89: wow: fix GTK offload H2C skbuff issue\n\nWe mistakenly put skb too large and that may exceed skb->end.\nTherefore, we fix it.\n\nskbuff: skb_over_panic: text:ffffffffc09e9a9d len:416 put:204 head:ffff8fba04eca780 data:ffff8fba04eca7e0 tail:0x200 end:0x140 dev:<NULL>\n------------[ cut here ]------------\nkernel BUG at net/core/skbuff.c:192!\ninvalid opcode: 0000 [#1] PREEMPT SMP PTI\nCPU: 1 PID: 4747 Comm: kworker/u4:44 Tainted: G           O       6.6.30-02659-gc18865c4dfbd #1 86547039b47e46935493f615ee31d0b2d711d35e\nHardware name: HP Meep/Meep, BIOS Google_Meep.11297.262.0 03/18/2021\nWorkqueue: events_unbound async_run_entry_fn\nRIP: 0010:skb_panic+0x5d/0x60\nCode: c6 63 8b 8f bb 4c 0f 45 f6 48 c7 c7 4d 89 8b bb 48 89 ce 44 89 d1 41 56 53 41 53 ff b0 c8 00 00 00 e8 27 5f 23 00 48 83 c4 20 <0f> 0b 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 0f 1f 44\nRSP: 0018:ffffaa700144bad0 EFLAGS: 00010282\nRAX: 0000000000000089 RBX: 0000000000000140 RCX: 14432c5aad26c900\nRDX: 0000000000000000 RSI: 00000000ffffdfff RDI: 0000000000000001\nRBP: ffffaa700144bae0 R08: 0000000000000000 R09: ffffaa700144b920\nR10: 00000000ffffdfff R11: ffffffffbc28fbc0 R12: ffff8fba4e57a010\nR13: 0000000000000000 R14: ffffffffbb8f8b63 R15: 0000000000000000\nFS:  0000000000000000(0000) GS:ffff8fba7bd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007999c4ad1000 CR3: 000000015503a000 CR4: 0000000000350ee0\nCall Trace:\n <TASK>\n ? __die_body+0x1f/0x70\n ? die+0x3d/0x60\n ? do_trap+0xa4/0x110\n ? skb_panic+0x5d/0x60\n ? do_error_trap+0x6d/0x90\n ? skb_panic+0x5d/0x60\n ? handle_invalid_op+0x30/0x40\n ? skb_panic+0x5d/0x60\n ? exc_invalid_op+0x3c/0x50\n ? asm_exc_invalid_op+0x16/0x20\n ? skb_panic+0x5d/0x60\n skb_put+0x49/0x50\n rtw89_fw_h2c_wow_gtk_ofld+0xbd/0x220 [rtw89_core 778b32de31cd1f14df2d6721ae99ba8a83636fa5]\n rtw89_wow_resume+0x31f/0x540 [rtw89_core 778b32de31cd1f14df2d6721ae99ba8a83636fa5]\n rtw89_ops_resume+0x2b/0xa0 [rtw89_core 778b32de31cd1f14df2d6721ae99ba8a83636fa5]\n ieee80211_reconfig+0x84/0x13e0 [mac80211 818a894e3b77da6298269c59ed7cdff065a4ed52]\n ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 1a793119e2aeb157c4ca4091ff8e1d9ae233b59d]\n ? dev_printk_emit+0x51/0x70\n ? _dev_info+0x6e/0x90\n ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 1a793119e2aeb157c4ca4091ff8e1d9ae233b59d]\n wiphy_resume+0x89/0x180 [cfg80211 1a793119e2aeb157c4ca4091ff8e1d9ae233b59d]\n ? __pfx_wiphy_resume+0x10/0x10 [cfg80211 1a793119e2aeb157c4ca4091ff8e1d9ae233b59d]\n dpm_run_callback+0x3c/0x140\n device_resume+0x1f9/0x3c0\n ? __pfx_dpm_watchdog_handler+0x10/0x10\n async_resume+0x1d/0x30\n async_run_entry_fn+0x29/0xd0\n process_scheduled_works+0x1d8/0x3d0\n worker_thread+0x1fc/0x2f0\n kthread+0xed/0x110\n ? __pfx_worker_thread+0x10/0x10\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x38/0x50\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1b/0x30\n </TASK>\nModules linked in: ccm 8021q r8153_ecm cdc_ether usbnet r8152 mii dm_integrity async_xor xor async_tx lz4 lz4_compress zstd zstd_compress zram zsmalloc uinput rfcomm cmac algif_hash rtw89_8922ae(O) algif_skcipher rtw89_8922a(O) af_alg rtw89_pci(O) rtw89_core(O) btusb(O) snd_soc_sst_bxt_da7219_max98357a btbcm(O) snd_soc_hdac_hdmi btintel(O) snd_soc_intel_hda_dsp_common snd_sof_probes btrtl(O) btmtk(O) snd_hda_codec_hdmi snd_soc_dmic uvcvideo videobuf2_vmalloc uvc videobuf2_memops videobuf2_v4l2 videobuf2_common snd_sof_pci_intel_apl snd_sof_intel_hda_common snd_soc_hdac_hda snd_sof_intel_hda soundwire_intel soundwire_generic_allocation snd_sof_intel_hda_mlink soundwire_cadence snd_sof_pci snd_sof_xtensa_dsp mac80211 snd_soc_acpi_intel_match snd_soc_acpi snd_sof snd_sof_utils soundwire_bus snd_soc_max98357a snd_soc_avs snd_soc_hda_codec snd_hda_ext_core snd_intel_dspcfg snd_intel_sdw_acpi snd_soc_da7219 snd_hda_codec snd_hwdep snd_hda_core veth ip6table_nat xt_MASQUERADE xt_cgroup fuse bluetooth ecdh_generic\n cfg80211 ecc\ngsmi: Log Shutdown \n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ef0d9d2f0dc1133db3d3a1c5167190c6627146b2",
      "https://git.kernel.org/stable/c/dda364c345913fe03ddbe4d5ae14a2754c100296"
    ],
    "受影响版本": [
      "ed9a3c0d4dd9ce79ff7f65238164a96da1b52dbf",
      "ed9a3c0d4dd9ce79ff7f65238164a96da1b52dbf"
    ],
    "公开日期": "2024年08月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-43834",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nxdp: fix invalid wait context of page_pool_destroy()\n\nIf the driver uses a page pool, it creates a page pool with\npage_pool_create().\nThe reference count of page pool is 1 as default.\nA page pool will be destroyed only when a reference count reaches 0.\npage_pool_destroy() is used to destroy page pool, it decreases a\nreference count.\nWhen a page pool is destroyed, ->disconnect() is called, which is\nmem_allocator_disconnect().\nThis function internally acquires mutex_lock().\n\nIf the driver uses XDP, it registers a memory model with\nxdp_rxq_info_reg_mem_model().\nThe xdp_rxq_info_reg_mem_model() internally increases a page pool\nreference count if a memory model is a page pool.\nNow the reference count is 2.\n\nTo destroy a page pool, the driver should call both page_pool_destroy()\nand xdp_unreg_mem_model().\nThe xdp_unreg_mem_model() internally calls page_pool_destroy().\nOnly page_pool_destroy() decreases a reference count.\n\nIf a driver calls page_pool_destroy() then xdp_unreg_mem_model(), we\nwill face an invalid wait context warning.\nBecause xdp_unreg_mem_model() calls page_pool_destroy() with\nrcu_read_lock().\nThe page_pool_destroy() internally acquires mutex_lock().\n\nSplat looks like:\n=============================\n[ BUG: Invalid wait context ]\n6.10.0-rc6+ #4 Tainted: G W\n-----------------------------\nethtool/1806 is trying to lock:\nffffffff90387b90 (mem_id_lock){+.+.}-{4:4}, at: mem_allocator_disconnect+0x73/0x150\nother info that might help us debug this:\ncontext-{5:5}\n3 locks held by ethtool/1806:\nstack backtrace:\nCPU: 0 PID: 1806 Comm: ethtool Tainted: G W 6.10.0-rc6+ #4 f916f41f172891c800f2fed\nHardware name: ASUS System Product Name/PRIME Z690-P D4, BIOS 0603 11/01/2021\nCall Trace:\n<TASK>\ndump_stack_lvl+0x7e/0xc0\n__lock_acquire+0x1681/0x4de0\n? _printk+0x64/0xe0\n? __pfx_mark_lock.part.0+0x10/0x10\n? __pfx___lock_acquire+0x10/0x10\nlock_acquire+0x1b3/0x580\n? mem_allocator_disconnect+0x73/0x150\n? __wake_up_klogd.part.0+0x16/0xc0\n? __pfx_lock_acquire+0x10/0x10\n? dump_stack_lvl+0x91/0xc0\n__mutex_lock+0x15c/0x1690\n? mem_allocator_disconnect+0x73/0x150\n? __pfx_prb_read_valid+0x10/0x10\n? mem_allocator_disconnect+0x73/0x150\n? __pfx_llist_add_batch+0x10/0x10\n? console_unlock+0x193/0x1b0\n? lockdep_hardirqs_on+0xbe/0x140\n? __pfx___mutex_lock+0x10/0x10\n? tick_nohz_tick_stopped+0x16/0x90\n? __irq_work_queue_local+0x1e5/0x330\n? irq_work_queue+0x39/0x50\n? __wake_up_klogd.part.0+0x79/0xc0\n? mem_allocator_disconnect+0x73/0x150\nmem_allocator_disconnect+0x73/0x150\n? __pfx_mem_allocator_disconnect+0x10/0x10\n? mark_held_locks+0xa5/0xf0\n? rcu_is_watching+0x11/0xb0\npage_pool_release+0x36e/0x6d0\npage_pool_destroy+0xd7/0x440\nxdp_unreg_mem_model+0x1a7/0x2a0\n? __pfx_xdp_unreg_mem_model+0x10/0x10\n? kfree+0x125/0x370\n? bnxt_free_ring.isra.0+0x2eb/0x500\n? bnxt_free_mem+0x5ac/0x2500\nxdp_rxq_info_unreg+0x4a/0xd0\nbnxt_free_mem+0x1356/0x2500\nbnxt_close_nic+0xf0/0x3b0\n? __pfx_bnxt_close_nic+0x10/0x10\n? ethnl_parse_bit+0x2c6/0x6d0\n? __pfx___nla_validate_parse+0x10/0x10\n? __pfx_ethnl_parse_bit+0x10/0x10\nbnxt_set_features+0x2a8/0x3e0\n__netdev_update_features+0x4dc/0x1370\n? ethnl_parse_bitset+0x4ff/0x750\n? __pfx_ethnl_parse_bitset+0x10/0x10\n? __pfx___netdev_update_features+0x10/0x10\n? mark_held_locks+0xa5/0xf0\n? _raw_spin_unlock_irqrestore+0x42/0x70\n? __pm_runtime_resume+0x7d/0x110\nethnl_set_features+0x32d/0xa20\n\nTo fix this problem, it uses rhashtable_lookup_fast() instead of\nrhashtable_lookup() with rcu_read_lock().\nUsing xa without rcu_read_lock() here is safe.\nxa is freed by __xdp_mem_allocator_rcu_free() and this is called by\ncall_rcu() of mem_xa_remove().\nThe mem_xa_remove() is called by page_pool_destroy() if a reference\ncount reaches 0.\nThe xa is already protected by the reference count mechanism well in the\ncontrol plane.\nSo removing rcu_read_lock() for page_pool_destroy() is safe.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/be9d08ff102df3ac4f66e826ea935cf3af63a4bd",
      "https://git.kernel.org/stable/c/6c390ef198aa69795427a5cb5fd7cb4bc7e6cd7a",
      "https://git.kernel.org/stable/c/3fc1be360b99baeea15cdee3cf94252cd3a72d26",
      "https://git.kernel.org/stable/c/bf0ce5aa5f2525ed1b921ba36de96e458e77f482",
      "https://git.kernel.org/stable/c/12144069209eec7f2090ce9afa15acdcc2c2a537",
      "https://git.kernel.org/stable/c/59a931c5b732ca5fc2ca727f5a72aeabaafa85ec"
    ],
    "受影响版本": [
      "c3f812cea0d7006469d1cf33a4a9f0a12bb4b3a3",
      "c3f812cea0d7006469d1cf33a4a9f0a12bb4b3a3",
      "c3f812cea0d7006469d1cf33a4a9f0a12bb4b3a3",
      "c3f812cea0d7006469d1cf33a4a9f0a12bb4b3a3",
      "c3f812cea0d7006469d1cf33a4a9f0a12bb4b3a3",
      "c3f812cea0d7006469d1cf33a4a9f0a12bb4b3a3",
      "bf22306d92ca59c59dc4aa3bab14768948193d56",
      "05f646cb2174d1a4e032b60b99097f5c4b522616"
    ],
    "公开日期": "2024年08月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-43825",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: Fix the sorting functionality in iio_gts_build_avail_time_table\n\nThe sorting in iio_gts_build_avail_time_table is not working as intended.\nIt could result in an out-of-bounds access when the time is zero.\n\nHere are more details:\n\n1. When the gts->itime_table[i].time_us is zero, e.g., the time\nsequence is `3, 0, 1`, the inner for-loop will not terminate and do\nout-of-bound writes. This is because once `times[j] > new`, the value\n`new` will be added in the current position and the `times[j]` will be\nmoved to `j+1` position, which makes the if-condition always hold.\nMeanwhile, idx will be added one, making the loop keep running without\ntermination and out-of-bound write.\n2. If none of the gts->itime_table[i].time_us is zero, the elements\nwill just be copied without being sorted as described in the comment\n\"Sort times from all tables to one and remove duplicates\".\n\nFor more details, please refer to\nhttps://lore.kernel.org/all/6dd0d822-046c-4dd2-9532-79d7ab96ec05@gmail.com.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/31ff8464ef540785344994986a010031410f9ff3",
      "https://git.kernel.org/stable/c/b5046de32fd1532c3f67065197fc1da82f0b5193",
      "https://git.kernel.org/stable/c/5acc3f971a01be48d5ff4252d8f9cdb87998cdfb"
    ],
    "受影响版本": [
      "38416c28e16890b52fdd5eb73479299ec3f062f3",
      "38416c28e16890b52fdd5eb73479299ec3f062f3",
      "38416c28e16890b52fdd5eb73479299ec3f062f3"
    ],
    "公开日期": "2024年08月17日"
  },
  {
    "设备品牌": "Microchip",
    "设备类型": "OTA",
    "产品型号": "TimeProvider 4100",
    "CVE编号": "CVE-2024-43687",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation (XSS or 'Cross-site Scripting') vulnerability in Microchip TimeProvider 4100 (banner config modules) allows Cross-Site Scripting (XSS).This issue affects TimeProvider 4100: from 1.0 before 2.4.7.",
    "攻击向量": "ADJACENT",
    "厂商补丁链接": [
      "https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-stored-xss-vulnerability-in-banner",
      "https://www.gruppotim.it/it/footer/red-team.html"
    ],
    "受影响版本": [
      "1.0",
      "2.4.16"
    ],
    "公开日期": "2024年10月04日"
  },
  {
    "设备品牌": "Microchip",
    "设备类型": "OTA",
    "产品型号": "TimeProvider 4100",
    "CVE编号": "CVE-2024-43686",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation (XSS or 'Cross-site Scripting') vulnerability in Microchip TimeProvider 4100 (data plot modules) allows Reflected XSS.This issue affects TimeProvider 4100: from 1.0 before 2.4.7.",
    "攻击向量": "ADJACENT",
    "厂商补丁链接": [
      "https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-reflected-xss-vulnerability",
      "https://www.gruppotim.it/it/footer/red-team.html"
    ],
    "受影响版本": [
      "1.0"
    ],
    "公开日期": "2024年10月04日"
  },
  {
    "设备品牌": "Microchip",
    "设备类型": "OTA",
    "产品型号": "TimeProvider 4100",
    "CVE编号": "CVE-2024-43685",
    "漏洞描述": "Improper Authentication vulnerability in Microchip TimeProvider 4100 (login modules) allows Session Hijacking.This issue affects TimeProvider 4100: from 1.0 before 2.4.7.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-session-token-fixation",
      "https://www.gruppotim.it/it/footer/red-team.html"
    ],
    "受影响版本": [
      "1.0"
    ],
    "公开日期": "2024年10月04日"
  },
  {
    "设备品牌": "Microchip",
    "设备类型": "OTA",
    "产品型号": "TimeProvider 4100",
    "CVE编号": "CVE-2024-43684",
    "漏洞描述": "Cross-Site Request Forgery (CSRF) vulnerability in Microchip TimeProvider 4100 allows Cross Site Request Forgery, Cross-Site Scripting (XSS).This issue affects TimeProvider 4100: from 1.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.gruppotim.it/it/footer/red-team.html",
      "https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-cross-site-request-forgery"
    ],
    "受影响版本": [
      "1.0"
    ],
    "公开日期": "2024年10月04日"
  },
  {
    "设备品牌": "Microchip",
    "设备类型": "OTA",
    "产品型号": "TimeProvider 4100",
    "CVE编号": "CVE-2024-43683",
    "漏洞描述": "URL Redirection to Untrusted Site ('Open Redirect') vulnerability in Microchip TimeProvider 4100 allows XSS Through HTTP Headers.This issue affects TimeProvider 4100: from 1.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-improper-verification-of-host-header",
      "https://www.gruppotim.it/it/footer/red-team.html"
    ],
    "受影响版本": [
      "1.0"
    ],
    "公开日期": "2024年10月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42321",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: flow_dissector: use DEBUG_NET_WARN_ON_ONCE\n\nThe following splat is easy to reproduce upstream as well as in -stable\nkernels. Florian Westphal provided the following commit:\n\n  d1dab4f71d37 (\"net: add and use __skb_get_hash_symmetric_net\")\n\nbut this complementary fix has been also suggested by Willem de Bruijn\nand it can be easily backported to -stable kernel which consists in\nusing DEBUG_NET_WARN_ON_ONCE instead to silence the following splat\ngiven __skb_get_hash() is used by the nftables tracing infrastructure to\nto identify packets in traces.\n\n[69133.561393] ------------[ cut here ]------------\n[69133.561404] WARNING: CPU: 0 PID: 43576 at net/core/flow_dissector.c:1104 __skb_flow_dissect+0x134f/\n[...]\n[69133.561944] CPU: 0 PID: 43576 Comm: socat Not tainted 6.10.0-rc7+ #379\n[69133.561959] RIP: 0010:__skb_flow_dissect+0x134f/0x2ad0\n[69133.561970] Code: 83 f9 04 0f 84 b3 00 00 00 45 85 c9 0f 84 aa 00 00 00 41 83 f9 02 0f 84 81 fc ff\nff 44 0f b7 b4 24 80 00 00 00 e9 8b f9 ff ff <0f> 0b e9 20 f3 ff ff 41 f6 c6 20 0f 84 e4 ef ff ff 48 8d 7b 12 e8\n[69133.561979] RSP: 0018:ffffc90000006fc0 EFLAGS: 00010246\n[69133.561988] RAX: 0000000000000000 RBX: ffffffff82f33e20 RCX: ffffffff81ab7e19\n[69133.561994] RDX: dffffc0000000000 RSI: ffffc90000007388 RDI: ffff888103a1b418\n[69133.562001] RBP: ffffc90000007310 R08: 0000000000000000 R09: 0000000000000000\n[69133.562007] R10: ffffc90000007388 R11: ffffffff810cface R12: ffff888103a1b400\n[69133.562013] R13: 0000000000000000 R14: ffffffff82f33e2a R15: ffffffff82f33e28\n[69133.562020] FS:  00007f40f7131740(0000) GS:ffff888390800000(0000) knlGS:0000000000000000\n[69133.562027] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[69133.562033] CR2: 00007f40f7346ee0 CR3: 000000015d200001 CR4: 00000000001706f0\n[69133.562040] Call Trace:\n[69133.562044]  <IRQ>\n[69133.562049]  ? __warn+0x9f/0x1a0\n[ 1211.841384]  ? __skb_flow_dissect+0x107e/0x2860\n[...]\n[ 1211.841496]  ? bpf_flow_dissect+0x160/0x160\n[ 1211.841753]  __skb_get_hash+0x97/0x280\n[ 1211.841765]  ? __skb_get_hash_symmetric+0x230/0x230\n[ 1211.841776]  ? mod_find+0xbf/0xe0\n[ 1211.841786]  ? get_stack_info_noinstr+0x12/0xe0\n[ 1211.841798]  ? bpf_ksym_find+0x56/0xe0\n[ 1211.841807]  ? __rcu_read_unlock+0x2a/0x70\n[ 1211.841819]  nft_trace_init+0x1b9/0x1c0 [nf_tables]\n[ 1211.841895]  ? nft_trace_notify+0x830/0x830 [nf_tables]\n[ 1211.841964]  ? get_stack_info+0x2b/0x80\n[ 1211.841975]  ? nft_do_chain_arp+0x80/0x80 [nf_tables]\n[ 1211.842044]  nft_do_chain+0x79c/0x850 [nf_tables]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/eb03d9826aa646577342a952d658d4598381c035",
      "https://git.kernel.org/stable/c/4afbac11f2f629d1e62817c4e210bdfaa7521107",
      "https://git.kernel.org/stable/c/c5d21aabf1b31a79f228508af33aee83456bc1b0",
      "https://git.kernel.org/stable/c/120f1c857a73e52132e473dee89b340440cb692b"
    ],
    "受影响版本": [
      "9b52e3f267a6835efd50ed9002d530666d16a411",
      "9b52e3f267a6835efd50ed9002d530666d16a411",
      "9b52e3f267a6835efd50ed9002d530666d16a411",
      "9b52e3f267a6835efd50ed9002d530666d16a411"
    ],
    "公开日期": "2024年08月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42317",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/huge_memory: avoid PMD-size page cache if needed\n\nxarray can't support arbitrary page cache size.  the largest and supported\npage cache size is defined as MAX_PAGECACHE_ORDER by commit 099d90642a71\n(\"mm/filemap: make MAX_PAGECACHE_ORDER acceptable to xarray\").  However,\nit's possible to have 512MB page cache in the huge memory's collapsing\npath on ARM64 system whose base page size is 64KB.  512MB page cache is\nbreaking the limitation and a warning is raised when the xarray entry is\nsplit as shown in the following example.\n\n[root@dhcp-10-26-1-207 ~]# cat /proc/1/smaps | grep KernelPageSize\nKernelPageSize:       64 kB\n[root@dhcp-10-26-1-207 ~]# cat /tmp/test.c\n   :\nint main(int argc, char **argv)\n{\n\tconst char *filename = TEST_XFS_FILENAME;\n\tint fd = 0;\n\tvoid *buf = (void *)-1, *p;\n\tint pgsize = getpagesize();\n\tint ret = 0;\n\n\tif (pgsize != 0x10000) {\n\t\tfprintf(stdout, \"System with 64KB base page size is required!\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tsystem(\"echo 0 > /sys/devices/virtual/bdi/253:0/read_ahead_kb\");\n\tsystem(\"echo 1 > /proc/sys/vm/drop_caches\");\n\n\t/* Open the xfs file */\n\tfd = open(filename, O_RDONLY);\n\tassert(fd > 0);\n\n\t/* Create VMA */\n\tbuf = mmap(NULL, TEST_MEM_SIZE, PROT_READ, MAP_SHARED, fd, 0);\n\tassert(buf != (void *)-1);\n\tfprintf(stdout, \"mapped buffer at 0x%p\\n\", buf);\n\n\t/* Populate VMA */\n\tret = madvise(buf, TEST_MEM_SIZE, MADV_NOHUGEPAGE);\n\tassert(ret == 0);\n\tret = madvise(buf, TEST_MEM_SIZE, MADV_POPULATE_READ);\n\tassert(ret == 0);\n\n\t/* Collapse VMA */\n\tret = madvise(buf, TEST_MEM_SIZE, MADV_HUGEPAGE);\n\tassert(ret == 0);\n\tret = madvise(buf, TEST_MEM_SIZE, MADV_COLLAPSE);\n\tif (ret) {\n\t\tfprintf(stdout, \"Error %d to madvise(MADV_COLLAPSE)\\n\", errno);\n\t\tgoto out;\n\t}\n\n\t/* Split xarray entry. Write permission is needed */\n\tmunmap(buf, TEST_MEM_SIZE);\n\tbuf = (void *)-1;\n\tclose(fd);\n\tfd = open(filename, O_RDWR);\n\tassert(fd > 0);\n\tfallocate(fd, FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE,\n \t\t  TEST_MEM_SIZE - pgsize, pgsize);\nout:\n\tif (buf != (void *)-1)\n\t\tmunmap(buf, TEST_MEM_SIZE);\n\tif (fd > 0)\n\t\tclose(fd);\n\n\treturn ret;\n}\n\n[root@dhcp-10-26-1-207 ~]# gcc /tmp/test.c -o /tmp/test\n[root@dhcp-10-26-1-207 ~]# /tmp/test\n ------------[ cut here ]------------\n WARNING: CPU: 25 PID: 7560 at lib/xarray.c:1025 xas_split_alloc+0xf8/0x128\n Modules linked in: nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib    \\\n nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct      \\\n nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4      \\\n ip_set rfkill nf_tables nfnetlink vfat fat virtio_balloon drm fuse   \\\n xfs libcrc32c crct10dif_ce ghash_ce sha2_ce sha256_arm64 virtio_net  \\\n sha1_ce net_failover virtio_blk virtio_console failover dimlib virtio_mmio\n CPU: 25 PID: 7560 Comm: test Kdump: loaded Not tainted 6.10.0-rc7-gavin+ #9\n Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-1.el9 05/24/2024\n pstate: 83400005 (Nzcv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--)\n pc : xas_split_alloc+0xf8/0x128\n lr : split_huge_page_to_list_to_order+0x1c4/0x780\n sp : ffff8000ac32f660\n x29: ffff8000ac32f660 x28: ffff0000e0969eb0 x27: ffff8000ac32f6c0\n x26: 0000000000000c40 x25: ffff0000e0969eb0 x24: 000000000000000d\n x23: ffff8000ac32f6c0 x22: ffffffdfc0700000 x21: 0000000000000000\n x20: 0000000000000000 x19: ffffffdfc0700000 x18: 0000000000000000\n x17: 0000000000000000 x16: ffffd5f3708ffc70 x15: 0000000000000000\n x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000\n x11: ffffffffffffffc0 x10: 0000000000000040 x9 : ffffd5f3708e692c\n x8 : 0000000000000003 x7 : 0000000000000000 x6 : ffff0000e0969eb8\n x5 : ffffd5f37289e378 x4 : 0000000000000000 x3 : 0000000000000c40\n x2 : 000000000000000d x1 : 000000000000000c x0 : 0000000000000000\n Call trace:\n  xas_split_alloc+0xf8/0x128\n  split_huge_page_to_list_to_order+0x1c4/0x780\n  truncate_inode_partial_folio+0xdc/0x160\n  truncate_inode_pages_range+0x1b4/0x4a8\n  truncate_pagecache_range+0x84/0xa\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e60f62f75c99740a28e2bf7e6044086033012a16",
      "https://git.kernel.org/stable/c/d659b715e94ac039803d7601505d3473393fc0be"
    ],
    "受影响版本": [
      "6b24ca4a1a8d4ee3221d6d44ddbb99f542e4bda3",
      "6b24ca4a1a8d4ee3221d6d44ddbb99f542e4bda3"
    ],
    "公开日期": "2024年08月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42266",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: make cow_file_range_inline() honor locked_page on error\n\nThe btrfs buffered write path runs through __extent_writepage() which\nhas some tricky return value handling for writepage_delalloc().\nSpecifically, when that returns 1, we exit, but for other return values\nwe continue and end up calling btrfs_folio_end_all_writers(). If the\nfolio has been unlocked (note that we check the PageLocked bit at the\nstart of __extent_writepage()), this results in an assert panic like\nthis one from syzbot:\n\n  BTRFS: error (device loop0 state EAL) in free_log_tree:3267: errno=-5 IO failure\n  BTRFS warning (device loop0 state EAL): Skipping commit of aborted transaction.\n  BTRFS: error (device loop0 state EAL) in cleanup_transaction:2018: errno=-5 IO failure\n  assertion failed: folio_test_locked(folio), in fs/btrfs/subpage.c:871\n  ------------[ cut here ]------------\n  kernel BUG at fs/btrfs/subpage.c:871!\n  Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI\n  CPU: 1 PID: 5090 Comm: syz-executor225 Not tainted\n  6.10.0-syzkaller-05505-gb1bc554e009e #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS\n  Google 06/27/2024\n  RIP: 0010:btrfs_folio_end_all_writers+0x55b/0x610 fs/btrfs/subpage.c:871\n  Code: e9 d3 fb ff ff e8 25 22 c2 fd 48 c7 c7 c0 3c 0e 8c 48 c7 c6 80 3d\n  0e 8c 48 c7 c2 60 3c 0e 8c b9 67 03 00 00 e8 66 47 ad 07 90 <0f> 0b e8\n  6e 45 b0 07 4c 89 ff be 08 00 00 00 e8 21 12 25 fe 4c 89\n  RSP: 0018:ffffc900033d72e0 EFLAGS: 00010246\n  RAX: 0000000000000045 RBX: 00fff0000000402c RCX: 663b7a08c50a0a00\n  RDX: 0000000000000000 RSI: 0000000080000000 RDI: 0000000000000000\n  RBP: ffffc900033d73b0 R08: ffffffff8176b98c R09: 1ffff9200067adfc\n  R10: dffffc0000000000 R11: fffff5200067adfd R12: 0000000000000001\n  R13: dffffc0000000000 R14: 0000000000000000 R15: ffffea0001cbee80\n  FS:  0000000000000000(0000) GS:ffff8880b9500000(0000)\n  knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f5f076012f8 CR3: 000000000e134000 CR4: 00000000003506f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n  <TASK>\n  __extent_writepage fs/btrfs/extent_io.c:1597 [inline]\n  extent_write_cache_pages fs/btrfs/extent_io.c:2251 [inline]\n  btrfs_writepages+0x14d7/0x2760 fs/btrfs/extent_io.c:2373\n  do_writepages+0x359/0x870 mm/page-writeback.c:2656\n  filemap_fdatawrite_wbc+0x125/0x180 mm/filemap.c:397\n  __filemap_fdatawrite_range mm/filemap.c:430 [inline]\n  __filemap_fdatawrite mm/filemap.c:436 [inline]\n  filemap_flush+0xdf/0x130 mm/filemap.c:463\n  btrfs_release_file+0x117/0x130 fs/btrfs/file.c:1547\n  __fput+0x24a/0x8a0 fs/file_table.c:422\n  task_work_run+0x24f/0x310 kernel/task_work.c:222\n  exit_task_work include/linux/task_work.h:40 [inline]\n  do_exit+0xa2f/0x27f0 kernel/exit.c:877\n  do_group_exit+0x207/0x2c0 kernel/exit.c:1026\n  __do_sys_exit_group kernel/exit.c:1037 [inline]\n  __se_sys_exit_group kernel/exit.c:1035 [inline]\n  __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1035\n  x64_sys_call+0x2634/0x2640\n  arch/x86/include/generated/asm/syscalls_64.h:232\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n  entry_SYSCALL_64_after_hwframe+0x77/0x7f\n  RIP: 0033:0x7f5f075b70c9\n  Code: Unable to access opcode bytes at\n  0x7f5f075b709f.\n\nI was hitting the same issue by doing hundreds of accelerated runs of\ngeneric/475, which also hits IO errors by design.\n\nI instrumented that reproducer with bpftrace and found that the\nundesirable folio_unlock was coming from the following callstack:\n\n  folio_unlock+5\n  __process_pages_contig+475\n  cow_file_range_inline.constprop.0+230\n  cow_file_range+803\n  btrfs_run_delalloc_range+566\n  writepage_delalloc+332\n  __extent_writepage # inlined in my stacktrace, but I added it here\n  extent_write_cache_pages+622\n\nLooking at the bisected-to pa\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/061e41581606000a83ce0f0f01d6ad338f3704e9",
      "https://git.kernel.org/stable/c/478574370bef7951fbd9ef5155537d6cbed49472"
    ],
    "受影响版本": [
      "0586d0a89e77d717da14df42648ace4a9fd67981",
      "0586d0a89e77d717da14df42648ace4a9fd67981"
    ],
    "公开日期": "2024年08月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42252",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nclosures: Change BUG_ON() to WARN_ON()\n\nIf a BUG_ON() can be hit in the wild, it shouldn't be a BUG_ON()\n\nFor reference, this has popped up once in the CI, and we'll need more\ninfo to debug it:\n\n03240 ------------[ cut here ]------------\n03240 kernel BUG at lib/closure.c:21!\n03240 kernel BUG at lib/closure.c:21!\n03240 Internal error: Oops - BUG: 00000000f2000800 [#1] SMP\n03240 Modules linked in:\n03240 CPU: 15 PID: 40534 Comm: kworker/u80:1 Not tainted 6.10.0-rc4-ktest-ga56da69799bd #25570\n03240 Hardware name: linux,dummy-virt (DT)\n03240 Workqueue: btree_update btree_interior_update_work\n03240 pstate: 00001005 (nzcv daif -PAN -UAO -TCO -DIT +SSBS BTYPE=--)\n03240 pc : closure_put+0x224/0x2a0\n03240 lr : closure_put+0x24/0x2a0\n03240 sp : ffff0000d12071c0\n03240 x29: ffff0000d12071c0 x28: dfff800000000000 x27: ffff0000d1207360\n03240 x26: 0000000000000040 x25: 0000000000000040 x24: 0000000000000040\n03240 x23: ffff0000c1f20180 x22: 0000000000000000 x21: ffff0000c1f20168\n03240 x20: 0000000040000000 x19: ffff0000c1f20140 x18: 0000000000000001\n03240 x17: 0000000000003aa0 x16: 0000000000003ad0 x15: 1fffe0001c326974\n03240 x14: 0000000000000a1e x13: 0000000000000000 x12: 1fffe000183e402d\n03240 x11: ffff6000183e402d x10: dfff800000000000 x9 : ffff6000183e402e\n03240 x8 : 0000000000000001 x7 : 00009fffe7c1bfd3 x6 : ffff0000c1f2016b\n03240 x5 : ffff0000c1f20168 x4 : ffff6000183e402e x3 : ffff800081391954\n03240 x2 : 0000000000000001 x1 : 0000000000000000 x0 : 00000000a8000000\n03240 Call trace:\n03240  closure_put+0x224/0x2a0\n03240  bch2_check_for_deadlock+0x910/0x1028\n03240  bch2_six_check_for_deadlock+0x1c/0x30\n03240  six_lock_slowpath.isra.0+0x29c/0xed0\n03240  six_lock_ip_waiter+0xa8/0xf8\n03240  __bch2_btree_node_lock_write+0x14c/0x298\n03240  bch2_trans_lock_write+0x6d4/0xb10\n03240  __bch2_trans_commit+0x135c/0x5520\n03240  btree_interior_update_work+0x1248/0x1c10\n03240  process_scheduled_works+0x53c/0xd90\n03240  worker_thread+0x370/0x8c8\n03240  kthread+0x258/0x2e8\n03240  ret_from_fork+0x10/0x20\n03240 Code: aa1303e0 d63f0020 a94363f7 17ffff8c (d4210000)\n03240 ---[ end trace 0000000000000000 ]---\n03240 Kernel panic - not syncing: Oops - BUG: Fatal exception\n03240 SMP: stopping secondary CPUs\n03241 SMP: failed to stop secondary CPUs 13,15\n03241 Kernel Offset: disabled\n03241 CPU features: 0x00,00000003,80000008,4240500b\n03241 Memory Limit: none\n03241 ---[ end Kernel panic - not syncing: Oops - BUG: Fatal exception ]---\n03246 ========= FAILED TIMEOUT copygc_torture_no_checksum in 7200s",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c894a74756478bb7aec894bcc513add3d554c0cf",
      "https://git.kernel.org/stable/c/ecb4aaa658da760fb83afd79cc5fd4360aa60635",
      "https://git.kernel.org/stable/c/5d85f2ab79d5918a66539ebf046c099f7448db8d",
      "https://git.kernel.org/stable/c/339b84ab6b1d66900c27bd999271cb2ae40ce812"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年08月08日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42251",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: page_ref: remove folio_try_get_rcu()\n\nThe below bug was reported on a non-SMP kernel:\n\n[  275.267158][ T4335] ------------[ cut here ]------------\n[  275.267949][ T4335] kernel BUG at include/linux/page_ref.h:275!\n[  275.268526][ T4335] invalid opcode: 0000 [#1] KASAN PTI\n[  275.269001][ T4335] CPU: 0 PID: 4335 Comm: trinity-c3 Not tainted 6.7.0-rc4-00061-gefa7df3e3bb5 #1\n[  275.269787][ T4335] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\n[  275.270679][ T4335] RIP: 0010:try_get_folio (include/linux/page_ref.h:275 (discriminator 3) mm/gup.c:79 (discriminator 3))\n[  275.272813][ T4335] RSP: 0018:ffffc90005dcf650 EFLAGS: 00010202\n[  275.273346][ T4335] RAX: 0000000000000246 RBX: ffffea00066e0000 RCX: 0000000000000000\n[  275.274032][ T4335] RDX: fffff94000cdc007 RSI: 0000000000000004 RDI: ffffea00066e0034\n[  275.274719][ T4335] RBP: ffffea00066e0000 R08: 0000000000000000 R09: fffff94000cdc006\n[  275.275404][ T4335] R10: ffffea00066e0037 R11: 0000000000000000 R12: 0000000000000136\n[  275.276106][ T4335] R13: ffffea00066e0034 R14: dffffc0000000000 R15: ffffea00066e0008\n[  275.276790][ T4335] FS:  00007fa2f9b61740(0000) GS:ffffffff89d0d000(0000) knlGS:0000000000000000\n[  275.277570][ T4335] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  275.278143][ T4335] CR2: 00007fa2f6c00000 CR3: 0000000134b04000 CR4: 00000000000406f0\n[  275.278833][ T4335] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  275.279521][ T4335] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  275.280201][ T4335] Call Trace:\n[  275.280499][ T4335]  <TASK>\n[ 275.280751][ T4335] ? die (arch/x86/kernel/dumpstack.c:421 arch/x86/kernel/dumpstack.c:434 arch/x86/kernel/dumpstack.c:447)\n[ 275.281087][ T4335] ? do_trap (arch/x86/kernel/traps.c:112 arch/x86/kernel/traps.c:153)\n[ 275.281463][ T4335] ? try_get_folio (include/linux/page_ref.h:275 (discriminator 3) mm/gup.c:79 (discriminator 3))\n[ 275.281884][ T4335] ? try_get_folio (include/linux/page_ref.h:275 (discriminator 3) mm/gup.c:79 (discriminator 3))\n[ 275.282300][ T4335] ? do_error_trap (arch/x86/kernel/traps.c:174)\n[ 275.282711][ T4335] ? try_get_folio (include/linux/page_ref.h:275 (discriminator 3) mm/gup.c:79 (discriminator 3))\n[ 275.283129][ T4335] ? handle_invalid_op (arch/x86/kernel/traps.c:212)\n[ 275.283561][ T4335] ? try_get_folio (include/linux/page_ref.h:275 (discriminator 3) mm/gup.c:79 (discriminator 3))\n[ 275.283990][ T4335] ? exc_invalid_op (arch/x86/kernel/traps.c:264)\n[ 275.284415][ T4335] ? asm_exc_invalid_op (arch/x86/include/asm/idtentry.h:568)\n[ 275.284859][ T4335] ? try_get_folio (include/linux/page_ref.h:275 (discriminator 3) mm/gup.c:79 (discriminator 3))\n[ 275.285278][ T4335] try_grab_folio (mm/gup.c:148)\n[ 275.285684][ T4335] __get_user_pages (mm/gup.c:1297 (discriminator 1))\n[ 275.286111][ T4335] ? __pfx___get_user_pages (mm/gup.c:1188)\n[ 275.286579][ T4335] ? __pfx_validate_chain (kernel/locking/lockdep.c:3825)\n[ 275.287034][ T4335] ? mark_lock (kernel/locking/lockdep.c:4656 (discriminator 1))\n[ 275.287416][ T4335] __gup_longterm_locked (mm/gup.c:1509 mm/gup.c:2209)\n[ 275.288192][ T4335] ? __pfx___gup_longterm_locked (mm/gup.c:2204)\n[ 275.288697][ T4335] ? __pfx_lock_acquire (kernel/locking/lockdep.c:5722)\n[ 275.289135][ T4335] ? __pfx___might_resched (kernel/sched/core.c:10106)\n[ 275.289595][ T4335] pin_user_pages_remote (mm/gup.c:3350)\n[ 275.290041][ T4335] ? __pfx_pin_user_pages_remote (mm/gup.c:3350)\n[ 275.290545][ T4335] ? find_held_lock (kernel/locking/lockdep.c:5244 (discriminator 1))\n[ 275.290961][ T4335] ? mm_access (kernel/fork.c:1573)\n[ 275.291353][ T4335] process_vm_rw_single_vec+0x142/0x360\n[ 275.291900][ T4335] ? __pfx_process_vm_rw_single_vec+0x10/0x10\n[ 275.292471][ T4335] ? mm_access (kernel/fork.c:1573)\n[ 275.292859][ T4335] process_vm_rw_core+0x272/0x4e0\n[ 275.293384][ T4335] ? hlock_class (a\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/16380f52b72166d6a33b508cc2509716f436253f",
      "https://git.kernel.org/stable/c/e7db2762ea3e69f215b3ec4db666006deccc37b4",
      "https://git.kernel.org/stable/c/fa2690af573dfefb47ba6eef888797a64b6b5f3c"
    ],
    "受影响版本": [
      "57edfcfd3419b4799353d8cbd6ce49da075cfdbd",
      "57edfcfd3419b4799353d8cbd6ce49da075cfdbd",
      "57edfcfd3419b4799353d8cbd6ce49da075cfdbd"
    ],
    "公开日期": "2024年08月08日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42250",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncachefiles: add missing lock protection when polling\n\nAdd missing lock protection in poll routine when iterating xarray,\notherwise:\n\nEven with RCU read lock held, only the slot of the radix tree is\nensured to be pinned there, while the data structure (e.g. struct\ncachefiles_req) stored in the slot has no such guarantee.  The poll\nroutine will iterate the radix tree and dereference cachefiles_req\naccordingly.  Thus RCU read lock is not adequate in this case and\nspinlock is needed here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/97cfd5e20ddc2e33e16ce369626ce76c9a475fd7",
      "https://git.kernel.org/stable/c/6bb6bd3dd6f382dfd36220d4b210a0c77c066651",
      "https://git.kernel.org/stable/c/8eadcab7f3dd809edbe5ae20533ff843dfea3a07",
      "https://git.kernel.org/stable/c/cf5bb09e742a9cf6349127e868329a8f69b7a014"
    ],
    "受影响版本": [
      "0e19a18f998dcabe8be590e0b39660a1f230209b",
      "18943864342705fa18dd4e6b8d608491fec81f6e",
      "b817e22b2e91257ace32a6768c3c003faeaa1c5c",
      "b817e22b2e91257ace32a6768c3c003faeaa1c5c"
    ],
    "公开日期": "2024年08月07日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42243",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/filemap: make MAX_PAGECACHE_ORDER acceptable to xarray\n\nPatch series \"mm/filemap: Limit page cache size to that supported by\nxarray\", v2.\n\nCurrently, xarray can't support arbitrary page cache size.  More details\ncan be found from the WARN_ON() statement in xas_split_alloc().  In our\ntest whose code is attached below, we hit the WARN_ON() on ARM64 system\nwhere the base page size is 64KB and huge page size is 512MB.  The issue\nwas reported long time ago and some discussions on it can be found here\n[1].\n\n[1] https://www.spinics.net/lists/linux-xfs/msg75404.html\n\nIn order to fix the issue, we need to adjust MAX_PAGECACHE_ORDER to one\nsupported by xarray and avoid PMD-sized page cache if needed.  The code\nchanges are suggested by David Hildenbrand.\n\nPATCH[1] adjusts MAX_PAGECACHE_ORDER to that supported by xarray\nPATCH[2-3] avoids PMD-sized page cache in the synchronous readahead path\nPATCH[4] avoids PMD-sized page cache for shmem files if needed\n\nTest program\n============\n# cat test.c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n\n#define TEST_XFS_FILENAME\t\"/tmp/data\"\n#define TEST_SHMEM_FILENAME\t\"/dev/shm/data\"\n#define TEST_MEM_SIZE\t\t0x20000000\n\nint main(int argc, char **argv)\n{\n\tconst char *filename;\n\tint fd = 0;\n\tvoid *buf = (void *)-1, *p;\n\tint pgsize = getpagesize();\n\tint ret;\n\n\tif (pgsize != 0x10000) {\n\t\tfprintf(stderr, \"64KB base page size is required\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tsystem(\"echo force > /sys/kernel/mm/transparent_hugepage/shmem_enabled\");\n\tsystem(\"rm -fr /tmp/data\");\n\tsystem(\"rm -fr /dev/shm/data\");\n\tsystem(\"echo 1 > /proc/sys/vm/drop_caches\");\n\n\t/* Open xfs or shmem file */\n\tfilename = TEST_XFS_FILENAME;\n\tif (argc > 1 && !strcmp(argv[1], \"shmem\"))\n\t\tfilename = TEST_SHMEM_FILENAME;\n\n\tfd = open(filename, O_CREAT | O_RDWR | O_TRUNC);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Unable to open <%s>\\n\", filename);\n\t\treturn -EIO;\n\t}\n\n\t/* Extend file size */\n\tret = ftruncate(fd, TEST_MEM_SIZE);\n\tif (ret) {\n\t\tfprintf(stderr, \"Error %d to ftruncate()\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* Create VMA */\n\tbuf = mmap(NULL, TEST_MEM_SIZE,\n\t\t   PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == (void *)-1) {\n\t\tfprintf(stderr, \"Unable to mmap <%s>\\n\", filename);\n\t\tgoto cleanup;\n\t}\n\n\tfprintf(stdout, \"mapped buffer at 0x%p\\n\", buf);\n\tret = madvise(buf, TEST_MEM_SIZE, MADV_HUGEPAGE);\n        if (ret) {\n\t\tfprintf(stderr, \"Unable to madvise(MADV_HUGEPAGE)\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Populate VMA */\n\tret = madvise(buf, TEST_MEM_SIZE, MADV_POPULATE_WRITE);\n\tif (ret) {\n\t\tfprintf(stderr, \"Error %d to madvise(MADV_POPULATE_WRITE)\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\t/* Punch the file to enforce xarray split */\n\tret = fallocate(fd, FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE,\n        \t\tTEST_MEM_SIZE - pgsize, pgsize);\n\tif (ret)\n\t\tfprintf(stderr, \"Error %d to fallocate()\\n\", ret);\n\ncleanup:\n\tif (buf != (void *)-1)\n\t\tmunmap(buf, TEST_MEM_SIZE);\n\tif (fd > 0)\n\t\tclose(fd);\n\n\treturn 0;\n}\n\n# gcc test.c -o test\n# cat /proc/1/smaps | grep KernelPageSize | head -n 1\nKernelPageSize:       64 kB\n# ./test shmem\n   :\n------------[ cut here ]------------\nWARNING: CPU: 17 PID: 5253 at lib/xarray.c:1025 xas_split_alloc+0xf8/0x128\nModules linked in: nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib  \\\nnft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct    \\\nnft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4    \\\nip_set nf_tables rfkill nfnetlink vfat fat virtio_balloon          \\\ndrm fuse xfs libcrc32c crct10dif_ce ghash_ce sha2_ce sha256_arm64  \\\nvirtio_net sha1_ce net_failover failover virtio_console virtio_blk \\\ndimlib virtio_mmio\nCPU: 17 PID: 5253 Comm: test Kdump: loaded Tainted: G W 6.10.0-rc5-gavin+ #12\nHardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-1.el9 05/24/2024\npstate: 83400005 (Nzcv daif +PAN -UAO +TC\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a0c42ddd0969fdc760a85e20e267776028a7ca4e",
      "https://git.kernel.org/stable/c/333c5539a31f48828456aa9997ec2808f06a699a",
      "https://git.kernel.org/stable/c/099d90642a711caae377f53309abfe27e8724a8b"
    ],
    "受影响版本": [
      "793917d997df2e432f3e9ac126e4482d68256d01",
      "793917d997df2e432f3e9ac126e4482d68256d01",
      "793917d997df2e432f3e9ac126e4482d68256d01"
    ],
    "公开日期": "2024年08月07日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42149",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs: don't misleadingly warn during thaw operations\n\nThe block device may have been frozen before it was claimed by a\nfilesystem. Concurrently another process might try to mount that\nfrozen block device and has temporarily claimed the block device for\nthat purpose causing a concurrent fs_bdev_thaw() to end up here. The\nmounter is already about to abort mounting because they still saw an\nelevanted bdev->bd_fsfreeze_count so get_bdev_super() will return\nNULL in that case.\n\nFor example, P1 calls dm_suspend() which calls into bdev_freeze() before\nthe block device has been claimed by the filesystem. This brings\nbdev->bd_fsfreeze_count to 1 and no call into fs_bdev_freeze() is\nrequired.\n\nNow P2 tries to mount that frozen block device. It claims it and checks\nbdev->bd_fsfreeze_count. As it's elevated it aborts mounting.\n\nIn the meantime P3 called dm_resume(). P3 sees that the block device is\nalready claimed by a filesystem and calls into fs_bdev_thaw().\n\nP3 takes a passive reference and realizes that the filesystem isn't\nready yet. P3 puts itself to sleep to wait for the filesystem to become\nready.\n\nP2 now puts the last active reference to the filesystem and marks it as\ndying. P3 gets woken, sees that the filesystem is dying and\nget_bdev_super() fails.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/25b1e3906e050d452427bc51620bb7f0a591373a",
      "https://git.kernel.org/stable/c/2ae4db5647d807efb6a87c09efaa6d1db9c905d7"
    ],
    "受影响版本": [
      "49ef8832fb1a9e0da0020eb17480fd286433bc13",
      "49ef8832fb1a9e0da0020eb17480fd286433bc13"
    ],
    "公开日期": "2024年07月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42146",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe: Add outer runtime_pm protection to xe_live_ktest@xe_dma_buf\n\nAny kunit doing any memory access should get their own runtime_pm\nouter references since they don't use the standard driver API\nentries. In special this dma_buf from the same driver.\n\nFound by pre-merge CI on adding WARN calls for unprotected\ninner callers:\n\n<6> [318.639739]     # xe_dma_buf_kunit: running xe_test_dmabuf_import_same_driver\n<4> [318.639957] ------------[ cut here ]------------\n<4> [318.639967] xe 0000:4d:00.0: Missing outer runtime PM protection\n<4> [318.640049] WARNING: CPU: 117 PID: 3832 at drivers/gpu/drm/xe/xe_pm.c:533 xe_pm_runtime_get_noresume+0x48/0x60 [xe]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0888d15ea45ba8ef4508edd1123ea5ad95b58994",
      "https://git.kernel.org/stable/c/f9116f658a6217b101e3b4e89f845775b6fb05d9"
    ],
    "受影响版本": [
      "dd08ebf6c3525a7ea2186e636df064ea47281987",
      "dd08ebf6c3525a7ea2186e636df064ea47281987"
    ],
    "公开日期": "2024年07月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42125",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw89: fw: scan offload prohibit all 6 GHz channel if no 6 GHz sband\n\nWe have some policy via BIOS to block uses of 6 GHz. In this case, 6 GHz\nsband will be NULL even if it is WiFi 7 chip. So, add NULL handling here\nto avoid crash.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ce4ba62f8bc5195a9a0d49c6235a9c99e619cadc",
      "https://git.kernel.org/stable/c/bb38626f3f97e16e6d368a9ff6daf320f3fe31d9"
    ],
    "受影响版本": [
      "4ba24331c973eb1df0d3b67b0e3f8b7cde7765a7",
      "4ba24331c973eb1df0d3b67b0e3f8b7cde7765a7"
    ],
    "公开日期": "2024年07月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42103",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix adding block group to a reclaim list and the unused list during reclaim\n\nThere is a potential parallel list adding for retrying in\nbtrfs_reclaim_bgs_work and adding to the unused list. Since the block\ngroup is removed from the reclaim list and it is on a relocation work,\nit can be added into the unused list in parallel. When that happens,\nadding it to the reclaim list will corrupt the list head and trigger\nlist corruption like below.\n\nFix it by taking fs_info->unused_bgs_lock.\n\n  [177.504][T2585409] BTRFS error (device nullb1): error relocating ch= unk 2415919104\n  [177.514][T2585409] list_del corruption. next->prev should be ff1100= 0344b119c0, but was ff11000377e87c70. (next=3Dff110002390cd9c0)\n  [177.529][T2585409] ------------[ cut here ]------------\n  [177.537][T2585409] kernel BUG at lib/list_debug.c:65!\n  [177.545][T2585409] Oops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTI\n  [177.555][T2585409] CPU: 9 PID: 2585409 Comm: kworker/u128:2 Tainted: G        W          6.10.0-rc5-kts #1\n  [177.568][T2585409] Hardware name: Supermicro SYS-520P-WTR/X12SPW-TF, BIOS 1.2 02/14/2022\n  [177.579][T2585409] Workqueue: events_unbound btrfs_reclaim_bgs_work[btrfs]\n  [177.589][T2585409] RIP: 0010:__list_del_entry_valid_or_report.cold+0x70/0x72\n  [177.624][T2585409] RSP: 0018:ff11000377e87a70 EFLAGS: 00010286\n  [177.633][T2585409] RAX: 000000000000006d RBX: ff11000344b119c0 RCX:0000000000000000\n  [177.644][T2585409] RDX: 000000000000006d RSI: 0000000000000008 RDI:ffe21c006efd0f40\n  [177.655][T2585409] RBP: ff110002e0509f78 R08: 0000000000000001 R09:ffe21c006efd0f08\n  [177.665][T2585409] R10: ff11000377e87847 R11: 0000000000000000 R12:ff110002390cd9c0\n  [177.676][T2585409] R13: ff11000344b119c0 R14: ff110002e0508000 R15:dffffc0000000000\n  [177.687][T2585409] FS:  0000000000000000(0000) GS:ff11000fec880000(0000) knlGS:0000000000000000\n  [177.700][T2585409] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [177.709][T2585409] CR2: 00007f06bc7b1978 CR3: 0000001021e86005 CR4:0000000000771ef0\n  [177.720][T2585409] DR0: 0000000000000000 DR1: 0000000000000000 DR2:0000000000000000\n  [177.731][T2585409] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:0000000000000400\n  [177.742][T2585409] PKRU: 55555554\n  [177.748][T2585409] Call Trace:\n  [177.753][T2585409]  <TASK>\n  [177.759][T2585409]  ? __die_body.cold+0x19/0x27\n  [177.766][T2585409]  ? die+0x2e/0x50\n  [177.772][T2585409]  ? do_trap+0x1ea/0x2d0\n  [177.779][T2585409]  ? __list_del_entry_valid_or_report.cold+0x70/0x72\n  [177.788][T2585409]  ? do_error_trap+0xa3/0x160\n  [177.795][T2585409]  ? __list_del_entry_valid_or_report.cold+0x70/0x72\n  [177.805][T2585409]  ? handle_invalid_op+0x2c/0x40\n  [177.812][T2585409]  ? __list_del_entry_valid_or_report.cold+0x70/0x72\n  [177.820][T2585409]  ? exc_invalid_op+0x2d/0x40\n  [177.827][T2585409]  ? asm_exc_invalid_op+0x1a/0x20\n  [177.834][T2585409]  ? __list_del_entry_valid_or_report.cold+0x70/0x72\n  [177.843][T2585409]  btrfs_delete_unused_bgs+0x3d9/0x14c0 [btrfs]\n\nThere is a similar retry_list code in btrfs_delete_unused_bgs(), but it is\nsafe, AFAICS. Since the block group was in the unused list, the used bytes\nshould be 0 when it was added to the unused list. Then, it checks\nblock_group->{used,reserved,pinned} are still 0 under the\nblock_group->lock. So, they should be still eligible for the unused list,\nnot the reclaim list.\n\nThe reason it is safe there it's because because we're holding\nspace_info->groups_sem in write mode.\n\nThat means no other task can allocate from the block group, so while we\nare at deleted_unused_bgs() it's not possible for other tasks to\nallocate and deallocate extents from the block group, so it can't be\nadded to the unused list or the reclaim list by anyone else.\n\nThe bug can be reproduced by btrfs/166 after a few rounds. In practice\nthis can be hit when relocation cannot find more chunk space and ends\nwith ENOSPC.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/522b39bd7163e8dc49f8cf10b9b782218ac48746",
      "https://git.kernel.org/stable/c/aa1d8cc0cc500e06b316cd6732d4e6c1388fe33c",
      "https://git.kernel.org/stable/c/f8e960be923f74a273c62478c9cab9523936752b",
      "https://git.kernel.org/stable/c/326fa14549d7969ef80d3f5beea5470cd1c8e67f",
      "https://git.kernel.org/stable/c/48f091fd50b2eb33ae5eaea9ed3c4f81603acf38"
    ],
    "受影响版本": [
      "2311fd03027d2c1b2ac4a3a41153a16352659b65",
      "15cb476ceb7da730857b8e94f06161273adb7a3a",
      "bf1e8c21f2bef7dfcdadc93b0bb2e8723639d5f7",
      "ab58fe210c40e582a9fd3d122ae21071adb5470a",
      "4eb4e85c4f818491efc67e9373aa16b123c3f522"
    ],
    "公开日期": "2024年07月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42096",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86: stop playing stack games in profile_pc()\n\nThe 'profile_pc()' function is used for timer-based profiling, which\nisn't really all that relevant any more to begin with, but it also ends\nup making assumptions based on the stack layout that aren't necessarily\nvalid.\n\nBasically, the code tries to account the time spent in spinlocks to the\ncaller rather than the spinlock, and while I support that as a concept,\nit's not worth the code complexity or the KASAN warnings when no serious\nprofiling is done using timers anyway these days.\n\nAnd the code really does depend on stack layout that is only true in the\nsimplest of cases.  We've lost the comment at some point (I think when\nthe 32-bit and 64-bit code was unified), but it used to say:\n\n\tAssume the lock function has either no stack frame or a copy\n\tof eflags from PUSHF.\n\nwhich explains why it just blindly loads a word or two straight off the\nstack pointer and then takes a minimal look at the values to just check\nif they might be eflags or the return pc:\n\n\tEflags always has bits 22 and up cleared unlike kernel addresses\n\nbut that basic stack layout assumption assumes that there isn't any lock\ndebugging etc going on that would complicate the code and cause a stack\nframe.\n\nIt causes KASAN unhappiness reported for years by syzkaller [1] and\nothers [2].\n\nWith no real practical reason for this any more, just remove the code.\n\nJust for historical interest, here's some background commits relating to\nthis code from 2006:\n\n  0cb91a229364 (\"i386: Account spinlocks to the caller during profiling for !FP kernels\")\n  31679f38d886 (\"Simplify profile_pc on x86-64\")\n\nand a code unification from 2009:\n\n  ef4512882dbe (\"x86: time_32/64.c unify profile_pc\")\n\nbut the basics of this thing actually goes back to before the git tree.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/65ebdde16e7f5da99dbf8a548fb635837d78384e",
      "https://git.kernel.org/stable/c/27c3be840911b15a3f24ed623f86153c825b6b29",
      "https://git.kernel.org/stable/c/49c09ca35a5f521d7fa18caf62fdf378f15e8aa4",
      "https://git.kernel.org/stable/c/2d07fea561d64357fb7b3f3751e653bf20306d77",
      "https://git.kernel.org/stable/c/161cef818545ecf980f0e2ebaf8ba7326ce53c2b",
      "https://git.kernel.org/stable/c/16222beb9f8e5ceb0beeb5cbe54bef16df501a92",
      "https://git.kernel.org/stable/c/a3b65c8cbc139bfce9541bc81c1bb766e5ba3f68",
      "https://git.kernel.org/stable/c/093d9603b60093a9aaae942db56107f6432a5dca"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年07月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-42086",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: chemical: bme680: Fix overflows in compensate() functions\n\nThere are cases in the compensate functions of the driver that\nthere could be overflows of variables due to bit shifting ops.\nThese implications were initially discussed here [1] and they\nwere mentioned in log message of Commit 1b3bd8592780 (\"iio:\nchemical: Add support for Bosch BME680 sensor\").\n\n[1]: https://lore.kernel.org/linux-iio/20180728114028.3c1bbe81@archlinux/",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6fa31bbe2ea8665ee970258eb8320cbf231dbe9e",
      "https://git.kernel.org/stable/c/b0af334616ed425024bf220adda0f004806b5feb",
      "https://git.kernel.org/stable/c/c326551e99f5416986074ce78bef94f6a404b517",
      "https://git.kernel.org/stable/c/7a13d1357658d3a3c1cd7b3b9543c805a6e5e6e9",
      "https://git.kernel.org/stable/c/ba1bb3e2a38a7fef1c1818dd4f2d9abbfdde553a",
      "https://git.kernel.org/stable/c/b5967393d50e3c6e632efda3ea3fdde14c1bfd0e",
      "https://git.kernel.org/stable/c/3add41bbda92938e9a528d74659dfc552796be4e",
      "https://git.kernel.org/stable/c/fdd478c3ae98c3f13628e110dce9b6cfb0d9b3c8"
    ],
    "受影响版本": [
      "1b3bd8592780c87c5eddabbe98666b086bbaee36",
      "1b3bd8592780c87c5eddabbe98666b086bbaee36",
      "1b3bd8592780c87c5eddabbe98666b086bbaee36",
      "1b3bd8592780c87c5eddabbe98666b086bbaee36",
      "1b3bd8592780c87c5eddabbe98666b086bbaee36",
      "1b3bd8592780c87c5eddabbe98666b086bbaee36",
      "1b3bd8592780c87c5eddabbe98666b086bbaee36",
      "1b3bd8592780c87c5eddabbe98666b086bbaee36"
    ],
    "公开日期": "2024年07月29日"
  },
  {
    "设备品牌": "jupyterhub",
    "设备类型": "OTA",
    "产品型号": "jupyterhub",
    "CVE编号": "CVE-2024-41942",
    "漏洞描述": "JupyterHub is software that allows one to create a multi-user server for Jupyter notebooks. Prior to versions 4.1.6 and 5.1.0, if a user is granted the `admin:users` scope, they may escalate their own privileges by making themselves a full admin user. The impact is relatively small in that `admin:users` is already an extremely privileged scope only granted to trusted users.\nIn effect, `admin:users` is equivalent to `admin=True`, which is not intended. Note that the change here only prevents escalation to the built-in JupyterHub admin role that has unrestricted permissions. It does not prevent users with e.g. `groups` permissions from granting themselves or other users permissions via group membership, which is intentional. Versions 4.1.6 and 5.1.0 fix this issue.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/jupyterhub/jupyterhub/security/advisories/GHSA-9x4q-3gxw-849f",
      "https://github.com/jupyterhub/jupyterhub/commit/99e2720b0fc626cbeeca3c6337f917fdacfaa428",
      "https://github.com/jupyterhub/jupyterhub/commit/ff2db557a85b6980f90c3158634bf924063ab8ba"
    ],
    "受影响版本": [
      "< 4.1.6",
      ">= 5.0.0, < 5.1.0"
    ],
    "公开日期": "2024年08月08日"
  },
  {
    "设备品牌": "canonical",
    "设备类型": "OTA",
    "产品型号": "operator",
    "CVE编号": "CVE-2024-41129",
    "漏洞描述": "The ops library is a Python framework for developing and testing Kubernetes and machine charms. The issue here is that ops passes the secret content as one of the args via CLI. This issue may affect any of the charms that are using: Juju (>=3.0), Juju secrets and not correctly capturing and processing `subprocess.CalledProcessError`. This vulnerability is fixed in 2.15.0.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://github.com/canonical/operator/security/advisories/GHSA-hcmv-jmqh-fjgm",
      "https://github.com/canonical/operator/commit/fea6d2072435a62170d4c01272572f1a7e916e61"
    ],
    "受影响版本": [
      ">= 2.0.0, < 2.15.0"
    ],
    "公开日期": "2024年07月22日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-41094",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/fbdev-dma: Only set smem_start is enable per module option\n\nOnly export struct fb_info.fix.smem_start if that is required by the\nuser and the memory does not come from vmalloc().\n\nSetting struct fb_info.fix.smem_start breaks systems where DMA\nmemory is backed by vmalloc address space. An example error is\nshown below.\n\n[    3.536043] ------------[ cut here ]------------\n[    3.540716] virt_to_phys used for non-linear address: 000000007fc4f540 (0xffff800086001000)\n[    3.552628] WARNING: CPU: 4 PID: 61 at arch/arm64/mm/physaddr.c:12 __virt_to_phys+0x68/0x98\n[    3.565455] Modules linked in:\n[    3.568525] CPU: 4 PID: 61 Comm: kworker/u12:5 Not tainted 6.6.23-06226-g4986cc3e1b75-dirty #250\n[    3.577310] Hardware name: NXP i.MX95 19X19 board (DT)\n[    3.582452] Workqueue: events_unbound deferred_probe_work_func\n[    3.588291] pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    3.595233] pc : __virt_to_phys+0x68/0x98\n[    3.599246] lr : __virt_to_phys+0x68/0x98\n[    3.603276] sp : ffff800083603990\n[    3.677939] Call trace:\n[    3.680393]  __virt_to_phys+0x68/0x98\n[    3.684067]  drm_fbdev_dma_helper_fb_probe+0x138/0x238\n[    3.689214]  __drm_fb_helper_initial_config_and_unlock+0x2b0/0x4c0\n[    3.695385]  drm_fb_helper_initial_config+0x4c/0x68\n[    3.700264]  drm_fbdev_dma_client_hotplug+0x8c/0xe0\n[    3.705161]  drm_client_register+0x60/0xb0\n[    3.709269]  drm_fbdev_dma_setup+0x94/0x148\n\nAdditionally, DMA memory is assumed to by contiguous in physical\naddress space, which is not guaranteed by vmalloc().\n\nResolve this by checking the module flag drm_leak_fbdev_smem when\nDRM allocated the instance of struct fb_info. Fbdev-dma then only\nsets smem_start only if required (via FBINFO_HIDE_SMEM_START). Also\nguarantee that the framebuffer is not located in vmalloc address\nspace.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f29fcfbf6067c0d8c83f84a045da9276c08deac5",
      "https://git.kernel.org/stable/c/00702cfa8432ac67a72f56de5e1d278ddea2ebde",
      "https://git.kernel.org/stable/c/d92a7580392ad4681b1d4f9275d00b95375ebe01"
    ],
    "受影响版本": [
      "a51c7663f144606a5f08e772fa3e1e4f2277a614",
      "a51c7663f144606a5f08e772fa3e1e4f2277a614",
      "a51c7663f144606a5f08e772fa3e1e4f2277a614"
    ],
    "公开日期": "2024年07月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-41092",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915/gt: Fix potential UAF by revoke of fence registers\n\nCI has been sporadically reporting the following issue triggered by\nigt@i915_selftest@live@hangcheck on ADL-P and similar machines:\n\n<6> [414.049203] i915: Running intel_hangcheck_live_selftests/igt_reset_evict_fence\n...\n<6> [414.068804] i915 0000:00:02.0: [drm] GT0: GUC: submission enabled\n<6> [414.068812] i915 0000:00:02.0: [drm] GT0: GUC: SLPC enabled\n<3> [414.070354] Unable to pin Y-tiled fence; err:-4\n<3> [414.071282] i915_vma_revoke_fence:301 GEM_BUG_ON(!i915_active_is_idle(&fence->active))\n...\n<4>[  609.603992] ------------[ cut here ]------------\n<2>[  609.603995] kernel BUG at drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:301!\n<4>[  609.604003] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n<4>[  609.604006] CPU: 0 PID: 268 Comm: kworker/u64:3 Tainted: G     U  W          6.9.0-CI_DRM_14785-g1ba62f8cea9c+ #1\n<4>[  609.604008] Hardware name: Intel Corporation Alder Lake Client Platform/AlderLake-P DDR4 RVP, BIOS RPLPFWI1.R00.4035.A00.2301200723 01/20/2023\n<4>[  609.604010] Workqueue: i915 __i915_gem_free_work [i915]\n<4>[  609.604149] RIP: 0010:i915_vma_revoke_fence+0x187/0x1f0 [i915]\n...\n<4>[  609.604271] Call Trace:\n<4>[  609.604273]  <TASK>\n...\n<4>[  609.604716]  __i915_vma_evict+0x2e9/0x550 [i915]\n<4>[  609.604852]  __i915_vma_unbind+0x7c/0x160 [i915]\n<4>[  609.604977]  force_unbind+0x24/0xa0 [i915]\n<4>[  609.605098]  i915_vma_destroy+0x2f/0xa0 [i915]\n<4>[  609.605210]  __i915_gem_object_pages_fini+0x51/0x2f0 [i915]\n<4>[  609.605330]  __i915_gem_free_objects.isra.0+0x6a/0xc0 [i915]\n<4>[  609.605440]  process_scheduled_works+0x351/0x690\n...\n\nIn the past, there were similar failures reported by CI from other IGT\ntests, observed on other platforms.\n\nBefore commit 63baf4f3d587 (\"drm/i915/gt: Only wait for GPU activity\nbefore unbinding a GGTT fence\"), i915_vma_revoke_fence() was waiting for\nidleness of vma->active via fence_update().   That commit introduced\nvma->fence->active in order for the fence_update() to be able to wait\nselectively on that one instead of vma->active since only idleness of\nfence registers was needed.  But then, another commit 0d86ee35097a\n(\"drm/i915/gt: Make fence revocation unequivocal\") replaced the call to\nfence_update() in i915_vma_revoke_fence() with only fence_write(), and\nalso added that GEM_BUG_ON(!i915_active_is_idle(&fence->active)) in front.\nNo justification was provided on why we might then expect idleness of\nvma->fence->active without first waiting on it.\n\nThe issue can be potentially caused by a race among revocation of fence\nregisters on one side and sequential execution of signal callbacks invoked\non completion of a request that was using them on the other, still\nprocessed in parallel to revocation of those fence registers.  Fix it by\nwaiting for idleness of vma->fence->active in i915_vma_revoke_fence().\n\n(cherry picked from commit 24bb052d3dd499c5956abad5f7d8e4fd07da7fb1)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f771b91f21c46ad1217328d05e72a2c7e3add535",
      "https://git.kernel.org/stable/c/29c0fdf49078ab161570d3d1c6e13d66f182717d",
      "https://git.kernel.org/stable/c/ca0fabd365a27a94a36e68a7a02df8ff3c13dac6",
      "https://git.kernel.org/stable/c/06dec31a0a5112a91f49085e8a8fa1a82296d5c7",
      "https://git.kernel.org/stable/c/414f4a31f7a811008fd9a33b06216b060bad18fc",
      "https://git.kernel.org/stable/c/996c3412a06578e9d779a16b9e79ace18125ab50"
    ],
    "受影响版本": [
      "0d86ee35097ae0f1c2c50f2b8035ef480e25e4f1",
      "0d86ee35097ae0f1c2c50f2b8035ef480e25e4f1",
      "0d86ee35097ae0f1c2c50f2b8035ef480e25e4f1",
      "0d86ee35097ae0f1c2c50f2b8035ef480e25e4f1",
      "0d86ee35097ae0f1c2c50f2b8035ef480e25e4f1",
      "0d86ee35097ae0f1c2c50f2b8035ef480e25e4f1"
    ],
    "公开日期": "2024年07月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-41068",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/sclp: Fix sclp_init() cleanup on failure\n\nIf sclp_init() fails it only partially cleans up: if there are multiple\nfailing calls to sclp_init() sclp_state_change_event will be added several\ntimes to sclp_reg_list, which results in the following warning:\n\n------------[ cut here ]------------\nlist_add double add: new=000003ffe1598c10, prev=000003ffe1598bf0, next=000003ffe1598c10.\nWARNING: CPU: 0 PID: 1 at lib/list_debug.c:35 __list_add_valid_or_report+0xde/0xf8\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 6.10.0-rc3\nKrnl PSW : 0404c00180000000 000003ffe0d6076a (__list_add_valid_or_report+0xe2/0xf8)\n           R:0 T:1 IO:0 EX:0 Key:0 M:1 W:0 P:0 AS:3 CC:0 PM:0 RI:0 EA:3\n...\nCall Trace:\n [<000003ffe0d6076a>] __list_add_valid_or_report+0xe2/0xf8\n([<000003ffe0d60766>] __list_add_valid_or_report+0xde/0xf8)\n [<000003ffe0a8d37e>] sclp_init+0x40e/0x450\n [<000003ffe00009f2>] do_one_initcall+0x42/0x1e0\n [<000003ffe15b77a6>] do_initcalls+0x126/0x150\n [<000003ffe15b7a0a>] kernel_init_freeable+0x1ba/0x1f8\n [<000003ffe0d6650e>] kernel_init+0x2e/0x180\n [<000003ffe000301c>] __ret_from_fork+0x3c/0x60\n [<000003ffe0d759ca>] ret_from_fork+0xa/0x30\n\nFix this by removing sclp_state_change_event from sclp_reg_list when\nsclp_init() fails.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a778987afc36d5dc02a1f82d352a81edcaf7eb83",
      "https://git.kernel.org/stable/c/455a6653d8700a81aa8ed2b6442a3be476007090",
      "https://git.kernel.org/stable/c/2e51db7ab71b89dc5a17068f5e201c69f13a4c9a",
      "https://git.kernel.org/stable/c/cf521049fcd07071ed42dc9758fce7d5ee120ec6",
      "https://git.kernel.org/stable/c/79b4be70d5a160969b805f638ac5b4efd0aac7a3",
      "https://git.kernel.org/stable/c/0a31b3fdc7e735c4f8c65fe4339945c717ed6808",
      "https://git.kernel.org/stable/c/be0259796d0b76bbc7461e12c186814a9e58244c",
      "https://git.kernel.org/stable/c/6434b33faaa063df500af355ee6c3942e0f8d982"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年07月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-41031",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/filemap: skip to create PMD-sized page cache if needed\n\nOn ARM64, HPAGE_PMD_ORDER is 13 when the base page size is 64KB.  The\nPMD-sized page cache can't be supported by xarray as the following error\nmessages indicate.\n\n------------[ cut here ]------------\nWARNING: CPU: 35 PID: 7484 at lib/xarray.c:1025 xas_split_alloc+0xf8/0x128\nModules linked in: nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib  \\\nnft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct    \\\nnft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4    \\\nip_set rfkill nf_tables nfnetlink vfat fat virtio_balloon drm      \\\nfuse xfs libcrc32c crct10dif_ce ghash_ce sha2_ce sha256_arm64      \\\nsha1_ce virtio_net net_failover virtio_console virtio_blk failover \\\ndimlib virtio_mmio\nCPU: 35 PID: 7484 Comm: test Kdump: loaded Tainted: G W 6.10.0-rc5-gavin+ #9\nHardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-1.el9 05/24/2024\npstate: 83400005 (Nzcv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--)\npc : xas_split_alloc+0xf8/0x128\nlr : split_huge_page_to_list_to_order+0x1c4/0x720\nsp : ffff800087a4f6c0\nx29: ffff800087a4f6c0 x28: ffff800087a4f720 x27: 000000001fffffff\nx26: 0000000000000c40 x25: 000000000000000d x24: ffff00010625b858\nx23: ffff800087a4f720 x22: ffffffdfc0780000 x21: 0000000000000000\nx20: 0000000000000000 x19: ffffffdfc0780000 x18: 000000001ff40000\nx17: 00000000ffffffff x16: 0000018000000000 x15: 51ec004000000000\nx14: 0000e00000000000 x13: 0000000000002000 x12: 0000000000000020\nx11: 51ec000000000000 x10: 51ece1c0ffff8000 x9 : ffffbeb961a44d28\nx8 : 0000000000000003 x7 : ffffffdfc0456420 x6 : ffff0000e1aa6eb8\nx5 : 20bf08b4fe778fca x4 : ffffffdfc0456420 x3 : 0000000000000c40\nx2 : 000000000000000d x1 : 000000000000000c x0 : 0000000000000000\nCall trace:\n xas_split_alloc+0xf8/0x128\n split_huge_page_to_list_to_order+0x1c4/0x720\n truncate_inode_partial_folio+0xdc/0x160\n truncate_inode_pages_range+0x1b4/0x4a8\n truncate_pagecache_range+0x84/0xa0\n xfs_flush_unmap_range+0x70/0x90 [xfs]\n xfs_file_fallocate+0xfc/0x4d8 [xfs]\n vfs_fallocate+0x124/0x2e8\n ksys_fallocate+0x4c/0xa0\n __arm64_sys_fallocate+0x24/0x38\n invoke_syscall.constprop.0+0x7c/0xd8\n do_el0_svc+0xb4/0xd0\n el0_svc+0x44/0x1d8\n el0t_64_sync_handler+0x134/0x150\n el0t_64_sync+0x17c/0x180\n\nFix it by skipping to allocate PMD-sized page cache when its size is\nlarger than MAX_PAGECACHE_ORDER.  For this specific case, we will fall to\nregular path where the readahead window is determined by BDI's sysfs file\n(read_ahead_kb).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/06b5a69c27ec405a3c3f2da8520ff1ee70b94a21",
      "https://git.kernel.org/stable/c/1ef650d3b1b2a16473981b447f38705fe9b93972",
      "https://git.kernel.org/stable/c/3390916aca7af1893ed2ebcdfee1d6fdb65bb058"
    ],
    "受影响版本": [
      "4687fdbb805a92ce5a9f23042c436dc64fef8b77",
      "4687fdbb805a92ce5a9f23042c436dc64fef8b77",
      "4687fdbb805a92ce5a9f23042c436dc64fef8b77"
    ],
    "公开日期": "2024年07月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-41030",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: discard write access to the directory open\n\nmay_open() does not allow a directory to be opened with the write access.\nHowever, some writing flags set by client result in adding write access\non server, making ksmbd incompatible with FUSE file system. Simply, let's\ndiscard the write access when opening a directory.\n\nlist_add corruption. next is NULL.\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:26!\npc : __list_add_valid+0x88/0xbc\nlr : __list_add_valid+0x88/0xbc\nCall trace:\n__list_add_valid+0x88/0xbc\nfuse_finish_open+0x11c/0x170\nfuse_open_common+0x284/0x5e8\nfuse_dir_open+0x14/0x24\ndo_dentry_open+0x2a4/0x4e0\ndentry_open+0x50/0x80\nsmb2_open+0xbe4/0x15a4\nhandle_ksmbd_work+0x478/0x5ec\nprocess_one_work+0x1b4/0x448\nworker_thread+0x25c/0x430\nkthread+0x104/0x1d4\nret_from_fork+0x10/0x20",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/66cf853e1c7a2407f15d9f7aaa3e47d61745e361",
      "https://git.kernel.org/stable/c/9e84b1ba5c98fb5c9f869c85db1d870354613baa",
      "https://git.kernel.org/stable/c/198498b2049c0f11f7670be6974570e02b0cc035",
      "https://git.kernel.org/stable/c/e2e33caa5dc2eae7bddf88b22ce11ec3d760e5cd"
    ],
    "受影响版本": [
      "0626e6641f6b467447c81dd7678a69c66f7746cf",
      "0626e6641f6b467447c81dd7678a69c66f7746cf",
      "0626e6641f6b467447c81dd7678a69c66f7746cf",
      "0626e6641f6b467447c81dd7678a69c66f7746cf"
    ],
    "公开日期": "2024年07月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-41004",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Build event generation tests only as modules\n\nThe kprobes and synth event generation test modules add events and lock\n(get a reference) those event file reference in module init function,\nand unlock and delete it in module exit function. This is because those\nare designed for playing as modules.\n\nIf we make those modules as built-in, those events are left locked in the\nkernel, and never be removed. This causes kprobe event self-test failure\nas below.\n\n[   97.349708] ------------[ cut here ]------------\n[   97.353453] WARNING: CPU: 3 PID: 1 at kernel/trace/trace_kprobe.c:2133 kprobe_trace_self_tests_init+0x3f1/0x480\n[   97.357106] Modules linked in:\n[   97.358488] CPU: 3 PID: 1 Comm: swapper/0 Not tainted 6.9.0-g699646734ab5-dirty #14\n[   97.361556] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n[   97.363880] RIP: 0010:kprobe_trace_self_tests_init+0x3f1/0x480\n[   97.365538] Code: a8 24 08 82 e9 ae fd ff ff 90 0f 0b 90 48 c7 c7 e5 aa 0b 82 e9 ee fc ff ff 90 0f 0b 90 48 c7 c7 2d 61 06 82 e9 8e fd ff ff 90 <0f> 0b 90 48 c7 c7 33 0b 0c 82 89 c6 e8 6e 03 1f ff 41 ff c7 e9 90\n[   97.370429] RSP: 0000:ffffc90000013b50 EFLAGS: 00010286\n[   97.371852] RAX: 00000000fffffff0 RBX: ffff888005919c00 RCX: 0000000000000000\n[   97.373829] RDX: ffff888003f40000 RSI: ffffffff8236a598 RDI: ffff888003f40a68\n[   97.375715] RBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000\n[   97.377675] R10: ffffffff811c9ae5 R11: ffffffff8120c4e0 R12: 0000000000000000\n[   97.379591] R13: 0000000000000001 R14: 0000000000000015 R15: 0000000000000000\n[   97.381536] FS:  0000000000000000(0000) GS:ffff88807dcc0000(0000) knlGS:0000000000000000\n[   97.383813] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   97.385449] CR2: 0000000000000000 CR3: 0000000002244000 CR4: 00000000000006b0\n[   97.387347] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[   97.389277] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[   97.391196] Call Trace:\n[   97.391967]  <TASK>\n[   97.392647]  ? __warn+0xcc/0x180\n[   97.393640]  ? kprobe_trace_self_tests_init+0x3f1/0x480\n[   97.395181]  ? report_bug+0xbd/0x150\n[   97.396234]  ? handle_bug+0x3e/0x60\n[   97.397311]  ? exc_invalid_op+0x1a/0x50\n[   97.398434]  ? asm_exc_invalid_op+0x1a/0x20\n[   97.399652]  ? trace_kprobe_is_busy+0x20/0x20\n[   97.400904]  ? tracing_reset_all_online_cpus+0x15/0x90\n[   97.402304]  ? kprobe_trace_self_tests_init+0x3f1/0x480\n[   97.403773]  ? init_kprobe_trace+0x50/0x50\n[   97.404972]  do_one_initcall+0x112/0x240\n[   97.406113]  do_initcall_level+0x95/0xb0\n[   97.407286]  ? kernel_init+0x1a/0x1a0\n[   97.408401]  do_initcalls+0x3f/0x70\n[   97.409452]  kernel_init_freeable+0x16f/0x1e0\n[   97.410662]  ? rest_init+0x1f0/0x1f0\n[   97.411738]  kernel_init+0x1a/0x1a0\n[   97.412788]  ret_from_fork+0x39/0x50\n[   97.413817]  ? rest_init+0x1f0/0x1f0\n[   97.414844]  ret_from_fork_asm+0x11/0x20\n[   97.416285]  </TASK>\n[   97.417134] irq event stamp: 13437323\n[   97.418376] hardirqs last  enabled at (13437337): [<ffffffff8110bc0c>] console_unlock+0x11c/0x150\n[   97.421285] hardirqs last disabled at (13437370): [<ffffffff8110bbf1>] console_unlock+0x101/0x150\n[   97.423838] softirqs last  enabled at (13437366): [<ffffffff8108e17f>] handle_softirqs+0x23f/0x2a0\n[   97.426450] softirqs last disabled at (13437393): [<ffffffff8108e346>] __irq_exit_rcu+0x66/0xd0\n[   97.428850] ---[ end trace 0000000000000000 ]---\n\nAnd also, since we can not cleanup dynamic_event file, ftracetest are\nfailed too.\n\nTo avoid these issues, build these tests only as modules.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a85bae262ccecc52a40c466ec067f6c915e0839d",
      "https://git.kernel.org/stable/c/98a7bfc48fffe170a60d87a5cbb7cdddf08184c3",
      "https://git.kernel.org/stable/c/32ef4dc2b1caf5825c0cf50646479608311cafc3",
      "https://git.kernel.org/stable/c/55d5d08174366efe57ca9e79964828b20c626c45",
      "https://git.kernel.org/stable/c/72a0199b361df2387018697b023fdcdd357449a9",
      "https://git.kernel.org/stable/c/3572bd5689b0812b161b40279e39ca5b66d73e88"
    ],
    "受影响版本": [
      "9fe41efaca08416657efa8731c0d47ccb6a3f3eb",
      "9fe41efaca08416657efa8731c0d47ccb6a3f3eb",
      "9fe41efaca08416657efa8731c0d47ccb6a3f3eb",
      "9fe41efaca08416657efa8731c0d47ccb6a3f3eb",
      "9fe41efaca08416657efa8731c0d47ccb6a3f3eb",
      "9fe41efaca08416657efa8731c0d47ccb6a3f3eb"
    ],
    "公开日期": "2024年07月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-41003",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix reg_set_min_max corruption of fake_reg\n\nJuan reported that after doing some changes to buzzer [0] and implementing\na new fuzzing strategy guided by coverage, they noticed the following in\none of the probes:\n\n  [...]\n  13: (79) r6 = *(u64 *)(r0 +0)         ; R0=map_value(ks=4,vs=8) R6_w=scalar()\n  14: (b7) r0 = 0                       ; R0_w=0\n  15: (b4) w0 = -1                      ; R0_w=0xffffffff\n  16: (74) w0 >>= 1                     ; R0_w=0x7fffffff\n  17: (5c) w6 &= w0                     ; R0_w=0x7fffffff R6_w=scalar(smin=smin32=0,smax=umax=umax32=0x7fffffff,var_off=(0x0; 0x7fffffff))\n  18: (44) w6 |= 2                      ; R6_w=scalar(smin=umin=smin32=umin32=2,smax=umax=umax32=0x7fffffff,var_off=(0x2; 0x7ffffffd))\n  19: (56) if w6 != 0x7ffffffd goto pc+1\n  REG INVARIANTS VIOLATION (true_reg2): range bounds violation u64=[0x7fffffff, 0x7ffffffd] s64=[0x7fffffff, 0x7ffffffd] u32=[0x7fffffff, 0x7ffffffd] s32=[0x7fffffff, 0x7ffffffd] var_off=(0x7fffffff, 0x0)\n  REG INVARIANTS VIOLATION (false_reg1): range bounds violation u64=[0x7fffffff, 0x7ffffffd] s64=[0x7fffffff, 0x7ffffffd] u32=[0x7fffffff, 0x7ffffffd] s32=[0x7fffffff, 0x7ffffffd] var_off=(0x7fffffff, 0x0)\n  REG INVARIANTS VIOLATION (false_reg2): const tnum out of sync with range bounds u64=[0x0, 0xffffffffffffffff] s64=[0x8000000000000000, 0x7fffffffffffffff] u32=[0x0, 0xffffffff] s32=[0x80000000, 0x7fffffff] var_off=(0x7fffffff, 0x0)\n  19: R6_w=0x7fffffff\n  20: (95) exit\n\n  from 19 to 21: R0=0x7fffffff R6=scalar(smin=umin=smin32=umin32=2,smax=umax=smax32=umax32=0x7ffffffe,var_off=(0x2; 0x7ffffffd)) R7=map_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map_ptr(ks=4,vs=8) fp-40=mmmmmmmm\n  21: R0=0x7fffffff R6=scalar(smin=umin=smin32=umin32=2,smax=umax=smax32=umax32=0x7ffffffe,var_off=(0x2; 0x7ffffffd)) R7=map_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map_ptr(ks=4,vs=8) fp-40=mmmmmmmm\n  21: (14) w6 -= 2147483632             ; R6_w=scalar(smin=umin=umin32=2,smax=umax=0xffffffff,smin32=0x80000012,smax32=14,var_off=(0x2; 0xfffffffd))\n  22: (76) if w6 s>= 0xe goto pc+1      ; R6_w=scalar(smin=umin=umin32=2,smax=umax=0xffffffff,smin32=0x80000012,smax32=13,var_off=(0x2; 0xfffffffd))\n  23: (95) exit\n\n  from 22 to 24: R0=0x7fffffff R6_w=14 R7=map_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map_ptr(ks=4,vs=8) fp-40=mmmmmmmm\n  24: R0=0x7fffffff R6_w=14 R7=map_ptr(ks=4,vs=8) R9=ctx() R10=fp0 fp-24=map_ptr(ks=4,vs=8) fp-40=mmmmmmmm\n  24: (14) w6 -= 14                     ; R6_w=0\n  [...]\n\nWhat can be seen here is a register invariant violation on line 19. After\nthe binary-or in line 18, the verifier knows that bit 2 is set but knows\nnothing about the rest of the content which was loaded from a map value,\nmeaning, range is [2,0x7fffffff] with var_off=(0x2; 0x7ffffffd). When in\nline 19 the verifier analyzes the branch, it splits the register states\nin reg_set_min_max() into the registers of the true branch (true_reg1,\ntrue_reg2) and the registers of the false branch (false_reg1, false_reg2).\n\nSince the test is w6 != 0x7ffffffd, the src_reg is a known constant.\nInternally, the verifier creates a \"fake\" register initialized as scalar\nto the value of 0x7ffffffd, and then passes it onto reg_set_min_max(). Now,\nfor line 19, it is mathematically impossible to take the false branch of\nthis program, yet the verifier analyzes it. It is impossible because the\nsecond bit of r6 will be set due to the prior or operation and the\nconstant in the condition has that bit unset (hex(fd) == binary(1111 1101).\n\nWhen the verifier first analyzes the false / fall-through branch, it will\ncompute an intersection between the var_off of r6 and of the constant. This\nis because the verifier creates a \"fake\" register initialized to the value\nof the constant. The intersection result later refines both registers in\nregs_refine_cond_op():\n\n  [...]\n  t = tnum_intersect(tnum_subreg(reg1->var_off), tnum_subreg(reg2->var_off));\n  reg1->var_o\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/41e8ab428a9964df378fa45760a660208712145b",
      "https://git.kernel.org/stable/c/92424801261d1564a0bb759da3cf3ccd69fdf5a2"
    ],
    "受影响版本": [
      "67420501e8681ae18f9f0ea0a69cd2f432100e70",
      "67420501e8681ae18f9f0ea0a69cd2f432100e70"
    ],
    "公开日期": "2024年07月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-41000",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock/ioctl: prefer different overflow check\n\nRunning syzkaller with the newly reintroduced signed integer overflow\nsanitizer shows this report:\n\n[   62.982337] ------------[ cut here ]------------\n[   62.985692] cgroup: Invalid name\n[   62.986211] UBSAN: signed-integer-overflow in ../block/ioctl.c:36:46\n[   62.989370] 9pnet_fd: p9_fd_create_tcp (7343): problem connecting socket to 127.0.0.1\n[   62.992992] 9223372036854775807 + 4095 cannot be represented in type 'long long'\n[   62.997827] 9pnet_fd: p9_fd_create_tcp (7345): problem connecting socket to 127.0.0.1\n[   62.999369] random: crng reseeded on system resumption\n[   63.000634] GUP no longer grows the stack in syz-executor.2 (7353): 20002000-20003000 (20001000)\n[   63.000668] CPU: 0 PID: 7353 Comm: syz-executor.2 Not tainted 6.8.0-rc2-00035-gb3ef86b5a957 #1\n[   63.000677] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[   63.000682] Call Trace:\n[   63.000686]  <TASK>\n[   63.000731]  dump_stack_lvl+0x93/0xd0\n[   63.000919]  __get_user_pages+0x903/0xd30\n[   63.001030]  __gup_longterm_locked+0x153e/0x1ba0\n[   63.001041]  ? _raw_read_unlock_irqrestore+0x17/0x50\n[   63.001072]  ? try_get_folio+0x29c/0x2d0\n[   63.001083]  internal_get_user_pages_fast+0x1119/0x1530\n[   63.001109]  iov_iter_extract_pages+0x23b/0x580\n[   63.001206]  bio_iov_iter_get_pages+0x4de/0x1220\n[   63.001235]  iomap_dio_bio_iter+0x9b6/0x1410\n[   63.001297]  __iomap_dio_rw+0xab4/0x1810\n[   63.001316]  iomap_dio_rw+0x45/0xa0\n[   63.001328]  ext4_file_write_iter+0xdde/0x1390\n[   63.001372]  vfs_write+0x599/0xbd0\n[   63.001394]  ksys_write+0xc8/0x190\n[   63.001403]  do_syscall_64+0xd4/0x1b0\n[   63.001421]  ? arch_exit_to_user_mode_prepare+0x3a/0x60\n[   63.001479]  entry_SYSCALL_64_after_hwframe+0x6f/0x77\n[   63.001535] RIP: 0033:0x7f7fd3ebf539\n[   63.001551] Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 14 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\n[   63.001562] RSP: 002b:00007f7fd32570c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[   63.001584] RAX: ffffffffffffffda RBX: 00007f7fd3ff3f80 RCX: 00007f7fd3ebf539\n[   63.001590] RDX: 4db6d1e4f7e43360 RSI: 0000000020000000 RDI: 0000000000000004\n[   63.001595] RBP: 00007f7fd3f1e496 R08: 0000000000000000 R09: 0000000000000000\n[   63.001599] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\n[   63.001604] R13: 0000000000000006 R14: 00007f7fd3ff3f80 R15: 00007ffd415ad2b8\n...\n[   63.018142] ---[ end trace ]---\n\nHistorically, the signed integer overflow sanitizer did not work in the\nkernel due to its interaction with `-fwrapv` but this has since been\nchanged [1] in the newest version of Clang; It was re-enabled in the\nkernel with Commit 557f8c582a9ba8ab (\"ubsan: Reintroduce signed overflow\nsanitizer\").\n\nLet's rework this overflow checking logic to not actually perform an\noverflow during the check itself, thus avoiding the UBSAN splat.\n\n[1]: https://github.com/llvm/llvm-project/pull/82432",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/58706e482bf45c4db48b0c53aba2468c97adda24",
      "https://git.kernel.org/stable/c/3220c90f4dbdc6d20d0608b164d964434a810d66",
      "https://git.kernel.org/stable/c/61ec76ec930709b7bcd69029ef1fe90491f20cf9",
      "https://git.kernel.org/stable/c/fd841ee01fb4a79cb7f5cc424b5c96c3a73b2d1e",
      "https://git.kernel.org/stable/c/54160fb1db2de367485f21e30196c42f7ee0be4e",
      "https://git.kernel.org/stable/c/ccb326b5f9e623eb7f130fbbf2505ec0e2dcaff9"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年07月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-40998",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix uninitialized ratelimit_state->lock access in __ext4_fill_super()\n\nIn the following concurrency we will access the uninitialized rs->lock:\n\next4_fill_super\n  ext4_register_sysfs\n   // sysfs registered msg_ratelimit_interval_ms\n                             // Other processes modify rs->interval to\n                             // non-zero via msg_ratelimit_interval_ms\n  ext4_orphan_cleanup\n    ext4_msg(sb, KERN_INFO, \"Errors on filesystem, \"\n      __ext4_msg\n        ___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state)\n          if (!rs->interval)  // do nothing if interval is 0\n            return 1;\n          raw_spin_trylock_irqsave(&rs->lock, flags)\n            raw_spin_trylock(lock)\n              _raw_spin_trylock\n                __raw_spin_trylock\n                  spin_acquire(&lock->dep_map, 0, 1, _RET_IP_)\n                    lock_acquire\n                      __lock_acquire\n                        register_lock_class\n                          assign_lock_key\n                            dump_stack();\n  ratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n    raw_spin_lock_init(&rs->lock);\n    // init rs->lock here\n\nand get the following dump_stack:\n\n=========================================================\nINFO: trying to register non-static key.\nThe code is fine but needs lockdep annotation, or maybe\nyou didn't initialize this object before use?\nturning off the locking correctness validator.\nCPU: 12 PID: 753 Comm: mount Tainted: G E 6.7.0-rc6-next-20231222 #504\n[...]\nCall Trace:\n dump_stack_lvl+0xc5/0x170\n dump_stack+0x18/0x30\n register_lock_class+0x740/0x7c0\n __lock_acquire+0x69/0x13a0\n lock_acquire+0x120/0x450\n _raw_spin_trylock+0x98/0xd0\n ___ratelimit+0xf6/0x220\n __ext4_msg+0x7f/0x160 [ext4]\n ext4_orphan_cleanup+0x665/0x740 [ext4]\n __ext4_fill_super+0x21ea/0x2b10 [ext4]\n ext4_fill_super+0x14d/0x360 [ext4]\n[...]\n=========================================================\n\nNormally interval is 0 until s_msg_ratelimit_state is initialized, so\n___ratelimit() does nothing. But registering sysfs precedes initializing\nrs->lock, so it is possible to change rs->interval to a non-zero value\nvia the msg_ratelimit_interval_ms interface of sysfs while rs->lock is\nuninitialized, and then a call to ext4_msg triggers the problem by\naccessing an uninitialized rs->lock. Therefore register sysfs after all\ninitializations are complete to avoid such problems.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/23afcd52af06880c6c913a0ad99022b8937b575c",
      "https://git.kernel.org/stable/c/645267906944a9aeec9d5c56ee24a9096a288798",
      "https://git.kernel.org/stable/c/b4b4fda34e535756f9e774fb2d09c4537b7dfd1c"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年07月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-40949",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: shmem: fix getting incorrect lruvec when replacing a shmem folio\n\nWhen testing shmem swapin, I encountered the warning below on my machine. \nThe reason is that replacing an old shmem folio with a new one causes\nmem_cgroup_migrate() to clear the old folio's memcg data.  As a result,\nthe old folio cannot get the correct memcg's lruvec needed to remove\nitself from the LRU list when it is being freed.  This could lead to\npossible serious problems, such as LRU list crashes due to holding the\nwrong LRU lock, and incorrect LRU statistics.\n\nTo fix this issue, we can fallback to use the mem_cgroup_replace_folio()\nto replace the old shmem folio.\n\n[ 5241.100311] page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x5d9960\n[ 5241.100317] head: order:4 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0\n[ 5241.100319] flags: 0x17fffe0000040068(uptodate|lru|head|swapbacked|node=0|zone=2|lastcpupid=0x3ffff)\n[ 5241.100323] raw: 17fffe0000040068 fffffdffd6687948 fffffdffd69ae008 0000000000000000\n[ 5241.100325] raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000\n[ 5241.100326] head: 17fffe0000040068 fffffdffd6687948 fffffdffd69ae008 0000000000000000\n[ 5241.100327] head: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000\n[ 5241.100328] head: 17fffe0000000204 fffffdffd6665801 ffffffffffffffff 0000000000000000\n[ 5241.100329] head: 0000000a00000010 0000000000000000 00000000ffffffff 0000000000000000\n[ 5241.100330] page dumped because: VM_WARN_ON_ONCE_FOLIO(!memcg && !mem_cgroup_disabled())\n[ 5241.100338] ------------[ cut here ]------------\n[ 5241.100339] WARNING: CPU: 19 PID: 78402 at include/linux/memcontrol.h:775 folio_lruvec_lock_irqsave+0x140/0x150\n[...]\n[ 5241.100374] pc : folio_lruvec_lock_irqsave+0x140/0x150\n[ 5241.100375] lr : folio_lruvec_lock_irqsave+0x138/0x150\n[ 5241.100376] sp : ffff80008b38b930\n[...]\n[ 5241.100398] Call trace:\n[ 5241.100399]  folio_lruvec_lock_irqsave+0x140/0x150\n[ 5241.100401]  __page_cache_release+0x90/0x300\n[ 5241.100404]  __folio_put+0x50/0x108\n[ 5241.100406]  shmem_replace_folio+0x1b4/0x240\n[ 5241.100409]  shmem_swapin_folio+0x314/0x528\n[ 5241.100411]  shmem_get_folio_gfp+0x3b4/0x930\n[ 5241.100412]  shmem_fault+0x74/0x160\n[ 5241.100414]  __do_fault+0x40/0x218\n[ 5241.100417]  do_shared_fault+0x34/0x1b0\n[ 5241.100419]  do_fault+0x40/0x168\n[ 5241.100420]  handle_pte_fault+0x80/0x228\n[ 5241.100422]  __handle_mm_fault+0x1c4/0x440\n[ 5241.100424]  handle_mm_fault+0x60/0x1f0\n[ 5241.100426]  do_page_fault+0x120/0x488\n[ 5241.100429]  do_translation_fault+0x4c/0x68\n[ 5241.100431]  do_mem_abort+0x48/0xa0\n[ 5241.100434]  el0_da+0x38/0xc0\n[ 5241.100436]  el0t_64_sync_handler+0x68/0xc0\n[ 5241.100437]  el0t_64_sync+0x14c/0x150\n[ 5241.100439] ---[ end trace 0000000000000000 ]---\n\n[baolin.wang@linux.alibaba.com: remove less helpful comments, per Matthew]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8c6c3719ebb7913f8a665d11816d2e38b0eadbab",
      "https://git.kernel.org/stable/c/9094b4a1c76cfe84b906cc152bab34d4ba26fa5c"
    ],
    "受影响版本": [
      "85ce2c517ade0d51b7ad95f2e88be9bbe294379a",
      "85ce2c517ade0d51b7ad95f2e88be9bbe294379a"
    ],
    "公开日期": "2024年07月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-40916",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/exynos: hdmi: report safe 640x480 mode as a fallback when no EDID found\n\nWhen reading EDID fails and driver reports no modes available, the DRM\ncore adds an artificial 1024x786 mode to the connector. Unfortunately\nsome variants of the Exynos HDMI (like the one in Exynos4 SoCs) are not\nable to drive such mode, so report a safe 640x480 mode instead of nothing\nin case of the EDID reading failure.\n\nThis fixes the following issue observed on Trats2 board since commit\n13d5b040363c (\"drm/exynos: do not return negative values from .get_modes()\"):\n\n[drm] Exynos DRM: using 11c00000.fimd device for DMA mapping operations\nexynos-drm exynos-drm: bound 11c00000.fimd (ops fimd_component_ops)\nexynos-drm exynos-drm: bound 12c10000.mixer (ops mixer_component_ops)\nexynos-dsi 11c80000.dsi: [drm:samsung_dsim_host_attach] Attached s6e8aa0 device (lanes:4 bpp:24 mode-flags:0x10b)\nexynos-drm exynos-drm: bound 11c80000.dsi (ops exynos_dsi_component_ops)\nexynos-drm exynos-drm: bound 12d00000.hdmi (ops hdmi_component_ops)\n[drm] Initialized exynos 1.1.0 20180330 for exynos-drm on minor 1\nexynos-hdmi 12d00000.hdmi: [drm:hdmiphy_enable.part.0] *ERROR* PLL could not reach steady state\npanel-samsung-s6e8aa0 11c80000.dsi.0: ID: 0xa2, 0x20, 0x8c\nexynos-mixer 12c10000.mixer: timeout waiting for VSYNC\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 11 at drivers/gpu/drm/drm_atomic_helper.c:1682 drm_atomic_helper_wait_for_vblanks.part.0+0x2b0/0x2b8\n[CRTC:70:crtc-1] vblank wait timed out\nModules linked in:\nCPU: 1 PID: 11 Comm: kworker/u16:0 Not tainted 6.9.0-rc5-next-20240424 #14913\nHardware name: Samsung Exynos (Flattened Device Tree)\nWorkqueue: events_unbound deferred_probe_work_func\nCall trace:\n unwind_backtrace from show_stack+0x10/0x14\n show_stack from dump_stack_lvl+0x68/0x88\n dump_stack_lvl from __warn+0x7c/0x1c4\n __warn from warn_slowpath_fmt+0x11c/0x1a8\n warn_slowpath_fmt from drm_atomic_helper_wait_for_vblanks.part.0+0x2b0/0x2b8\n drm_atomic_helper_wait_for_vblanks.part.0 from drm_atomic_helper_commit_tail_rpm+0x7c/0x8c\n drm_atomic_helper_commit_tail_rpm from commit_tail+0x9c/0x184\n commit_tail from drm_atomic_helper_commit+0x168/0x190\n drm_atomic_helper_commit from drm_atomic_commit+0xb4/0xe0\n drm_atomic_commit from drm_client_modeset_commit_atomic+0x23c/0x27c\n drm_client_modeset_commit_atomic from drm_client_modeset_commit_locked+0x60/0x1cc\n drm_client_modeset_commit_locked from drm_client_modeset_commit+0x24/0x40\n drm_client_modeset_commit from __drm_fb_helper_restore_fbdev_mode_unlocked+0x9c/0xc4\n __drm_fb_helper_restore_fbdev_mode_unlocked from drm_fb_helper_set_par+0x2c/0x3c\n drm_fb_helper_set_par from fbcon_init+0x3d8/0x550\n fbcon_init from visual_init+0xc0/0x108\n visual_init from do_bind_con_driver+0x1b8/0x3a4\n do_bind_con_driver from do_take_over_console+0x140/0x1ec\n do_take_over_console from do_fbcon_takeover+0x70/0xd0\n do_fbcon_takeover from fbcon_fb_registered+0x19c/0x1ac\n fbcon_fb_registered from register_framebuffer+0x190/0x21c\n register_framebuffer from __drm_fb_helper_initial_config_and_unlock+0x350/0x574\n __drm_fb_helper_initial_config_and_unlock from exynos_drm_fbdev_client_hotplug+0x6c/0xb0\n exynos_drm_fbdev_client_hotplug from drm_client_register+0x58/0x94\n drm_client_register from exynos_drm_bind+0x160/0x190\n exynos_drm_bind from try_to_bring_up_aggregate_device+0x200/0x2d8\n try_to_bring_up_aggregate_device from __component_add+0xb0/0x170\n __component_add from mixer_probe+0x74/0xcc\n mixer_probe from platform_probe+0x5c/0xb8\n platform_probe from really_probe+0xe0/0x3d8\n really_probe from __driver_probe_device+0x9c/0x1e4\n __driver_probe_device from driver_probe_device+0x30/0xc0\n driver_probe_device from __device_attach_driver+0xa8/0x120\n __device_attach_driver from bus_for_each_drv+0x80/0xcc\n bus_for_each_drv from __device_attach+0xac/0x1fc\n __device_attach from bus_probe_device+0x8c/0x90\n bus_probe_device from deferred_probe_work_func+0\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e23f2eaf51ecb6ab4ceb770e747d50c1db2eb222",
      "https://git.kernel.org/stable/c/4dfffb50316c761c59386c9b002a10ac6d7bb6c9",
      "https://git.kernel.org/stable/c/6d6bb258d886e124e5a5328e947b36fdcb3a6028",
      "https://git.kernel.org/stable/c/c3ca24dfe9a2b3f4e8899af108829b0f4b4b15ec",
      "https://git.kernel.org/stable/c/35bcf16b4a28c10923ff391d14f6ed0ae471ee5f",
      "https://git.kernel.org/stable/c/510a6c0dfa6ec61d07a4b64698d8dc60045bd632",
      "https://git.kernel.org/stable/c/799d4b392417ed6889030a5b2335ccb6dcf030ab"
    ],
    "受影响版本": [
      "348aa3d47e8bc2fa4e5b8079554724343631b82a",
      "a8cb3b072403ce0748d368278bc7ab87d15e90a7",
      "912c149a52c37a2f8199449360bf392ae4ef7f4c",
      "8f914db6fe252c5e78a9b8b03adc1b0a33aec25d",
      "b71ae5fb2dd3c89c66efa613dccffc45c246c8b9",
      "13d5b040363c7ec0ac29c2de9cf661a24a8aa531",
      "13d5b040363c7ec0ac29c2de9cf661a24a8aa531",
      "d930ab0399c350f9da9c64030daca368c78e2f51",
      "1cef1ef376c6421bb18e2185b5e10973bc272136"
    ],
    "公开日期": "2024年07月12日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2024-40575",
    "漏洞描述": "An issue in Huawei Technologies opengauss (openGauss 5.0.0 build) v.7.3.0 allows a local attacker to cause a denial of service via the modification of table attributes",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://opengauss.org",
      "https://gist.github.com/RuiHuaLiu2023/92059b0fa6c625e3d39001c5a9b2dc71"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年07月24日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2024-40516",
    "漏洞描述": "An issue in H3C Technologies Co., Limited H3C Magic RC3000 RC3000V100R009 allows a remote attacker to execute arbitrary code via the Routing functionality.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://gist.github.com/as-lky/2acc62c6283c7a1fe3af046b05091d15"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-39500",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsock_map: avoid race between sock_map_close and sk_psock_put\n\nsk_psock_get will return NULL if the refcount of psock has gone to 0, which\nwill happen when the last call of sk_psock_put is done. However,\nsk_psock_drop may not have finished yet, so the close callback will still\npoint to sock_map_close despite psock being NULL.\n\nThis can be reproduced with a thread deleting an element from the sock map,\nwhile the second one creates a socket, adds it to the map and closes it.\n\nThat will trigger the WARN_ON_ONCE:\n\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 7220 at net/core/sock_map.c:1701 sock_map_close+0x2a2/0x2d0 net/core/sock_map.c:1701\nModules linked in:\nCPU: 1 PID: 7220 Comm: syz-executor380 Not tainted 6.9.0-syzkaller-07726-g3c999d1ae3c7 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/02/2024\nRIP: 0010:sock_map_close+0x2a2/0x2d0 net/core/sock_map.c:1701\nCode: df e8 92 29 88 f8 48 8b 1b 48 89 d8 48 c1 e8 03 42 80 3c 20 00 74 08 48 89 df e8 79 29 88 f8 4c 8b 23 eb 89 e8 4f 15 23 f8 90 <0f> 0b 90 48 83 c4 08 5b 41 5c 41 5d 41 5e 41 5f 5d e9 13 26 3d 02\nRSP: 0018:ffffc9000441fda8 EFLAGS: 00010293\nRAX: ffffffff89731ae1 RBX: ffffffff94b87540 RCX: ffff888029470000\nRDX: 0000000000000000 RSI: ffffffff8bcab5c0 RDI: ffffffff8c1faba0\nRBP: 0000000000000000 R08: ffffffff92f9b61f R09: 1ffffffff25f36c3\nR10: dffffc0000000000 R11: fffffbfff25f36c4 R12: ffffffff89731840\nR13: ffff88804b587000 R14: ffff88804b587000 R15: ffffffff89731870\nFS:  000055555e080380(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000000 CR3: 00000000207d4000 CR4: 0000000000350ef0\nCall Trace:\n <TASK>\n unix_release+0x87/0xc0 net/unix/af_unix.c:1048\n __sock_release net/socket.c:659 [inline]\n sock_close+0xbe/0x240 net/socket.c:1421\n __fput+0x42b/0x8a0 fs/file_table.c:422\n __do_sys_close fs/open.c:1556 [inline]\n __se_sys_close fs/open.c:1541 [inline]\n __x64_sys_close+0x7f/0x110 fs/open.c:1541\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7fb37d618070\nCode: 00 00 48 c7 c2 b8 ff ff ff f7 d8 64 89 02 b8 ff ff ff ff eb d4 e8 10 2c 00 00 80 3d 31 f0 07 00 00 74 17 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 48 c3 0f 1f 80 00 00 00 00 48 83 ec 18 89 7c\nRSP: 002b:00007ffcd4a525d8 EFLAGS: 00000202 ORIG_RAX: 0000000000000003\nRAX: ffffffffffffffda RBX: 0000000000000005 RCX: 00007fb37d618070\nRDX: 0000000000000010 RSI: 00000000200001c0 RDI: 0000000000000004\nRBP: 0000000000000000 R08: 0000000100000000 R09: 0000000100000000\nR10: 0000000000000000 R11: 0000000000000202 R12: 0000000000000000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nUse sk_psock, which will only check that the pointer is not been set to\nNULL yet, which should only happen after the callbacks are restored. If,\nthen, a reference can still be gotten, we may call sk_psock_stop and cancel\npsock->work.\n\nAs suggested by Paolo Abeni, reorder the condition so the control flow is\nless convoluted.\n\nAfter that change, the reproducer does not trigger the WARN_ON_ONCE\nanymore.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4959ffc65a0e94f8acaac20deac49f89e6ded52d",
      "https://git.kernel.org/stable/c/5eabdf17fed2ad41b836bb4055ec36d95e512c50",
      "https://git.kernel.org/stable/c/e946428439a0d2079959f5603256ac51b6047017",
      "https://git.kernel.org/stable/c/3627605de498639a3c586c8684d12c89cba11073",
      "https://git.kernel.org/stable/c/4b4647add7d3c8530493f7247d11e257ee425bf0"
    ],
    "受影响版本": [
      "aadb2bb83ff789de63b48b4edeab7329423a50d3",
      "aadb2bb83ff789de63b48b4edeab7329423a50d3",
      "aadb2bb83ff789de63b48b4edeab7329423a50d3",
      "aadb2bb83ff789de63b48b4edeab7329423a50d3",
      "aadb2bb83ff789de63b48b4edeab7329423a50d3"
    ],
    "公开日期": "2024年07月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-39495",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ngreybus: Fix use-after-free bug in gb_interface_release due to race condition.\n\nIn gb_interface_create, &intf->mode_switch_completion is bound with\ngb_interface_mode_switch_work. Then it will be started by\ngb_interface_request_mode_switch. Here is the relevant code.\nif (!queue_work(system_long_wq, &intf->mode_switch_work)) {\n\t...\n}\n\nIf we call gb_interface_release to make cleanup, there may be an\nunfinished work. This function will call kfree to free the object\n\"intf\". However, if gb_interface_mode_switch_work is scheduled to\nrun after kfree, it may cause use-after-free error as\ngb_interface_mode_switch_work will use the object \"intf\".\nThe possible execution flow that may lead to the issue is as follows:\n\nCPU0                            CPU1\n\n                            |   gb_interface_create\n                            |   gb_interface_request_mode_switch\ngb_interface_release        |\nkfree(intf) (free)          |\n                            |   gb_interface_mode_switch_work\n                            |   mutex_lock(&intf->mutex) (use)\n\nFix it by canceling the work before kfree.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/74cd0a421896b2e07eafe7da4275302bfecef201",
      "https://git.kernel.org/stable/c/2b6bb0b4abfd79b8698ee161bb73c0936a2aaf83",
      "https://git.kernel.org/stable/c/fb071f5c75d4b1c177824de74ee75f9dd34123b9",
      "https://git.kernel.org/stable/c/9a733d69a4a59c2d08620e6589d823c24be773dc",
      "https://git.kernel.org/stable/c/0b8fba38bdfb848fac52e71270b2aa3538c996ea",
      "https://git.kernel.org/stable/c/03ea2b129344152157418929f06726989efc0445",
      "https://git.kernel.org/stable/c/5c9c5d7f26acc2c669c1dcf57d1bb43ee99220ce"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年07月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-39488",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: asm-bug: Add .align 2 to the end of __BUG_ENTRY\n\nWhen CONFIG_DEBUG_BUGVERBOSE=n, we fail to add necessary padding bytes\nto bug_table entries, and as a result the last entry in a bug table will\nbe ignored, potentially leading to an unexpected panic(). All prior\nentries in the table will be handled correctly.\n\nThe arm64 ABI requires that struct fields of up to 8 bytes are\nnaturally-aligned, with padding added within a struct such that struct\nare suitably aligned within arrays.\n\nWhen CONFIG_DEBUG_BUGVERPOSE=y, the layout of a bug_entry is:\n\n\tstruct bug_entry {\n\t\tsigned int      bug_addr_disp;\t// 4 bytes\n\t\tsigned int      file_disp;\t// 4 bytes\n\t\tunsigned short  line;\t\t// 2 bytes\n\t\tunsigned short  flags;\t\t// 2 bytes\n\t}\n\n... with 12 bytes total, requiring 4-byte alignment.\n\nWhen CONFIG_DEBUG_BUGVERBOSE=n, the layout of a bug_entry is:\n\n\tstruct bug_entry {\n\t\tsigned int      bug_addr_disp;\t// 4 bytes\n\t\tunsigned short  flags;\t\t// 2 bytes\n\t\t< implicit padding >\t\t// 2 bytes\n\t}\n\n... with 8 bytes total, with 6 bytes of data and 2 bytes of trailing\npadding, requiring 4-byte alginment.\n\nWhen we create a bug_entry in assembly, we align the start of the entry\nto 4 bytes, which implicitly handles padding for any prior entries.\nHowever, we do not align the end of the entry, and so when\nCONFIG_DEBUG_BUGVERBOSE=n, the final entry lacks the trailing padding\nbytes.\n\nFor the main kernel image this is not a problem as find_bug() doesn't\ndepend on the trailing padding bytes when searching for entries:\n\n\tfor (bug = __start___bug_table; bug < __stop___bug_table; ++bug)\n\t\tif (bugaddr == bug_addr(bug))\n\t\t\treturn bug;\n\nHowever for modules, module_bug_finalize() depends on the trailing\nbytes when calculating the number of entries:\n\n\tmod->num_bugs = sechdrs[i].sh_size / sizeof(struct bug_entry);\n\n... and as the last bug_entry lacks the necessary padding bytes, this entry\nwill not be counted, e.g. in the case of a single entry:\n\n\tsechdrs[i].sh_size == 6\n\tsizeof(struct bug_entry) == 8;\n\n\tsechdrs[i].sh_size / sizeof(struct bug_entry) == 0;\n\nConsequently module_find_bug() will miss the last bug_entry when it does:\n\n\tfor (i = 0; i < mod->num_bugs; ++i, ++bug)\n\t\tif (bugaddr == bug_addr(bug))\n\t\t\tgoto out;\n\n... which can lead to a kenrel panic due to an unhandled bug.\n\nThis can be demonstrated with the following module:\n\n\tstatic int __init buginit(void)\n\t{\n\t\tWARN(1, \"hello\\n\");\n\t\treturn 0;\n\t}\n\n\tstatic void __exit bugexit(void)\n\t{\n\t}\n\n\tmodule_init(buginit);\n\tmodule_exit(bugexit);\n\tMODULE_LICENSE(\"GPL\");\n\n... which will trigger a kernel panic when loaded:\n\n\t------------[ cut here ]------------\n\thello\n\tUnexpected kernel BRK exception at EL1\n\tInternal error: BRK handler: 00000000f2000800 [#1] PREEMPT SMP\n\tModules linked in: hello(O+)\n\tCPU: 0 PID: 50 Comm: insmod Tainted: G           O       6.9.1 #8\n\tHardware name: linux,dummy-virt (DT)\n\tpstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n\tpc : buginit+0x18/0x1000 [hello]\n\tlr : buginit+0x18/0x1000 [hello]\n\tsp : ffff800080533ae0\n\tx29: ffff800080533ae0 x28: 0000000000000000 x27: 0000000000000000\n\tx26: ffffaba8c4e70510 x25: ffff800080533c30 x24: ffffaba8c4a28a58\n\tx23: 0000000000000000 x22: 0000000000000000 x21: ffff3947c0eab3c0\n\tx20: ffffaba8c4e3f000 x19: ffffaba846464000 x18: 0000000000000006\n\tx17: 0000000000000000 x16: ffffaba8c2492834 x15: 0720072007200720\n\tx14: 0720072007200720 x13: ffffaba8c49b27c8 x12: 0000000000000312\n\tx11: 0000000000000106 x10: ffffaba8c4a0a7c8 x9 : ffffaba8c49b27c8\n\tx8 : 00000000ffffefff x7 : ffffaba8c4a0a7c8 x6 : 80000000fffff000\n\tx5 : 0000000000000107 x4 : 0000000000000000 x3 : 0000000000000000\n\tx2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff3947c0eab3c0\n\tCall trace:\n\t buginit+0x18/0x1000 [hello]\n\t do_one_initcall+0x80/0x1c8\n\t do_init_module+0x60/0x218\n\t load_module+0x1ba4/0x1d70\n\t __do_sys_init_module+0x198/0x1d0\n\t __arm64_sys_init_module+0x1c/0x28\n\t invoke_syscall+0x48/0x114\n\t el0_svc\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f221bd58db0f6ca087ac0392284f6bce21f4f8ea",
      "https://git.kernel.org/stable/c/22469a0335a1a1a690349b58bcb55822457df81e",
      "https://git.kernel.org/stable/c/461a760d578b2b2c2faac3040b6b7c77baf128f8",
      "https://git.kernel.org/stable/c/c1929c041a262a4a27265db8dce3619c92aa678c",
      "https://git.kernel.org/stable/c/3fd487ffaa697ddb05af78a75aaaddabe71c52b0",
      "https://git.kernel.org/stable/c/9f2ad88f9b349554f64e4037ec185c84d7dd9c7d",
      "https://git.kernel.org/stable/c/c27a2f7668e215c1ebbccd96fab27a220a93f1f7",
      "https://git.kernel.org/stable/c/ffbf4fb9b5c12ff878a10ea17997147ea4ebea6f"
    ],
    "受影响版本": [
      "9fb7410f955f7a62c1f882ca8f9ffd4525907e28",
      "9fb7410f955f7a62c1f882ca8f9ffd4525907e28",
      "9fb7410f955f7a62c1f882ca8f9ffd4525907e28",
      "9fb7410f955f7a62c1f882ca8f9ffd4525907e28",
      "9fb7410f955f7a62c1f882ca8f9ffd4525907e28",
      "9fb7410f955f7a62c1f882ca8f9ffd4525907e28",
      "9fb7410f955f7a62c1f882ca8f9ffd4525907e28",
      "9fb7410f955f7a62c1f882ca8f9ffd4525907e28"
    ],
    "公开日期": "2024年07月10日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-39486",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/drm_file: Fix pid refcounting race\n\n<maarten.lankhorst@linux.intel.com>, Maxime Ripard\n<mripard@kernel.org>, Thomas Zimmermann <tzimmermann@suse.de>\n\nfilp->pid is supposed to be a refcounted pointer; however, before this\npatch, drm_file_update_pid() only increments the refcount of a struct\npid after storing a pointer to it in filp->pid and dropping the\ndev->filelist_mutex, making the following race possible:\n\nprocess A               process B\n=========               =========\n                        begin drm_file_update_pid\n                        mutex_lock(&dev->filelist_mutex)\n                        rcu_replace_pointer(filp->pid, <pid B>, 1)\n                        mutex_unlock(&dev->filelist_mutex)\nbegin drm_file_update_pid\nmutex_lock(&dev->filelist_mutex)\nrcu_replace_pointer(filp->pid, <pid A>, 1)\nmutex_unlock(&dev->filelist_mutex)\nget_pid(<pid A>)\nsynchronize_rcu()\nput_pid(<pid B>)   *** pid B reaches refcount 0 and is freed here ***\n                        get_pid(<pid B>)   *** UAF ***\n                        synchronize_rcu()\n                        put_pid(<pid A>)\n\nAs far as I know, this race can only occur with CONFIG_PREEMPT_RCU=y\nbecause it requires RCU to detect a quiescent state in code that is not\nexplicitly calling into the scheduler.\n\nThis race leads to use-after-free of a \"struct pid\".\nIt is probably somewhat hard to hit because process A has to pass\nthrough a synchronize_rcu() operation while process B is between\nmutex_unlock() and get_pid().\n\nFix it by ensuring that by the time a pointer to the current task's pid\nis stored in the file, an extra reference to the pid has been taken.\n\nThis fix also removes the condition for synchronize_rcu(); I think\nthat optimization is unnecessary complexity, since in that case we\nwould usually have bailed out on the lockless check above.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/16682588ead4a593cf1aebb33b36df4d1e9e4ffa",
      "https://git.kernel.org/stable/c/0acce2a5c619ef1abdee783d7fea5eac78ce4844",
      "https://git.kernel.org/stable/c/4f2a129b33a2054e62273edd5a051c34c08d96e9"
    ],
    "受影响版本": [
      "031ddd28008971cce0b5626379b910d0a05fb4dd",
      "1c7a387ffef894b1ab3942f0482dac7a6e0a909c",
      "1c7a387ffef894b1ab3942f0482dac7a6e0a909c"
    ],
    "公开日期": "2024年07月06日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-39371",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring: check for non-NULL file pointer in io_file_can_poll()\n\nIn earlier kernels, it was possible to trigger a NULL pointer\ndereference off the forced async preparation path, if no file had\nbeen assigned. The trace leading to that looks as follows:\n\nBUG: kernel NULL pointer dereference, address: 00000000000000b0\nPGD 0 P4D 0\nOops: 0000 [#1] PREEMPT SMP\nCPU: 67 PID: 1633 Comm: buf-ring-invali Not tainted 6.8.0-rc3+ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS unknown 2/2/2022\nRIP: 0010:io_buffer_select+0xc3/0x210\nCode: 00 00 48 39 d1 0f 82 ae 00 00 00 48 81 4b 48 00 00 01 00 48 89 73 70 0f b7 50 0c 66 89 53 42 85 ed 0f 85 d2 00 00 00 48 8b 13 <48> 8b 92 b0 00 00 00 48 83 7a 40 00 0f 84 21 01 00 00 4c 8b 20 5b\nRSP: 0018:ffffb7bec38c7d88 EFLAGS: 00010246\nRAX: ffff97af2be61000 RBX: ffff97af234f1700 RCX: 0000000000000040\nRDX: 0000000000000000 RSI: ffff97aecfb04820 RDI: ffff97af234f1700\nRBP: 0000000000000000 R08: 0000000000200030 R09: 0000000000000020\nR10: ffffb7bec38c7dc8 R11: 000000000000c000 R12: ffffb7bec38c7db8\nR13: ffff97aecfb05800 R14: ffff97aecfb05800 R15: ffff97af2be5e000\nFS:  00007f852f74b740(0000) GS:ffff97b1eeec0000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000000000b0 CR3: 000000016deab005 CR4: 0000000000370ef0\nCall Trace:\n <TASK>\n ? __die+0x1f/0x60\n ? page_fault_oops+0x14d/0x420\n ? do_user_addr_fault+0x61/0x6a0\n ? exc_page_fault+0x6c/0x150\n ? asm_exc_page_fault+0x22/0x30\n ? io_buffer_select+0xc3/0x210\n __io_import_iovec+0xb5/0x120\n io_readv_prep_async+0x36/0x70\n io_queue_sqe_fallback+0x20/0x260\n io_submit_sqes+0x314/0x630\n __do_sys_io_uring_enter+0x339/0xbc0\n ? __do_sys_io_uring_register+0x11b/0xc50\n ? vm_mmap_pgoff+0xce/0x160\n do_syscall_64+0x5f/0x180\n entry_SYSCALL_64_after_hwframe+0x46/0x4e\nRIP: 0033:0x55e0a110a67e\nCode: ba cc 00 00 00 45 31 c0 44 0f b6 92 d0 00 00 00 31 d2 41 b9 08 00 00 00 41 83 e2 01 41 c1 e2 04 41 09 c2 b8 aa 01 00 00 0f 05 <c3> 90 89 30 eb a9 0f 1f 40 00 48 8b 42 20 8b 00 a8 06 75 af 85 f6\n\nbecause the request is marked forced ASYNC and has a bad file fd, and\nhence takes the forced async prep path.\n\nCurrent kernels with the request async prep cleaned up can no longer hit\nthis issue, but for ease of backporting, let's add this safety check in\nhere too as it really doesn't hurt. For both cases, this will inevitably\nend with a CQE posted with -EBADF.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c2844d5e58576c55d8e8d4a9f74902d3f7be8044",
      "https://git.kernel.org/stable/c/43cfac7b88adedfb26c27834386992650f1642f3",
      "https://git.kernel.org/stable/c/65561b4c1c9e01443cb76387eb36a9109e7048ee",
      "https://git.kernel.org/stable/c/5fc16fa5f13b3c06fdb959ef262050bd810416a2"
    ],
    "受影响版本": [
      "a76c0b31eef50fdb8b21d53a6d050f59241fb88e",
      "a76c0b31eef50fdb8b21d53a6d050f59241fb88e",
      "a76c0b31eef50fdb8b21d53a6d050f59241fb88e",
      "a76c0b31eef50fdb8b21d53a6d050f59241fb88e"
    ],
    "公开日期": "2024年06月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-39298",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/memory-failure: fix handling of dissolved but not taken off from buddy pages\n\nWhen I did memory failure tests recently, below panic occurs:\n\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x8cee00\nflags: 0x6fffe0000000000(node=1|zone=2|lastcpupid=0x7fff)\nraw: 06fffe0000000000 dead000000000100 dead000000000122 0000000000000000\nraw: 0000000000000000 0000000000000009 00000000ffffffff 0000000000000000\npage dumped because: VM_BUG_ON_PAGE(!PageBuddy(page))\n------------[ cut here ]------------\nkernel BUG at include/linux/page-flags.h:1009!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nRIP: 0010:__del_page_from_free_list+0x151/0x180\nRSP: 0018:ffffa49c90437998 EFLAGS: 00000046\nRAX: 0000000000000035 RBX: 0000000000000009 RCX: ffff8dd8dfd1c9c8\nRDX: 0000000000000000 RSI: 0000000000000027 RDI: ffff8dd8dfd1c9c0\nRBP: ffffd901233b8000 R08: ffffffffab5511f8 R09: 0000000000008c69\nR10: 0000000000003c15 R11: ffffffffab5511f8 R12: ffff8dd8fffc0c80\nR13: 0000000000000001 R14: ffff8dd8fffc0c80 R15: 0000000000000009\nFS:  00007ff916304740(0000) GS:ffff8dd8dfd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000055eae50124c8 CR3: 00000008479e0000 CR4: 00000000000006f0\nCall Trace:\n <TASK>\n __rmqueue_pcplist+0x23b/0x520\n get_page_from_freelist+0x26b/0xe40\n __alloc_pages_noprof+0x113/0x1120\n __folio_alloc_noprof+0x11/0xb0\n alloc_buddy_hugetlb_folio.isra.0+0x5a/0x130\n __alloc_fresh_hugetlb_folio+0xe7/0x140\n alloc_pool_huge_folio+0x68/0x100\n set_max_huge_pages+0x13d/0x340\n hugetlb_sysctl_handler_common+0xe8/0x110\n proc_sys_call_handler+0x194/0x280\n vfs_write+0x387/0x550\n ksys_write+0x64/0xe0\n do_syscall_64+0xc2/0x1d0\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7ff916114887\nRSP: 002b:00007ffec8a2fd78 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 000055eae500e350 RCX: 00007ff916114887\nRDX: 0000000000000004 RSI: 000055eae500e390 RDI: 0000000000000003\nRBP: 000055eae50104c0 R08: 0000000000000000 R09: 000055eae50104c0\nR10: 0000000000000077 R11: 0000000000000246 R12: 0000000000000004\nR13: 0000000000000004 R14: 00007ff916216b80 R15: 00007ff916216a00\n </TASK>\nModules linked in: mce_inject hwpoison_inject\n---[ end trace 0000000000000000 ]---\n\nAnd before the panic, there had an warning about bad page state:\n\nBUG: Bad page state in process page-types  pfn:8cee00\npage: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x8cee00\nflags: 0x6fffe0000000000(node=1|zone=2|lastcpupid=0x7fff)\npage_type: 0xffffff7f(buddy)\nraw: 06fffe0000000000 ffffd901241c0008 ffffd901240f8008 0000000000000000\nraw: 0000000000000000 0000000000000009 00000000ffffff7f 0000000000000000\npage dumped because: nonzero mapcount\nModules linked in: mce_inject hwpoison_inject\nCPU: 8 PID: 154211 Comm: page-types Not tainted 6.9.0-rc4-00499-g5544ec3178e2-dirty #22\nCall Trace:\n <TASK>\n dump_stack_lvl+0x83/0xa0\n bad_page+0x63/0xf0\n free_unref_page+0x36e/0x5c0\n unpoison_memory+0x50b/0x630\n simple_attr_write_xsigned.constprop.0.isra.0+0xb3/0x110\n debugfs_attr_write+0x42/0x60\n full_proxy_write+0x5b/0x80\n vfs_write+0xcd/0x550\n ksys_write+0x64/0xe0\n do_syscall_64+0xc2/0x1d0\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0033:0x7f189a514887\nRSP: 002b:00007ffdcd899718 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f189a514887\nRDX: 0000000000000009 RSI: 00007ffdcd899730 RDI: 0000000000000003\nRBP: 00007ffdcd8997a0 R08: 0000000000000000 R09: 00007ffdcd8994b2\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007ffdcda199a8\nR13: 0000000000404af1 R14: 000000000040ad78 R15: 00007f189a7a5040\n </TASK>\n\nThe root cause should be the below race:\n\n memory_failure\n  try_memory_failure_hugetlb\n   me_huge_page\n    __page_handle_poison\n     dissolve_free_hugetlb_folio\n     drain_all_pages -- Buddy page can be isolated e.g. for compaction.\n     take_page_off_buddy -- Failed as page is not in the \n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/00b0752c7f15dfdf129cacc6a27d61c54141182b",
      "https://git.kernel.org/stable/c/bb9bb13ce64cc7cae47f5e2ab9ce93b7bfa0117e",
      "https://git.kernel.org/stable/c/41cd2de3c95020b7f86a3cb5fab42fbf454a63bd",
      "https://git.kernel.org/stable/c/8cf360b9d6a840700e06864236a01a883b34bbad"
    ],
    "受影响版本": [
      "ceaf8fbea79a854373b9fc03c9fde98eb8712725",
      "ceaf8fbea79a854373b9fc03c9fde98eb8712725",
      "ceaf8fbea79a854373b9fc03c9fde98eb8712725",
      "ceaf8fbea79a854373b9fc03c9fde98eb8712725"
    ],
    "公开日期": "2024年06月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-39296",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbonding: fix oops during rmmod\n\n\"rmmod bonding\" causes an oops ever since commit cc317ea3d927 (\"bonding:\nremove redundant NULL check in debugfs function\").  Here are the relevant\nfunctions being called:\n\nbonding_exit()\n  bond_destroy_debugfs()\n    debugfs_remove_recursive(bonding_debug_root);\n    bonding_debug_root = NULL; <--------- SET TO NULL HERE\n  bond_netlink_fini()\n    rtnl_link_unregister()\n      __rtnl_link_unregister()\n        unregister_netdevice_many_notify()\n          bond_uninit()\n            bond_debug_unregister()\n              (commit removed check for bonding_debug_root == NULL)\n              debugfs_remove()\n              simple_recursive_removal()\n                down_write() -> OOPS\n\nHowever, reverting the bad commit does not solve the problem completely\nbecause the original code contains a race that could cause the same\noops, although it was much less likely to be triggered unintentionally:\n\nCPU1\n  rmmod bonding\n    bonding_exit()\n      bond_destroy_debugfs()\n        debugfs_remove_recursive(bonding_debug_root);\n\nCPU2\n  echo -bond0 > /sys/class/net/bonding_masters\n    bond_uninit()\n      bond_debug_unregister()\n        if (!bonding_debug_root)\n\nCPU1\n        bonding_debug_root = NULL;\n\nSo do NOT revert the bad commit (since the removed checks were racy\nanyway), and instead change the order of actions taken during module\nremoval.  The same oops can also happen if there is an error during\nmodule init, so apply the same fix there.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f07224c16678a8af54ddc059b3d2d51885d7f35e",
      "https://git.kernel.org/stable/c/cf48aee81103ca06d09d73d33fb72f1191069aa6",
      "https://git.kernel.org/stable/c/a45835a0bb6ef7d5ddbc0714dd760de979cb6ece"
    ],
    "受影响版本": [
      "cc317ea3d9272fab4f6fef527c865f30ca479394",
      "cc317ea3d9272fab4f6fef527c865f30ca479394",
      "cc317ea3d9272fab4f6fef527c865f30ca479394"
    ],
    "公开日期": "2024年06月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-38664",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: zynqmp_dpsub: Always register bridge\n\nWe must always register the DRM bridge, since zynqmp_dp_hpd_work_func\ncalls drm_bridge_hpd_notify, which in turn expects hpd_mutex to be\ninitialized. We do this before zynqmp_dpsub_drm_init since that calls\ndrm_bridge_attach. This fixes the following lockdep warning:\n\n[   19.217084] ------------[ cut here ]------------\n[   19.227530] DEBUG_LOCKS_WARN_ON(lock->magic != lock)\n[   19.227768] WARNING: CPU: 0 PID: 140 at kernel/locking/mutex.c:582 __mutex_lock+0x4bc/0x550\n[   19.241696] Modules linked in:\n[   19.244937] CPU: 0 PID: 140 Comm: kworker/0:4 Not tainted 6.6.20+ #96\n[   19.252046] Hardware name: xlnx,zynqmp (DT)\n[   19.256421] Workqueue: events zynqmp_dp_hpd_work_func\n[   19.261795] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   19.269104] pc : __mutex_lock+0x4bc/0x550\n[   19.273364] lr : __mutex_lock+0x4bc/0x550\n[   19.277592] sp : ffffffc085c5bbe0\n[   19.281066] x29: ffffffc085c5bbe0 x28: 0000000000000000 x27: ffffff88009417f8\n[   19.288624] x26: ffffff8800941788 x25: ffffff8800020008 x24: ffffffc082aa3000\n[   19.296227] x23: ffffffc080d90e3c x22: 0000000000000002 x21: 0000000000000000\n[   19.303744] x20: 0000000000000000 x19: ffffff88002f5210 x18: 0000000000000000\n[   19.311295] x17: 6c707369642e3030 x16: 3030613464662072 x15: 0720072007200720\n[   19.318922] x14: 0000000000000000 x13: 284e4f5f4e524157 x12: 0000000000000001\n[   19.326442] x11: 0001ffc085c5b940 x10: 0001ff88003f388b x9 : 0001ff88003f3888\n[   19.334003] x8 : 0001ff88003f3888 x7 : 0000000000000000 x6 : 0000000000000000\n[   19.341537] x5 : 0000000000000000 x4 : 0000000000001668 x3 : 0000000000000000\n[   19.349054] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffffff88003f3880\n[   19.356581] Call trace:\n[   19.359160]  __mutex_lock+0x4bc/0x550\n[   19.363032]  mutex_lock_nested+0x24/0x30\n[   19.367187]  drm_bridge_hpd_notify+0x2c/0x6c\n[   19.371698]  zynqmp_dp_hpd_work_func+0x44/0x54\n[   19.376364]  process_one_work+0x3ac/0x988\n[   19.380660]  worker_thread+0x398/0x694\n[   19.384736]  kthread+0x1bc/0x1c0\n[   19.388241]  ret_from_fork+0x10/0x20\n[   19.392031] irq event stamp: 183\n[   19.395450] hardirqs last  enabled at (183): [<ffffffc0800b9278>] finish_task_switch.isra.0+0xa8/0x2d4\n[   19.405140] hardirqs last disabled at (182): [<ffffffc081ad3754>] __schedule+0x714/0xd04\n[   19.413612] softirqs last  enabled at (114): [<ffffffc080133de8>] srcu_invoke_callbacks+0x158/0x23c\n[   19.423128] softirqs last disabled at (110): [<ffffffc080133de8>] srcu_invoke_callbacks+0x158/0x23c\n[   19.432614] ---[ end trace 0000000000000000 ]---\n\n(cherry picked from commit 61ba791c4a7a09a370c45b70a81b8c7d4cf6b2ae)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6ead3eccf67bc8318b1ce95ed879b2cc05b4fce9",
      "https://git.kernel.org/stable/c/603661357056b5e5ba6d86f505fbc936eff396ba",
      "https://git.kernel.org/stable/c/be3f3042391d061cfca2bd22630e0d101acea5fc"
    ],
    "受影响版本": [
      "eb2d64bfcc174919a921295a5327b99a3b8f4166",
      "eb2d64bfcc174919a921295a5327b99a3b8f4166",
      "eb2d64bfcc174919a921295a5327b99a3b8f4166"
    ],
    "公开日期": "2024年06月24日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-38626",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfuse: clear FR_SENT when re-adding requests into pending list\n\nThe following warning was reported by lee bruce:\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 8264 at fs/fuse/dev.c:300\n  fuse_request_end+0x685/0x7e0 fs/fuse/dev.c:300\n  Modules linked in:\n  CPU: 0 PID: 8264 Comm: ab2 Not tainted 6.9.0-rc7\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996)\n  RIP: 0010:fuse_request_end+0x685/0x7e0 fs/fuse/dev.c:300\n  ......\n  Call Trace:\n  <TASK>\n  fuse_dev_do_read.constprop.0+0xd36/0x1dd0 fs/fuse/dev.c:1334\n  fuse_dev_read+0x166/0x200 fs/fuse/dev.c:1367\n  call_read_iter include/linux/fs.h:2104 [inline]\n  new_sync_read fs/read_write.c:395 [inline]\n  vfs_read+0x85b/0xba0 fs/read_write.c:476\n  ksys_read+0x12f/0x260 fs/read_write.c:619\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xce/0x260 arch/x86/entry/common.c:83\n  entry_SYSCALL_64_after_hwframe+0x77/0x7f\n  ......\n  </TASK>\n\nThe warning is due to the FUSE_NOTIFY_RESEND notify sent by the write()\nsyscall in the reproducer program and it happens as follows:\n\n(1) calls fuse_dev_read() to read the INIT request\nThe read succeeds. During the read, bit FR_SENT will be set on the\nrequest.\n(2) calls fuse_dev_write() to send an USE_NOTIFY_RESEND notify\nThe resend notify will resend all processing requests, so the INIT\nrequest is moved from processing list to pending list again.\n(3) calls fuse_dev_read() with an invalid output address\nfuse_dev_read() will try to copy the same INIT request to the output\naddress, but it will fail due to the invalid address, so the INIT\nrequest is ended and triggers the warning in fuse_request_end().\n\nFix it by clearing FR_SENT when re-adding requests into pending list.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/533070db659a9589310a743e9de14cf9d651ffaf",
      "https://git.kernel.org/stable/c/246014876d782bbf2e652267482cd2e799fb5fcd"
    ],
    "受影响版本": [
      "760eac73f9f69aa28fcb3050b4946c2dcc656d12",
      "760eac73f9f69aa28fcb3050b4946c2dcc656d12"
    ],
    "公开日期": "2024年06月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-38616",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: carl9170: re-fix fortified-memset warning\n\nThe carl9170_tx_release() function sometimes triggers a fortified-memset\nwarning in my randconfig builds:\n\nIn file included from include/linux/string.h:254,\n                 from drivers/net/wireless/ath/carl9170/tx.c:40:\nIn function 'fortify_memset_chk',\n    inlined from 'carl9170_tx_release' at drivers/net/wireless/ath/carl9170/tx.c:283:2,\n    inlined from 'kref_put' at include/linux/kref.h:65:3,\n    inlined from 'carl9170_tx_put_skb' at drivers/net/wireless/ath/carl9170/tx.c:342:9:\ninclude/linux/fortify-string.h:493:25: error: call to '__write_overflow_field' declared with attribute warning: detected write beyond size of field (1st parameter); maybe use struct_group()? [-Werror=attribute-warning]\n  493 |                         __write_overflow_field(p_size_field, size);\n\nKees previously tried to avoid this by using memset_after(), but it seems\nthis does not fully address the problem. I noticed that the memset_after()\nhere is done on a different part of the union (status) than the original\ncast was from (rate_driver_data), which may confuse the compiler.\n\nUnfortunately, the memset_after() trick does not work on driver_rates[]\nbecause that is part of an anonymous struct, and I could not get\nstruct_group() to do this either. Using two separate memset() calls\non the two members does address the warning though.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/13857683126e8a6492af73c74d702835f7a2175b",
      "https://git.kernel.org/stable/c/87586467098281f04fa93e59fe3a516b954bddc4",
      "https://git.kernel.org/stable/c/0c38c9c460bb8ce8d6f6cf316e0d71a70983ec83",
      "https://git.kernel.org/stable/c/042a39bb8e0812466327a5102606e88a5a4f8c02",
      "https://git.kernel.org/stable/c/066afafc10c9476ee36c47c9062527a17e763901"
    ],
    "受影响版本": [
      "fb5f6a0e8063b7a84d6d44ef353846ccd7708d2e",
      "fb5f6a0e8063b7a84d6d44ef353846ccd7708d2e",
      "fb5f6a0e8063b7a84d6d44ef353846ccd7708d2e",
      "fb5f6a0e8063b7a84d6d44ef353846ccd7708d2e",
      "fb5f6a0e8063b7a84d6d44ef353846ccd7708d2e"
    ],
    "公开日期": "2024年06月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-38613",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nm68k: Fix spinlock race in kernel thread creation\n\nContext switching does take care to retain the correct lock owner across\nthe switch from 'prev' to 'next' tasks.  This does rely on interrupts\nremaining disabled for the entire duration of the switch.\n\nThis condition is guaranteed for normal process creation and context\nswitching between already running processes, because both 'prev' and\n'next' already have interrupts disabled in their saved copies of the\nstatus register.\n\nThe situation is different for newly created kernel threads.  The status\nregister is set to PS_S in copy_thread(), which does leave the IPL at 0.\nUpon restoring the 'next' thread's status register in switch_to() aka\nresume(), interrupts then become enabled prematurely.  resume() then\nreturns via ret_from_kernel_thread() and schedule_tail() where run queue\nlock is released (see finish_task_switch() and finish_lock_switch()).\n\nA timer interrupt calling scheduler_tick() before the lock is released\nin finish_task_switch() will find the lock already taken, with the\ncurrent task as lock owner.  This causes a spinlock recursion warning as\nreported by Guenter Roeck.\n\nAs far as I can ascertain, this race has been opened in commit\n533e6903bea0 (\"m68k: split ret_from_fork(), simplify kernel_thread()\")\nbut I haven't done a detailed study of kernel history so it may well\npredate that commit.\n\nInterrupts cannot be disabled in the saved status register copy for\nkernel threads (init will complain about interrupts disabled when\nfinally starting user space).  Disable interrupts temporarily when\nswitching the tasks' register sets in resume().\n\nNote that a simple oriw 0x700,%sr after restoring sr is not enough here\n- this leaves enough of a race for the 'spinlock recursion' warning to\nstill be observed.\n\nTested on ARAnyM and qemu (Quadra 800 emulation).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2a8d1d95302c7d52c6ac8fa5cb4a6948ae0d3a14",
      "https://git.kernel.org/stable/c/5213cc01d0464c011fdc09f318705603ed3a746b",
      "https://git.kernel.org/stable/c/4eeffecc8e3cce25bb559502c2fd94a948bcde82",
      "https://git.kernel.org/stable/c/77b2b67a0f8bce260c53907e5749d61466d90c87",
      "https://git.kernel.org/stable/c/0d9ae1253535f6e85a016e09c25ecbe6f7f59ef0",
      "https://git.kernel.org/stable/c/f3baf0f4f92af32943ebf27b960e0552c6c082fd",
      "https://git.kernel.org/stable/c/f1d4274a84c069be0f6098ab10c3443fc1f7134c",
      "https://git.kernel.org/stable/c/95f00caf767b5968c2c51083957b38be4748a78a",
      "https://git.kernel.org/stable/c/da89ce46f02470ef08f0f580755d14d547da59ed"
    ],
    "受影响版本": [
      "533e6903bea0440816a0f517b0845ccea4cc7917",
      "533e6903bea0440816a0f517b0845ccea4cc7917",
      "533e6903bea0440816a0f517b0845ccea4cc7917",
      "533e6903bea0440816a0f517b0845ccea4cc7917",
      "533e6903bea0440816a0f517b0845ccea4cc7917",
      "533e6903bea0440816a0f517b0845ccea4cc7917",
      "533e6903bea0440816a0f517b0845ccea4cc7917",
      "533e6903bea0440816a0f517b0845ccea4cc7917",
      "533e6903bea0440816a0f517b0845ccea4cc7917"
    ],
    "公开日期": "2024年06月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-38607",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmacintosh/via-macii: Fix \"BUG: sleeping function called from invalid context\"\n\nThe via-macii ADB driver calls request_irq() after disabling hard\ninterrupts. But disabling interrupts isn't necessary here because the\nVIA shift register interrupt was masked during VIA1 initialization.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e4ff8bcfb2841fe4e17e5901578b632adb89036d",
      "https://git.kernel.org/stable/c/1e9c3f2caec548cfa7a65416ec4e6006e542f18e",
      "https://git.kernel.org/stable/c/280619bbdeac186fb320fab3d61122d2a085def8",
      "https://git.kernel.org/stable/c/010d4cb19bb13f423e3e746b824f314a9bf3e9a9",
      "https://git.kernel.org/stable/c/787fb79efc15b3b86442ecf079b8148f173376d7",
      "https://git.kernel.org/stable/c/d43a8c7ec0841e0ff91a968770aeca83f0fd4c56",
      "https://git.kernel.org/stable/c/5900a88e897e6deb1bdce09ee34167a81c2da89d",
      "https://git.kernel.org/stable/c/2907d409ce5946390f513976f0454888d37d1058",
      "https://git.kernel.org/stable/c/d301a71c76ee4c384b4e03cdc320a55f5cf1df05"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年06月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-38601",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nring-buffer: Fix a race between readers and resize checks\n\nThe reader code in rb_get_reader_page() swaps a new reader page into the\nring buffer by doing cmpxchg on old->list.prev->next to point it to the\nnew page. Following that, if the operation is successful,\nold->list.next->prev gets updated too. This means the underlying\ndoubly-linked list is temporarily inconsistent, page->prev->next or\npage->next->prev might not be equal back to page for some page in the\nring buffer.\n\nThe resize operation in ring_buffer_resize() can be invoked in parallel.\nIt calls rb_check_pages() which can detect the described inconsistency\nand stop further tracing:\n\n[  190.271762] ------------[ cut here ]------------\n[  190.271771] WARNING: CPU: 1 PID: 6186 at kernel/trace/ring_buffer.c:1467 rb_check_pages.isra.0+0x6a/0xa0\n[  190.271789] Modules linked in: [...]\n[  190.271991] Unloaded tainted modules: intel_uncore_frequency(E):1 skx_edac(E):1\n[  190.272002] CPU: 1 PID: 6186 Comm: cmd.sh Kdump: loaded Tainted: G            E      6.9.0-rc6-default #5 158d3e1e6d0b091c34c3b96bfd99a1c58306d79f\n[  190.272011] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.0-0-gd239552c-rebuilt.opensuse.org 04/01/2014\n[  190.272015] RIP: 0010:rb_check_pages.isra.0+0x6a/0xa0\n[  190.272023] Code: [...]\n[  190.272028] RSP: 0018:ffff9c37463abb70 EFLAGS: 00010206\n[  190.272034] RAX: ffff8eba04b6cb80 RBX: 0000000000000007 RCX: ffff8eba01f13d80\n[  190.272038] RDX: ffff8eba01f130c0 RSI: ffff8eba04b6cd00 RDI: ffff8eba0004c700\n[  190.272042] RBP: ffff8eba0004c700 R08: 0000000000010002 R09: 0000000000000000\n[  190.272045] R10: 00000000ffff7f52 R11: ffff8eba7f600000 R12: ffff8eba0004c720\n[  190.272049] R13: ffff8eba00223a00 R14: 0000000000000008 R15: ffff8eba067a8000\n[  190.272053] FS:  00007f1bd64752c0(0000) GS:ffff8eba7f680000(0000) knlGS:0000000000000000\n[  190.272057] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  190.272061] CR2: 00007f1bd6662590 CR3: 000000010291e001 CR4: 0000000000370ef0\n[  190.272070] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  190.272073] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  190.272077] Call Trace:\n[  190.272098]  <TASK>\n[  190.272189]  ring_buffer_resize+0x2ab/0x460\n[  190.272199]  __tracing_resize_ring_buffer.part.0+0x23/0xa0\n[  190.272206]  tracing_resize_ring_buffer+0x65/0x90\n[  190.272216]  tracing_entries_write+0x74/0xc0\n[  190.272225]  vfs_write+0xf5/0x420\n[  190.272248]  ksys_write+0x67/0xe0\n[  190.272256]  do_syscall_64+0x82/0x170\n[  190.272363]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[  190.272373] RIP: 0033:0x7f1bd657d263\n[  190.272381] Code: [...]\n[  190.272385] RSP: 002b:00007ffe72b643f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[  190.272391] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007f1bd657d263\n[  190.272395] RDX: 0000000000000002 RSI: 0000555a6eb538e0 RDI: 0000000000000001\n[  190.272398] RBP: 0000555a6eb538e0 R08: 000000000000000a R09: 0000000000000000\n[  190.272401] R10: 0000555a6eb55190 R11: 0000000000000246 R12: 00007f1bd6662500\n[  190.272404] R13: 0000000000000002 R14: 00007f1bd6667c00 R15: 0000000000000002\n[  190.272412]  </TASK>\n[  190.272414] ---[ end trace 0000000000000000 ]---\n\nNote that ring_buffer_resize() calls rb_check_pages() only if the parent\ntrace_buffer has recording disabled. Recent commit d78ab792705c\n(\"tracing: Stop current tracer when resizing buffer\") causes that it is\nnow always the case which makes it more likely to experience this issue.\n\nThe window to hit this race is nonetheless very small. To help\nreproducing it, one can add a delay loop in rb_get_reader_page():\n\n ret = rb_head_page_replace(reader, cpu_buffer->reader_page);\n if (!ret)\n \tgoto spin;\n for (unsigned i = 0; i < 1U << 26; i++)  /* inserted delay loop */\n \t__asm__ __volatile__ (\"\" : : : \"memory\");\n rb_list_head(reader->list.next)->prev = &cpu_buffer->reader_page->list;\n\n.. \n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b50932ea673b5a089a4bb570a8a868d95c72854e",
      "https://git.kernel.org/stable/c/c68b7a442ee61d04ca58b2b5cb5ea7cb8230f84a",
      "https://git.kernel.org/stable/c/1e160196042cac946798ac192a0bc3398f1aa66b",
      "https://git.kernel.org/stable/c/595363182f28786d641666a09e674b852c83b4bb",
      "https://git.kernel.org/stable/c/54c64967ba5f8658ae7da76005024ebd3d9d8f6e",
      "https://git.kernel.org/stable/c/af3274905b3143ea23142bbf77bd9b610c54e533",
      "https://git.kernel.org/stable/c/5ef9e330406d3fb4f4b2c8bca2c6b8a93bae32d1",
      "https://git.kernel.org/stable/c/79b52013429a42b8efdb0cda8bb0041386abab87",
      "https://git.kernel.org/stable/c/c2274b908db05529980ec056359fae916939fdaa"
    ],
    "受影响版本": [
      "659f451ff21315ebfeeb46b9adccee8ce1b52c25",
      "659f451ff21315ebfeeb46b9adccee8ce1b52c25",
      "659f451ff21315ebfeeb46b9adccee8ce1b52c25",
      "659f451ff21315ebfeeb46b9adccee8ce1b52c25",
      "659f451ff21315ebfeeb46b9adccee8ce1b52c25",
      "659f451ff21315ebfeeb46b9adccee8ce1b52c25",
      "659f451ff21315ebfeeb46b9adccee8ce1b52c25",
      "659f451ff21315ebfeeb46b9adccee8ce1b52c25",
      "659f451ff21315ebfeeb46b9adccee8ce1b52c25"
    ],
    "公开日期": "2024年06月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-38565",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ar5523: enable proper endpoint verification\n\nSyzkaller reports [1] hitting a warning about an endpoint in use\nnot having an expected type to it.\n\nFix the issue by checking for the existence of all proper\nendpoints with their according types intact.\n\nSadly, this patch has not been tested on real hardware.\n\n[1] Syzkaller report:\n------------[ cut here ]------------\nusb 1-1: BOGUS urb xfer, pipe 3 != type 1\nWARNING: CPU: 0 PID: 3643 at drivers/usb/core/urb.c:504 usb_submit_urb+0xed6/0x1880 drivers/usb/core/urb.c:504\n...\nCall Trace:\n <TASK>\n ar5523_cmd+0x41b/0x780 drivers/net/wireless/ath/ar5523/ar5523.c:275\n ar5523_cmd_read drivers/net/wireless/ath/ar5523/ar5523.c:302 [inline]\n ar5523_host_available drivers/net/wireless/ath/ar5523/ar5523.c:1376 [inline]\n ar5523_probe+0x14b0/0x1d10 drivers/net/wireless/ath/ar5523/ar5523.c:1655\n usb_probe_interface+0x30f/0x7f0 drivers/usb/core/driver.c:396\n call_driver_probe drivers/base/dd.c:560 [inline]\n really_probe+0x249/0xb90 drivers/base/dd.c:639\n __driver_probe_device+0x1df/0x4d0 drivers/base/dd.c:778\n driver_probe_device+0x4c/0x1a0 drivers/base/dd.c:808\n __device_attach_driver+0x1d4/0x2e0 drivers/base/dd.c:936\n bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:427\n __device_attach+0x1e4/0x530 drivers/base/dd.c:1008\n bus_probe_device+0x1e8/0x2a0 drivers/base/bus.c:487\n device_add+0xbd9/0x1e90 drivers/base/core.c:3517\n usb_set_configuration+0x101d/0x1900 drivers/usb/core/message.c:2170\n usb_generic_driver_probe+0xbe/0x100 drivers/usb/core/generic.c:238\n usb_probe_device+0xd8/0x2c0 drivers/usb/core/driver.c:293\n call_driver_probe drivers/base/dd.c:560 [inline]\n really_probe+0x249/0xb90 drivers/base/dd.c:639\n __driver_probe_device+0x1df/0x4d0 drivers/base/dd.c:778\n driver_probe_device+0x4c/0x1a0 drivers/base/dd.c:808\n __device_attach_driver+0x1d4/0x2e0 drivers/base/dd.c:936\n bus_for_each_drv+0x163/0x1e0 drivers/base/bus.c:427\n __device_attach+0x1e4/0x530 drivers/base/dd.c:1008\n bus_probe_device+0x1e8/0x2a0 drivers/base/bus.c:487\n device_add+0xbd9/0x1e90 drivers/base/core.c:3517\n usb_new_device.cold+0x685/0x10ad drivers/usb/core/hub.c:2573\n hub_port_connect drivers/usb/core/hub.c:5353 [inline]\n hub_port_connect_change drivers/usb/core/hub.c:5497 [inline]\n port_event drivers/usb/core/hub.c:5653 [inline]\n hub_event+0x26cb/0x45d0 drivers/usb/core/hub.c:5735\n process_one_work+0x9bf/0x1710 kernel/workqueue.c:2289\n worker_thread+0x669/0x1090 kernel/workqueue.c:2436\n kthread+0x2e8/0x3a0 kernel/kthread.c:376\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/79ddf5f2020fd593d50f1363bb5131283d74f78f",
      "https://git.kernel.org/stable/c/68a5a00c5d38978a3f8460c6f182f7beec8688ff",
      "https://git.kernel.org/stable/c/ee25389df80138907bc9dcdf4a2be2067cde9a81",
      "https://git.kernel.org/stable/c/b4c24de37a6bb383394a6fef2b85a6db41d426f5",
      "https://git.kernel.org/stable/c/34f7ebff1b9699e0b89fa58b693bc098c2f5ec72",
      "https://git.kernel.org/stable/c/b33a81e4ecfb022b028cae37d1c1ce28ac1b359d",
      "https://git.kernel.org/stable/c/beeed260b92af158592f5e8d2dab65dae45c6f70",
      "https://git.kernel.org/stable/c/7bbf76c9bb2c58375e183074e44f9712483f0603",
      "https://git.kernel.org/stable/c/e120b6388d7d88635d67dcae6483f39c37111850"
    ],
    "受影响版本": [
      "b7d572e1871df06a96a1c9591c71c5494ff6b624",
      "b7d572e1871df06a96a1c9591c71c5494ff6b624",
      "b7d572e1871df06a96a1c9591c71c5494ff6b624",
      "b7d572e1871df06a96a1c9591c71c5494ff6b624",
      "b7d572e1871df06a96a1c9591c71c5494ff6b624",
      "b7d572e1871df06a96a1c9591c71c5494ff6b624",
      "b7d572e1871df06a96a1c9591c71c5494ff6b624",
      "b7d572e1871df06a96a1c9591c71c5494ff6b624",
      "b7d572e1871df06a96a1c9591c71c5494ff6b624"
    ],
    "公开日期": "2024年06月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-38555",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5: Discard command completions in internal error\n\nFix use after free when FW completion arrives while device is in\ninternal error state. Avoid calling completion handler in this case,\nsince the device will flush the command interface and trigger all\ncompletions manually.\n\nKernel log:\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\n...\nRIP: 0010:refcount_warn_saturate+0xd8/0xe0\n...\nCall Trace:\n<IRQ>\n? __warn+0x79/0x120\n? refcount_warn_saturate+0xd8/0xe0\n? report_bug+0x17c/0x190\n? handle_bug+0x3c/0x60\n? exc_invalid_op+0x14/0x70\n? asm_exc_invalid_op+0x16/0x20\n? refcount_warn_saturate+0xd8/0xe0\ncmd_ent_put+0x13b/0x160 [mlx5_core]\nmlx5_cmd_comp_handler+0x5f9/0x670 [mlx5_core]\ncmd_comp_notifier+0x1f/0x30 [mlx5_core]\nnotifier_call_chain+0x35/0xb0\natomic_notifier_call_chain+0x16/0x20\nmlx5_eq_async_int+0xf6/0x290 [mlx5_core]\nnotifier_call_chain+0x35/0xb0\natomic_notifier_call_chain+0x16/0x20\nirq_int_handler+0x19/0x30 [mlx5_core]\n__handle_irq_event_percpu+0x4b/0x160\nhandle_irq_event+0x2e/0x80\nhandle_edge_irq+0x98/0x230\n__common_interrupt+0x3b/0xa0\ncommon_interrupt+0x7b/0xa0\n</IRQ>\n<TASK>\nasm_common_interrupt+0x22/0x40",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f6fbb8535e990f844371086ab2c1221f71f993d3",
      "https://git.kernel.org/stable/c/3cb92b0ad73d3f1734e812054e698d655e9581b0",
      "https://git.kernel.org/stable/c/bf8aaf0ae01c27ae3c06aa8610caf91e50393396",
      "https://git.kernel.org/stable/c/1337ec94bc5a9eed250e33f5f5c89a28a6bfabdb",
      "https://git.kernel.org/stable/c/1d5dce5e92a70274de67a59e1e674c3267f94cd7",
      "https://git.kernel.org/stable/c/7ac4c69c34240c6de820492c0a28a0bd1494265a",
      "https://git.kernel.org/stable/c/db9b31aa9bc56ff0d15b78f7e827d61c4a096e40"
    ],
    "受影响版本": [
      "27c79b3a9212cf4ba634c157e07d29548181a208",
      "51d138c2610a236c1ed0059d034ee4c74f452b86",
      "51d138c2610a236c1ed0059d034ee4c74f452b86",
      "51d138c2610a236c1ed0059d034ee4c74f452b86",
      "51d138c2610a236c1ed0059d034ee4c74f452b86",
      "51d138c2610a236c1ed0059d034ee4c74f452b86",
      "51d138c2610a236c1ed0059d034ee4c74f452b86",
      "2e5d24b3bf091802c5456dc8f8f6a6be4493c8ca"
    ],
    "公开日期": "2024年06月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-37354",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix crash on racing fsync and size-extending write into prealloc\n\nWe have been seeing crashes on duplicate keys in\nbtrfs_set_item_key_safe():\n\n  BTRFS critical (device vdb): slot 4 key (450 108 8192) new key (450 108 8192)\n  ------------[ cut here ]------------\n  kernel BUG at fs/btrfs/ctree.c:2620!\n  invalid opcode: 0000 [#1] PREEMPT SMP PTI\n  CPU: 0 PID: 3139 Comm: xfs_io Kdump: loaded Not tainted 6.9.0 #6\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014\n  RIP: 0010:btrfs_set_item_key_safe+0x11f/0x290 [btrfs]\n\nWith the following stack trace:\n\n  #0  btrfs_set_item_key_safe (fs/btrfs/ctree.c:2620:4)\n  #1  btrfs_drop_extents (fs/btrfs/file.c:411:4)\n  #2  log_one_extent (fs/btrfs/tree-log.c:4732:9)\n  #3  btrfs_log_changed_extents (fs/btrfs/tree-log.c:4955:9)\n  #4  btrfs_log_inode (fs/btrfs/tree-log.c:6626:9)\n  #5  btrfs_log_inode_parent (fs/btrfs/tree-log.c:7070:8)\n  #6  btrfs_log_dentry_safe (fs/btrfs/tree-log.c:7171:8)\n  #7  btrfs_sync_file (fs/btrfs/file.c:1933:8)\n  #8  vfs_fsync_range (fs/sync.c:188:9)\n  #9  vfs_fsync (fs/sync.c:202:9)\n  #10 do_fsync (fs/sync.c:212:9)\n  #11 __do_sys_fdatasync (fs/sync.c:225:9)\n  #12 __se_sys_fdatasync (fs/sync.c:223:1)\n  #13 __x64_sys_fdatasync (fs/sync.c:223:1)\n  #14 do_syscall_x64 (arch/x86/entry/common.c:52:14)\n  #15 do_syscall_64 (arch/x86/entry/common.c:83:7)\n  #16 entry_SYSCALL_64+0xaf/0x14c (arch/x86/entry/entry_64.S:121)\n\nSo we're logging a changed extent from fsync, which is splitting an\nextent in the log tree. But this split part already exists in the tree,\ntriggering the BUG().\n\nThis is the state of the log tree at the time of the crash, dumped with\ndrgn (https://github.com/osandov/drgn/blob/main/contrib/btrfs_tree.py)\nto get more details than btrfs_print_leaf() gives us:\n\n  >>> print_extent_buffer(prog.crashed_thread().stack_trace()[0][\"eb\"])\n  leaf 33439744 level 0 items 72 generation 9 owner 18446744073709551610\n  leaf 33439744 flags 0x100000000000000\n  fs uuid e5bd3946-400c-4223-8923-190ef1f18677\n  chunk uuid d58cb17e-6d02-494a-829a-18b7d8a399da\n          item 0 key (450 INODE_ITEM 0) itemoff 16123 itemsize 160\n                  generation 7 transid 9 size 8192 nbytes 8473563889606862198\n                  block group 0 mode 100600 links 1 uid 0 gid 0 rdev 0\n                  sequence 204 flags 0x10(PREALLOC)\n                  atime 1716417703.220000000 (2024-05-22 15:41:43)\n                  ctime 1716417704.983333333 (2024-05-22 15:41:44)\n                  mtime 1716417704.983333333 (2024-05-22 15:41:44)\n                  otime 17592186044416.000000000 (559444-03-08 01:40:16)\n          item 1 key (450 INODE_REF 256) itemoff 16110 itemsize 13\n                  index 195 namelen 3 name: 193\n          item 2 key (450 XATTR_ITEM 1640047104) itemoff 16073 itemsize 37\n                  location key (0 UNKNOWN.0 0) type XATTR\n                  transid 7 data_len 1 name_len 6\n                  name: user.a\n                  data a\n          item 3 key (450 EXTENT_DATA 0) itemoff 16020 itemsize 53\n                  generation 9 type 1 (regular)\n                  extent data disk byte 303144960 nr 12288\n                  extent data offset 0 nr 4096 ram 12288\n                  extent compression 0 (none)\n          item 4 key (450 EXTENT_DATA 4096) itemoff 15967 itemsize 53\n                  generation 9 type 2 (prealloc)\n                  prealloc data disk byte 303144960 nr 12288\n                  prealloc data offset 4096 nr 8192\n          item 5 key (450 EXTENT_DATA 8192) itemoff 15914 itemsize 53\n                  generation 9 type 2 (prealloc)\n                  prealloc data disk byte 303144960 nr 12288\n                  prealloc data offset 8192 nr 4096\n  ...\n\nSo the real problem happened earlier: notice that items 4 (4k-12k) and 5\n(8k-12k) overlap. Both are prealloc extents. Item 4 straddles i_size and\nitem 5 starts at i_size.\n\nHere is the state of \n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1ff2bd566fbcefcb892be85c493bdb92b911c428",
      "https://git.kernel.org/stable/c/3d08c52ba1887a1ff9c179d4b6a18b427bcb2097",
      "https://git.kernel.org/stable/c/f4e5ed974876c14d3623e04dc43d3e3281bc6011",
      "https://git.kernel.org/stable/c/9d274c19a71b3a276949933859610721a453946b"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年06月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36959",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npinctrl: devicetree: fix refcount leak in pinctrl_dt_to_map()\n\nIf we fail to allocate propname buffer, we need to drop the reference\ncount we just took. Because the pinctrl_dt_free_maps() includes the\ndroping operation, here we call it directly.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/06780473cb8a858d1d6cab2673e021b072a852d1",
      "https://git.kernel.org/stable/c/47d253c485491caaf70d8cd8c0248ae26e42581f",
      "https://git.kernel.org/stable/c/35ab679e8bb5a81a4f922d3efbd43e32bce69274",
      "https://git.kernel.org/stable/c/76aa2440deb9a35507590f2c981a69a57ecd305d",
      "https://git.kernel.org/stable/c/518d5ddafeb084d6d9b1773ed85164300037d0e6",
      "https://git.kernel.org/stable/c/026e24cf31733dbd97f41cc9bc5273ace428eeec",
      "https://git.kernel.org/stable/c/c7e02ccc9fdc496fe51e440e3e66ac36509ca049",
      "https://git.kernel.org/stable/c/a0cedbcc8852d6c77b00634b81e41f17f29d9404"
    ],
    "受影响版本": [
      "a988dcd3dd9e691c5ccc3324b209688f3b5453e9",
      "040f726fecd88121f3b95e70369785ad452dddf9",
      "777430aa4ddccaa5accec6db90ffc1d47f00d471",
      "97e5b508e96176f1a73888ed89df396d7041bfcb",
      "91d5c5060ee24fe8da88cd585bb43b843d2f0dce",
      "91d5c5060ee24fe8da88cd585bb43b843d2f0dce",
      "91d5c5060ee24fe8da88cd585bb43b843d2f0dce",
      "91d5c5060ee24fe8da88cd585bb43b843d2f0dce",
      "aaf552c5d53abe4659176e099575fe870d2e4768",
      "b4d9f55cd38435358bc16d580612bc0d798d7b4c",
      "5834a3a98cd266ad35a229923c0adbd0addc8d68"
    ],
    "公开日期": "2024年05月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36947",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nqibfs: fix dentry leak\n\nsimple_recursive_removal() drops the pinning references to all positives\nin subtree.  For the cases when its argument has been kept alive by\nthe pinning alone that's exactly the right thing to do, but here\nthe argument comes from dcache lookup, that needs to be balanced by\nexplicit dput().\n\nFucked-up-by: Al Viro <viro@zeniv.linux.org.uk>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/24dd9b08df718f20ccf2dd1519909fefd8c233ee",
      "https://git.kernel.org/stable/c/bd8f78c71defbcb7a9ed331e7f287507df972b00",
      "https://git.kernel.org/stable/c/db71ca93259dd1078bcfea3afafde2143cfc2da7",
      "https://git.kernel.org/stable/c/02ee394a5d899d9bd2f0759382e9481cab6166f8",
      "https://git.kernel.org/stable/c/aa23317d0268b309bb3f0801ddd0d61813ff5afb"
    ],
    "受影响版本": [
      "e41d237818598c0b17458b4d0416b091a7959e55",
      "e41d237818598c0b17458b4d0416b091a7959e55",
      "e41d237818598c0b17458b4d0416b091a7959e55",
      "e41d237818598c0b17458b4d0416b091a7959e55",
      "e41d237818598c0b17458b4d0416b091a7959e55"
    ],
    "公开日期": "2024年05月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36944",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nReapply \"drm/qxl: simplify qxl_fence_wait\"\n\nThis reverts commit 07ed11afb68d94eadd4ffc082b97c2331307c5ea.\n\nStephen Rostedt reports:\n \"I went to run my tests on my VMs and the tests hung on boot up.\n  Unfortunately, the most I ever got out was:\n\n  [   93.607888] Testing event system initcall: OK\n  [   93.667730] Running tests on all trace events:\n  [   93.669757] Testing all events: OK\n  [   95.631064] ------------[ cut here ]------------\n  Timed out after 60 seconds\"\n\nand further debugging points to a possible circular locking dependency\nbetween the console_owner locking and the worker pool locking.\n\nReverting the commit allows Steve's VM to boot to completion again.\n\n[ This may obviously result in the \"[TTM] Buffer eviction failed\"\n  messages again, which was the reason for that original revert. But at\n  this point this seems preferable to a non-booting system... ]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4a89ac4b0921c4ea21eb1b4cf3a469a91bacfcea",
      "https://git.kernel.org/stable/c/b548c53bc3ab83dc6fc86c8e840f013b2032267a",
      "https://git.kernel.org/stable/c/148ed8b4d64f94ab079c8f0d88c3f444db97ba97",
      "https://git.kernel.org/stable/c/3dfe35d8683daf9ba69278643efbabe40000bbf6",
      "https://git.kernel.org/stable/c/3628e0383dd349f02f882e612ab6184e4bb3dc10"
    ],
    "受影响版本": [
      "8d278fc34cdd8a44e995fa93dfd31d619a2e1fe6",
      "84fb60063509e462e39c0e097c7d6dbb71c95967",
      "42cbe04a5c77da74fb7161b0ae63f1f6e105d633",
      "13ab5db42a593f9904acc39055ee3ae75963fc88",
      "07ed11afb68d94eadd4ffc082b97c2331307c5ea"
    ],
    "公开日期": "2024年05月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36941",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: nl80211: don't free NULL coalescing rule\n\nIf the parsing fails, we can dereference a NULL pointer here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/327382dc0f16b268950b96e0052595efd80f7b0a",
      "https://git.kernel.org/stable/c/97792d0611ae2e6fe3ccefb0a94a1d802317c457",
      "https://git.kernel.org/stable/c/5a730a161ac2290d46d49be76b2b1aee8d2eb307",
      "https://git.kernel.org/stable/c/ad12c74e953b68ad85c78adc6408ed8435c64af4",
      "https://git.kernel.org/stable/c/b0db4caa10f2e4e811cf88744fbf0d074b67ec1f",
      "https://git.kernel.org/stable/c/244822c09b4f9aedfb5977f03c0deeb39da8ec7d",
      "https://git.kernel.org/stable/c/f92772a642485394db5c9a17bd0ee73fc6902383",
      "https://git.kernel.org/stable/c/801ea33ae82d6a9d954074fbcf8ea9d18f1543a7"
    ],
    "受影响版本": [
      "be29b99a9b51b0338eea3c66a58de53bbd01de24",
      "be29b99a9b51b0338eea3c66a58de53bbd01de24",
      "be29b99a9b51b0338eea3c66a58de53bbd01de24",
      "be29b99a9b51b0338eea3c66a58de53bbd01de24",
      "be29b99a9b51b0338eea3c66a58de53bbd01de24",
      "be29b99a9b51b0338eea3c66a58de53bbd01de24",
      "be29b99a9b51b0338eea3c66a58de53bbd01de24",
      "be29b99a9b51b0338eea3c66a58de53bbd01de24"
    ],
    "公开日期": "2024年05月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36938",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, skmsg: Fix NULL pointer dereference in sk_psock_skb_ingress_enqueue\n\nFix NULL pointer data-races in sk_psock_skb_ingress_enqueue() which\nsyzbot reported [1].\n\n[1]\nBUG: KCSAN: data-race in sk_psock_drop / sk_psock_skb_ingress_enqueue\n\nwrite to 0xffff88814b3278b8 of 8 bytes by task 10724 on cpu 1:\n sk_psock_stop_verdict net/core/skmsg.c:1257 [inline]\n sk_psock_drop+0x13e/0x1f0 net/core/skmsg.c:843\n sk_psock_put include/linux/skmsg.h:459 [inline]\n sock_map_close+0x1a7/0x260 net/core/sock_map.c:1648\n unix_release+0x4b/0x80 net/unix/af_unix.c:1048\n __sock_release net/socket.c:659 [inline]\n sock_close+0x68/0x150 net/socket.c:1421\n __fput+0x2c1/0x660 fs/file_table.c:422\n __fput_sync+0x44/0x60 fs/file_table.c:507\n __do_sys_close fs/open.c:1556 [inline]\n __se_sys_close+0x101/0x1b0 fs/open.c:1541\n __x64_sys_close+0x1f/0x30 fs/open.c:1541\n do_syscall_64+0xd3/0x1d0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nread to 0xffff88814b3278b8 of 8 bytes by task 10713 on cpu 0:\n sk_psock_data_ready include/linux/skmsg.h:464 [inline]\n sk_psock_skb_ingress_enqueue+0x32d/0x390 net/core/skmsg.c:555\n sk_psock_skb_ingress_self+0x185/0x1e0 net/core/skmsg.c:606\n sk_psock_verdict_apply net/core/skmsg.c:1008 [inline]\n sk_psock_verdict_recv+0x3e4/0x4a0 net/core/skmsg.c:1202\n unix_read_skb net/unix/af_unix.c:2546 [inline]\n unix_stream_read_skb+0x9e/0xf0 net/unix/af_unix.c:2682\n sk_psock_verdict_data_ready+0x77/0x220 net/core/skmsg.c:1223\n unix_stream_sendmsg+0x527/0x860 net/unix/af_unix.c:2339\n sock_sendmsg_nosec net/socket.c:730 [inline]\n __sock_sendmsg+0x140/0x180 net/socket.c:745\n ____sys_sendmsg+0x312/0x410 net/socket.c:2584\n ___sys_sendmsg net/socket.c:2638 [inline]\n __sys_sendmsg+0x1e9/0x280 net/socket.c:2667\n __do_sys_sendmsg net/socket.c:2676 [inline]\n __se_sys_sendmsg net/socket.c:2674 [inline]\n __x64_sys_sendmsg+0x46/0x50 net/socket.c:2674\n do_syscall_64+0xd3/0x1d0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nvalue changed: 0xffffffff83d7feb0 -> 0x0000000000000000\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 0 PID: 10713 Comm: syz-executor.4 Tainted: G        W          6.8.0-syzkaller-08951-gfe46a7dd189e #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/29/2024\n\nPrior to this, commit 4cd12c6065df (\"bpf, sockmap: Fix NULL pointer\ndereference in sk_psock_verdict_data_ready()\") fixed one NULL pointer\nsimilarly due to no protection of saved_data_ready. Here is another\ndifferent caller causing the same issue because of the same reason. So\nwe should protect it with sk_callback_lock read lock because the writer\nside in the sk_psock_drop() uses \"write_lock_bh(&sk->sk_callback_lock);\".\n\nTo avoid errors that could happen in future, I move those two pairs of\nlock into the sk_psock_data_ready(), which is suggested by John Fastabend.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c0809c128dad4c3413818384eb06a341633db973",
      "https://git.kernel.org/stable/c/5965bc7535fb87510b724e5465ccc1a1cf00916d",
      "https://git.kernel.org/stable/c/39dc9e1442385d6e9be0b6491ee488dddd55ae27",
      "https://git.kernel.org/stable/c/b397a0ab8582c533ec0c6b732392f141fc364f87",
      "https://git.kernel.org/stable/c/772d5729b5ff0df0d37b32db600ce635b2172f80",
      "https://git.kernel.org/stable/c/6648e613226e18897231ab5e42ffc29e63fa3365"
    ],
    "受影响版本": [
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c",
      "604326b41a6fb9b4a78b6179335decee0365cd8c"
    ],
    "公开日期": "2024年05月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36919",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: bnx2fc: Remove spin_lock_bh while releasing resources after upload\n\nThe session resources are used by FW and driver when session is offloaded,\nonce session is uploaded these resources are not used. The lock is not\nrequired as these fields won't be used any longer. The offload and upload\ncalls are sequential, hence lock is not required.\n\nThis will suppress following BUG_ON():\n\n[  449.843143] ------------[ cut here ]------------\n[  449.848302] kernel BUG at mm/vmalloc.c:2727!\n[  449.853072] invalid opcode: 0000 [#1] PREEMPT SMP PTI\n[  449.858712] CPU: 5 PID: 1996 Comm: kworker/u24:2 Not tainted 5.14.0-118.el9.x86_64 #1\nRebooting.\n[  449.867454] Hardware name: Dell Inc. PowerEdge R730/0WCJNT, BIOS 2.3.4 11/08/2016\n[  449.876966] Workqueue: fc_rport_eq fc_rport_work [libfc]\n[  449.882910] RIP: 0010:vunmap+0x2e/0x30\n[  449.887098] Code: 00 65 8b 05 14 a2 f0 4a a9 00 ff ff 00 75 1b 55 48 89 fd e8 34 36 79 00 48 85 ed 74 0b 48 89 ef 31 f6 5d e9 14 fc ff ff 5d c3 <0f> 0b 0f 1f 44 00 00 41 57 41 56 49 89 ce 41 55 49 89 fd 41 54 41\n[  449.908054] RSP: 0018:ffffb83d878b3d68 EFLAGS: 00010206\n[  449.913887] RAX: 0000000080000201 RBX: ffff8f4355133550 RCX: 000000000d400005\n[  449.921843] RDX: 0000000000000001 RSI: 0000000000001000 RDI: ffffb83da53f5000\n[  449.929808] RBP: ffff8f4ac6675800 R08: ffffb83d878b3d30 R09: 00000000000efbdf\n[  449.937774] R10: 0000000000000003 R11: ffff8f434573e000 R12: 0000000000001000\n[  449.945736] R13: 0000000000001000 R14: ffffb83da53f5000 R15: ffff8f43d4ea3ae0\n[  449.953701] FS:  0000000000000000(0000) GS:ffff8f529fc80000(0000) knlGS:0000000000000000\n[  449.962732] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  449.969138] CR2: 00007f8cf993e150 CR3: 0000000efbe10003 CR4: 00000000003706e0\n[  449.977102] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  449.985065] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  449.993028] Call Trace:\n[  449.995756]  __iommu_dma_free+0x96/0x100\n[  450.000139]  bnx2fc_free_session_resc+0x67/0x240 [bnx2fc]\n[  450.006171]  bnx2fc_upload_session+0xce/0x100 [bnx2fc]\n[  450.011910]  bnx2fc_rport_event_handler+0x9f/0x240 [bnx2fc]\n[  450.018136]  fc_rport_work+0x103/0x5b0 [libfc]\n[  450.023103]  process_one_work+0x1e8/0x3c0\n[  450.027581]  worker_thread+0x50/0x3b0\n[  450.031669]  ? rescuer_thread+0x370/0x370\n[  450.036143]  kthread+0x149/0x170\n[  450.039744]  ? set_kthread_struct+0x40/0x40\n[  450.044411]  ret_from_fork+0x22/0x30\n[  450.048404] Modules linked in: vfat msdos fat xfs nfs_layout_nfsv41_files rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver dm_service_time qedf qed crc8 bnx2fc libfcoe libfc scsi_transport_fc intel_rapl_msr intel_rapl_common x86_pkg_temp_thermal intel_powerclamp dcdbas rapl intel_cstate intel_uncore mei_me pcspkr mei ipmi_ssif lpc_ich ipmi_si fuse zram ext4 mbcache jbd2 loop nfsv3 nfs_acl nfs lockd grace fscache netfs irdma ice sd_mod t10_pi sg ib_uverbs ib_core 8021q garp mrp stp llc mgag200 i2c_algo_bit drm_kms_helper syscopyarea sysfillrect sysimgblt mxm_wmi fb_sys_fops cec crct10dif_pclmul ahci crc32_pclmul bnx2x drm ghash_clmulni_intel libahci rfkill i40e libata megaraid_sas mdio wmi sunrpc lrw dm_crypt dm_round_robin dm_multipath dm_snapshot dm_bufio dm_mirror dm_region_hash dm_log dm_zero dm_mod linear raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx raid6_pq libcrc32c crc32c_intel raid1 raid0 iscsi_ibft squashfs be2iscsi bnx2i cnic uio cxgb4i cxgb4 tls\n[  450.048497]  libcxgbi libcxgb qla4xxx iscsi_boot_sysfs iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi edd ipmi_devintf ipmi_msghandler\n[  450.159753] ---[ end trace 712de2c57c64abc8 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/468f3e3c15076338367b0945b041105b67cf31e3",
      "https://git.kernel.org/stable/c/acd370c1fb86b7302c1cbb354a7c1cd9953768eb",
      "https://git.kernel.org/stable/c/ad498539dda0816aadef384ec117bfea304c75c3",
      "https://git.kernel.org/stable/c/93aa5ccc44781bdfef1bf0bc4c2c292d45251312",
      "https://git.kernel.org/stable/c/1150606d47d711d5bfdf329a1a96ed7027085936",
      "https://git.kernel.org/stable/c/c885ab23206b1f1ba0731ffe7c9455c6a91db256",
      "https://git.kernel.org/stable/c/ea50941cd8c9f0b12f38b73d3b1bfeca660dd342",
      "https://git.kernel.org/stable/c/c214ed2a4dda35b308b0b28eed804d7ae66401f9"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年05月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36916",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-iocost: avoid out of bounds shift\n\nUBSAN catches undefined behavior in blk-iocost, where sometimes\niocg->delay is shifted right by a number that is too large,\nresulting in undefined behavior on some architectures.\n\n[  186.556576] ------------[ cut here ]------------\nUBSAN: shift-out-of-bounds in block/blk-iocost.c:1366:23\nshift exponent 64 is too large for 64-bit type 'u64' (aka 'unsigned long long')\nCPU: 16 PID: 0 Comm: swapper/16 Tainted: G S          E    N 6.9.0-0_fbk700_debug_rc2_kbuilder_0_gc85af715cac0 #1\nHardware name: Quanta Twin Lakes MP/Twin Lakes Passive MP, BIOS F09_3A23 12/08/2020\nCall Trace:\n <IRQ>\n dump_stack_lvl+0x8f/0xe0\n __ubsan_handle_shift_out_of_bounds+0x22c/0x280\n iocg_kick_delay+0x30b/0x310\n ioc_timer_fn+0x2fb/0x1f80\n __run_timer_base+0x1b6/0x250\n...\n\nAvoid that undefined behavior by simply taking the\n\"delay = 0\" branch if the shift is too large.\n\nI am not sure what the symptoms of an undefined value\ndelay will be, but I suspect it could be more than a\nlittle annoying to debug.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/62accf6c1d7b433752cb3591bba8967b7a801ad5",
      "https://git.kernel.org/stable/c/844fc023e9f14a4fb1de5ae1eaefafd6d69c5fa1",
      "https://git.kernel.org/stable/c/f6add0a6f78dc6360b822ca4b6f9f2f14174c8ca",
      "https://git.kernel.org/stable/c/ce0e99cae00e3131872936713b7f55eefd53ab86",
      "https://git.kernel.org/stable/c/488dc6808cb8369685f18cee81e88e7052ac153b",
      "https://git.kernel.org/stable/c/beaa51b36012fad5a4d3c18b88a617aea7a9b96d"
    ],
    "受影响版本": [
      "5160a5a53c0c4ae3708959d9465ea43ad5d90542",
      "5160a5a53c0c4ae3708959d9465ea43ad5d90542",
      "5160a5a53c0c4ae3708959d9465ea43ad5d90542",
      "5160a5a53c0c4ae3708959d9465ea43ad5d90542",
      "5160a5a53c0c4ae3708959d9465ea43ad5d90542",
      "5160a5a53c0c4ae3708959d9465ea43ad5d90542"
    ],
    "公开日期": "2024年05月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36901",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: prevent NULL dereference in ip6_output()\n\nAccording to syzbot, there is a chance that ip6_dst_idev()\nreturns NULL in ip6_output(). Most places in IPv6 stack\ndeal with a NULL idev just fine, but not here.\n\nsyzbot reported:\n\ngeneral protection fault, probably for non-canonical address 0xdffffc00000000bc: 0000 [#1] PREEMPT SMP KASAN PTI\nKASAN: null-ptr-deref in range [0x00000000000005e0-0x00000000000005e7]\nCPU: 0 PID: 9775 Comm: syz-executor.4 Not tainted 6.9.0-rc5-syzkaller-00157-g6a30653b604a #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\n RIP: 0010:ip6_output+0x231/0x3f0 net/ipv6/ip6_output.c:237\nCode: 3c 1e 00 49 89 df 74 08 4c 89 ef e8 19 58 db f7 48 8b 44 24 20 49 89 45 00 49 89 c5 48 8d 9d e0 05 00 00 48 89 d8 48 c1 e8 03 <42> 0f b6 04 38 84 c0 4c 8b 74 24 28 0f 85 61 01 00 00 8b 1b 31 ff\nRSP: 0018:ffffc9000927f0d8 EFLAGS: 00010202\nRAX: 00000000000000bc RBX: 00000000000005e0 RCX: 0000000000040000\nRDX: ffffc900131f9000 RSI: 0000000000004f47 RDI: 0000000000004f48\nRBP: 0000000000000000 R08: ffffffff8a1f0b9a R09: 1ffffffff1f51fad\nR10: dffffc0000000000 R11: fffffbfff1f51fae R12: ffff8880293ec8c0\nR13: ffff88805d7fc000 R14: 1ffff1100527d91a R15: dffffc0000000000\nFS:  00007f135c6856c0(0000) GS:ffff8880b9400000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000080 CR3: 0000000064096000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n  NF_HOOK include/linux/netfilter.h:314 [inline]\n  ip6_xmit+0xefe/0x17f0 net/ipv6/ip6_output.c:358\n  sctp_v6_xmit+0x9f2/0x13f0 net/sctp/ipv6.c:248\n  sctp_packet_transmit+0x26ad/0x2ca0 net/sctp/output.c:653\n  sctp_packet_singleton+0x22c/0x320 net/sctp/outqueue.c:783\n  sctp_outq_flush_ctrl net/sctp/outqueue.c:914 [inline]\n  sctp_outq_flush+0x6d5/0x3e20 net/sctp/outqueue.c:1212\n  sctp_side_effects net/sctp/sm_sideeffect.c:1198 [inline]\n  sctp_do_sm+0x59cc/0x60c0 net/sctp/sm_sideeffect.c:1169\n  sctp_primitive_ASSOCIATE+0x95/0xc0 net/sctp/primitive.c:73\n  __sctp_connect+0x9cd/0xe30 net/sctp/socket.c:1234\n  sctp_connect net/sctp/socket.c:4819 [inline]\n  sctp_inet_connect+0x149/0x1f0 net/sctp/socket.c:4834\n  __sys_connect_file net/socket.c:2048 [inline]\n  __sys_connect+0x2df/0x310 net/socket.c:2065\n  __do_sys_connect net/socket.c:2075 [inline]\n  __se_sys_connect net/socket.c:2072 [inline]\n  __x64_sys_connect+0x7a/0x90 net/socket.c:2072\n  do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n  do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9df3b2474a627994433a87cbf325a562555b17de",
      "https://git.kernel.org/stable/c/2272e2db38f2e85929278146d7c770f22f528579",
      "https://git.kernel.org/stable/c/ea0cb87402f774b0e1214ffba0f57028b27cf155",
      "https://git.kernel.org/stable/c/e31b25cc2066d3f2b6c38579253882008d4469b0",
      "https://git.kernel.org/stable/c/55f7eb4001ef2a3b48cf039cf263f9ed0ec5a488",
      "https://git.kernel.org/stable/c/4db783d68b9b39a411a96096c10828ff5dfada7a"
    ],
    "受影响版本": [
      "778d80be52699596bf70e0eb0761cf5e1e46088d",
      "778d80be52699596bf70e0eb0761cf5e1e46088d",
      "778d80be52699596bf70e0eb0761cf5e1e46088d",
      "778d80be52699596bf70e0eb0761cf5e1e46088d",
      "778d80be52699596bf70e0eb0761cf5e1e46088d",
      "778d80be52699596bf70e0eb0761cf5e1e46088d"
    ],
    "公开日期": "2024年05月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36899",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpiolib: cdev: Fix use after free in lineinfo_changed_notify\n\nThe use-after-free issue occurs as follows: when the GPIO chip device file\nis being closed by invoking gpio_chrdev_release(), watched_lines is freed\nby bitmap_free(), but the unregistration of lineinfo_changed_nb notifier\nchain failed due to waiting write rwsem. Additionally, one of the GPIO\nchip's lines is also in the release process and holds the notifier chain's\nread rwsem. Consequently, a race condition leads to the use-after-free of\nwatched_lines.\n\nHere is the typical stack when issue happened:\n\n[free]\ngpio_chrdev_release()\n  --> bitmap_free(cdev->watched_lines)                  <-- freed\n  --> blocking_notifier_chain_unregister()\n    --> down_write(&nh->rwsem)                          <-- waiting rwsem\n          --> __down_write_common()\n            --> rwsem_down_write_slowpath()\n                  --> schedule_preempt_disabled()\n                    --> schedule()\n\n[use]\nst54spi_gpio_dev_release()\n  --> gpio_free()\n    --> gpiod_free()\n      --> gpiod_free_commit()\n        --> gpiod_line_state_notify()\n          --> blocking_notifier_call_chain()\n            --> down_read(&nh->rwsem);                  <-- held rwsem\n            --> notifier_call_chain()\n              --> lineinfo_changed_notify()\n                --> test_bit(xxxx, cdev->watched_lines) <-- use after free\n\nThe side effect of the use-after-free issue is that a GPIO line event is\nbeing generated for userspace where it shouldn't. However, since the chrdev\nis being closed, userspace won't have the chance to read that event anyway.\n\nTo fix the issue, call the bitmap_free() function after the unregistration\nof lineinfo_changed_nb notifier chain.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2dfbb920a89bdc58087672ad5325dc6c588b6860",
      "https://git.kernel.org/stable/c/2d008d4961b039d2edce8976289773961b7e5fb5",
      "https://git.kernel.org/stable/c/d38c49f7bdf14381270736299e2ff68ec248a017",
      "https://git.kernel.org/stable/c/95ca7c90eaf5ea8a8460536535101e3e81160e2a",
      "https://git.kernel.org/stable/c/ca710b5f40b8b16fdcad50bebd47f50e4c62d239",
      "https://git.kernel.org/stable/c/02f6b0e1ec7e0e7d059dddc893645816552039da"
    ],
    "受影响版本": [
      "51c1064e82e77b39a49889287ca50709303e2f26",
      "51c1064e82e77b39a49889287ca50709303e2f26",
      "51c1064e82e77b39a49889287ca50709303e2f26",
      "51c1064e82e77b39a49889287ca50709303e2f26",
      "51c1064e82e77b39a49889287ca50709303e2f26",
      "51c1064e82e77b39a49889287ca50709303e2f26"
    ],
    "公开日期": "2024年05月30日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36009",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nax25: Fix netdev refcount issue\n\nThe dev_tracker is added to ax25_cb in ax25_bind(). When the\nax25 device is detaching, the dev_tracker of ax25_cb should be\ndeallocated in ax25_kill_by_device() instead of the dev_tracker\nof ax25_dev. The log reported by ref_tracker is shown below:\n\n[   80.884935] ref_tracker: reference already released.\n[   80.885150] ref_tracker: allocated in:\n[   80.885349]  ax25_dev_device_up+0x105/0x540\n[   80.885730]  ax25_device_event+0xa4/0x420\n[   80.885730]  notifier_call_chain+0xc9/0x1e0\n[   80.885730]  __dev_notify_flags+0x138/0x280\n[   80.885730]  dev_change_flags+0xd7/0x180\n[   80.885730]  dev_ifsioc+0x6a9/0xa30\n[   80.885730]  dev_ioctl+0x4d8/0xd90\n[   80.885730]  sock_do_ioctl+0x1c2/0x2d0\n[   80.885730]  sock_ioctl+0x38b/0x4f0\n[   80.885730]  __se_sys_ioctl+0xad/0xf0\n[   80.885730]  do_syscall_64+0xc4/0x1b0\n[   80.885730]  entry_SYSCALL_64_after_hwframe+0x67/0x6f\n[   80.885730] ref_tracker: freed in:\n[   80.885730]  ax25_device_event+0x272/0x420\n[   80.885730]  notifier_call_chain+0xc9/0x1e0\n[   80.885730]  dev_close_many+0x272/0x370\n[   80.885730]  unregister_netdevice_many_notify+0x3b5/0x1180\n[   80.885730]  unregister_netdev+0xcf/0x120\n[   80.885730]  sixpack_close+0x11f/0x1b0\n[   80.885730]  tty_ldisc_kill+0xcb/0x190\n[   80.885730]  tty_ldisc_hangup+0x338/0x3d0\n[   80.885730]  __tty_hangup+0x504/0x740\n[   80.885730]  tty_release+0x46e/0xd80\n[   80.885730]  __fput+0x37f/0x770\n[   80.885730]  __x64_sys_close+0x7b/0xb0\n[   80.885730]  do_syscall_64+0xc4/0x1b0\n[   80.885730]  entry_SYSCALL_64_after_hwframe+0x67/0x6f\n[   80.893739] ------------[ cut here ]------------\n[   80.894030] WARNING: CPU: 2 PID: 140 at lib/ref_tracker.c:255 ref_tracker_free+0x47b/0x6b0\n[   80.894297] Modules linked in:\n[   80.894929] CPU: 2 PID: 140 Comm: ax25_conn_rel_6 Not tainted 6.9.0-rc4-g8cd26fd90c1a #11\n[   80.895190] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qem4\n[   80.895514] RIP: 0010:ref_tracker_free+0x47b/0x6b0\n[   80.895808] Code: 83 c5 18 4c 89 eb 48 c1 eb 03 8a 04 13 84 c0 0f 85 df 01 00 00 41 83 7d 00 00 75 4b 4c 89 ff 9\n[   80.896171] RSP: 0018:ffff888009edf8c0 EFLAGS: 00000286\n[   80.896339] RAX: 1ffff1100141ac00 RBX: 1ffff1100149463b RCX: dffffc0000000000\n[   80.896502] RDX: 0000000000000001 RSI: 0000000000000246 RDI: ffff88800a0d6518\n[   80.896925] RBP: ffff888009edf9b0 R08: ffff88806d3288d3 R09: 1ffff1100da6511a\n[   80.897212] R10: dffffc0000000000 R11: ffffed100da6511b R12: ffff88800a4a31d4\n[   80.897859] R13: ffff88800a4a31d8 R14: dffffc0000000000 R15: ffff88800a0d6518\n[   80.898279] FS:  00007fd88b7fe700(0000) GS:ffff88806d300000(0000) knlGS:0000000000000000\n[   80.899436] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   80.900181] CR2: 00007fd88c001d48 CR3: 000000000993e000 CR4: 00000000000006f0\n...\n[   80.935774] ref_tracker: sp%d@000000000bb9df3d has 1/1 users at\n[   80.935774]      ax25_bind+0x424/0x4e0\n[   80.935774]      __sys_bind+0x1d9/0x270\n[   80.935774]      __x64_sys_bind+0x75/0x80\n[   80.935774]      do_syscall_64+0xc4/0x1b0\n[   80.935774]      entry_SYSCALL_64_after_hwframe+0x67/0x6f\n\nChange ax25_dev->dev_tracker to the dev_tracker of ax25_cb\nin order to mitigate the bug.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0d14f104027e30720582448706c7d6b43065c851",
      "https://git.kernel.org/stable/c/4fee8fa86a15d7790268eea458b1aec69c695530",
      "https://git.kernel.org/stable/c/c42b073d9af4a5329b25b17390c63ab3847f30e8",
      "https://git.kernel.org/stable/c/467324bcfe1a31ec65d0cf4aa59421d6b7a7d52b"
    ],
    "受影响版本": [
      "feef318c855a361a1eccd880f33e88c460eb63b4",
      "feef318c855a361a1eccd880f33e88c460eb63b4",
      "feef318c855a361a1eccd880f33e88c460eb63b4",
      "feef318c855a361a1eccd880f33e88c460eb63b4",
      "b8c07f33aa35dacf5444e7053ed9662d1869f536",
      "b1e0a6fc7f17500484c402ad1cd018c24dfc14b3",
      "7528d0f2210c3a1154186175516ed37aa970f2b1",
      "57cc15f5fd550316e4104eaf84b90fbc640fd7a5",
      "b982492ec3a115e0a136856a1b2dbe32f2d21a0e"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36007",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum_acl_tcam: Fix warning during rehash\n\nAs previously explained, the rehash delayed work migrates filters from\none region to another. This is done by iterating over all chunks (all\nthe filters with the same priority) in the region and in each chunk\niterating over all the filters.\n\nWhen the work runs out of credits it stores the current chunk and entry\nas markers in the per-work context so that it would know where to resume\nthe migration from the next time the work is scheduled.\n\nUpon error, the chunk marker is reset to NULL, but without resetting the\nentry markers despite being relative to it. This can result in migration\nbeing resumed from an entry that does not belong to the chunk being\nmigrated. In turn, this will eventually lead to a chunk being iterated\nover as if it is an entry. Because of how the two structures happen to\nbe defined, this does not lead to KASAN splats, but to warnings such as\n[1].\n\nFix by creating a helper that resets all the markers and call it from\nall the places the currently only reset the chunk marker. For good\nmeasures also call it when starting a completely new rehash. Add a\nwarning to avoid future cases.\n\n[1]\nWARNING: CPU: 7 PID: 1076 at drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_keys.c:407 mlxsw_afk_encode+0x242/0x2f0\nModules linked in:\nCPU: 7 PID: 1076 Comm: kworker/7:24 Tainted: G        W          6.9.0-rc3-custom-00880-g29e61d91b77b #29\nHardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019\nWorkqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work\nRIP: 0010:mlxsw_afk_encode+0x242/0x2f0\n[...]\nCall Trace:\n <TASK>\n mlxsw_sp_acl_atcam_entry_add+0xd9/0x3c0\n mlxsw_sp_acl_tcam_entry_create+0x5e/0xa0\n mlxsw_sp_acl_tcam_vchunk_migrate_all+0x109/0x290\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x6c/0x470\n process_one_work+0x151/0x370\n worker_thread+0x2cb/0x3e0\n kthread+0xd0/0x100\n ret_from_fork+0x34/0x50\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0b88631855026b55cad901ac28d081e0f358e596",
      "https://git.kernel.org/stable/c/1d76bd2a0034d0d08045c1c6adf2235d88982952",
      "https://git.kernel.org/stable/c/039992b6d2df097c65f480dcf269de3d2656f573",
      "https://git.kernel.org/stable/c/751d352858108314efd33dddd5a9a2b6bf7d6916",
      "https://git.kernel.org/stable/c/e890456051fe8c57944b911defb3e6de91315861",
      "https://git.kernel.org/stable/c/17e9e0bbae652b9b2049e51699e93dfa60b2988d",
      "https://git.kernel.org/stable/c/743edc8547a92b6192aa1f1b6bb78233fa21dc9b"
    ],
    "受影响版本": [
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36006",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum_acl_tcam: Fix incorrect list API usage\n\nBoth the function that migrates all the chunks within a region and the\nfunction that migrates all the entries within a chunk call\nlist_first_entry() on the respective lists without checking that the\nlists are not empty. This is incorrect usage of the API, which leads to\nthe following warning [1].\n\nFix by returning if the lists are empty as there is nothing to migrate\nin this case.\n\n[1]\nWARNING: CPU: 0 PID: 6437 at drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c:1266 mlxsw_sp_acl_tcam_vchunk_migrate_all+0x1f1/0>\nModules linked in:\nCPU: 0 PID: 6437 Comm: kworker/0:37 Not tainted 6.9.0-rc3-custom-00883-g94a65f079ef6 #39\nHardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019\nWorkqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work\nRIP: 0010:mlxsw_sp_acl_tcam_vchunk_migrate_all+0x1f1/0x2c0\n[...]\nCall Trace:\n <TASK>\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x6c/0x4a0\n process_one_work+0x151/0x370\n worker_thread+0x2cb/0x3e0\n kthread+0xd0/0x100\n ret_from_fork+0x34/0x50\n ret_from_fork_asm+0x1a/0x30\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0b2c13b670b168e324e1cf109e67056a20fd610a",
      "https://git.kernel.org/stable/c/09846c2309b150b8ce4e0ce96f058197598fc530",
      "https://git.kernel.org/stable/c/64435b64e43d8ee60faa46c0cd04e323e8b2a7b0",
      "https://git.kernel.org/stable/c/4526a56e02da3725db979358964df9cd9c567154",
      "https://git.kernel.org/stable/c/ab4ecfb627338e440ae11def004c524a00d93e40",
      "https://git.kernel.org/stable/c/af8b593c3dd9df82cb199be65863af004b09fd97",
      "https://git.kernel.org/stable/c/b377add0f0117409c418ddd6504bd682ebe0bf79"
    ],
    "受影响版本": [
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf",
      "6f9579d4e3021b17b0a4cde6b04a6c94c9575cdf"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36005",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: honor table dormant flag from netdev release event path\n\nCheck for table dormant flag otherwise netdev release event path tries\nto unregister an already unregistered hook.\n\n[524854.857999] ------------[ cut here ]------------\n[524854.858010] WARNING: CPU: 0 PID: 3386599 at net/netfilter/core.c:501 __nf_unregister_net_hook+0x21a/0x260\n[...]\n[524854.858848] CPU: 0 PID: 3386599 Comm: kworker/u32:2 Not tainted 6.9.0-rc3+ #365\n[524854.858869] Workqueue: netns cleanup_net\n[524854.858886] RIP: 0010:__nf_unregister_net_hook+0x21a/0x260\n[524854.858903] Code: 24 e8 aa 73 83 ff 48 63 43 1c 83 f8 01 0f 85 3d ff ff ff e8 98 d1 f0 ff 48 8b 3c 24 e8 8f 73 83 ff 48 63 43 1c e9 26 ff ff ff <0f> 0b 48 83 c4 18 48 c7 c7 00 68 e9 82 5b 5d 41 5c 41 5d 41 5e 41\n[524854.858914] RSP: 0018:ffff8881e36d79e0 EFLAGS: 00010246\n[524854.858926] RAX: 0000000000000000 RBX: ffff8881339ae790 RCX: ffffffff81ba524a\n[524854.858936] RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff8881c8a16438\n[524854.858945] RBP: ffff8881c8a16438 R08: 0000000000000001 R09: ffffed103c6daf34\n[524854.858954] R10: ffff8881e36d79a7 R11: 0000000000000000 R12: 0000000000000005\n[524854.858962] R13: ffff8881c8a16000 R14: 0000000000000000 R15: ffff8881351b5a00\n[524854.858971] FS:  0000000000000000(0000) GS:ffff888390800000(0000) knlGS:0000000000000000\n[524854.858982] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[524854.858991] CR2: 00007fc9be0f16f4 CR3: 00000001437cc004 CR4: 00000000001706f0\n[524854.859000] Call Trace:\n[524854.859006]  <TASK>\n[524854.859013]  ? __warn+0x9f/0x1a0\n[524854.859027]  ? __nf_unregister_net_hook+0x21a/0x260\n[524854.859044]  ? report_bug+0x1b1/0x1e0\n[524854.859060]  ? handle_bug+0x3c/0x70\n[524854.859071]  ? exc_invalid_op+0x17/0x40\n[524854.859083]  ? asm_exc_invalid_op+0x1a/0x20\n[524854.859100]  ? __nf_unregister_net_hook+0x6a/0x260\n[524854.859116]  ? __nf_unregister_net_hook+0x21a/0x260\n[524854.859135]  nf_tables_netdev_event+0x337/0x390 [nf_tables]\n[524854.859304]  ? __pfx_nf_tables_netdev_event+0x10/0x10 [nf_tables]\n[524854.859461]  ? packet_notifier+0xb3/0x360\n[524854.859476]  ? _raw_spin_unlock_irqrestore+0x11/0x40\n[524854.859489]  ? dcbnl_netdevice_event+0x35/0x140\n[524854.859507]  ? __pfx_nf_tables_netdev_event+0x10/0x10 [nf_tables]\n[524854.859661]  notifier_call_chain+0x7d/0x140\n[524854.859677]  unregister_netdevice_many_notify+0x5e1/0xae0",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e4bb6da24de336a7899033a65490ed2d892efa5b",
      "https://git.kernel.org/stable/c/5c45feb3c288cf44a529e2657b36c259d86497d2",
      "https://git.kernel.org/stable/c/13ba94f6cc820fdea15efeaa17d4c722874eebf9",
      "https://git.kernel.org/stable/c/8260c980aee7d8d8a3db39faf19c391d2f898816",
      "https://git.kernel.org/stable/c/ca34c40d1c22c555fa7f4a21a1c807fea7290a0a",
      "https://git.kernel.org/stable/c/8e30abc9ace4f0add4cd761dfdbfaebae5632dd2"
    ],
    "受影响版本": [
      "d54725cd11a57c30f650260cfb0a92c268bdc3e0",
      "d54725cd11a57c30f650260cfb0a92c268bdc3e0",
      "d54725cd11a57c30f650260cfb0a92c268bdc3e0",
      "d54725cd11a57c30f650260cfb0a92c268bdc3e0",
      "d54725cd11a57c30f650260cfb0a92c268bdc3e0",
      "d54725cd11a57c30f650260cfb0a92c268bdc3e0"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36004",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: Do not use WQ_MEM_RECLAIM flag for workqueue\n\nIssue reported by customer during SRIOV testing, call trace:\nWhen both i40e and the i40iw driver are loaded, a warning\nin check_flush_dependency is being triggered. This seems\nto be because of the i40e driver workqueue is allocated with\nthe WQ_MEM_RECLAIM flag, and the i40iw one is not.\n\nSimilar error was encountered on ice too and it was fixed by\nremoving the flag. Do the same for i40e too.\n\n[Feb 9 09:08] ------------[ cut here ]------------\n[  +0.000004] workqueue: WQ_MEM_RECLAIM i40e:i40e_service_task [i40e] is\nflushing !WQ_MEM_RECLAIM infiniband:0x0\n[  +0.000060] WARNING: CPU: 0 PID: 937 at kernel/workqueue.c:2966\ncheck_flush_dependency+0x10b/0x120\n[  +0.000007] Modules linked in: snd_seq_dummy snd_hrtimer snd_seq\nsnd_timer snd_seq_device snd soundcore nls_utf8 cifs cifs_arc4\nnls_ucs2_utils rdma_cm iw_cm ib_cm cifs_md4 dns_resolver netfs qrtr\nrfkill sunrpc vfat fat intel_rapl_msr intel_rapl_common irdma\nintel_uncore_frequency intel_uncore_frequency_common ice ipmi_ssif\nisst_if_common skx_edac nfit libnvdimm x86_pkg_temp_thermal\nintel_powerclamp gnss coretemp ib_uverbs rapl intel_cstate ib_core\niTCO_wdt iTCO_vendor_support acpi_ipmi mei_me ipmi_si intel_uncore\nioatdma i2c_i801 joydev pcspkr mei ipmi_devintf lpc_ich\nintel_pch_thermal i2c_smbus ipmi_msghandler acpi_power_meter acpi_pad\nxfs libcrc32c ast sd_mod drm_shmem_helper t10_pi drm_kms_helper sg ixgbe\ndrm i40e ahci crct10dif_pclmul libahci crc32_pclmul igb crc32c_intel\nlibata ghash_clmulni_intel i2c_algo_bit mdio dca wmi dm_mirror\ndm_region_hash dm_log dm_mod fuse\n[  +0.000050] CPU: 0 PID: 937 Comm: kworker/0:3 Kdump: loaded Not\ntainted 6.8.0-rc2-Feb-net_dev-Qiueue-00279-gbd43c5687e05 #1\n[  +0.000003] Hardware name: Intel Corporation S2600BPB/S2600BPB, BIOS\nSE5C620.86B.02.01.0013.121520200651 12/15/2020\n[  +0.000001] Workqueue: i40e i40e_service_task [i40e]\n[  +0.000024] RIP: 0010:check_flush_dependency+0x10b/0x120\n[  +0.000003] Code: ff 49 8b 54 24 18 48 8d 8b b0 00 00 00 49 89 e8 48\n81 c6 b0 00 00 00 48 c7 c7 b0 97 fa 9f c6 05 8a cc 1f 02 01 e8 35 b3 fd\nff <0f> 0b e9 10 ff ff ff 80 3d 78 cc 1f 02 00 75 94 e9 46 ff ff ff 90\n[  +0.000002] RSP: 0018:ffffbd294976bcf8 EFLAGS: 00010282\n[  +0.000002] RAX: 0000000000000000 RBX: ffff94d4c483c000 RCX:\n0000000000000027\n[  +0.000001] RDX: ffff94d47f620bc8 RSI: 0000000000000001 RDI:\nffff94d47f620bc0\n[  +0.000001] RBP: 0000000000000000 R08: 0000000000000000 R09:\n00000000ffff7fff\n[  +0.000001] R10: ffffbd294976bb98 R11: ffffffffa0be65e8 R12:\nffff94c5451ea180\n[  +0.000001] R13: ffff94c5ab5e8000 R14: ffff94c5c20b6e05 R15:\nffff94c5f1330ab0\n[  +0.000001] FS:  0000000000000000(0000) GS:ffff94d47f600000(0000)\nknlGS:0000000000000000\n[  +0.000002] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  +0.000001] CR2: 00007f9e6f1fca70 CR3: 0000000038e20004 CR4:\n00000000007706f0\n[  +0.000000] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n0000000000000000\n[  +0.000001] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:\n0000000000000400\n[  +0.000001] PKRU: 55555554\n[  +0.000001] Call Trace:\n[  +0.000001]  <TASK>\n[  +0.000002]  ? __warn+0x80/0x130\n[  +0.000003]  ? check_flush_dependency+0x10b/0x120\n[  +0.000002]  ? report_bug+0x195/0x1a0\n[  +0.000005]  ? handle_bug+0x3c/0x70\n[  +0.000003]  ? exc_invalid_op+0x14/0x70\n[  +0.000002]  ? asm_exc_invalid_op+0x16/0x20\n[  +0.000006]  ? check_flush_dependency+0x10b/0x120\n[  +0.000002]  ? check_flush_dependency+0x10b/0x120\n[  +0.000002]  __flush_workqueue+0x126/0x3f0\n[  +0.000015]  ib_cache_cleanup_one+0x1c/0xe0 [ib_core]\n[  +0.000056]  __ib_unregister_device+0x6a/0xb0 [ib_core]\n[  +0.000023]  ib_unregister_device_and_put+0x34/0x50 [ib_core]\n[  +0.000020]  i40iw_close+0x4b/0x90 [irdma]\n[  +0.000022]  i40e_notify_client_of_netdev_close+0x54/0xc0 [i40e]\n[  +0.000035]  i40e_service_task+0x126/0x190 [i40e]\n[  +0.000024]  process_one_work+0x174/0x340\n[  +0.000003]  worker_th\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/09b54d29f05129b092f7c793a70b689ffb3c7b2c",
      "https://git.kernel.org/stable/c/546d0fe9d76e8229a67369f9cb61e961d99038bd",
      "https://git.kernel.org/stable/c/fbbb2404340dd6178e281bd427c271f7d5ec1d22",
      "https://git.kernel.org/stable/c/ff7431f898dd00892a545b7d0ce7adf5b926944f",
      "https://git.kernel.org/stable/c/152ed360cf2d273f88fc99a518b7eb868aae2939",
      "https://git.kernel.org/stable/c/8d6105f637883c8c09825e962308c06e977de4f0",
      "https://git.kernel.org/stable/c/1594dac8b1ed78f9e75c263327e198a2e5e25b0e",
      "https://git.kernel.org/stable/c/2cc7d150550cc981aceedf008f5459193282425c"
    ],
    "受影响版本": [
      "4d5957cbdecdbb77d24c1465caadd801c07afa4a",
      "4d5957cbdecdbb77d24c1465caadd801c07afa4a",
      "4d5957cbdecdbb77d24c1465caadd801c07afa4a",
      "4d5957cbdecdbb77d24c1465caadd801c07afa4a",
      "4d5957cbdecdbb77d24c1465caadd801c07afa4a",
      "4d5957cbdecdbb77d24c1465caadd801c07afa4a",
      "4d5957cbdecdbb77d24c1465caadd801c07afa4a",
      "4d5957cbdecdbb77d24c1465caadd801c07afa4a"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-36001",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfs: Fix the pre-flush when appending to a file in writethrough mode\n\nIn netfs_perform_write(), when the file is marked NETFS_ICTX_WRITETHROUGH\nor O_*SYNC or RWF_*SYNC was specified, write-through caching is performed\non a buffered file.  When setting up for write-through, we flush any\nconflicting writes in the region and wait for the write to complete,\nfailing if there's a write error to return.\n\nThe issue arises if we're writing at or above the EOF position because we\nskip the flush and - more importantly - the wait.  This becomes a problem\nif there's a partial folio at the end of the file that is being written out\nand we want to make a write to it too.  Both the already-running write and\nthe write we start both want to clear the writeback mark, but whoever is\nsecond causes a warning looking something like:\n\n    ------------[ cut here ]------------\n    R=00000012: folio 11 is not under writeback\n    WARNING: CPU: 34 PID: 654 at fs/netfs/write_collect.c:105\n    ...\n    CPU: 34 PID: 654 Comm: kworker/u386:27 Tainted: G S ...\n    ...\n    Workqueue: events_unbound netfs_write_collection_worker\n    ...\n    RIP: 0010:netfs_writeback_lookup_folio\n\nFix this by making the flush-and-wait unconditional.  It will do nothing if\nthere are no folios in the pagecache and will return quickly if there are\nno folios in the region specified.\n\nFurther, move the WBC attachment above the flush call as the flush is going\nto attach a WBC and detach it again if it is not present - and since we\nneed one anyway we might as well share it.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5eaf23b2e81349f6614f88396dc468fda89fc0b9",
      "https://git.kernel.org/stable/c/c97f59e276d4e93480f29a70accbd0d7273cf3f5"
    ],
    "受影响版本": [
      "41d8e7673a7726cba57cb8112d81c89cfb6c3e35",
      "41d8e7673a7726cba57cb8112d81c89cfb6c3e35"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35990",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndma: xilinx_dpdma: Fix locking\n\nThere are several places where either chan->lock or chan->vchan.lock was\nnot held. Add appropriate locking. This fixes lockdep warnings like\n\n[   31.077578] ------------[ cut here ]------------\n[   31.077831] WARNING: CPU: 2 PID: 40 at drivers/dma/xilinx/xilinx_dpdma.c:834 xilinx_dpdma_chan_queue_transfer+0x274/0x5e0\n[   31.077953] Modules linked in:\n[   31.078019] CPU: 2 PID: 40 Comm: kworker/u12:1 Not tainted 6.6.20+ #98\n[   31.078102] Hardware name: xlnx,zynqmp (DT)\n[   31.078169] Workqueue: events_unbound deferred_probe_work_func\n[   31.078272] pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   31.078377] pc : xilinx_dpdma_chan_queue_transfer+0x274/0x5e0\n[   31.078473] lr : xilinx_dpdma_chan_queue_transfer+0x270/0x5e0\n[   31.078550] sp : ffffffc083bb2e10\n[   31.078590] x29: ffffffc083bb2e10 x28: 0000000000000000 x27: ffffff880165a168\n[   31.078754] x26: ffffff880164e920 x25: ffffff880164eab8 x24: ffffff880164d480\n[   31.078920] x23: ffffff880165a148 x22: ffffff880164e988 x21: 0000000000000000\n[   31.079132] x20: ffffffc082aa3000 x19: ffffff880164e880 x18: 0000000000000000\n[   31.079295] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n[   31.079453] x14: 0000000000000000 x13: ffffff8802263dc0 x12: 0000000000000001\n[   31.079613] x11: 0001ffc083bb2e34 x10: 0001ff880164e98f x9 : 0001ffc082aa3def\n[   31.079824] x8 : 0001ffc082aa3dec x7 : 0000000000000000 x6 : 0000000000000516\n[   31.079982] x5 : ffffffc7f8d43000 x4 : ffffff88003c9c40 x3 : ffffffffffffffff\n[   31.080147] x2 : ffffffc7f8d43000 x1 : 00000000000000c0 x0 : 0000000000000000\n[   31.080307] Call trace:\n[   31.080340]  xilinx_dpdma_chan_queue_transfer+0x274/0x5e0\n[   31.080518]  xilinx_dpdma_issue_pending+0x11c/0x120\n[   31.080595]  zynqmp_disp_layer_update+0x180/0x3ac\n[   31.080712]  zynqmp_dpsub_plane_atomic_update+0x11c/0x21c\n[   31.080825]  drm_atomic_helper_commit_planes+0x20c/0x684\n[   31.080951]  drm_atomic_helper_commit_tail+0x5c/0xb0\n[   31.081139]  commit_tail+0x234/0x294\n[   31.081246]  drm_atomic_helper_commit+0x1f8/0x210\n[   31.081363]  drm_atomic_commit+0x100/0x140\n[   31.081477]  drm_client_modeset_commit_atomic+0x318/0x384\n[   31.081634]  drm_client_modeset_commit_locked+0x8c/0x24c\n[   31.081725]  drm_client_modeset_commit+0x34/0x5c\n[   31.081812]  __drm_fb_helper_restore_fbdev_mode_unlocked+0x104/0x168\n[   31.081899]  drm_fb_helper_set_par+0x50/0x70\n[   31.081971]  fbcon_init+0x538/0xc48\n[   31.082047]  visual_init+0x16c/0x23c\n[   31.082207]  do_bind_con_driver.isra.0+0x2d0/0x634\n[   31.082320]  do_take_over_console+0x24c/0x33c\n[   31.082429]  do_fbcon_takeover+0xbc/0x1b0\n[   31.082503]  fbcon_fb_registered+0x2d0/0x34c\n[   31.082663]  register_framebuffer+0x27c/0x38c\n[   31.082767]  __drm_fb_helper_initial_config_and_unlock+0x5c0/0x91c\n[   31.082939]  drm_fb_helper_initial_config+0x50/0x74\n[   31.083012]  drm_fbdev_dma_client_hotplug+0xb8/0x108\n[   31.083115]  drm_client_register+0xa0/0xf4\n[   31.083195]  drm_fbdev_dma_setup+0xb0/0x1cc\n[   31.083293]  zynqmp_dpsub_drm_init+0x45c/0x4e0\n[   31.083431]  zynqmp_dpsub_probe+0x444/0x5e0\n[   31.083616]  platform_probe+0x8c/0x13c\n[   31.083713]  really_probe+0x258/0x59c\n[   31.083793]  __driver_probe_device+0xc4/0x224\n[   31.083878]  driver_probe_device+0x70/0x1c0\n[   31.083961]  __device_attach_driver+0x108/0x1e0\n[   31.084052]  bus_for_each_drv+0x9c/0x100\n[   31.084125]  __device_attach+0x100/0x298\n[   31.084207]  device_initial_probe+0x14/0x20\n[   31.084292]  bus_probe_device+0xd8/0xdc\n[   31.084368]  deferred_probe_work_func+0x11c/0x180\n[   31.084451]  process_one_work+0x3ac/0x988\n[   31.084643]  worker_thread+0x398/0x694\n[   31.084752]  kthread+0x1bc/0x1c0\n[   31.084848]  ret_from_fork+0x10/0x20\n[   31.084932] irq event stamp: 64549\n[   31.084970] hardirqs last  enabled at (64548): [<ffffffc081adf35c>] _raw_spin_unlock_irqrestore+0x80/0x90\n[   31.085157]\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fcdd5bb4a8c81c64c1334d7e0aba41a8829a24de",
      "https://git.kernel.org/stable/c/0ccac964520a6f19e355652c8ca38af2a7f27076",
      "https://git.kernel.org/stable/c/8bf574183282d219cfa991f7df37aad491d74c11",
      "https://git.kernel.org/stable/c/8e3c94767cad5150198e4337c8b91f3bb068e14b",
      "https://git.kernel.org/stable/c/c660be571609e03e7d5972343536a736fcb31557",
      "https://git.kernel.org/stable/c/244296cc3a155199a8b080d19e645d7d49081a38"
    ],
    "受影响版本": [
      "7cbb0c63de3fc218fd06ecfedb477772a4d12f76",
      "7cbb0c63de3fc218fd06ecfedb477772a4d12f76",
      "7cbb0c63de3fc218fd06ecfedb477772a4d12f76",
      "7cbb0c63de3fc218fd06ecfedb477772a4d12f76",
      "7cbb0c63de3fc218fd06ecfedb477772a4d12f76",
      "7cbb0c63de3fc218fd06ecfedb477772a4d12f76"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35982",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbatman-adv: Avoid infinite loop trying to resize local TT\n\nIf the MTU of one of an attached interface becomes too small to transmit\nthe local translation table then it must be resized to fit inside all\nfragments (when enabled) or a single packet.\n\nBut if the MTU becomes too low to transmit even the header + the VLAN\nspecific part then the resizing of the local TT will never succeed. This\ncan for example happen when the usable space is 110 bytes and 11 VLANs are\non top of batman-adv. In this case, at least 116 byte would be needed.\nThere will just be an endless spam of\n\n   batman_adv: batadv0: Forced to purge local tt entries to fit new maximum fragment MTU (110)\n\nin the log but the function will never finish. Problem here is that the\ntimeout will be halved all the time and will then stagnate at 0 and\ntherefore never be able to reduce the table even more.\n\nThere are other scenarios possible with a similar result. The number of\nBATADV_TT_CLIENT_NOPURGE entries in the local TT can for example be too\nhigh to fit inside a packet. Such a scenario can therefore happen also with\nonly a single VLAN + 7 non-purgable addresses - requiring at least 120\nbytes.\n\nWhile this should be handled proactively when:\n\n* interface with too low MTU is added\n* VLAN is added\n* non-purgeable local mac is added\n* MTU of an attached interface is reduced\n* fragmentation setting gets disabled (which most likely requires dropping\n  attached interfaces)\n\nnot all of these scenarios can be prevented because batman-adv is only\nconsuming events without the the possibility to prevent these actions\n(non-purgable MAC address added, MTU of an attached interface is reduced).\nIt is therefore necessary to also make sure that the code is able to handle\nalso the situations when there were already incompatible system\nconfiguration are present.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/04720ea2e6c64459a90ca28570ea78335eccd924",
      "https://git.kernel.org/stable/c/b3ddf6904073990492454b1dd1c10a24be8c74c6",
      "https://git.kernel.org/stable/c/70a8be9dc2fb65d67f8c1e0c88c587e08e2e575d",
      "https://git.kernel.org/stable/c/87b6af1a7683e021710c08fc0551fc078346032f",
      "https://git.kernel.org/stable/c/3fe79b2c83461edbbf86ed8a6f3924820ff89259",
      "https://git.kernel.org/stable/c/4ca2a5fb54ea2cc43edea614207fcede562d91c2",
      "https://git.kernel.org/stable/c/ca54e2671548616ad34885f90d4f26f7adb088f0",
      "https://git.kernel.org/stable/c/b1f532a3b1e6d2e5559c7ace49322922637a28aa"
    ],
    "受影响版本": [
      "a19d3d85e1b854e4a483a55d740a42458085560d",
      "a19d3d85e1b854e4a483a55d740a42458085560d",
      "a19d3d85e1b854e4a483a55d740a42458085560d",
      "a19d3d85e1b854e4a483a55d740a42458085560d",
      "a19d3d85e1b854e4a483a55d740a42458085560d",
      "a19d3d85e1b854e4a483a55d740a42458085560d",
      "a19d3d85e1b854e4a483a55d740a42458085560d",
      "a19d3d85e1b854e4a483a55d740a42458085560d"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35981",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio_net: Do not send RSS key if it is not supported\n\nThere is a bug when setting the RSS options in virtio_net that can break\nthe whole machine, getting the kernel into an infinite loop.\n\nRunning the following command in any QEMU virtual machine with virtionet\nwill reproduce this problem:\n\n    # ethtool -X eth0  hfunc toeplitz\n\nThis is how the problem happens:\n\n1) ethtool_set_rxfh() calls virtnet_set_rxfh()\n\n2) virtnet_set_rxfh() calls virtnet_commit_rss_command()\n\n3) virtnet_commit_rss_command() populates 4 entries for the rss\nscatter-gather\n\n4) Since the command above does not have a key, then the last\nscatter-gatter entry will be zeroed, since rss_key_size == 0.\nsg_buf_size = vi->rss_key_size;\n\n5) This buffer is passed to qemu, but qemu is not happy with a buffer\nwith zero length, and do the following in virtqueue_map_desc() (QEMU\nfunction):\n\n  if (!sz) {\n      virtio_error(vdev, \"virtio: zero sized buffers are not allowed\");\n\n6) virtio_error() (also QEMU function) set the device as broken\n\n    vdev->broken = true;\n\n7) Qemu bails out, and do not repond this crazy kernel.\n\n8) The kernel is waiting for the response to come back (function\nvirtnet_send_command())\n\n9) The kernel is waiting doing the following :\n\n      while (!virtqueue_get_buf(vi->cvq, &tmp) &&\n\t     !virtqueue_is_broken(vi->cvq))\n\t      cpu_relax();\n\n10) None of the following functions above is true, thus, the kernel\nloops here forever. Keeping in mind that virtqueue_is_broken() does\nnot look at the qemu `vdev->broken`, so, it never realizes that the\nvitio is broken at QEMU side.\n\nFix it by not sending RSS commands if the feature is not available in\nthe device.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/539a2b995a4ed93125cb0efae0f793b00ab2158b",
      "https://git.kernel.org/stable/c/43a71c1b4b3a6d4db857b1435d271540279fc7de",
      "https://git.kernel.org/stable/c/28e9a64638cd16bc1ecac9ff74ffeacb9fb652de",
      "https://git.kernel.org/stable/c/059a49aa2e25c58f90b50151f109dd3c4cdb3a47"
    ],
    "受影响版本": [
      "c7114b1249fa3b5f3a434606ba4cc89c4a27d618",
      "c7114b1249fa3b5f3a434606ba4cc89c4a27d618",
      "c7114b1249fa3b5f3a434606ba4cc89c4a27d618",
      "c7114b1249fa3b5f3a434606ba4cc89c4a27d618"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35970",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Clear stale u->oob_skb.\n\nsyzkaller started to report deadlock of unix_gc_lock after commit\n4090fa373f0e (\"af_unix: Replace garbage collection algorithm.\"), but\nit just uncovers the bug that has been there since commit 314001f0bf92\n(\"af_unix: Add OOB support\").\n\nThe repro basically does the following.\n\n  from socket import *\n  from array import array\n\n  c1, c2 = socketpair(AF_UNIX, SOCK_STREAM)\n  c1.sendmsg([b'a'], [(SOL_SOCKET, SCM_RIGHTS, array(\"i\", [c2.fileno()]))], MSG_OOB)\n  c2.recv(1)  # blocked as no normal data in recv queue\n\n  c2.close()  # done async and unblock recv()\n  c1.close()  # done async and trigger GC\n\nA socket sends its file descriptor to itself as OOB data and tries to\nreceive normal data, but finally recv() fails due to async close().\n\nThe problem here is wrong handling of OOB skb in manage_oob().  When\nrecvmsg() is called without MSG_OOB, manage_oob() is called to check\nif the peeked skb is OOB skb.  In such a case, manage_oob() pops it\nout of the receive queue but does not clear unix_sock(sk)->oob_skb.\nThis is wrong in terms of uAPI.\n\nLet's say we send \"hello\" with MSG_OOB, and \"world\" without MSG_OOB.\nThe 'o' is handled as OOB data.  When recv() is called twice without\nMSG_OOB, the OOB data should be lost.\n\n  >>> from socket import *\n  >>> c1, c2 = socketpair(AF_UNIX, SOCK_STREAM, 0)\n  >>> c1.send(b'hello', MSG_OOB)  # 'o' is OOB data\n  5\n  >>> c1.send(b'world')\n  5\n  >>> c2.recv(5)  # OOB data is not received\n  b'hell'\n  >>> c2.recv(5)  # OOB date is skipped\n  b'world'\n  >>> c2.recv(5, MSG_OOB)  # This should return an error\n  b'o'\n\nIn the same situation, TCP actually returns -EINVAL for the last\nrecv().\n\nAlso, if we do not clear unix_sk(sk)->oob_skb, unix_poll() always set\nEPOLLPRI even though the data has passed through by previous recv().\n\nTo avoid these issues, we must clear unix_sk(sk)->oob_skb when dequeuing\nit from recv queue.\n\nThe reason why the old GC did not trigger the deadlock is because the\nold GC relied on the receive queue to detect the loop.\n\nWhen it is triggered, the socket with OOB data is marked as GC candidate\nbecause file refcount == inflight count (1).  However, after traversing\nall inflight sockets, the socket still has a positive inflight count (1),\nthus the socket is excluded from candidates.  Then, the old GC lose the\nchance to garbage-collect the socket.\n\nWith the old GC, the repro continues to create true garbage that will\nnever be freed nor detected by kmemleak as it's linked to the global\ninflight list.  That's why we couldn't even notice the issue.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b4bc99d04c689b5652665394ae8d3e02fb754153",
      "https://git.kernel.org/stable/c/84a352b7eba1142a95441380058985ff19f25ec9",
      "https://git.kernel.org/stable/c/601a89ea24d05089debfa2dc896ea9f5937ac7a6",
      "https://git.kernel.org/stable/c/698a95ade1a00e6494482046902b986dfffd1caf",
      "https://git.kernel.org/stable/c/b46f4eaa4f0ec38909fb0072eea3aeddb32f954e"
    ],
    "受影响版本": [
      "314001f0bf927015e459c9d387d62a231fe93af3",
      "314001f0bf927015e459c9d387d62a231fe93af3",
      "314001f0bf927015e459c9d387d62a231fe93af3",
      "314001f0bf927015e459c9d387d62a231fe93af3",
      "314001f0bf927015e459c9d387d62a231fe93af3"
    ],
    "公开日期": "2024年05月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35932",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/vc4: don't check if plane->state->fb == state->fb\n\nCurrently, when using non-blocking commits, we can see the following\nkernel warning:\n\n[  110.908514] ------------[ cut here ]------------\n[  110.908529] refcount_t: underflow; use-after-free.\n[  110.908620] WARNING: CPU: 0 PID: 1866 at lib/refcount.c:87 refcount_dec_not_one+0xb8/0xc0\n[  110.908664] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device cmac algif_hash aes_arm64 aes_generic algif_skcipher af_alg bnep hid_logitech_hidpp vc4 brcmfmac hci_uart btbcm brcmutil bluetooth snd_soc_hdmi_codec cfg80211 cec drm_display_helper drm_dma_helper drm_kms_helper snd_soc_core snd_compress snd_pcm_dmaengine fb_sys_fops sysimgblt syscopyarea sysfillrect raspberrypi_hwmon ecdh_generic ecc rfkill libaes i2c_bcm2835 binfmt_misc joydev snd_bcm2835(C) bcm2835_codec(C) bcm2835_isp(C) v4l2_mem2mem videobuf2_dma_contig snd_pcm bcm2835_v4l2(C) raspberrypi_gpiomem bcm2835_mmal_vchiq(C) videobuf2_v4l2 snd_timer videobuf2_vmalloc videobuf2_memops videobuf2_common snd videodev vc_sm_cma(C) mc hid_logitech_dj uio_pdrv_genirq uio i2c_dev drm fuse dm_mod drm_panel_orientation_quirks backlight ip_tables x_tables ipv6\n[  110.909086] CPU: 0 PID: 1866 Comm: kodi.bin Tainted: G         C         6.1.66-v8+ #32\n[  110.909104] Hardware name: Raspberry Pi 3 Model B Rev 1.2 (DT)\n[  110.909114] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  110.909132] pc : refcount_dec_not_one+0xb8/0xc0\n[  110.909152] lr : refcount_dec_not_one+0xb4/0xc0\n[  110.909170] sp : ffffffc00913b9c0\n[  110.909177] x29: ffffffc00913b9c0 x28: 000000556969bbb0 x27: 000000556990df60\n[  110.909205] x26: 0000000000000002 x25: 0000000000000004 x24: ffffff8004448480\n[  110.909230] x23: ffffff800570b500 x22: ffffff802e03a7bc x21: ffffffecfca68c78\n[  110.909257] x20: ffffff8002b42000 x19: ffffff802e03a600 x18: 0000000000000000\n[  110.909283] x17: 0000000000000011 x16: ffffffffffffffff x15: 0000000000000004\n[  110.909308] x14: 0000000000000fff x13: ffffffed577e47e0 x12: 0000000000000003\n[  110.909333] x11: 0000000000000000 x10: 0000000000000027 x9 : c912d0d083728c00\n[  110.909359] x8 : c912d0d083728c00 x7 : 65646e75203a745f x6 : 746e756f63666572\n[  110.909384] x5 : ffffffed579f62ee x4 : ffffffed579eb01e x3 : 0000000000000000\n[  110.909409] x2 : 0000000000000000 x1 : ffffffc00913b750 x0 : 0000000000000001\n[  110.909434] Call trace:\n[  110.909441]  refcount_dec_not_one+0xb8/0xc0\n[  110.909461]  vc4_bo_dec_usecnt+0x4c/0x1b0 [vc4]\n[  110.909903]  vc4_cleanup_fb+0x44/0x50 [vc4]\n[  110.910315]  drm_atomic_helper_cleanup_planes+0x88/0xa4 [drm_kms_helper]\n[  110.910669]  vc4_atomic_commit_tail+0x390/0x9dc [vc4]\n[  110.911079]  commit_tail+0xb0/0x164 [drm_kms_helper]\n[  110.911397]  drm_atomic_helper_commit+0x1d0/0x1f0 [drm_kms_helper]\n[  110.911716]  drm_atomic_commit+0xb0/0xdc [drm]\n[  110.912569]  drm_mode_atomic_ioctl+0x348/0x4b8 [drm]\n[  110.913330]  drm_ioctl_kernel+0xec/0x15c [drm]\n[  110.914091]  drm_ioctl+0x24c/0x3b0 [drm]\n[  110.914850]  __arm64_sys_ioctl+0x9c/0xd4\n[  110.914873]  invoke_syscall+0x4c/0x114\n[  110.914897]  el0_svc_common+0xd0/0x118\n[  110.914917]  do_el0_svc+0x38/0xd0\n[  110.914936]  el0_svc+0x30/0x8c\n[  110.914958]  el0t_64_sync_handler+0x84/0xf0\n[  110.914979]  el0t_64_sync+0x18c/0x190\n[  110.914996] ---[ end trace 0000000000000000 ]---\n\nThis happens because, although `prepare_fb` and `cleanup_fb` are\nperfectly balanced, we cannot guarantee consistency in the check\nplane->state->fb == state->fb. This means that sometimes we can increase\nthe refcount in `prepare_fb` and don't decrease it in `cleanup_fb`. The\nopposite can also be true.\n\nIn fact, the struct drm_plane .state shouldn't be accessed directly\nbut instead, the `drm_atomic_get_new_plane_state()` helper function should\nbe used. So, we could stick to this check, but using\n`drm_atomic_get_new_plane_state()`. But actually, this check is not re\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/48bfb4b03c5ff6e1fa1dc73fb915e150b0968c40",
      "https://git.kernel.org/stable/c/d6b2fe2db1d0927b2d7df5c763eba55d0e1def3c",
      "https://git.kernel.org/stable/c/5343f724c912c77541029123f47ecd3d2ea63bdd",
      "https://git.kernel.org/stable/c/5ee0d47dcf33efd8950b347dcf4d20bab12a3fa9"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年05月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35927",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: Check output polling initialized before disabling\n\nIn drm_kms_helper_poll_disable() check if output polling\nsupport is initialized before disabling polling. If not flag\nthis as a warning.\nAdditionally in drm_mode_config_helper_suspend() and\ndrm_mode_config_helper_resume() calls, that re the callers of these\nfunctions, avoid invoking them if polling is not initialized.\nFor drivers like hyperv-drm, that do not initialize connector\npolling, if suspend is called without this check, it leads to\nsuspend failure with following stack\n[  770.719392] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.\n[  770.720592] printk: Suspending console(s) (use no_console_suspend to debug)\n[  770.948823] ------------[ cut here ]------------\n[  770.948824] WARNING: CPU: 1 PID: 17197 at kernel/workqueue.c:3162 __flush_work.isra.0+0x212/0x230\n[  770.948831] Modules linked in: rfkill nft_counter xt_conntrack xt_owner udf nft_compat crc_itu_t nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables nfnetlink vfat fat mlx5_ib ib_uverbs ib_core mlx5_core intel_rapl_msr intel_rapl_common kvm_amd ccp mlxfw kvm psample hyperv_drm tls drm_shmem_helper drm_kms_helper irqbypass pcspkr syscopyarea sysfillrect sysimgblt hv_balloon hv_utils joydev drm fuse xfs libcrc32c pci_hyperv pci_hyperv_intf sr_mod sd_mod cdrom t10_pi sg hv_storvsc scsi_transport_fc hv_netvsc serio_raw hyperv_keyboard hid_hyperv crct10dif_pclmul crc32_pclmul crc32c_intel hv_vmbus ghash_clmulni_intel dm_mirror dm_region_hash dm_log dm_mod\n[  770.948863] CPU: 1 PID: 17197 Comm: systemd-sleep Not tainted 5.14.0-362.2.1.el9_3.x86_64 #1\n[  770.948865] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.1 05/09/2022\n[  770.948866] RIP: 0010:__flush_work.isra.0+0x212/0x230\n[  770.948869] Code: 8b 4d 00 4c 8b 45 08 89 ca 48 c1 e9 04 83 e2 08 83 e1 0f 83 ca 02 89 c8 48 0f ba 6d 00 03 e9 25 ff ff ff 0f 0b e9 4e ff ff ff <0f> 0b 45 31 ed e9 44 ff ff ff e8 8f 89 b2 00 66 66 2e 0f 1f 84 00\n[  770.948870] RSP: 0018:ffffaf4ac213fb10 EFLAGS: 00010246\n[  770.948871] RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff8c992857\n[  770.948872] RDX: 0000000000000001 RSI: 0000000000000001 RDI: ffff9aad82b00330\n[  770.948873] RBP: ffff9aad82b00330 R08: 0000000000000000 R09: ffff9aad87ee3d10\n[  770.948874] R10: 0000000000000200 R11: 0000000000000000 R12: ffff9aad82b00330\n[  770.948874] R13: 0000000000000001 R14: 0000000000000000 R15: 0000000000000001\n[  770.948875] FS:  00007ff1b2f6bb40(0000) GS:ffff9aaf37d00000(0000) knlGS:0000000000000000\n[  770.948878] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  770.948878] CR2: 0000555f345cb666 CR3: 00000001462dc005 CR4: 0000000000370ee0\n[  770.948879] Call Trace:\n[  770.948880]  <TASK>\n[  770.948881]  ? show_trace_log_lvl+0x1c4/0x2df\n[  770.948884]  ? show_trace_log_lvl+0x1c4/0x2df\n[  770.948886]  ? __cancel_work_timer+0x103/0x190\n[  770.948887]  ? __flush_work.isra.0+0x212/0x230\n[  770.948889]  ? __warn+0x81/0x110\n[  770.948891]  ? __flush_work.isra.0+0x212/0x230\n[  770.948892]  ? report_bug+0x10a/0x140\n[  770.948895]  ? handle_bug+0x3c/0x70\n[  770.948898]  ? exc_invalid_op+0x14/0x70\n[  770.948899]  ? asm_exc_invalid_op+0x16/0x20\n[  770.948903]  ? __flush_work.isra.0+0x212/0x230\n[  770.948905]  __cancel_work_timer+0x103/0x190\n[  770.948907]  ? _raw_spin_unlock_irqrestore+0xa/0x30\n[  770.948910]  drm_kms_helper_poll_disable+0x1e/0x40 [drm_kms_helper]\n[  770.948923]  drm_mode_config_helper_suspend+0x1c/0x80 [drm_kms_helper]\n[  770.948933]  ? __pfx_vmbus_suspend+0x10/0x10 [hv_vmbus]\n[  770.948942]  hyperv_vmbus_suspend+0x17/0x40 [hyperv_drm]\n[  770.948944]  ? __pfx_vmbus_suspend+0x10/0x10 [hv_vmbus]\n[  770.948951]  dpm_run_callback+0x4c/0x140\n[  770.948954]  __device_suspend_noir\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3d1b47e3a935abd4f258a945db87e7267ff4079c",
      "https://git.kernel.org/stable/c/18451798f4a4e7418b9fad7e7dd313fe84b1f545",
      "https://git.kernel.org/stable/c/5abffb66d12bcac84bf7b66389c571b8bb6e82bd"
    ],
    "受影响版本": [
      "78b991ccfa64a438e2d8c2997d22d55621ab277d",
      "78b991ccfa64a438e2d8c2997d22d55621ab277d",
      "78b991ccfa64a438e2d8c2997d22d55621ab277d"
    ],
    "公开日期": "2024年05月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35901",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: mana: Fix Rx DMA datasize and skb_over_panic\n\nmana_get_rxbuf_cfg() aligns the RX buffer's DMA datasize to be\nmultiple of 64. So a packet slightly bigger than mtu+14, say 1536,\ncan be received and cause skb_over_panic.\n\nSample dmesg:\n[ 5325.237162] skbuff: skb_over_panic: text:ffffffffc043277a len:1536 put:1536 head:ff1100018b517000 data:ff1100018b517100 tail:0x700 end:0x6ea dev:<NULL>\n[ 5325.243689] ------------[ cut here ]------------\n[ 5325.245748] kernel BUG at net/core/skbuff.c:192!\n[ 5325.247838] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n[ 5325.258374] RIP: 0010:skb_panic+0x4f/0x60\n[ 5325.302941] Call Trace:\n[ 5325.304389]  <IRQ>\n[ 5325.315794]  ? skb_panic+0x4f/0x60\n[ 5325.317457]  ? asm_exc_invalid_op+0x1f/0x30\n[ 5325.319490]  ? skb_panic+0x4f/0x60\n[ 5325.321161]  skb_put+0x4e/0x50\n[ 5325.322670]  mana_poll+0x6fa/0xb50 [mana]\n[ 5325.324578]  __napi_poll+0x33/0x1e0\n[ 5325.326328]  net_rx_action+0x12e/0x280\n\nAs discussed internally, this alignment is not necessary. To fix\nthis bug, remove it from the code. So oversized packets will be\nmarked as CQE_RX_TRUNCATED by NIC, and dropped.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ca58927b00385005f488b6a9905ced7a4f719aad",
      "https://git.kernel.org/stable/c/05cb7c41fa1a7a7b2c2a6b81bbe7c67f5c11932b",
      "https://git.kernel.org/stable/c/c0de6ab920aafb56feab56058e46b688e694a246"
    ],
    "受影响版本": [
      "2fbbd712baf1c60996554326728bbdbef5616e12",
      "2fbbd712baf1c60996554326728bbdbef5616e12",
      "2fbbd712baf1c60996554326728bbdbef5616e12"
    ],
    "公开日期": "2024年05月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35893",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: act_skbmod: prevent kernel-infoleak\n\nsyzbot found that tcf_skbmod_dump() was copying four bytes\nfrom kernel stack to user space [1].\n\nThe issue here is that 'struct tc_skbmod' has a four bytes hole.\n\nWe need to clear the structure before filling fields.\n\n[1]\nBUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n BUG: KMSAN: kernel-infoleak in copy_to_user_iter lib/iov_iter.c:24 [inline]\n BUG: KMSAN: kernel-infoleak in iterate_ubuf include/linux/iov_iter.h:29 [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n BUG: KMSAN: kernel-infoleak in iterate_and_advance include/linux/iov_iter.h:271 [inline]\n BUG: KMSAN: kernel-infoleak in _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n  instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n  copy_to_user_iter lib/iov_iter.c:24 [inline]\n  iterate_ubuf include/linux/iov_iter.h:29 [inline]\n  iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n  iterate_and_advance include/linux/iov_iter.h:271 [inline]\n  _copy_to_iter+0x366/0x2520 lib/iov_iter.c:185\n  copy_to_iter include/linux/uio.h:196 [inline]\n  simple_copy_to_iter net/core/datagram.c:532 [inline]\n  __skb_datagram_iter+0x185/0x1000 net/core/datagram.c:420\n  skb_copy_datagram_iter+0x5c/0x200 net/core/datagram.c:546\n  skb_copy_datagram_msg include/linux/skbuff.h:4050 [inline]\n  netlink_recvmsg+0x432/0x1610 net/netlink/af_netlink.c:1962\n  sock_recvmsg_nosec net/socket.c:1046 [inline]\n  sock_recvmsg+0x2c4/0x340 net/socket.c:1068\n  __sys_recvfrom+0x35a/0x5f0 net/socket.c:2242\n  __do_sys_recvfrom net/socket.c:2260 [inline]\n  __se_sys_recvfrom net/socket.c:2256 [inline]\n  __x64_sys_recvfrom+0x126/0x1d0 net/socket.c:2256\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit was stored to memory at:\n  pskb_expand_head+0x30f/0x19d0 net/core/skbuff.c:2253\n  netlink_trim+0x2c2/0x330 net/netlink/af_netlink.c:1317\n  netlink_unicast+0x9f/0x1260 net/netlink/af_netlink.c:1351\n  nlmsg_unicast include/net/netlink.h:1144 [inline]\n  nlmsg_notify+0x21d/0x2f0 net/netlink/af_netlink.c:2610\n  rtnetlink_send+0x73/0x90 net/core/rtnetlink.c:741\n  rtnetlink_maybe_send include/linux/rtnetlink.h:17 [inline]\n  tcf_add_notify net/sched/act_api.c:2048 [inline]\n  tcf_action_add net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x146e/0x19d0 net/sched/act_api.c:2119\n  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650 net/netlink/af_netlink.c:2559\n  rtnetlink_rcv+0x34/0x40 net/core/rtnetlink.c:6613\n  netlink_unicast_kernel net/netlink/af_netlink.c:1335 [inline]\n  netlink_unicast+0xf4c/0x1260 net/netlink/af_netlink.c:1361\n  netlink_sendmsg+0x10df/0x11f0 net/netlink/af_netlink.c:1905\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n  ____sys_sendmsg+0x877/0xb60 net/socket.c:2584\n  ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n  __sys_sendmsg net/socket.c:2667 [inline]\n  __do_sys_sendmsg net/socket.c:2676 [inline]\n  __se_sys_sendmsg net/socket.c:2674 [inline]\n  __x64_sys_sendmsg+0x307/0x4a0 net/socket.c:2674\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit was stored to memory at:\n  __nla_put lib/nlattr.c:1041 [inline]\n  nla_put+0x1c6/0x230 lib/nlattr.c:1099\n  tcf_skbmod_dump+0x23f/0xc20 net/sched/act_skbmod.c:256\n  tcf_action_dump_old net/sched/act_api.c:1191 [inline]\n  tcf_action_dump_1+0x85e/0x970 net/sched/act_api.c:1227\n  tcf_action_dump+0x1fd/0x460 net/sched/act_api.c:1251\n  tca_get_fill+0x519/0x7a0 net/sched/act_api.c:1628\n  tcf_add_notify_msg net/sched/act_api.c:2023 [inline]\n  tcf_add_notify net/sched/act_api.c:2042 [inline]\n  tcf_action_add net/sched/act_api.c:2071 [inline]\n  tc_ctl_action+0x1365/0x19d0 net/sched/act_api.c:2119\n  rtnetlink_rcv_msg+0x1737/0x1900 net/core/rtnetlink.c:6595\n  netlink_rcv_skb+0x375/0x650 net/netlink/af_netli\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f190a4aa03cbd518bd9c62a66e1233984f5fd2ec",
      "https://git.kernel.org/stable/c/f356eb2fb567e0931143ac1769ac802d3b3e2077",
      "https://git.kernel.org/stable/c/5e45dc4408857305f4685abfd7a528a1e58b51b5",
      "https://git.kernel.org/stable/c/a097fc199ab5f4b5392c5144034c0d2148b55a14",
      "https://git.kernel.org/stable/c/55d3fe7b2b7bc354e7cbc1f7b8f98a29ccd5a366",
      "https://git.kernel.org/stable/c/729ad2ac2a2cdc9f4a4bdfd40bfd276e6bc33924",
      "https://git.kernel.org/stable/c/7bb2c7103d8c13b06a57bf997b8cdbe93cd7283c",
      "https://git.kernel.org/stable/c/d313eb8b77557a6d5855f42d2234bd592c7b50dd"
    ],
    "受影响版本": [
      "86da71b57383d40993cb90baafb3735cffe5d800",
      "86da71b57383d40993cb90baafb3735cffe5d800",
      "86da71b57383d40993cb90baafb3735cffe5d800",
      "86da71b57383d40993cb90baafb3735cffe5d800",
      "86da71b57383d40993cb90baafb3735cffe5d800",
      "86da71b57383d40993cb90baafb3735cffe5d800",
      "86da71b57383d40993cb90baafb3735cffe5d800",
      "86da71b57383d40993cb90baafb3735cffe5d800"
    ],
    "公开日期": "2024年05月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35886",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nipv6: Fix infinite recursion in fib6_dump_done().\n\nsyzkaller reported infinite recursive calls of fib6_dump_done() during\nnetlink socket destruction.  [1]\n\nFrom the log, syzkaller sent an AF_UNSPEC RTM_GETROUTE message, and then\nthe response was generated.  The following recvmmsg() resumed the dump\nfor IPv6, but the first call of inet6_dump_fib() failed at kzalloc() due\nto the fault injection.  [0]\n\n  12:01:34 executing program 3:\n  r0 = socket$nl_route(0x10, 0x3, 0x0)\n  sendmsg$nl_route(r0, ... snip ...)\n  recvmmsg(r0, ... snip ...) (fail_nth: 8)\n\nHere, fib6_dump_done() was set to nlk_sk(sk)->cb.done, and the next call\nof inet6_dump_fib() set it to nlk_sk(sk)->cb.args[3].  syzkaller stopped\nreceiving the response halfway through, and finally netlink_sock_destruct()\ncalled nlk_sk(sk)->cb.done().\n\nfib6_dump_done() calls fib6_dump_end() and nlk_sk(sk)->cb.done() if it\nis still not NULL.  fib6_dump_end() rewrites nlk_sk(sk)->cb.done() by\nnlk_sk(sk)->cb.args[3], but it has the same function, not NULL, calling\nitself recursively and hitting the stack guard page.\n\nTo avoid the issue, let's set the destructor after kzalloc().\n\n[0]:\nFAULT_INJECTION: forcing a failure.\nname failslab, interval 1, probability 0, space 0, times 0\nCPU: 1 PID: 432110 Comm: syz-executor.3 Not tainted 6.8.0-12821-g537c2e91d354-dirty #11\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl (lib/dump_stack.c:117)\n should_fail_ex (lib/fault-inject.c:52 lib/fault-inject.c:153)\n should_failslab (mm/slub.c:3733)\n kmalloc_trace (mm/slub.c:3748 mm/slub.c:3827 mm/slub.c:3992)\n inet6_dump_fib (./include/linux/slab.h:628 ./include/linux/slab.h:749 net/ipv6/ip6_fib.c:662)\n rtnl_dump_all (net/core/rtnetlink.c:4029)\n netlink_dump (net/netlink/af_netlink.c:2269)\n netlink_recvmsg (net/netlink/af_netlink.c:1988)\n ____sys_recvmsg (net/socket.c:1046 net/socket.c:2801)\n ___sys_recvmsg (net/socket.c:2846)\n do_recvmmsg (net/socket.c:2943)\n __x64_sys_recvmmsg (net/socket.c:3041 net/socket.c:3034 net/socket.c:3034)\n\n[1]:\nBUG: TASK stack guard page was hit at 00000000f2fa9af1 (stack is 00000000b7912430..000000009a436beb)\nstack guard page: 0000 [#1] PREEMPT SMP KASAN\nCPU: 1 PID: 223719 Comm: kworker/1:3 Not tainted 6.8.0-12821-g537c2e91d354-dirty #11\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nWorkqueue: events netlink_sock_destruct_work\nRIP: 0010:fib6_dump_done (net/ipv6/ip6_fib.c:570)\nCode: 3c 24 e8 f3 e9 51 fd e9 28 fd ff ff 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 41 57 41 56 41 55 41 54 55 48 89 fd <53> 48 8d 5d 60 e8 b6 4d 07 fd 48 89 da 48 b8 00 00 00 00 00 fc ff\nRSP: 0018:ffffc9000d980000 EFLAGS: 00010293\nRAX: 0000000000000000 RBX: ffffffff84405990 RCX: ffffffff844059d3\nRDX: ffff8881028e0000 RSI: ffffffff84405ac2 RDI: ffff88810c02f358\nRBP: ffff88810c02f358 R08: 0000000000000007 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000224 R12: 0000000000000000\nR13: ffff888007c82c78 R14: ffff888007c82c68 R15: ffff888007c82c68\nFS:  0000000000000000(0000) GS:ffff88811b100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffc9000d97fff8 CR3: 0000000102309002 CR4: 0000000000770ef0\nPKRU: 55555554\nCall Trace:\n <#DF>\n </#DF>\n <TASK>\n fib6_dump_done (net/ipv6/ip6_fib.c:572 (discriminator 1))\n fib6_dump_done (net/ipv6/ip6_fib.c:572 (discriminator 1))\n ...\n fib6_dump_done (net/ipv6/ip6_fib.c:572 (discriminator 1))\n fib6_dump_done (net/ipv6/ip6_fib.c:572 (discriminator 1))\n netlink_sock_destruct (net/netlink/af_netlink.c:401)\n __sk_destruct (net/core/sock.c:2177 (discriminator 2))\n sk_destruct (net/core/sock.c:2224)\n __sk_free (net/core/sock.c:2235)\n sk_free (net/core/sock.c:2246)\n process_one_work (kernel/workqueue.c:3259)\n worker_thread (kernel/workqueue.c:3329 kernel/workqueue.\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9472d07cd095cbd3294ac54c42f304a38fbe9bfe",
      "https://git.kernel.org/stable/c/9c5258196182c25b55c33167cd72fdd9bbf08985",
      "https://git.kernel.org/stable/c/fd307f2d91d40fa7bc55df3e2cd1253fabf8a2d6",
      "https://git.kernel.org/stable/c/40a344b2ddc06c1a2caa7208a43911f39c662778",
      "https://git.kernel.org/stable/c/167d4b47a9bdcb01541dfa29e9f3cbb8edd3dfd2",
      "https://git.kernel.org/stable/c/f2dd75e57285f49e34af1a5b6cd8945c08243776",
      "https://git.kernel.org/stable/c/4a7c465a5dcd657d59d25bf4815e19ac05c13061",
      "https://git.kernel.org/stable/c/d21d40605bca7bd5fc23ef03d4c1ca1f48bc2cae"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年05月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35877",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/mm/pat: fix VM_PAT handling in COW mappings\n\nPAT handling won't do the right thing in COW mappings: the first PTE (or,\nin fact, all PTEs) can be replaced during write faults to point at anon\nfolios.  Reliably recovering the correct PFN and cachemode using\nfollow_phys() from PTEs will not work in COW mappings.\n\nUsing follow_phys(), we might just get the address+protection of the anon\nfolio (which is very wrong), or fail on swap/nonswap entries, failing\nfollow_phys() and triggering a WARN_ON_ONCE() in untrack_pfn() and\ntrack_pfn_copy(), not properly calling free_pfn_range().\n\nIn free_pfn_range(), we either wouldn't call memtype_free() or would call\nit with the wrong range, possibly leaking memory.\n\nTo fix that, let's update follow_phys() to refuse returning anon folios,\nand fallback to using the stored PFN inside vma->vm_pgoff for COW mappings\nif we run into that.\n\nWe will now properly handle untrack_pfn() with COW mappings, where we\ndon't need the cachemode.  We'll have to fail fork()->track_pfn_copy() if\nthe first page was replaced by an anon folio, though: we'd have to store\nthe cachemode in the VMA to make this work, likely growing the VMA size.\n\nFor now, lets keep it simple and let track_pfn_copy() just fail in that\ncase: it would have failed in the past with swap/nonswap entries already,\nand it would have done the wrong thing with anon folios.\n\nSimple reproducer to trigger the WARN_ON_ONCE() in untrack_pfn():\n\n<--- C reproducer --->\n #include <stdio.h>\n #include <sys/mman.h>\n #include <unistd.h>\n #include <liburing.h>\n\n int main(void)\n {\n         struct io_uring_params p = {};\n         int ring_fd;\n         size_t size;\n         char *map;\n\n         ring_fd = io_uring_setup(1, &p);\n         if (ring_fd < 0) {\n                 perror(\"io_uring_setup\");\n                 return 1;\n         }\n         size = p.sq_off.array + p.sq_entries * sizeof(unsigned);\n\n         /* Map the submission queue ring MAP_PRIVATE */\n         map = mmap(0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE,\n                    ring_fd, IORING_OFF_SQ_RING);\n         if (map == MAP_FAILED) {\n                 perror(\"mmap\");\n                 return 1;\n         }\n\n         /* We have at least one page. Let's COW it. */\n         *map = 0;\n         pause();\n         return 0;\n }\n<--- C reproducer --->\n\nOn a system with 16 GiB RAM and swap configured:\n # ./iouring &\n # memhog 16G\n # killall iouring\n[  301.552930] ------------[ cut here ]------------\n[  301.553285] WARNING: CPU: 7 PID: 1402 at arch/x86/mm/pat/memtype.c:1060 untrack_pfn+0xf4/0x100\n[  301.553989] Modules linked in: binfmt_misc nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_g\n[  301.558232] CPU: 7 PID: 1402 Comm: iouring Not tainted 6.7.5-100.fc38.x86_64 #1\n[  301.558772] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebu4\n[  301.559569] RIP: 0010:untrack_pfn+0xf4/0x100\n[  301.559893] Code: 75 c4 eb cf 48 8b 43 10 8b a8 e8 00 00 00 3b 6b 28 74 b8 48 8b 7b 30 e8 ea 1a f7 000\n[  301.561189] RSP: 0018:ffffba2c0377fab8 EFLAGS: 00010282\n[  301.561590] RAX: 00000000ffffffea RBX: ffff9208c8ce9cc0 RCX: 000000010455e047\n[  301.562105] RDX: 07fffffff0eb1e0a RSI: 0000000000000000 RDI: ffff9208c391d200\n[  301.562628] RBP: 0000000000000000 R08: ffffba2c0377fab8 R09: 0000000000000000\n[  301.563145] R10: ffff9208d2292d50 R11: 0000000000000002 R12: 00007fea890e0000\n[  301.563669] R13: 0000000000000000 R14: ffffba2c0377fc08 R15: 0000000000000000\n[  301.564186] FS:  0000000000000000(0000) GS:ffff920c2fbc0000(0000) knlGS:0000000000000000\n[  301.564773] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  301.565197] CR2: 00007fea88ee8a20 CR3: 00000001033a8000 CR4: 0000000000750ef0\n[  301.565725] PKRU: 55555554\n[  301.565944] Call Trace:\n[  301.566148]  <TASK>\n[  301.566325]  ? untrack_pfn+0xf4/0x100\n[  301.566618]  ? __warn+0x81/0x130\n[  301.566876]  ? untrack_pfn+0xf4/0x100\n[  3\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f18681daaec9665a15c5e7e0f591aad5d0ac622b",
      "https://git.kernel.org/stable/c/09e6bb53217bf388a0d2fd7fb21e74ab9dffc173",
      "https://git.kernel.org/stable/c/c2b2430b48f3c9eaccd2c3d2ad75bb540d4952f4",
      "https://git.kernel.org/stable/c/7cfee26d1950250b14c5cb0a37b142f3fcc6396a",
      "https://git.kernel.org/stable/c/97e93367e82752e475a33839a80b33bdbef1209f",
      "https://git.kernel.org/stable/c/51b7841f3fe84606ec0bd8da859d22e05e5419ec",
      "https://git.kernel.org/stable/c/1341e4b32e1fb1b0acd002ccd56f07bd32f2abc6",
      "https://git.kernel.org/stable/c/04c35ab3bdae7fefbd7c7a7355f29fa03a035221"
    ],
    "受影响版本": [
      "5899329b19100c0b82dc78e9b21ed8b920c9ffb3",
      "5899329b19100c0b82dc78e9b21ed8b920c9ffb3",
      "5899329b19100c0b82dc78e9b21ed8b920c9ffb3",
      "5899329b19100c0b82dc78e9b21ed8b920c9ffb3",
      "5899329b19100c0b82dc78e9b21ed8b920c9ffb3",
      "5899329b19100c0b82dc78e9b21ed8b920c9ffb3",
      "5899329b19100c0b82dc78e9b21ed8b920c9ffb3",
      "5899329b19100c0b82dc78e9b21ed8b920c9ffb3"
    ],
    "公开日期": "2024年05月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35855",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum_acl_tcam: Fix possible use-after-free during activity update\n\nThe rule activity update delayed work periodically traverses the list of\nconfigured rules and queries their activity from the device.\n\nAs part of this task it accesses the entry pointed by 'ventry->entry',\nbut this entry can be changed concurrently by the rehash delayed work,\nleading to a use-after-free [1].\n\nFix by closing the race and perform the activity query under the\n'vregion->lock' mutex.\n\n[1]\nBUG: KASAN: slab-use-after-free in mlxsw_sp_acl_tcam_flower_rule_activity_get+0x121/0x140\nRead of size 8 at addr ffff8881054ed808 by task kworker/0:18/181\n\nCPU: 0 PID: 181 Comm: kworker/0:18 Not tainted 6.9.0-rc2-custom-00781-gd5ab772d32f7 #2\nHardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019\nWorkqueue: mlxsw_core mlxsw_sp_acl_rule_activity_update_work\nCall Trace:\n <TASK>\n dump_stack_lvl+0xc6/0x120\n print_report+0xce/0x670\n kasan_report+0xd7/0x110\n mlxsw_sp_acl_tcam_flower_rule_activity_get+0x121/0x140\n mlxsw_sp_acl_rule_activity_update_work+0x219/0x400\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 1039:\n kasan_save_stack+0x33/0x60\n kasan_save_track+0x14/0x30\n __kasan_kmalloc+0x8f/0xa0\n __kmalloc+0x19c/0x360\n mlxsw_sp_acl_tcam_entry_create+0x7b/0x1f0\n mlxsw_sp_acl_tcam_vchunk_migrate_all+0x30d/0xb50\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x157/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30\n\nFreed by task 1039:\n kasan_save_stack+0x33/0x60\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n poison_slab_object+0x102/0x170\n __kasan_slab_free+0x14/0x30\n kfree+0xc1/0x290\n mlxsw_sp_acl_tcam_vchunk_migrate_all+0x3d7/0xb50\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x157/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1b73f6e4ea770410a937a8db98f77e52594d23a0",
      "https://git.kernel.org/stable/c/e24d2487424779c02760ff50cd9021b8676e19ef",
      "https://git.kernel.org/stable/c/c17976b42d546ee118ca300db559630ee96fb758",
      "https://git.kernel.org/stable/c/b996e8699da810e4c915841d6aaef761007f933a",
      "https://git.kernel.org/stable/c/feabdac2057e863d0e140a2adf3d232eb4882db4",
      "https://git.kernel.org/stable/c/b183b915beef818a25e3154d719ca015a1ae0770",
      "https://git.kernel.org/stable/c/79b5b4b18bc85b19d3a518483f9abbbe6d7b3ba4"
    ],
    "受影响版本": [
      "2bffc5322fd8679e879cd6370881ee50cf141ada",
      "2bffc5322fd8679e879cd6370881ee50cf141ada",
      "2bffc5322fd8679e879cd6370881ee50cf141ada",
      "2bffc5322fd8679e879cd6370881ee50cf141ada",
      "2bffc5322fd8679e879cd6370881ee50cf141ada",
      "2bffc5322fd8679e879cd6370881ee50cf141ada",
      "2bffc5322fd8679e879cd6370881ee50cf141ada"
    ],
    "公开日期": "2024年05月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35854",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum_acl_tcam: Fix possible use-after-free during rehash\n\nThe rehash delayed work migrates filters from one region to another\naccording to the number of available credits.\n\nThe migrated from region is destroyed at the end of the work if the\nnumber of credits is non-negative as the assumption is that this is\nindicative of migration being complete. This assumption is incorrect as\na non-negative number of credits can also be the result of a failed\nmigration.\n\nThe destruction of a region that still has filters referencing it can\nresult in a use-after-free [1].\n\nFix by not destroying the region if migration failed.\n\n[1]\nBUG: KASAN: slab-use-after-free in mlxsw_sp_acl_ctcam_region_entry_remove+0x21d/0x230\nRead of size 8 at addr ffff8881735319e8 by task kworker/0:31/3858\n\nCPU: 0 PID: 3858 Comm: kworker/0:31 Tainted: G        W          6.9.0-rc2-custom-00782-gf2275c2157d8 #5\nHardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019\nWorkqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work\nCall Trace:\n <TASK>\n dump_stack_lvl+0xc6/0x120\n print_report+0xce/0x670\n kasan_report+0xd7/0x110\n mlxsw_sp_acl_ctcam_region_entry_remove+0x21d/0x230\n mlxsw_sp_acl_ctcam_entry_del+0x2e/0x70\n mlxsw_sp_acl_atcam_entry_del+0x81/0x210\n mlxsw_sp_acl_tcam_vchunk_migrate_all+0x3cd/0xb50\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x157/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 174:\n kasan_save_stack+0x33/0x60\n kasan_save_track+0x14/0x30\n __kasan_kmalloc+0x8f/0xa0\n __kmalloc+0x19c/0x360\n mlxsw_sp_acl_tcam_region_create+0xdf/0x9c0\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x954/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30\n\nFreed by task 7:\n kasan_save_stack+0x33/0x60\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n poison_slab_object+0x102/0x170\n __kasan_slab_free+0x14/0x30\n kfree+0xc1/0x290\n mlxsw_sp_acl_tcam_region_destroy+0x272/0x310\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x731/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e118e7ea24d1392878ef85926627c6bc640c4388",
      "https://git.kernel.org/stable/c/a429a912d6c779807f4d72a6cc0a1efaaa3613e1",
      "https://git.kernel.org/stable/c/4c89642ca47fb620914780c7c51d8d1248201121",
      "https://git.kernel.org/stable/c/813e2ab753a8f8c243a39ede20c2e0adc15f3887",
      "https://git.kernel.org/stable/c/311eeaa7b9e26aba5b3d57b09859f07d8e9fc049",
      "https://git.kernel.org/stable/c/a02687044e124f8ccb427cd3632124a4e1a7d7c1",
      "https://git.kernel.org/stable/c/54225988889931467a9b55fdbef534079b665519"
    ],
    "受影响版本": [
      "c9c9af91f1d9a636aecc55302c792538e549a430",
      "c9c9af91f1d9a636aecc55302c792538e549a430",
      "c9c9af91f1d9a636aecc55302c792538e549a430",
      "c9c9af91f1d9a636aecc55302c792538e549a430",
      "c9c9af91f1d9a636aecc55302c792538e549a430",
      "c9c9af91f1d9a636aecc55302c792538e549a430",
      "c9c9af91f1d9a636aecc55302c792538e549a430"
    ],
    "公开日期": "2024年05月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35853",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum_acl_tcam: Fix memory leak during rehash\n\nThe rehash delayed work migrates filters from one region to another.\nThis is done by iterating over all chunks (all the filters with the same\npriority) in the region and in each chunk iterating over all the\nfilters.\n\nIf the migration fails, the code tries to migrate the filters back to\nthe old region. However, the rollback itself can also fail in which case\nanother migration will be erroneously performed. Besides the fact that\nthis ping pong is not a very good idea, it also creates a problem.\n\nEach virtual chunk references two chunks: The currently used one\n('vchunk->chunk') and a backup ('vchunk->chunk2'). During migration the\nfirst holds the chunk we want to migrate filters to and the second holds\nthe chunk we are migrating filters from.\n\nThe code currently assumes - but does not verify - that the backup chunk\ndoes not exist (NULL) if the currently used chunk does not reference the\ntarget region. This assumption breaks when we are trying to rollback a\nrollback, resulting in the backup chunk being overwritten and leaked\n[1].\n\nFix by not rolling back a failed rollback and add a warning to avoid\nfuture cases.\n\n[1]\nWARNING: CPU: 5 PID: 1063 at lib/parman.c:291 parman_destroy+0x17/0x20\nModules linked in:\nCPU: 5 PID: 1063 Comm: kworker/5:11 Tainted: G        W          6.9.0-rc2-custom-00784-gc6a05c468a0b #14\nHardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019\nWorkqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work\nRIP: 0010:parman_destroy+0x17/0x20\n[...]\nCall Trace:\n <TASK>\n mlxsw_sp_acl_atcam_region_fini+0x19/0x60\n mlxsw_sp_acl_tcam_region_destroy+0x49/0xf0\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x1f1/0x470\n process_one_work+0x151/0x370\n worker_thread+0x2cb/0x3e0\n kthread+0xd0/0x100\n ret_from_fork+0x34/0x50\n ret_from_fork_asm+0x1a/0x30\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c6f3fa7f5a748bf6e5c4eb742686d6952f854e76",
      "https://git.kernel.org/stable/c/617e98ba4c50f4547c9eb0946b1cfc26937d70d1",
      "https://git.kernel.org/stable/c/413a01886c3958d4b8aac23a3bff3d430b92093e",
      "https://git.kernel.org/stable/c/b822644fd90992ee362c5e0c8d2556efc8856c76",
      "https://git.kernel.org/stable/c/0ae8ff7b6d42e33943af462910bdcfa2ec0cb8cf",
      "https://git.kernel.org/stable/c/b3fd51f684a0711504f82de510da109ae639722d",
      "https://git.kernel.org/stable/c/8ca3f7a7b61393804c46f170743c3b839df13977"
    ],
    "受影响版本": [
      "843500518509128a935edab96bd8efef7c54669e",
      "843500518509128a935edab96bd8efef7c54669e",
      "843500518509128a935edab96bd8efef7c54669e",
      "843500518509128a935edab96bd8efef7c54669e",
      "843500518509128a935edab96bd8efef7c54669e",
      "843500518509128a935edab96bd8efef7c54669e",
      "843500518509128a935edab96bd8efef7c54669e"
    ],
    "公开日期": "2024年05月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35808",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmd/dm-raid: don't call md_reap_sync_thread() directly\n\nCurrently md_reap_sync_thread() is called from raid_message() directly\nwithout holding 'reconfig_mutex', this is definitely unsafe because\nmd_reap_sync_thread() can change many fields that is protected by\n'reconfig_mutex'.\n\nHowever, hold 'reconfig_mutex' here is still problematic because this\nwill cause deadlock, for example, commit 130443d60b1b (\"md: refactor\nidle/frozen_sync_thread() to fix deadlock\").\n\nFix this problem by using stop_sync_thread() to unregister sync_thread,\nlike md/raid did.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/347dcdc15a1706f61aa545ae498ededdf31aeebc",
      "https://git.kernel.org/stable/c/9e59b8d76ff511505eb0dd1478329f09e0f04669",
      "https://git.kernel.org/stable/c/cd32b27a66db8776d8b8e82ec7d7dde97a8693b0"
    ],
    "受影响版本": [
      "be83651f0050ca8621d58d35dad558e9c45cb18f",
      "be83651f0050ca8621d58d35dad558e9c45cb18f",
      "be83651f0050ca8621d58d35dad558e9c45cb18f"
    ],
    "公开日期": "2024年05月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-35790",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: altmodes/displayport: create sysfs nodes as driver's default device attribute group\n\nThe DisplayPort driver's sysfs nodes may be present to the userspace before\ntypec_altmode_set_drvdata() completes in dp_altmode_probe. This means that\na sysfs read can trigger a NULL pointer error by deferencing dp->hpd in\nhpd_show or dp->lock in pin_assignment_show, as dev_get_drvdata() returns\nNULL in those cases.\n\nRemove manual sysfs node creation in favor of adding attribute group as\ndefault for devices bound to the driver. The ATTRIBUTE_GROUPS() macro is\nnot used here otherwise the path to the sysfs nodes is no longer compliant\nwith the ABI.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6b989ea1c479533ab8dbfbeb1704c94b1d3320da",
      "https://git.kernel.org/stable/c/9794ffd9d0c39ee070fbd733f862bbe89b28ba33",
      "https://git.kernel.org/stable/c/f1c5ddaef506e3517dce338c08a60663b1521920",
      "https://git.kernel.org/stable/c/4a22aeac24d0d5f26ba741408e8b5a4be6dc5dc0",
      "https://git.kernel.org/stable/c/0ad011776c057ce881b7fd6d8c79ecd459c087e9",
      "https://git.kernel.org/stable/c/165376f6b23e9a779850e750fb2eb06622e5a531"
    ],
    "受影响版本": [
      "0e3bb7d6894d9b6e67d6382bb03a46a1dc989588",
      "0e3bb7d6894d9b6e67d6382bb03a46a1dc989588",
      "0e3bb7d6894d9b6e67d6382bb03a46a1dc989588",
      "0e3bb7d6894d9b6e67d6382bb03a46a1dc989588",
      "0e3bb7d6894d9b6e67d6382bb03a46a1dc989588",
      "0e3bb7d6894d9b6e67d6382bb03a46a1dc989588"
    ],
    "公开日期": "2024年05月17日"
  },
  {
    "设备品牌": "Teplitsa of social technologies",
    "设备类型": "OTA",
    "产品型号": "Leyka",
    "CVE编号": "CVE-2024-35683",
    "漏洞描述": "Missing Authorization vulnerability in Teplitsa of social technologies Leyka.This issue affects Leyka: from n/a through 3.31.1.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/leyka/wordpress-leyka-plugin-3-31-1-broken-access-control-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年06月11日"
  },
  {
    "设备品牌": "stacklok",
    "设备类型": "OTA",
    "产品型号": "minder",
    "CVE编号": "CVE-2024-35238",
    "漏洞描述": "Minder by Stacklok is an open source software supply chain security platform. Minder prior to version 0.0.51 is vulnerable to a denial-of-service (DoS) attack which could allow an attacker to crash the Minder server and deny other users access to it. The root cause of the vulnerability is that Minders sigstore verifier reads an untrusted response entirely into memory without enforcing a limit on the response body. An attacker can exploit this by making Minder make a request to an attacker-controlled endpoint which returns a response with a large body which will crash the Minder server. Specifically, the point of failure is where Minder parses the response from the GitHub attestations endpoint in `getAttestationReply`. Here, Minder makes a request to the `orgs/$owner/attestations/$checksumref` GitHub endpoint (line 285) and then parses the response into the `AttestationReply` (line 295). The way Minder parses the response on line 295 makes it prone to DoS if the response is large enough. Essentially, the response needs to be larger than the machine has available memory.  Version 0.0.51 contains a patch for this issue.\n\nThe content that is hosted at the `orgs/$owner/attestations/$checksumref` GitHub attestation endpoint is controlled by users including unauthenticated users to Minders threat model. However, a user will need to configure their own Minder settings to cause Minder to make Minder send a request to fetch the attestations. The user would need to know of a package whose attestations were configured in such a way that they would return a large response when fetching them. As such, the steps needed to carry out this attack would look as such:\n\n1. The attacker adds a package to ghcr.io with attestations that can be fetched via the `orgs/$owner/attestations/$checksumref` GitHub endpoint.\n2. The attacker registers on Minder and makes Minder fetch the attestations.\n3. Minder fetches attestations and crashes thereby being denied of service.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/stacklok/minder/security/advisories/GHSA-8fmj-33gw-g7pw",
      "https://github.com/stacklok/minder/commit/fe321d345b4f738de6a06b13207addc72b59f892",
      "https://github.com/stacklok/minder/blob/daccbc12e364e2d407d56b87a13f7bb24cbdb074/internal/verifier/sigstore/container/container.go#L271-L300"
    ],
    "受影响版本": [
      "< 0.0.51"
    ],
    "公开日期": "2024年05月27日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2024-31497",
    "漏洞描述": "In PuTTY 0.68 through 0.80 before 0.81, biased ECDSA nonce generation allows an attacker to recover a user's NIST P-521 secret key via a quick attack in approximately 60 signatures. This is especially important in a scenario where an adversary is able to read messages signed by PuTTY or Pageant. The required set of signed messages may be publicly readable because they are stored in a public Git service that supports use of SSH for commit signing, and the signatures were made by Pageant through an agent-forwarding mechanism. In other words, an adversary may already have enough signature information to compromise a victim's private key, even if there is no further use of vulnerable PuTTY versions. After a key compromise, an adversary may be able to conduct supply-chain attacks on software maintained in Git. A second, independent scenario is that the adversary is an operator of an SSH server to which the victim authenticates (for remote login or file copy), even though this server is not fully trusted by the victim, and the victim uses the same private key for SSH connections to other services operated by other entities. Here, the rogue server operator (who would otherwise have no way to determine the victim's private key) can derive the victim's private key, and then use it for unauthorized access to those other services. If the other services include Git services, then again it may be possible to conduct supply-chain attacks on software maintained in Git. This also affects, for example, FileZilla before 3.67.0, WinSCP before 6.3.3, TortoiseGit before 2.15.0.1, and TortoiseSVN through 1.14.6.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.chiark.greenend.org.uk/~sgtatham/putty/changes.html",
      "https://filezilla-project.org/versions.php",
      "https://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/vuln-p521-bias.html",
      "https://www.openwall.com/lists/oss-security/2024/04/15/6",
      "https://tartarus.org/~simon/putty-snapshots/htmldoc/Chapter9.html#pageant-forward",
      "https://docs.ccv.brown.edu/oscar/connecting-to-oscar/ssh/ssh-agent-forwarding/key-generation-and-agent-forwarding-with-putty",
      "https://news.ycombinator.com/item?id=40044665",
      "https://winscp.net/eng/news.php",
      "https://tortoisegit.org",
      "https://github.com/advisories/GHSA-6p4c-r453-8743",
      "https://bugzilla.redhat.com/show_bug.cgi?id=2275183",
      "https://bugzilla.suse.com/show_bug.cgi?id=1222864",
      "https://security-tracker.debian.org/tracker/CVE-2024-31497",
      "https://twitter.com/lambdafu/status/1779969509522133272",
      "https://git.tartarus.org/?h=c193fe9848f50a88a4089aac647fecc31ae96d27&p=simon/putty.git",
      "https://www.reddit.com/r/sysadmin/comments/1c4wmoj/putty_vulnerability_affecting_v068_to_v08/",
      "https://github.com/daedalus/BreakingECDSAwithLLL",
      "https://www.bleepingcomputer.com/news/security/putty-ssh-client-flaw-allows-recovery-of-cryptographic-private-keys/",
      "https://twitter.com/CCBalert/status/1780229237569470549",
      "https://securityonline.info/cve-2024-31497-critical-putty-vulnerability-exposes-private-keys-immediate-action-required/",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WMJH7M663BVO3SY6MFAW2FAZWLLXAPRQ/",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/MMHILY2K7HQGQRHOC375KRRG2M6625RD/",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/IZS3B37GNGWOOV7QU7B7JFK76U4TOP4V/",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WFDZBV7ZCAZ6AH3VCQ34SSY7L3J7VZXZ/",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PUOTQVGC4DISVHQGSPUYGXO6TLDK65LA/",
      "http://www.openwall.com/lists/oss-security/2024/04/15/6",
      "https://lists.debian.org/debian-lts-announce/2024/06/msg00014.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年04月15日"
  },
  {
    "设备品牌": "Zebra",
    "设备类型": "OTA",
    "产品型号": "ZTC GK420d",
    "CVE编号": "CVE-2024-3125",
    "漏洞描述": "A vulnerability classified as problematic was found in Zebra ZTC GK420d 1.0. This vulnerability affects unknown code of the file /settings of the component Alert Setup Page. The manipulation of the argument Address leads to cross site scripting. The attack can be initiated remotely. The exploit has been disclosed to the public and may be used. The identifier of this vulnerability is VDB-258868. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/strik3r0x1/Vulns/blob/main/ZTC_GK420d-SXSS.md"
    ],
    "受影响版本": [
      "1.0"
    ],
    "公开日期": "2024年04月01日"
  },
  {
    "设备品牌": "johnbillion",
    "设备类型": "OTA",
    "产品型号": "wp-crontrol",
    "CVE编号": "CVE-2024-28850",
    "漏洞描述": "WP Crontrol controls the cron events on WordPress websites.  WP Crontrol includes a feature that allows administrative users to create events in the WP-Cron system that store and execute PHP code subject to the restrictive security permissions documented here. While there is no known vulnerability in this feature on its own, there exists potential for this feature to be vulnerable to RCE if it were specifically targeted via vulnerability chaining that exploited a separate SQLi (or similar) vulnerability. This is exploitable on a site if one of the below preconditions are met, the site is vulnerable to a writeable SQLi vulnerability in any plugin, theme, or WordPress core, the site's database is compromised at the hosting level, the site is vulnerable to a method of updating arbitrary options in the wp_options table, or the site is vulnerable to a method of triggering an arbitrary action, filter, or function with control of the parameters.  As a hardening measure, WP Crontrol version 1.16.2 ships with a new feature that prevents tampering of the code stored in a PHP cron event.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://github.com/johnbillion/wp-crontrol/security/advisories/GHSA-9xvf-cjvf-ff5q",
      "https://github.com/johnbillion/wp-crontrol/releases/tag/1.16.2"
    ],
    "受影响版本": [
      "< 1.16.2"
    ],
    "公开日期": "2024年03月25日"
  },
  {
    "设备品牌": "SDG Technologies",
    "设备类型": "OTA",
    "产品型号": "PnPSCADA",
    "CVE编号": "CVE-2024-2882",
    "漏洞描述": "SDG Technologies PnPSCADA allows a remote attacker to attach various entities without requiring system authentication. This breach could potentially lead to unauthorized control, data manipulation, and access to sensitive information within the SCADA system.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.cisa.gov/news-events/ics-advisories/icsa-24-179-02"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年06月27日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2024-28519",
    "漏洞描述": "A kernel handle leak issue in ProcObsrvesx.sys 4.0.0.49 in MicroWorld Technologies Inc eScan Antivirus could allow privilege escalation for low-privileged users.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://northwave-cybersecurity.com/vulnerability-notice-escan-antivirus",
      "https://www.escanav.com/en/index.asp"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年05月03日"
  },
  {
    "设备品牌": "lestrrat-go",
    "设备类型": "OTA",
    "产品型号": "jwx",
    "CVE编号": "CVE-2024-28122",
    "漏洞描述": " JWX is Go module implementing various JWx (JWA/JWE/JWK/JWS/JWT, otherwise known as JOSE) technologies. This vulnerability allows an attacker with a trusted public key to cause a Denial-of-Service (DoS) condition by crafting a malicious JSON Web Encryption (JWE) token with an exceptionally high compression ratio. This issue has been patched in versions 1.2.29 and 2.0.21.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/lestrrat-go/jwx/security/advisories/GHSA-hj3v-m684-v259",
      "https://github.com/lestrrat-go/jwx/releases/tag/v1.2.29",
      "https://github.com/lestrrat-go/jwx/releases/tag/v2.0.21"
    ],
    "受影响版本": [
      ">= 2.0.0, < 2.0.21",
      ">= 1.2.0, < 1.2.29"
    ],
    "公开日期": "2024年03月09日"
  },
  {
    "设备品牌": "MC Technologies",
    "设备类型": "OTA",
    "产品型号": "MC LR Router",
    "CVE编号": "CVE-2024-28027",
    "漏洞描述": "Three OS command injection vulnerabilities exist in the web interface I/O configuration functionality of MC Technologies MC LR Router 2.10.5. A specially crafted HTTP request can lead to arbitrary command execution. An attacker can make an authenticated HTTP request to trigger these vulnerabilities.This vulnerability refers to the authetnicated OS Command injection that occurs through the attacker-controlled `timer1` parameter, at offset `0x8e80`.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://talosintelligence.com/vulnerability_reports/TALOS-2024-1953"
    ],
    "受影响版本": [
      "2.10.5 (QEMU)"
    ],
    "公开日期": "2024年11月21日"
  },
  {
    "设备品牌": "MC Technologies",
    "设备类型": "OTA",
    "产品型号": "MC LR Router",
    "CVE编号": "CVE-2024-28026",
    "漏洞描述": "Three OS command injection vulnerabilities exist in the web interface I/O configuration functionality of MC Technologies MC LR Router 2.10.5. A specially crafted HTTP request can lead to arbitrary command execution. An attacker can make an authenticated HTTP request to trigger these vulnerabilities.This vulnerability refers to the authenticated OS Command Injection that occurs through the attacker-controlled `out1` parameter, at offset `0x8efc`.\r\n\r\n    \r\n    int out_ret = sscanf(current_param->key, \"out%u\", &io_idx);\r\n    if (out_ret == 1 && io_idx == 1)\r\n    {\r\n        // [4] Similar to `3`, but `out1` instead of `btn1`\r\n        if (asprintf(&command, \"/usr/sbin/vout %s %u vo_manual\", current_param->value, 1) > 0)\r\n        {\r\n            system(command);\r\n            return -1;\r\n        }\r\n    }",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://talosintelligence.com/vulnerability_reports/TALOS-2024-1953"
    ],
    "受影响版本": [
      "2.10.5 (QEMU)"
    ],
    "公开日期": "2024年11月21日"
  },
  {
    "设备品牌": "MC Technologies",
    "设备类型": "OTA",
    "产品型号": "MC LR Router",
    "CVE编号": "CVE-2024-28025",
    "漏洞描述": "Three OS command injection vulnerabilities exist in the web interface I/O configuration functionality of MC Technologies MC LR Router 2.10.5. A specially crafted HTTP request can lead to arbitrary command execution. An attacker can make an authenticated HTTP request to trigger these vulnerabilities.This vulnerability refers to the authenticated OS Command Injection that occurs through the attacker-controlled `btn1` parameter, at offset `0x8eb0`.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://talosintelligence.com/vulnerability_reports/TALOS-2024-1953"
    ],
    "受影响版本": [
      "2.10.5 (QEMU)"
    ],
    "公开日期": "2024年11月21日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "LiteSpeed Cache",
    "CVE编号": "CVE-2024-28000",
    "漏洞描述": "Incorrect Privilege Assignment vulnerability in LiteSpeed Technologies LiteSpeed Cache litespeed-cache allows Privilege Escalation.This issue affects LiteSpeed Cache: from 1.9 through 6.3.0.1.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/litespeed-cache/wordpress-litespeed-cache-plugin-6-3-0-1-unauthenticated-privilege-escalation-vulnerability?_s_id=cve",
      "https://patchstack.com/articles/critical-privilege-escalation-in-litespeed-cache-plugin-affecting-5-million-sites?_s_id=cve"
    ],
    "受影响版本": [
      "1.9"
    ],
    "公开日期": "2024年08月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27413",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nefi/capsule-loader: fix incorrect allocation size\n\ngcc-14 notices that the allocation with sizeof(void) on 32-bit architectures\nis not enough for a 64-bit phys_addr_t:\n\ndrivers/firmware/efi/capsule-loader.c: In function 'efi_capsule_open':\ndrivers/firmware/efi/capsule-loader.c:295:24: error: allocation of insufficient size '4' for type 'phys_addr_t' {aka 'long long unsigned int'} with size '8' [-Werror=alloc-size]\n  295 |         cap_info->phys = kzalloc(sizeof(void *), GFP_KERNEL);\n      |                        ^\n\nUse the correct type instead here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/00cf21ac526011a29fc708f8912da446fac19f7b",
      "https://git.kernel.org/stable/c/950d4d74d311a18baed6878dbfba8180d7e5dddd",
      "https://git.kernel.org/stable/c/537e3f49dbe88881a6f0752beaa596942d9efd64",
      "https://git.kernel.org/stable/c/4b73473c050a612fb4317831371073eda07c3050",
      "https://git.kernel.org/stable/c/ddc547dd05a46720866c32022300f7376c40119f",
      "https://git.kernel.org/stable/c/11aabd7487857b8e7d768fefb092f66dfde68492",
      "https://git.kernel.org/stable/c/62a5dcd9bd3097e9813de62fa6f22815e84a0172",
      "https://git.kernel.org/stable/c/fccfa646ef3628097d59f7d9c1a3e84d4b6bb45e"
    ],
    "受影响版本": [
      "f24c4d478013d82bd1b943df566fff3561d52864",
      "f24c4d478013d82bd1b943df566fff3561d52864",
      "f24c4d478013d82bd1b943df566fff3561d52864",
      "f24c4d478013d82bd1b943df566fff3561d52864",
      "f24c4d478013d82bd1b943df566fff3561d52864",
      "f24c4d478013d82bd1b943df566fff3561d52864",
      "f24c4d478013d82bd1b943df566fff3561d52864",
      "f24c4d478013d82bd1b943df566fff3561d52864",
      "95a362c9a6892085f714eb6e31eea6a0e3aa93bf"
    ],
    "公开日期": "2024年05月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27412",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npower: supply: bq27xxx-i2c: Do not free non existing IRQ\n\nThe bq27xxx i2c-client may not have an IRQ, in which case\nclient->irq will be 0. bq27xxx_battery_i2c_probe() already has\nan if (client->irq) check wrapping the request_threaded_irq().\n\nBut bq27xxx_battery_i2c_remove() unconditionally calls\nfree_irq(client->irq) leading to:\n\n[  190.310742] ------------[ cut here ]------------\n[  190.310843] Trying to free already-free IRQ 0\n[  190.310861] WARNING: CPU: 2 PID: 1304 at kernel/irq/manage.c:1893 free_irq+0x1b8/0x310\n\nFollowed by a backtrace when unbinding the driver. Add\nan if (client->irq) to bq27xxx_battery_i2c_remove() mirroring\nprobe() to fix this.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d4d813c0a14d6bf52d810a55db06a2e7e3d98eaa",
      "https://git.kernel.org/stable/c/7394abc8926adee6a817bab10797e0adc898af77",
      "https://git.kernel.org/stable/c/d7acc4a569f5f4513120c85ea2b9f04909b7490f",
      "https://git.kernel.org/stable/c/e601ae81910ce6a3797876e190a2d8ef6cf828bc",
      "https://git.kernel.org/stable/c/cefe18e9ec84f8fe3e198ccebb815cc996eb9797",
      "https://git.kernel.org/stable/c/fbca8bae1ba79d443a58781b45e92a73a24ac8f8",
      "https://git.kernel.org/stable/c/083686474e7c97b0f8b66df37fcb64e432e8b771",
      "https://git.kernel.org/stable/c/2df70149e73e79783bcbc7db4fa51ecef0e2022c"
    ],
    "受影响版本": [
      "76d2ed844def0cb8704d766924b07b2a918b3e30",
      "dafe9136be7b7fc30f1f3ca410c15b7cc65bee44",
      "1da9a4b55a6688e3a30c16d0cf2e7c6a90a684fb",
      "e01820a94aea99296e500f54b3f36a2985061045",
      "e65fee45687fa2109e03056a696dc7d68a151296",
      "444ff00734f3878cd54ddd1ed5e2e6dbea9326d5",
      "444ff00734f3878cd54ddd1ed5e2e6dbea9326d5",
      "444ff00734f3878cd54ddd1ed5e2e6dbea9326d5",
      "ca4a2ddd2e69ca82ca5992d4c49649b2cbac3b74",
      "28960625adaaf3fa3d83c8d3596661d2576d0a83"
    ],
    "公开日期": "2024年05月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27410",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: nl80211: reject iftype change with mesh ID change\n\nIt's currently possible to change the mesh ID when the\ninterface isn't yet in mesh mode, at the same time as\nchanging it into mesh mode. This leads to an overwrite\nof data in the wdev->u union for the interface type it\ncurrently has, causing cfg80211_change_iface() to do\nwrong things when switching.\n\nWe could probably allow setting an interface to mesh\nwhile setting the mesh ID at the same time by doing a\ndifferent order of operations here, but realistically\nthere's no userspace that's going to do this, so just\ndisallow changes in iftype when setting mesh ID.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/930e826962d9f01dcd2220176134427358d112f2",
      "https://git.kernel.org/stable/c/177d574be4b58f832354ab1ef5a297aa0c9aa2df",
      "https://git.kernel.org/stable/c/a2add961a5ed25cfd6a74f9ffb9e7ab6d6ded838",
      "https://git.kernel.org/stable/c/f78c1375339a291cba492a70eaf12ec501d28a8e"
    ],
    "受影响版本": [
      "7b0a0e3c3a88260b6fcb017e49f198463aa62ed1",
      "7b0a0e3c3a88260b6fcb017e49f198463aa62ed1",
      "7b0a0e3c3a88260b6fcb017e49f198463aa62ed1",
      "7b0a0e3c3a88260b6fcb017e49f198463aa62ed1",
      "7a53ad13c09150076b7ddde96c2dfc5622c90b45"
    ],
    "公开日期": "2024年05月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27400",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: once more fix the call oder in amdgpu_ttm_move() v2\n\nThis reverts drm/amdgpu: fix ftrace event amdgpu_bo_move always move\non same heap. The basic problem here is that after the move the old\nlocation is simply not available any more.\n\nSome fixes were suggested, but essentially we should call the move\nnotification before actually moving things because only this way we have\nthe correct order for DMA-buf and VM move notifications as well.\n\nAlso rework the statistic handling so that we don't update the eviction\ncounter before the move.\n\nv2: add missing NULL check",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5c25b169f9a0b34ee410891a96bc9d7b9ed6f9be",
      "https://git.kernel.org/stable/c/0c7ed3ed35eec9138b88d42217b5a6b9a62bda4d",
      "https://git.kernel.org/stable/c/9a4f6e138720b6e9adf7b82a71d0292f3f276480",
      "https://git.kernel.org/stable/c/d3a9331a6591e9df64791e076f6591f440af51c3"
    ],
    "受影响版本": [
      "d443fb67ca5ab04760449d21ddea66f6728e5b00",
      "e7a0ee45c653784edda5e36bae6ae3c75fd5e7a8",
      "94aeb4117343d072e3a35b9595bcbfc0058ee724",
      "94aeb4117343d072e3a35b9595bcbfc0058ee724",
      "77bcd4ab446fa35ad135b1c7404415ed9a129296",
      "1cd2b612474c07b17a21e27f2eed8dff75cb5057"
    ],
    "公开日期": "2024年05月13日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27389",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npstore: inode: Only d_invalidate() is needed\n\nUnloading a modular pstore backend with records in pstorefs would\ntrigger the dput() double-drop warning:\n\n  WARNING: CPU: 0 PID: 2569 at fs/dcache.c:762 dput.part.0+0x3f3/0x410\n\nUsing the combo of d_drop()/dput() (as mentioned in\nDocumentation/filesystems/vfs.rst) isn't the right approach here, and\nleads to the reference counting problem seen above. Use d_invalidate()\nand update the code to not bother checking for error codes that can\nnever happen.\n\n---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/db6e5e16f1ee9e3b01d2f71c7f0ba945f4bf0f4e",
      "https://git.kernel.org/stable/c/4cdf9006fc095af71da80e9b5f48a32e991b9ed3",
      "https://git.kernel.org/stable/c/cb9e802e49c24eeb3af35e9e8c04d526f35f112a",
      "https://git.kernel.org/stable/c/340682ed1932b8e3bd0bfc6c31a0c6354eb57cc6",
      "https://git.kernel.org/stable/c/a43e0fc5e9134a46515de2f2f8d4100b74e50de3"
    ],
    "受影响版本": [
      "609e28bb139e53621521130f0d4aea27a725d465",
      "609e28bb139e53621521130f0d4aea27a725d465",
      "609e28bb139e53621521130f0d4aea27a725d465",
      "609e28bb139e53621521130f0d4aea27a725d465",
      "609e28bb139e53621521130f0d4aea27a725d465"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27072",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: usbtv: Remove useless locks in usbtv_video_free()\n\nRemove locks calls in usbtv_video_free() because\nare useless and may led to a deadlock as reported here:\nhttps://syzkaller.appspot.com/x/bisect.txt?x=166dc872180000\nAlso remove usbtv_stop() call since it will be called when\nunregistering the device.\n\nBefore 'c838530d230b' this issue would only be noticed if you\ndisconnect while streaming and now it is noticeable even when\ndisconnecting while not streaming.\n\n\n[hverkuil: fix minor spelling mistake in log message]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4ec4641df57cbdfdc51bb4959afcdbcf5003ddb9",
      "https://git.kernel.org/stable/c/d5ed208d04acf06781d63d30f9fa991e8d609ebd",
      "https://git.kernel.org/stable/c/bdd82c47b22a8befd617b723098b2a41b77373c7",
      "https://git.kernel.org/stable/c/dea46e246ef0f98d89d59a4229157cd9ffb636bf",
      "https://git.kernel.org/stable/c/3e7d82ebb86e94643bdb30b0b5b077ed27dce1c2",
      "https://git.kernel.org/stable/c/65e6a2773d655172143cc0b927cdc89549842895"
    ],
    "受影响版本": [
      "f3d27f34fdd7701e499617d2c1d94480a98f6d07",
      "f3d27f34fdd7701e499617d2c1d94480a98f6d07",
      "f3d27f34fdd7701e499617d2c1d94480a98f6d07",
      "f3d27f34fdd7701e499617d2c1d94480a98f6d07",
      "f3d27f34fdd7701e499617d2c1d94480a98f6d07",
      "f3d27f34fdd7701e499617d2c1d94480a98f6d07"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27066",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio: packed: fix unmap leak for indirect desc table\n\nWhen use_dma_api and premapped are true, then the do_unmap is false.\n\nBecause the do_unmap is false, vring_unmap_extra_packed is not called by\ndetach_buf_packed.\n\n  if (unlikely(vq->do_unmap)) {\n                curr = id;\n                for (i = 0; i < state->num; i++) {\n                        vring_unmap_extra_packed(vq,\n                                                 &vq->packed.desc_extra[curr]);\n                        curr = vq->packed.desc_extra[curr].next;\n                }\n  }\n\nSo the indirect desc table is not unmapped. This causes the unmap leak.\n\nSo here, we check vq->use_dma_api instead. Synchronously, dma info is\nupdated based on use_dma_api judgment\n\nThis bug does not occur, because no driver use the premapped with\nindirect.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e142169aca5546ae6619c39a575cda8105362100",
      "https://git.kernel.org/stable/c/75450ff8c6fe8755bf5b139b238eaf9739cfd64e",
      "https://git.kernel.org/stable/c/51bacd9d29bf98c3ebc65e4a0477bb86306b4140",
      "https://git.kernel.org/stable/c/d5c0ed17fea60cca9bc3bf1278b49ba79242bbcd"
    ],
    "受影响版本": [
      "b319940f83c21bb4c1fabffe68a862be879a6193",
      "b319940f83c21bb4c1fabffe68a862be879a6193",
      "b319940f83c21bb4c1fabffe68a862be879a6193",
      "b319940f83c21bb4c1fabffe68a862be879a6193"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27012",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: restore set elements when delete set fails\n\nFrom abort path, nft_mapelem_activate() needs to restore refcounters to\nthe original state. Currently, it uses the set->ops->walk() to iterate\nover these set elements. The existing set iterator skips inactive\nelements in the next generation, this does not work from the abort path\nto restore the original state since it has to skip active elements\ninstead (not inactive ones).\n\nThis patch moves the check for inactive elements to the set iterator\ncallback, then it reverses the logic for the .activate case which\nneeds to skip active elements.\n\nToggle next generation bit for elements when delete set command is\ninvoked and call nft_clear() from .activate (abort) path to restore the\nnext generation bit.\n\nThe splat below shows an object in mappings memleak:\n\n[43929.457523] ------------[ cut here ]------------\n[43929.457532] WARNING: CPU: 0 PID: 1139 at include/net/netfilter/nf_tables.h:1237 nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]\n[...]\n[43929.458014] RIP: 0010:nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]\n[43929.458076] Code: 83 f8 01 77 ab 49 8d 7c 24 08 e8 37 5e d0 de 49 8b 6c 24 08 48 8d 7d 50 e8 e9 5c d0 de 8b 45 50 8d 50 ff 89 55 50 85 c0 75 86 <0f> 0b eb 82 0f 0b eb b3 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90\n[43929.458081] RSP: 0018:ffff888140f9f4b0 EFLAGS: 00010246\n[43929.458086] RAX: 0000000000000000 RBX: ffff8881434f5288 RCX: dffffc0000000000\n[43929.458090] RDX: 00000000ffffffff RSI: ffffffffa26d28a7 RDI: ffff88810ecc9550\n[43929.458093] RBP: ffff88810ecc9500 R08: 0000000000000001 R09: ffffed10281f3e8f\n[43929.458096] R10: 0000000000000003 R11: ffff0000ffff0000 R12: ffff8881434f52a0\n[43929.458100] R13: ffff888140f9f5f4 R14: ffff888151c7a800 R15: 0000000000000002\n[43929.458103] FS:  00007f0c687c4740(0000) GS:ffff888390800000(0000) knlGS:0000000000000000\n[43929.458107] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[43929.458111] CR2: 00007f58dbe5b008 CR3: 0000000123602005 CR4: 00000000001706f0\n[43929.458114] Call Trace:\n[43929.458118]  <TASK>\n[43929.458121]  ? __warn+0x9f/0x1a0\n[43929.458127]  ? nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]\n[43929.458188]  ? report_bug+0x1b1/0x1e0\n[43929.458196]  ? handle_bug+0x3c/0x70\n[43929.458200]  ? exc_invalid_op+0x17/0x40\n[43929.458211]  ? nft_setelem_data_deactivate+0xd7/0xf0 [nf_tables]\n[43929.458271]  ? nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]\n[43929.458332]  nft_mapelem_deactivate+0x24/0x30 [nf_tables]\n[43929.458392]  nft_rhash_walk+0xdd/0x180 [nf_tables]\n[43929.458453]  ? __pfx_nft_rhash_walk+0x10/0x10 [nf_tables]\n[43929.458512]  ? rb_insert_color+0x2e/0x280\n[43929.458520]  nft_map_deactivate+0xdc/0x1e0 [nf_tables]\n[43929.458582]  ? __pfx_nft_map_deactivate+0x10/0x10 [nf_tables]\n[43929.458642]  ? __pfx_nft_mapelem_deactivate+0x10/0x10 [nf_tables]\n[43929.458701]  ? __rcu_read_unlock+0x46/0x70\n[43929.458709]  nft_delset+0xff/0x110 [nf_tables]\n[43929.458769]  nft_flush_table+0x16f/0x460 [nf_tables]\n[43929.458830]  nf_tables_deltable+0x501/0x580 [nf_tables]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/86658fc7414d4b9e25c2699d751034537503d637",
      "https://git.kernel.org/stable/c/e79b47a8615d42c68aaeb68971593333667382ed"
    ],
    "受影响版本": [
      "628bd3e49cba1c066228e23d71a852c23e26da73",
      "628bd3e49cba1c066228e23d71a852c23e26da73",
      "bc9f791d2593f17e39f87c6e2b3a36549a3705b1",
      "3c7ec098e3b588434a8b07ea9b5b36f04cef1f50",
      "a136b7942ad2a50de708f76ea299ccb45ac7a7f9",
      "25aa2ad37c2162be1c0bc4fe6397f7e4c13f00f8",
      "d60be2da67d172aecf866302c91ea11533eca4d9",
      "dc7cdf8cbcbf8b13de1df93f356ec04cdeef5c41"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27011",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: fix memleak in map from abort path\n\nThe delete set command does not rely on the transaction object for\nelement removal, therefore, a combination of delete element + delete set\nfrom the abort path could result in restoring twice the refcount of the\nmapping.\n\nCheck for inactive element in the next generation for the delete element\ncommand in the abort path, skip restoring state if next generation bit\nhas been already cleared. This is similar to the activate logic using\nthe set walk iterator.\n\n[ 6170.286929] ------------[ cut here ]------------\n[ 6170.286939] WARNING: CPU: 6 PID: 790302 at net/netfilter/nf_tables_api.c:2086 nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.287071] Modules linked in: [...]\n[ 6170.287633] CPU: 6 PID: 790302 Comm: kworker/6:2 Not tainted 6.9.0-rc3+ #365\n[ 6170.287768] RIP: 0010:nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.287886] Code: df 48 8d 7d 58 e8 69 2e 3b df 48 8b 7d 58 e8 80 1b 37 df 48 8d 7d 68 e8 57 2e 3b df 48 8b 7d 68 e8 6e 1b 37 df 48 89 ef eb c4 <0f> 0b 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 0f\n[ 6170.287895] RSP: 0018:ffff888134b8fd08 EFLAGS: 00010202\n[ 6170.287904] RAX: 0000000000000001 RBX: ffff888125bffb28 RCX: dffffc0000000000\n[ 6170.287912] RDX: 0000000000000003 RSI: ffffffffa20298ab RDI: ffff88811ebe4750\n[ 6170.287919] RBP: ffff88811ebe4700 R08: ffff88838e812650 R09: fffffbfff0623a55\n[ 6170.287926] R10: ffffffff8311d2af R11: 0000000000000001 R12: ffff888125bffb10\n[ 6170.287933] R13: ffff888125bffb10 R14: dead000000000122 R15: dead000000000100\n[ 6170.287940] FS:  0000000000000000(0000) GS:ffff888390b00000(0000) knlGS:0000000000000000\n[ 6170.287948] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 6170.287955] CR2: 00007fd31fc00710 CR3: 0000000133f60004 CR4: 00000000001706f0\n[ 6170.287962] Call Trace:\n[ 6170.287967]  <TASK>\n[ 6170.287973]  ? __warn+0x9f/0x1a0\n[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.288092]  ? report_bug+0x1b1/0x1e0\n[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.288092]  ? report_bug+0x1b1/0x1e0\n[ 6170.288104]  ? handle_bug+0x3c/0x70\n[ 6170.288112]  ? exc_invalid_op+0x17/0x40\n[ 6170.288120]  ? asm_exc_invalid_op+0x1a/0x20\n[ 6170.288132]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]\n[ 6170.288243]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]\n[ 6170.288366]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]\n[ 6170.288483]  nf_tables_trans_destroy_work+0x588/0x590 [nf_tables]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a1bd2a38a1c6388fc8556816dc203c3e9dc52237",
      "https://git.kernel.org/stable/c/49d0e656d19dfb2d4d7c230e4a720d37b3decff6",
      "https://git.kernel.org/stable/c/86a1471d7cde792941109b93b558b5dc078b9ee9"
    ],
    "受影响版本": [
      "591054469b3eef34bc097c30fae8ededddf8d796",
      "591054469b3eef34bc097c30fae8ededddf8d796",
      "591054469b3eef34bc097c30fae8ededddf8d796"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-27000",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nserial: mxs-auart: add spinlock around changing cts state\n\nThe uart_handle_cts_change() function in serial_core expects the caller\nto hold uport->lock. For example, I have seen the below kernel splat,\nwhen the Bluetooth driver is loaded on an i.MX28 board.\n\n    [   85.119255] ------------[ cut here ]------------\n    [   85.124413] WARNING: CPU: 0 PID: 27 at /drivers/tty/serial/serial_core.c:3453 uart_handle_cts_change+0xb4/0xec\n    [   85.134694] Modules linked in: hci_uart bluetooth ecdh_generic ecc wlcore_sdio configfs\n    [   85.143314] CPU: 0 PID: 27 Comm: kworker/u3:0 Not tainted 6.6.3-00021-gd62a2f068f92 #1\n    [   85.151396] Hardware name: Freescale MXS (Device Tree)\n    [   85.156679] Workqueue: hci0 hci_power_on [bluetooth]\n    (...)\n    [   85.191765]  uart_handle_cts_change from mxs_auart_irq_handle+0x380/0x3f4\n    [   85.198787]  mxs_auart_irq_handle from __handle_irq_event_percpu+0x88/0x210\n    (...)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/56434e295bd446142025913bfdf1587f5e1970ad",
      "https://git.kernel.org/stable/c/21535ef0ac1945080198fe3e4347ea498205c99a",
      "https://git.kernel.org/stable/c/0dc0637e6b16158af85945425821bfd0151adb37",
      "https://git.kernel.org/stable/c/479244d68f5d94f3903eced52b093c1e01ddb495",
      "https://git.kernel.org/stable/c/2c9b943e9924cf1269e44289bc5e60e51b0f5270",
      "https://git.kernel.org/stable/c/5f40fd6ca2cf0bfbc5a5c9e403dfce8ca899ba37",
      "https://git.kernel.org/stable/c/94b0e65c75f4af888ab2dd6c90f060f762924e86",
      "https://git.kernel.org/stable/c/54c4ec5f8c471b7c1137a1f769648549c423c026"
    ],
    "受影响版本": [
      "4d90bb147ef6b91f529a21b498ff2b5fdc6785b4",
      "4d90bb147ef6b91f529a21b498ff2b5fdc6785b4",
      "4d90bb147ef6b91f529a21b498ff2b5fdc6785b4",
      "4d90bb147ef6b91f529a21b498ff2b5fdc6785b4",
      "4d90bb147ef6b91f529a21b498ff2b5fdc6785b4",
      "4d90bb147ef6b91f529a21b498ff2b5fdc6785b4",
      "4d90bb147ef6b91f529a21b498ff2b5fdc6785b4",
      "4d90bb147ef6b91f529a21b498ff2b5fdc6785b4"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26984",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnouveau: fix instmem race condition around ptr stores\n\nRunning a lot of VK CTS in parallel against nouveau, once every\nfew hours you might see something like this crash.\n\nBUG: kernel NULL pointer dereference, address: 0000000000000008\nPGD 8000000114e6e067 P4D 8000000114e6e067 PUD 109046067 PMD 0\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 7 PID: 53891 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27\nHardware name: Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI/Z390 I AORUS PRO WIFI-CF, BIOS F8 11/05/2021\nRIP: 0010:gp100_vmm_pgt_mem+0xe3/0x180 [nouveau]\nCode: c7 48 01 c8 49 89 45 58 85 d2 0f 84 95 00 00 00 41 0f b7 46 12 49 8b 7e 08 89 da 42 8d 2c f8 48 8b 47 08 41 83 c7 01 48 89 ee <48> 8b 40 08 ff d0 0f 1f 00 49 8b 7e 08 48 89 d9 48 8d 75 04 48 c1\nRSP: 0000:ffffac20c5857838 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: 00000000004d8001 RCX: 0000000000000001\nRDX: 00000000004d8001 RSI: 00000000000006d8 RDI: ffffa07afe332180\nRBP: 00000000000006d8 R08: ffffac20c5857ad0 R09: 0000000000ffff10\nR10: 0000000000000001 R11: ffffa07af27e2de0 R12: 000000000000001c\nR13: ffffac20c5857ad0 R14: ffffa07a96fe9040 R15: 000000000000001c\nFS:  00007fe395eed7c0(0000) GS:ffffa07e2c980000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000008 CR3: 000000011febe001 CR4: 00000000003706f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\n...\n\n ? gp100_vmm_pgt_mem+0xe3/0x180 [nouveau]\n ? gp100_vmm_pgt_mem+0x37/0x180 [nouveau]\n nvkm_vmm_iter+0x351/0xa20 [nouveau]\n ? __pfx_nvkm_vmm_ref_ptes+0x10/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n ? __lock_acquire+0x3ed/0x2170\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n nvkm_vmm_ptes_get_map+0xc2/0x100 [nouveau]\n ? __pfx_nvkm_vmm_ref_ptes+0x10/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n nvkm_vmm_map_locked+0x224/0x3a0 [nouveau]\n\nAdding any sort of useful debug usually makes it go away, so I hand\nwrote the function in a line, and debugged the asm.\n\nEvery so often pt->memory->ptrs is NULL. This ptrs ptr is set in\nthe nv50_instobj_acquire called from nvkm_kmap.\n\nIf Thread A and Thread B both get to nv50_instobj_acquire around\nthe same time, and Thread A hits the refcount_set line, and in\nlockstep thread B succeeds at refcount_inc_not_zero, there is a\nchance the ptrs value won't have been stored since refcount_set\nis unordered. Force a memory barrier here, I picked smp_mb, since\nwe want it on all CPUs and it's write followed by a read.\n\nv2: use paired smp_rmb/smp_wmb.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/bba8ec5e9b16649d85bc9e9086bf7ae5b5716ff9",
      "https://git.kernel.org/stable/c/1bc4825d4c3ec6abe43cf06c3c39d664d044cbf7",
      "https://git.kernel.org/stable/c/13d76b2f443dc371842916dd8768009ff1594716",
      "https://git.kernel.org/stable/c/3ab056814cd8ab84744c9a19ef51360b2271c572",
      "https://git.kernel.org/stable/c/ad74d208f213c06d860916ad40f609ade8c13039",
      "https://git.kernel.org/stable/c/a019b44b1bc6ed224c46fb5f88a8a10dd116e525",
      "https://git.kernel.org/stable/c/21ca9539f09360fd83654f78f2c361f2f5ddcb52",
      "https://git.kernel.org/stable/c/fff1386cc889d8fb4089d285f883f8cba62d82ce"
    ],
    "受影响版本": [
      "be55287aa5ba6895e9d4d3ed2f08a1be7a065957",
      "be55287aa5ba6895e9d4d3ed2f08a1be7a065957",
      "be55287aa5ba6895e9d4d3ed2f08a1be7a065957",
      "be55287aa5ba6895e9d4d3ed2f08a1be7a065957",
      "be55287aa5ba6895e9d4d3ed2f08a1be7a065957",
      "be55287aa5ba6895e9d4d3ed2f08a1be7a065957",
      "be55287aa5ba6895e9d4d3ed2f08a1be7a065957",
      "be55287aa5ba6895e9d4d3ed2f08a1be7a065957"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26963",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3-am62: fix module unload/reload behavior\n\nAs runtime PM is enabled, the module can be runtime\nsuspended when .remove() is called.\n\nDo a pm_runtime_get_sync() to make sure module is active\nbefore doing any register operations.\n\nDoing a pm_runtime_put_sync() should disable the refclk\nso no need to disable it again.\n\nFixes the below warning at module removel.\n\n[   39.705310] ------------[ cut here ]------------\n[   39.710004] clk:162:3 already disabled\n[   39.713941] WARNING: CPU: 0 PID: 921 at drivers/clk/clk.c:1090 clk_core_disable+0xb0/0xb8\n\nWe called of_platform_populate() in .probe() so call the\ncleanup function of_platform_depopulate() in .remove().\nGet rid of the now unnnecessary dwc3_ti_remove_core().\nWithout this, module re-load doesn't work properly.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6c6a45645a2e6a272dfde14eddbb6706de63c25d",
      "https://git.kernel.org/stable/c/7dfed9855397d0df4c6f748d1f66547ab3bad766",
      "https://git.kernel.org/stable/c/629b534c42d04f0797980f2d1ed105fdb8906975",
      "https://git.kernel.org/stable/c/3895780fabd120d0fbd54354014e85207b25687c",
      "https://git.kernel.org/stable/c/6661befe41009c210efa2c1bcd16a5cc4cff8a06"
    ],
    "受影响版本": [
      "e8784c0aec03a2581ee55827ba694e129d6a57ad",
      "e8784c0aec03a2581ee55827ba694e129d6a57ad",
      "e8784c0aec03a2581ee55827ba694e129d6a57ad",
      "e8784c0aec03a2581ee55827ba694e129d6a57ad",
      "e8784c0aec03a2581ee55827ba694e129d6a57ad"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26958",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfs: fix UAF in direct writes\n\nIn production we have been hitting the following warning consistently\n\n------------[ cut here ]------------\nrefcount_t: underflow; use-after-free.\nWARNING: CPU: 17 PID: 1800359 at lib/refcount.c:28 refcount_warn_saturate+0x9c/0xe0\nWorkqueue: nfsiod nfs_direct_write_schedule_work [nfs]\nRIP: 0010:refcount_warn_saturate+0x9c/0xe0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? __warn+0x9f/0x130\n ? refcount_warn_saturate+0x9c/0xe0\n ? report_bug+0xcc/0x150\n ? handle_bug+0x3d/0x70\n ? exc_invalid_op+0x16/0x40\n ? asm_exc_invalid_op+0x16/0x20\n ? refcount_warn_saturate+0x9c/0xe0\n nfs_direct_write_schedule_work+0x237/0x250 [nfs]\n process_one_work+0x12f/0x4a0\n worker_thread+0x14e/0x3b0\n ? ZSTD_getCParams_internal+0x220/0x220\n kthread+0xdc/0x120\n ? __btf_name_valid+0xa0/0xa0\n ret_from_fork+0x1f/0x30\n\nThis is because we're completing the nfs_direct_request twice in a row.\n\nThe source of this is when we have our commit requests to submit, we\nprocess them and send them off, and then in the completion path for the\ncommit requests we have\n\nif (nfs_commit_end(cinfo.mds))\n\tnfs_direct_write_complete(dreq);\n\nHowever since we're submitting asynchronous requests we sometimes have\none that completes before we submit the next one, so we end up calling\ncomplete on the nfs_direct_request twice.\n\nThe only other place we use nfs_generic_commit_list() is in\n__nfs_commit_inode, which wraps this call in a\n\nnfs_commit_begin();\nnfs_commit_end();\n\nWhich is a common pattern for this style of completion handling, one\nthat is also repeated in the direct code with get_dreq()/put_dreq()\ncalls around where we process events as well as in the completion paths.\n\nFix this by using the same pattern for the commit requests.\n\nBefore with my 200 node rocksdb stress running this warning would pop\nevery 10ish minutes.  With my patch the stress test has been running for\nseveral hours without popping.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4595d90b5d2ea5fa4d318d13f59055aa4bf3e7f5",
      "https://git.kernel.org/stable/c/80d24b308b7ee7037fc90d8ac99f6f78df0a256f",
      "https://git.kernel.org/stable/c/3abc2d160ed8213948b147295d77d44a22c88fa3",
      "https://git.kernel.org/stable/c/e25447c35f8745337ea8bc0c9697fcac14df8605",
      "https://git.kernel.org/stable/c/1daf52b5ffb24870fbeda20b4967526d8f9e12ab",
      "https://git.kernel.org/stable/c/cf54f66e1dd78990ec6b32177bca7e6ea2144a95",
      "https://git.kernel.org/stable/c/17f46b803d4f23c66cacce81db35fef3adb8f2af"
    ],
    "受影响版本": [
      "af7cf057933f01dc7f33ddfb5e436ad598ed17ad",
      "af7cf057933f01dc7f33ddfb5e436ad598ed17ad",
      "af7cf057933f01dc7f33ddfb5e436ad598ed17ad",
      "af7cf057933f01dc7f33ddfb5e436ad598ed17ad",
      "af7cf057933f01dc7f33ddfb5e436ad598ed17ad",
      "af7cf057933f01dc7f33ddfb5e436ad598ed17ad",
      "af7cf057933f01dc7f33ddfb5e436ad598ed17ad"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26956",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix failure to detect DAT corruption in btree and direct mappings\n\nPatch series \"nilfs2: fix kernel bug at submit_bh_wbc()\".\n\nThis resolves a kernel BUG reported by syzbot.  Since there are two\nflaws involved, I've made each one a separate patch.\n\nThe first patch alone resolves the syzbot-reported bug, but I think\nboth fixes should be sent to stable, so I've tagged them as such.\n\n\nThis patch (of 2):\n\nSyzbot has reported a kernel bug in submit_bh_wbc() when writing file data\nto a nilfs2 file system whose metadata is corrupted.\n\nThere are two flaws involved in this issue.\n\nThe first flaw is that when nilfs_get_block() locates a data block using\nbtree or direct mapping, if the disk address translation routine\nnilfs_dat_translate() fails with internal code -ENOENT due to DAT metadata\ncorruption, it can be passed back to nilfs_get_block().  This causes\nnilfs_get_block() to misidentify an existing block as non-existent,\ncausing both data block lookup and insertion to fail inconsistently.\n\nThe second flaw is that nilfs_get_block() returns a successful status in\nthis inconsistent state.  This causes the caller __block_write_begin_int()\nor others to request a read even though the buffer is not mapped,\nresulting in a BUG_ON check for the BH_Mapped flag in submit_bh_wbc()\nfailing.\n\nThis fixes the first issue by changing the return value to code -EINVAL\nwhen a conversion using DAT fails with code -ENOENT, avoiding the\nconflicting condition that leads to the kernel bug described above.  Here,\ncode -EINVAL indicates that metadata corruption was detected during the\nblock lookup, which will be properly handled as a file system error and\nconverted to -EIO when passing through the nilfs2 bmap layer.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b67189690eb4b7ecc84ae16fa1e880e0123eaa35",
      "https://git.kernel.org/stable/c/9cbe1ad5f4354f4df1445e5f4883983328cd6d8e",
      "https://git.kernel.org/stable/c/c3b5c5c31e723b568f83d8cafab8629d9d830ffb",
      "https://git.kernel.org/stable/c/2e2619ff5d0def4bb6c2037a32a6eaa28dd95c84",
      "https://git.kernel.org/stable/c/46b832e09d43b394ac0f6d9485d2b1a06593f0b7",
      "https://git.kernel.org/stable/c/f69e81396aea66304d214f175aa371f1b5578862",
      "https://git.kernel.org/stable/c/a8e4d098de1c0f4c5c1f2ed4633a860f0da6d713",
      "https://git.kernel.org/stable/c/82827ca21e7c8a91384c5baa656f78a5adfa4ab4",
      "https://git.kernel.org/stable/c/f2f26b4a84a0ef41791bd2d70861c8eac748f4ba"
    ],
    "受影响版本": [
      "c3a7abf06ce719a51139e62a034590be99abbc2c",
      "c3a7abf06ce719a51139e62a034590be99abbc2c",
      "c3a7abf06ce719a51139e62a034590be99abbc2c",
      "c3a7abf06ce719a51139e62a034590be99abbc2c",
      "c3a7abf06ce719a51139e62a034590be99abbc2c",
      "c3a7abf06ce719a51139e62a034590be99abbc2c",
      "c3a7abf06ce719a51139e62a034590be99abbc2c",
      "c3a7abf06ce719a51139e62a034590be99abbc2c",
      "c3a7abf06ce719a51139e62a034590be99abbc2c"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26937",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/i915/gt: Reset queue_priority_hint on parking\n\nOriginally, with strict in order execution, we could complete execution\nonly when the queue was empty. Preempt-to-busy allows replacement of an\nactive request that may complete before the preemption is processed by\nHW. If that happens, the request is retired from the queue, but the\nqueue_priority_hint remains set, preventing direct submission until\nafter the next CS interrupt is processed.\n\nThis preempt-to-busy race can be triggered by the heartbeat, which will\nalso act as the power-management barrier and upon completion allow us to\nidle the HW. We may process the completion of the heartbeat, and begin\nparking the engine before the CS event that restores the\nqueue_priority_hint, causing us to fail the assertion that it is MIN.\n\n<3>[  166.210729] __engine_park:283 GEM_BUG_ON(engine->sched_engine->queue_priority_hint != (-((int)(~0U >> 1)) - 1))\n<0>[  166.210781] Dumping ftrace buffer:\n<0>[  166.210795] ---------------------------------\n...\n<0>[  167.302811] drm_fdin-1097      2..s1. 165741070us : trace_ports: 0000:00:02.0 rcs0: promote { ccid:20 1217:2 prio 0 }\n<0>[  167.302861] drm_fdin-1097      2d.s2. 165741072us : execlists_submission_tasklet: 0000:00:02.0 rcs0: preempting last=1217:2, prio=0, hint=2147483646\n<0>[  167.302928] drm_fdin-1097      2d.s2. 165741072us : __i915_request_unsubmit: 0000:00:02.0 rcs0: fence 1217:2, current 0\n<0>[  167.302992] drm_fdin-1097      2d.s2. 165741073us : __i915_request_submit: 0000:00:02.0 rcs0: fence 3:4660, current 4659\n<0>[  167.303044] drm_fdin-1097      2d.s1. 165741076us : execlists_submission_tasklet: 0000:00:02.0 rcs0: context:3 schedule-in, ccid:40\n<0>[  167.303095] drm_fdin-1097      2d.s1. 165741077us : trace_ports: 0000:00:02.0 rcs0: submit { ccid:40 3:4660* prio 2147483646 }\n<0>[  167.303159] kworker/-89       11..... 165741139us : i915_request_retire.part.0: 0000:00:02.0 rcs0: fence c90:2, current 2\n<0>[  167.303208] kworker/-89       11..... 165741148us : __intel_context_do_unpin: 0000:00:02.0 rcs0: context:c90 unpin\n<0>[  167.303272] kworker/-89       11..... 165741159us : i915_request_retire.part.0: 0000:00:02.0 rcs0: fence 1217:2, current 2\n<0>[  167.303321] kworker/-89       11..... 165741166us : __intel_context_do_unpin: 0000:00:02.0 rcs0: context:1217 unpin\n<0>[  167.303384] kworker/-89       11..... 165741170us : i915_request_retire.part.0: 0000:00:02.0 rcs0: fence 3:4660, current 4660\n<0>[  167.303434] kworker/-89       11d..1. 165741172us : __intel_context_retire: 0000:00:02.0 rcs0: context:1216 retire runtime: { total:56028ns, avg:56028ns }\n<0>[  167.303484] kworker/-89       11..... 165741198us : __engine_park: 0000:00:02.0 rcs0: parked\n<0>[  167.303534]   <idle>-0         5d.H3. 165741207us : execlists_irq_handler: 0000:00:02.0 rcs0: semaphore yield: 00000040\n<0>[  167.303583] kworker/-89       11..... 165741397us : __intel_context_retire: 0000:00:02.0 rcs0: context:1217 retire runtime: { total:325575ns, avg:0ns }\n<0>[  167.303756] kworker/-89       11..... 165741777us : __intel_context_retire: 0000:00:02.0 rcs0: context:c90 retire runtime: { total:0ns, avg:0ns }\n<0>[  167.303806] kworker/-89       11..... 165742017us : __engine_park: __engine_park:283 GEM_BUG_ON(engine->sched_engine->queue_priority_hint != (-((int)(~0U >> 1)) - 1))\n<0>[  167.303811] ---------------------------------\n<4>[  167.304722] ------------[ cut here ]------------\n<2>[  167.304725] kernel BUG at drivers/gpu/drm/i915/gt/intel_engine_pm.c:283!\n<4>[  167.304731] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n<4>[  167.304734] CPU: 11 PID: 89 Comm: kworker/11:1 Tainted: G        W          6.8.0-rc2-CI_DRM_14193-gc655e0fd2804+ #1\n<4>[  167.304736] Hardware name: Intel Corporation Rocket Lake Client Platform/RocketLake S UDIMM 6L RVP, BIOS RKLSFWI1.R00.3173.A03.2204210138 04/21/2022\n<4>[  167.304738] Workqueue: i915-unordered retire_work_handler [i915]\n<4>[  16\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/67944e6db656bf1e986aa2a359f866f851091f8a",
      "https://git.kernel.org/stable/c/fe34587acc995e7b1d7a5d3444a0736721ec32b3",
      "https://git.kernel.org/stable/c/ac9b6b3e8d1237136c8ebf0fa1ce037dd7e2948f",
      "https://git.kernel.org/stable/c/7eab7b021835ae422c38b968d5cc60e99408fb62",
      "https://git.kernel.org/stable/c/3b031e4fcb2740988143c303f81f69f18ce86325",
      "https://git.kernel.org/stable/c/aed034866a08bb7e6e34d50a5629a4d23fe83703",
      "https://git.kernel.org/stable/c/8fd9b0ce8c26533fe4d5d15ea15bbf7b904b611c",
      "https://git.kernel.org/stable/c/4a3859ea5240365d21f6053ee219bb240d520895"
    ],
    "受影响版本": [
      "22b7a426bbe1ebe1520f92da4cd1617d1e1b5fc4",
      "22b7a426bbe1ebe1520f92da4cd1617d1e1b5fc4",
      "22b7a426bbe1ebe1520f92da4cd1617d1e1b5fc4",
      "22b7a426bbe1ebe1520f92da4cd1617d1e1b5fc4",
      "22b7a426bbe1ebe1520f92da4cd1617d1e1b5fc4",
      "22b7a426bbe1ebe1520f92da4cd1617d1e1b5fc4",
      "22b7a426bbe1ebe1520f92da4cd1617d1e1b5fc4",
      "22b7a426bbe1ebe1520f92da4cd1617d1e1b5fc4"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26935",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: Fix unremoved procfs host directory regression\n\nCommit fc663711b944 (\"scsi: core: Remove the /proc/scsi/${proc_name}\ndirectory earlier\") fixed a bug related to modules loading/unloading, by\nadding a call to scsi_proc_hostdir_rm() on scsi_remove_host(). But that led\nto a potential duplicate call to the hostdir_rm() routine, since it's also\ncalled from scsi_host_dev_release(). That triggered a regression report,\nwhich was then fixed by commit be03df3d4bfe (\"scsi: core: Fix a procfs host\ndirectory removal regression\"). The fix just dropped the hostdir_rm() call\nfrom dev_release().\n\nBut it happens that this proc directory is created on scsi_host_alloc(),\nand that function \"pairs\" with scsi_host_dev_release(), while\nscsi_remove_host() pairs with scsi_add_host(). In other words, it seems the\nreason for removing the proc directory on dev_release() was meant to cover\ncases in which a SCSI host structure was allocated, but the call to\nscsi_add_host() didn't happen. And that pattern happens to exist in some\nerror paths, for example.\n\nSyzkaller causes that by using USB raw gadget device, error'ing on\nusb-storage driver, at usb_stor_probe2(). By checking that path, we can see\nthat the BadDevice label leads to a scsi_host_put() after a SCSI host\nallocation, but there's no call to scsi_add_host() in such path. That leads\nto messages like this in dmesg (and a leak of the SCSI host proc\nstructure):\n\nusb-storage 4-1:87.51: USB Mass Storage device detected\nproc_dir_entry 'scsi/usb-storage' already registered\nWARNING: CPU: 1 PID: 3519 at fs/proc/generic.c:377 proc_register+0x347/0x4e0 fs/proc/generic.c:376\n\nThe proper fix seems to still call scsi_proc_hostdir_rm() on dev_release(),\nbut guard that with the state check for SHOST_CREATED; there is even a\ncomment in scsi_host_dev_release() detailing that: such conditional is\nmeant for cases where the SCSI host was allocated but there was no calls to\n{add,remove}_host(), like the usb-storage case.\n\nThis is what we propose here and with that, the error path of usb-storage\ndoes not trigger the warning anymore.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0053f15d50d50c9312d8ab9c11e2e405812dfcac",
      "https://git.kernel.org/stable/c/5c2386ba80e779a92ec3bb64ccadbedd88f779b1",
      "https://git.kernel.org/stable/c/cea234bb214b17d004dfdccce4491e6ff57c96ee",
      "https://git.kernel.org/stable/c/3678cf67ff7136db1dd3bf63c361650db5d92889",
      "https://git.kernel.org/stable/c/d4c34782b6d7b1e68d18d9549451b19433bd4c6c",
      "https://git.kernel.org/stable/c/e293c773c13b830cdc251f155df2254981abc320",
      "https://git.kernel.org/stable/c/f4ff08fab66eb5c0b97e1a24edac052fb40bf5d7",
      "https://git.kernel.org/stable/c/f23a4d6e07570826fe95023ca1aa96a011fa9f84"
    ],
    "受影响版本": [
      "88c3d3bb6469cea929ac68fd326bdcbefcdfdd83",
      "68c665bb185037e7eb66fb792c61da9d7151e99c",
      "2a764d55e938743efa7c2cba7305633bcf227f09",
      "7e0ae8667fcdd99d1756922e1140cac75f5fa279",
      "be03df3d4bfe7e8866d4aa43d62e648ffe884f5f",
      "be03df3d4bfe7e8866d4aa43d62e648ffe884f5f",
      "be03df3d4bfe7e8866d4aa43d62e648ffe884f5f",
      "be03df3d4bfe7e8866d4aa43d62e648ffe884f5f",
      "73f030d4ef6d1ad17f824a0a2eb637ef7a9c7d51"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26926",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbinder: check offset alignment in binder_get_object()\n\nCommit 6d98eb95b450 (\"binder: avoid potential data leakage when copying\ntxn\") introduced changes to how binder objects are copied. In doing so,\nit unintentionally removed an offset alignment check done through calls\nto binder_alloc_copy_from_buffer() -> check_buffer().\n\nThese calls were replaced in binder_get_object() with copy_from_user(),\nso now an explicit offset alignment check is needed here. This avoids\nlater complications when unwinding the objects gets harder.\n\nIt is worth noting this check existed prior to commit 7a67a39320df\n(\"binder: add function to copy binder object from buffer\"), likely\nremoved due to redundancy at the time.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/68a28f551e4690db2b27b3db716c7395f6fada12",
      "https://git.kernel.org/stable/c/48a1f83ca9c68518b1a783c62e6a8223144fa9fc",
      "https://git.kernel.org/stable/c/a2fd6dbc98be1105a1d8e9e31575da8873ef115c",
      "https://git.kernel.org/stable/c/a6d2a8b211c874971ee4cf3ddd167408177f6e76",
      "https://git.kernel.org/stable/c/1d7f1049035b2060342f11eff957cf567d810bdc",
      "https://git.kernel.org/stable/c/f01d6619045704d78613b14e2e0420bfdb7f1c15",
      "https://git.kernel.org/stable/c/aaef73821a3b0194a01bd23ca77774f704a04d40"
    ],
    "受影响版本": [
      "c056a6ba35e00ae943e377eb09abd77a6915b31a",
      "23e9d815fad84c1bee3742a8de4bd39510435362",
      "7a9ad4aceb0226b391c9d3b8e4ac2e7d438b6bde",
      "6d98eb95b450a75adb4516a1d33652dc78d2b20c",
      "6d98eb95b450a75adb4516a1d33652dc78d2b20c",
      "6d98eb95b450a75adb4516a1d33652dc78d2b20c",
      "6d98eb95b450a75adb4516a1d33652dc78d2b20c",
      "66e12f5b3a9733f941893a00753b10498724607d"
    ],
    "公开日期": "2024年04月24日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26907",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/mlx5: Fix fortify source warning while accessing Eth segment\n\n ------------[ cut here ]------------\n memcpy: detected field-spanning write (size 56) of single field \"eseg->inline_hdr.start\" at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 (size 2)\n WARNING: CPU: 0 PID: 293779 at /var/lib/dkms/mlnx-ofed-kernel/5.8/build/drivers/infiniband/hw/mlx5/wr.c:131 mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n Modules linked in: 8021q garp mrp stp llc rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) ib_uverbs(OE) ib_core(OE) mlx5_core(OE) pci_hyperv_intf mlxdevm(OE) mlx_compat(OE) tls mlxfw(OE) psample nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink mst_pciconf(OE) knem(OE) vfio_pci vfio_pci_core vfio_iommu_type1 vfio iommufd irqbypass cuse nfsv3 nfs fscache netfs xfrm_user xfrm_algo ipmi_devintf ipmi_msghandler binfmt_misc crct10dif_pclmul crc32_pclmul polyval_clmulni polyval_generic ghash_clmulni_intel sha512_ssse3 snd_pcsp aesni_intel crypto_simd cryptd snd_pcm snd_timer joydev snd soundcore input_leds serio_raw evbug nfsd auth_rpcgss nfs_acl lockd grace sch_fq_codel sunrpc drm efi_pstore ip_tables x_tables autofs4 psmouse virtio_net net_failover failover floppy\n  [last unloaded: mlx_compat(OE)]\n CPU: 0 PID: 293779 Comm: ssh Tainted: G           OE      6.2.0-32-generic #32~22.04.1-Ubuntu\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n RIP: 0010:mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n Code: 0c 01 00 a8 01 75 25 48 8b 75 a0 b9 02 00 00 00 48 c7 c2 10 5b fd c0 48 c7 c7 80 5b fd c0 c6 05 57 0c 03 00 01 e8 95 4d 93 da <0f> 0b 44 8b 4d b0 4c 8b 45 c8 48 8b 4d c0 e9 49 fb ff ff 41 0f b7\n RSP: 0018:ffffb5b48478b570 EFLAGS: 00010046\n RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n RBP: ffffb5b48478b628 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000000 R12: ffffb5b48478b5e8\n R13: ffff963a3c609b5e R14: ffff9639c3fbd800 R15: ffffb5b480475a80\n FS:  00007fc03b444c80(0000) GS:ffff963a3dc00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000556f46bdf000 CR3: 0000000006ac6003 CR4: 00000000003706f0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <TASK>\n  ? show_regs+0x72/0x90\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  ? __warn+0x8d/0x160\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  ? report_bug+0x1bb/0x1d0\n  ? handle_bug+0x46/0x90\n  ? exc_invalid_op+0x19/0x80\n  ? asm_exc_invalid_op+0x1b/0x20\n  ? mlx5_ib_post_send+0x191b/0x1a60 [mlx5_ib]\n  mlx5_ib_post_send_nodrain+0xb/0x20 [mlx5_ib]\n  ipoib_send+0x2ec/0x770 [ib_ipoib]\n  ipoib_start_xmit+0x5a0/0x770 [ib_ipoib]\n  dev_hard_start_xmit+0x8e/0x1e0\n  ? validate_xmit_skb_list+0x4d/0x80\n  sch_direct_xmit+0x116/0x3a0\n  __dev_xmit_skb+0x1fd/0x580\n  __dev_queue_xmit+0x284/0x6b0\n  ? _raw_spin_unlock_irq+0xe/0x50\n  ? __flush_work.isra.0+0x20d/0x370\n  ? push_pseudo_header+0x17/0x40 [ib_ipoib]\n  neigh_connected_output+0xcd/0x110\n  ip_finish_output2+0x179/0x480\n  ? __smp_call_single_queue+0x61/0xa0\n  __ip_finish_output+0xc3/0x190\n  ip_finish_output+0x2e/0xf0\n  ip_output+0x78/0x110\n  ? __pfx_ip_finish_output+0x10/0x10\n  ip_local_out+0x64/0x70\n  __ip_queue_xmit+0x18a/0x460\n  ip_queue_xmit+0x15/0x30\n  __tcp_transmit_skb+0x914/0x9c0\n  tcp_write_xmit+0x334/0x8d0\n  tcp_push_one+0x3c/0x60\n  tcp_sendmsg_locked+0x2e1/0xac0\n  tcp_sendmsg+0x2d/0x50\n  inet_sendmsg+0x43/0x90\n  sock_sendmsg+0x68/0x80\n  sock_write_iter+0x93/0x100\n  vfs_write+0x326/0x3c0\n  ksys_write+0xbd/0xf0\n  ? do_syscall_64+0x69/0x90\n  __x64_sys_write+0x19/0x30\n  do_syscall_\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d27c48dc309da72c3b46351a1205d89687272baa",
      "https://git.kernel.org/stable/c/60ba938a8bc8c90e724c75f98e932f9fb7ae1b9d",
      "https://git.kernel.org/stable/c/cad82f1671e41094acd3b9a60cd27d67a3c64a21",
      "https://git.kernel.org/stable/c/9a624a5f95733bac4648ecadb320ca83aa9c08fd",
      "https://git.kernel.org/stable/c/185fa07000e0a81d54cf8c05414cebff14469a5c",
      "https://git.kernel.org/stable/c/4d5e86a56615cc387d21c629f9af8fb0e958d350"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年04月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26880",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm: call the resume method on internal suspend\n\nThere is this reported crash when experimenting with the lvm2 testsuite.\nThe list corruption is caused by the fact that the postsuspend and resume\nmethods were not paired correctly; there were two consecutive calls to the\norigin_postsuspend function. The second call attempts to remove the\n\"hash_list\" entry from a list, while it was already removed by the first\ncall.\n\nFix __dm_internal_resume so that it calls the preresume and resume\nmethods of the table's targets.\n\nIf a preresume method of some target fails, we are in a tricky situation.\nWe can't return an error because dm_internal_resume isn't supposed to\nreturn errors. We can't return success, because then the \"resume\" and\n\"postsuspend\" methods would not be paired correctly. So, we set the\nDMF_SUSPENDED flag and we fake normal suspend - it may confuse userspace\ntools, but it won't cause a kernel crash.\n\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:56!\ninvalid opcode: 0000 [#1] PREEMPT SMP\nCPU: 1 PID: 8343 Comm: dmsetup Not tainted 6.8.0-rc6 #4\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014\nRIP: 0010:__list_del_entry_valid_or_report+0x77/0xc0\n<snip>\nRSP: 0018:ffff8881b831bcc0 EFLAGS: 00010282\nRAX: 000000000000004e RBX: ffff888143b6eb80 RCX: 0000000000000000\nRDX: 0000000000000001 RSI: ffffffff819053d0 RDI: 00000000ffffffff\nRBP: ffff8881b83a3400 R08: 00000000fffeffff R09: 0000000000000058\nR10: 0000000000000000 R11: ffffffff81a24080 R12: 0000000000000001\nR13: ffff88814538e000 R14: ffff888143bc6dc0 R15: ffffffffa02e4bb0\nFS:  00000000f7c0f780(0000) GS:ffff8893f0a40000(0000) knlGS:0000000000000000\nCS:  0010 DS: 002b ES: 002b CR0: 0000000080050033\nCR2: 0000000057fb5000 CR3: 0000000143474000 CR4: 00000000000006b0\nCall Trace:\n <TASK>\n ? die+0x2d/0x80\n ? do_trap+0xeb/0xf0\n ? __list_del_entry_valid_or_report+0x77/0xc0\n ? do_error_trap+0x60/0x80\n ? __list_del_entry_valid_or_report+0x77/0xc0\n ? exc_invalid_op+0x49/0x60\n ? __list_del_entry_valid_or_report+0x77/0xc0\n ? asm_exc_invalid_op+0x16/0x20\n ? table_deps+0x1b0/0x1b0 [dm_mod]\n ? __list_del_entry_valid_or_report+0x77/0xc0\n origin_postsuspend+0x1a/0x50 [dm_snapshot]\n dm_table_postsuspend_targets+0x34/0x50 [dm_mod]\n dm_suspend+0xd8/0xf0 [dm_mod]\n dev_suspend+0x1f2/0x2f0 [dm_mod]\n ? table_deps+0x1b0/0x1b0 [dm_mod]\n ctl_ioctl+0x300/0x5f0 [dm_mod]\n dm_compat_ctl_ioctl+0x7/0x10 [dm_mod]\n __x64_compat_sys_ioctl+0x104/0x170\n do_syscall_64+0x184/0x1b0\n entry_SYSCALL_64_after_hwframe+0x46/0x4e\nRIP: 0033:0xf7e6aead\n<snip>\n---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/69836d9329f0b4c58faaf3d886a7748ddb5bf718",
      "https://git.kernel.org/stable/c/da7ece2197101b1469853e6b5e915be1e3896d52",
      "https://git.kernel.org/stable/c/f89bd27709376d37ff883067193320c58a8c1d5a",
      "https://git.kernel.org/stable/c/03ad5ad53e51abf3a4c7538c1bc67a5982b41dc5",
      "https://git.kernel.org/stable/c/ad10289f68f45649816cc68eb93f45fd5ec48a15",
      "https://git.kernel.org/stable/c/15a3fc5c8774c17589dabfe1d642d40685c985af",
      "https://git.kernel.org/stable/c/ef02d8edf738557af2865c5bfb66a03c4e071be7",
      "https://git.kernel.org/stable/c/360a7d1be8112654f1fb328ed3862be630bca3f4",
      "https://git.kernel.org/stable/c/65e8fbde64520001abf1c8d0e573561b4746ef38"
    ],
    "受影响版本": [
      "ffcc39364160663cda1a3c358f4537302a92459b",
      "ffcc39364160663cda1a3c358f4537302a92459b",
      "ffcc39364160663cda1a3c358f4537302a92459b",
      "ffcc39364160663cda1a3c358f4537302a92459b",
      "ffcc39364160663cda1a3c358f4537302a92459b",
      "ffcc39364160663cda1a3c358f4537302a92459b",
      "ffcc39364160663cda1a3c358f4537302a92459b",
      "ffcc39364160663cda1a3c358f4537302a92459b",
      "ffcc39364160663cda1a3c358f4537302a92459b"
    ],
    "公开日期": "2024年04月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26877",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: xilinx - call finalize with bh disabled\n\nWhen calling crypto_finalize_request, BH should be disabled to avoid\ntriggering the following calltrace:\n\n    ------------[ cut here ]------------\n    WARNING: CPU: 2 PID: 74 at crypto/crypto_engine.c:58 crypto_finalize_request+0xa0/0x118\n    Modules linked in: cryptodev(O)\n    CPU: 2 PID: 74 Comm: firmware:zynqmp Tainted: G           O       6.8.0-rc1-yocto-standard #323\n    Hardware name: ZynqMP ZCU102 Rev1.0 (DT)\n    pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n    pc : crypto_finalize_request+0xa0/0x118\n    lr : crypto_finalize_request+0x104/0x118\n    sp : ffffffc085353ce0\n    x29: ffffffc085353ce0 x28: 0000000000000000 x27: ffffff8808ea8688\n    x26: ffffffc081715038 x25: 0000000000000000 x24: ffffff880100db00\n    x23: ffffff880100da80 x22: 0000000000000000 x21: 0000000000000000\n    x20: ffffff8805b14000 x19: ffffff880100da80 x18: 0000000000010450\n    x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n    x14: 0000000000000003 x13: 0000000000000000 x12: ffffff880100dad0\n    x11: 0000000000000000 x10: ffffffc0832dcd08 x9 : ffffffc0812416d8\n    x8 : 00000000000001f4 x7 : ffffffc0830d2830 x6 : 0000000000000001\n    x5 : ffffffc082091000 x4 : ffffffc082091658 x3 : 0000000000000000\n    x2 : ffffffc7f9653000 x1 : 0000000000000000 x0 : ffffff8802d20000\n    Call trace:\n     crypto_finalize_request+0xa0/0x118\n     crypto_finalize_aead_request+0x18/0x30\n     zynqmp_handle_aes_req+0xcc/0x388\n     crypto_pump_work+0x168/0x2d8\n     kthread_worker_fn+0xfc/0x3a0\n     kthread+0x118/0x138\n     ret_from_fork+0x10/0x20\n    irq event stamp: 40\n    hardirqs last  enabled at (39): [<ffffffc0812416f8>] _raw_spin_unlock_irqrestore+0x70/0xb0\n    hardirqs last disabled at (40): [<ffffffc08122d208>] el1_dbg+0x28/0x90\n    softirqs last  enabled at (36): [<ffffffc080017dec>] kernel_neon_begin+0x8c/0xf0\n    softirqs last disabled at (34): [<ffffffc080017dc0>] kernel_neon_begin+0x60/0xf0\n    ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8a01335aedc50a66d04dd39203c89f4bc8042596",
      "https://git.kernel.org/stable/c/03e6d4e948432a61b35783323b6ab2be071d2619",
      "https://git.kernel.org/stable/c/a71f66bd5f7b9b35a8aaa49e29565eca66299399",
      "https://git.kernel.org/stable/c/23bc89fdce71124cd2126fc919c7076e7cb489cf",
      "https://git.kernel.org/stable/c/9db89b1fb85557892e6681724b367287de5f9f20",
      "https://git.kernel.org/stable/c/dbf291d8ffffb70f48286176a15c6c54f0bb0743",
      "https://git.kernel.org/stable/c/a853450bf4c752e664abab0b2fad395b7ad7701c"
    ],
    "受影响版本": [
      "4d96f7d48131fefe30d7c1d1e2a23ef37164dbf5",
      "4d96f7d48131fefe30d7c1d1e2a23ef37164dbf5",
      "4d96f7d48131fefe30d7c1d1e2a23ef37164dbf5",
      "4d96f7d48131fefe30d7c1d1e2a23ef37164dbf5",
      "4d96f7d48131fefe30d7c1d1e2a23ef37164dbf5",
      "4d96f7d48131fefe30d7c1d1e2a23ef37164dbf5",
      "4d96f7d48131fefe30d7c1d1e2a23ef37164dbf5"
    ],
    "公开日期": "2024年04月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26865",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nrds: tcp: Fix use-after-free of net in reqsk_timer_handler().\n\nsyzkaller reported a warning of netns tracker [0] followed by KASAN\nsplat [1] and another ref tracker warning [1].\n\nsyzkaller could not find a repro, but in the log, the only suspicious\nsequence was as follows:\n\n  18:26:22 executing program 1:\n  r0 = socket$inet6_mptcp(0xa, 0x1, 0x106)\n  ...\n  connect$inet6(r0, &(0x7f0000000080)={0xa, 0x4001, 0x0, @loopback}, 0x1c) (async)\n\nThe notable thing here is 0x4001 in connect(), which is RDS_TCP_PORT.\n\nSo, the scenario would be:\n\n  1. unshare(CLONE_NEWNET) creates a per netns tcp listener in\n      rds_tcp_listen_init().\n  2. syz-executor connect()s to it and creates a reqsk.\n  3. syz-executor exit()s immediately.\n  4. netns is dismantled.  [0]\n  5. reqsk timer is fired, and UAF happens while freeing reqsk.  [1]\n  6. listener is freed after RCU grace period.  [2]\n\nBasically, reqsk assumes that the listener guarantees netns safety\nuntil all reqsk timers are expired by holding the listener's refcount.\nHowever, this was not the case for kernel sockets.\n\nCommit 740ea3c4a0b2 (\"tcp: Clean up kernel listener's reqsk in\ninet_twsk_purge()\") fixed this issue only for per-netns ehash.\n\nLet's apply the same fix for the global ehash.\n\n[0]:\nref_tracker: net notrefcnt@0000000065449cc3 has 1/1 users at\n     sk_alloc (./include/net/net_namespace.h:337 net/core/sock.c:2146)\n     inet6_create (net/ipv6/af_inet6.c:192 net/ipv6/af_inet6.c:119)\n     __sock_create (net/socket.c:1572)\n     rds_tcp_listen_init (net/rds/tcp_listen.c:279)\n     rds_tcp_init_net (net/rds/tcp.c:577)\n     ops_init (net/core/net_namespace.c:137)\n     setup_net (net/core/net_namespace.c:340)\n     copy_net_ns (net/core/net_namespace.c:497)\n     create_new_namespaces (kernel/nsproxy.c:110)\n     unshare_nsproxy_namespaces (kernel/nsproxy.c:228 (discriminator 4))\n     ksys_unshare (kernel/fork.c:3429)\n     __x64_sys_unshare (kernel/fork.c:3496)\n     do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83)\n     entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:129)\n...\nWARNING: CPU: 0 PID: 27 at lib/ref_tracker.c:179 ref_tracker_dir_exit (lib/ref_tracker.c:179)\n\n[1]:\nBUG: KASAN: slab-use-after-free in inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966)\nRead of size 8 at addr ffff88801b370400 by task swapper/0/0\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nCall Trace:\n <IRQ>\n dump_stack_lvl (lib/dump_stack.c:107 (discriminator 1))\n print_report (mm/kasan/report.c:378 mm/kasan/report.c:488)\n kasan_report (mm/kasan/report.c:603)\n inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966)\n reqsk_timer_handler (net/ipv4/inet_connection_sock.c:979 net/ipv4/inet_connection_sock.c:1092)\n call_timer_fn (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/timer.h:127 kernel/time/timer.c:1701)\n __run_timers.part.0 (kernel/time/timer.c:1752 kernel/time/timer.c:2038)\n run_timer_softirq (kernel/time/timer.c:2053)\n __do_softirq (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/irq.h:142 kernel/softirq.c:554)\n irq_exit_rcu (kernel/softirq.c:427 kernel/softirq.c:632 kernel/softirq.c:644)\n sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1076 (discriminator 14))\n </IRQ>\n\nAllocated by task 258 on cpu 0 at 83.612050s:\n kasan_save_stack (mm/kasan/common.c:48)\n kasan_save_track (mm/kasan/common.c:68)\n __kasan_slab_alloc (mm/kasan/common.c:343)\n kmem_cache_alloc (mm/slub.c:3813 mm/slub.c:3860 mm/slub.c:3867)\n copy_net_ns (./include/linux/slab.h:701 net/core/net_namespace.c:421 net/core/net_namespace.c:480)\n create_new_namespaces (kernel/nsproxy.c:110)\n unshare_nsproxy_name\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9905a157048f441f1412e7bd13372f4a971d75c6",
      "https://git.kernel.org/stable/c/f901ee07853ce97e9f1104c7c898fbbe447f0279",
      "https://git.kernel.org/stable/c/9ceac040506a05a30b104b2aa2e9146810704500",
      "https://git.kernel.org/stable/c/1e9fd5cf8d7f487332560f7bb312fc7d416817f3",
      "https://git.kernel.org/stable/c/2a750d6a5b365265dbda33330a6188547ddb5c24"
    ],
    "受影响版本": [
      "467fa15356acfb7b2efa38839c3e76caa4e6e0ea",
      "467fa15356acfb7b2efa38839c3e76caa4e6e0ea",
      "467fa15356acfb7b2efa38839c3e76caa4e6e0ea",
      "467fa15356acfb7b2efa38839c3e76caa4e6e0ea",
      "467fa15356acfb7b2efa38839c3e76caa4e6e0ea"
    ],
    "公开日期": "2024年04月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26854",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: fix uninitialized dplls mutex usage\n\nThe pf->dplls.lock mutex is initialized too late, after its first use.\nMove it to the top of ice_dpll_init.\nNote that the \"err_exit\" error path destroys the mutex. And the mutex is\nthe last thing destroyed in ice_dpll_deinit.\nThis fixes the following warning with CONFIG_DEBUG_MUTEXES:\n\n ice 0000:10:00.0: The DDP package was successfully loaded: ICE OS Default Package version 1.3.36.0\n ice 0000:10:00.0: 252.048 Gb/s available PCIe bandwidth (16.0 GT/s PCIe x16 link)\n ice 0000:10:00.0: PTP init successful\n ------------[ cut here ]------------\n DEBUG_LOCKS_WARN_ON(lock->magic != lock)\n WARNING: CPU: 0 PID: 410 at kernel/locking/mutex.c:587 __mutex_lock+0x773/0xd40\n Modules linked in: crct10dif_pclmul crc32_pclmul crc32c_intel polyval_clmulni polyval_generic ice(+) nvme nvme_c>\n CPU: 0 PID: 410 Comm: kworker/0:4 Not tainted 6.8.0-rc5+ #3\n Hardware name: HPE ProLiant DL110 Gen10 Plus/ProLiant DL110 Gen10 Plus, BIOS U56 10/19/2023\n Workqueue: events work_for_cpu_fn\n RIP: 0010:__mutex_lock+0x773/0xd40\n Code: c0 0f 84 1d f9 ff ff 44 8b 35 0d 9c 69 01 45 85 f6 0f 85 0d f9 ff ff 48 c7 c6 12 a2 a9 85 48 c7 c7 12 f1 a>\n RSP: 0018:ff7eb1a3417a7ae0 EFLAGS: 00010286\n RAX: 0000000000000000 RBX: 0000000000000002 RCX: 0000000000000000\n RDX: 0000000000000002 RSI: ffffffff85ac2bff RDI: 00000000ffffffff\n RBP: ff7eb1a3417a7b80 R08: 0000000000000000 R09: 00000000ffffbfff\n R10: ff7eb1a3417a7978 R11: ff32b80f7fd2e568 R12: 0000000000000000\n R13: 0000000000000000 R14: 0000000000000000 R15: ff32b7f02c50e0d8\n FS:  0000000000000000(0000) GS:ff32b80efe800000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000055b5852cc000 CR3: 000000003c43a004 CR4: 0000000000771ef0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n PKRU: 55555554\n Call Trace:\n  <TASK>\n  ? __warn+0x84/0x170\n  ? __mutex_lock+0x773/0xd40\n  ? report_bug+0x1c7/0x1d0\n  ? prb_read_valid+0x1b/0x30\n  ? handle_bug+0x42/0x70\n  ? exc_invalid_op+0x18/0x70\n  ? asm_exc_invalid_op+0x1a/0x20\n  ? __mutex_lock+0x773/0xd40\n  ? rcu_is_watching+0x11/0x50\n  ? __kmalloc_node_track_caller+0x346/0x490\n  ? ice_dpll_lock_status_get+0x28/0x50 [ice]\n  ? __pfx_ice_dpll_lock_status_get+0x10/0x10 [ice]\n  ? ice_dpll_lock_status_get+0x28/0x50 [ice]\n  ice_dpll_lock_status_get+0x28/0x50 [ice]\n  dpll_device_get_one+0x14f/0x2e0\n  dpll_device_event_send+0x7d/0x150\n  dpll_device_register+0x124/0x180\n  ice_dpll_init_dpll+0x7b/0xd0 [ice]\n  ice_dpll_init+0x224/0xa40 [ice]\n  ? _dev_info+0x70/0x90\n  ice_load+0x468/0x690 [ice]\n  ice_probe+0x75b/0xa10 [ice]\n  ? _raw_spin_unlock_irqrestore+0x4f/0x80\n  ? process_one_work+0x1a3/0x500\n  local_pci_probe+0x47/0xa0\n  work_for_cpu_fn+0x17/0x30\n  process_one_work+0x20d/0x500\n  worker_thread+0x1df/0x3e0\n  ? __pfx_worker_thread+0x10/0x10\n  kthread+0x103/0x140\n  ? __pfx_kthread+0x10/0x10\n  ret_from_fork+0x31/0x50\n  ? __pfx_kthread+0x10/0x10\n  ret_from_fork_asm+0x1b/0x30\n  </TASK>\n irq event stamp: 125197\n hardirqs last  enabled at (125197): [<ffffffff8416409d>] finish_task_switch.isra.0+0x12d/0x3d0\n hardirqs last disabled at (125196): [<ffffffff85134044>] __schedule+0xea4/0x19f0\n softirqs last  enabled at (105334): [<ffffffff84e1e65a>] napi_get_frags_check+0x1a/0x60\n softirqs last disabled at (105332): [<ffffffff84e1e65a>] napi_get_frags_check+0x1a/0x60\n ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/db29ceff3e25c48907016da456a7cbee6310fd83",
      "https://git.kernel.org/stable/c/9224fc86f1776193650a33a275cac628952f80a9"
    ],
    "受影响版本": [
      "d7999f5ea64bb10d2857b8cbfe973be373bac7c9",
      "d7999f5ea64bb10d2857b8cbfe973be373bac7c9"
    ],
    "公开日期": "2024年04月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26831",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/handshake: Fix handshake_req_destroy_test1\n\nRecently, handshake_req_destroy_test1 started failing:\n\nExpected handshake_req_destroy_test == req, but\n    handshake_req_destroy_test == 0000000000000000\n    req == 0000000060f99b40\nnot ok 11 req_destroy works\n\nThis is because \"sock_release(sock)\" was replaced with \"fput(filp)\"\nto address a memory leak. Note that sock_release() is synchronous\nbut fput() usually delays the final close and clean-up.\n\nThe delay is not consequential in the other cases that were changed\nbut handshake_req_destroy_test1 is testing that handshake_req_cancel()\nfollowed by closing the file actually does call the ->hp_destroy\nmethod. Thus the PTR_EQ test at the end has to be sure that the\nfinal close is complete before it checks the pointer.\n\nWe cannot use a completion here because if ->hp_destroy is never\ncalled (ie, there is an API bug) then the test will hang.\n\nReported by: Guenter Roeck <linux@roeck-us.net>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d74226e03df1bf19848f18344401f254345af912",
      "https://git.kernel.org/stable/c/7f97805b8df6e33850e225e6bd3ebd9e246920af",
      "https://git.kernel.org/stable/c/4e1d71cabb19ec2586827adfc60d68689c68c194"
    ],
    "受影响版本": [
      "4a0f07d71b0483cc08c03cefa7c85749e187c214",
      "4a0f07d71b0483cc08c03cefa7c85749e187c214",
      "4a0f07d71b0483cc08c03cefa7c85749e187c214",
      "1751e44980466e3ebc246d22d3ebd422197704b6"
    ],
    "公开日期": "2024年04月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26812",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvfio/pci: Create persistent INTx handler\n\nA vulnerability exists where the eventfd for INTx signaling can be\ndeconfigured, which unregisters the IRQ handler but still allows\neventfds to be signaled with a NULL context through the SET_IRQS ioctl\nor through unmask irqfd if the device interrupt is pending.\n\nIdeally this could be solved with some additional locking; the igate\nmutex serializes the ioctl and config space accesses, and the interrupt\nhandler is unregistered relative to the trigger, but the irqfd path\nruns asynchronous to those.  The igate mutex cannot be acquired from the\natomic context of the eventfd wake function.  Disabling the irqfd\nrelative to the eventfd registration is potentially incompatible with\nexisting userspace.\n\nAs a result, the solution implemented here moves configuration of the\nINTx interrupt handler to track the lifetime of the INTx context object\nand irq_type configuration, rather than registration of a particular\ntrigger eventfd.  Synchronization is added between the ioctl path and\neventfd_signal() wrapper such that the eventfd trigger can be\ndynamically updated relative to in-flight interrupts or irqfd callbacks.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b18fa894d615c8527e15d96b76c7448800e13899",
      "https://git.kernel.org/stable/c/27d40bf72dd9a6600b76ad05859176ea9a1b4897",
      "https://git.kernel.org/stable/c/4cb0d7532126d23145329826c38054b4e9a05e7c",
      "https://git.kernel.org/stable/c/7d29d4c72c1e196cce6969c98072a272d1a703b3",
      "https://git.kernel.org/stable/c/69276a555c740acfbff13fb5769ee9c92e1c828e",
      "https://git.kernel.org/stable/c/4c089cefe30924fbe20dd1ee92774ea1f5eca834",
      "https://git.kernel.org/stable/c/0e09cf81959d9f12b75ad5c6dd53d237432ed034",
      "https://git.kernel.org/stable/c/18c198c96a815c962adc2b9b77909eec0be7df4d"
    ],
    "受影响版本": [
      "89e1f7d4c66d85f42c3d52ea3866eb10cadf6153",
      "89e1f7d4c66d85f42c3d52ea3866eb10cadf6153",
      "89e1f7d4c66d85f42c3d52ea3866eb10cadf6153",
      "89e1f7d4c66d85f42c3d52ea3866eb10cadf6153",
      "89e1f7d4c66d85f42c3d52ea3866eb10cadf6153",
      "89e1f7d4c66d85f42c3d52ea3866eb10cadf6153",
      "89e1f7d4c66d85f42c3d52ea3866eb10cadf6153",
      "89e1f7d4c66d85f42c3d52ea3866eb10cadf6153"
    ],
    "公开日期": "2024年04月05日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26806",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: cadence-qspi: remove system-wide suspend helper calls from runtime PM hooks\n\nThe ->runtime_suspend() and ->runtime_resume() callbacks are not\nexpected to call spi_controller_suspend() and spi_controller_resume().\nRemove calls to those in the cadence-qspi driver.\n\nThose helpers have two roles currently:\n - They stop/start the queue, including dealing with the kworker.\n - They toggle the SPI controller SPI_CONTROLLER_SUSPENDED flag. It\n   requires acquiring ctlr->bus_lock_mutex.\n\nStep one is irrelevant because cadence-qspi is not queued. Step two\nhowever has two implications:\n - A deadlock occurs, because ->runtime_resume() is called in a context\n   where the lock is already taken (in the ->exec_op() callback, where\n   the usage count is incremented).\n - It would disallow all operations once the device is auto-suspended.\n\nHere is a brief call tree highlighting the mutex deadlock:\n\nspi_mem_exec_op()\n        ...\n        spi_mem_access_start()\n                mutex_lock(&ctlr->bus_lock_mutex)\n\n        cqspi_exec_mem_op()\n                pm_runtime_resume_and_get()\n                        cqspi_resume()\n                                spi_controller_resume()\n                                        mutex_lock(&ctlr->bus_lock_mutex)\n                ...\n\n        spi_mem_access_end()\n                mutex_unlock(&ctlr->bus_lock_mutex)\n        ...",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/041562ebc4759c9932b59a06527f8753b86da365",
      "https://git.kernel.org/stable/c/959043afe53ae80633e810416cee6076da6e91c6"
    ],
    "受影响版本": [
      "0578a6dbfe7514db7134501cf93acc21cf13e479",
      "0578a6dbfe7514db7134501cf93acc21cf13e479"
    ],
    "公开日期": "2024年04月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26802",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nstmmac: Clear variable when destroying workqueue\n\nCurrently when suspending driver and stopping workqueue it is checked whether\nworkqueue is not NULL and if so, it is destroyed.\nFunction destroy_workqueue() does drain queue and does clear variable, but\nit does not set workqueue variable to NULL. This can cause kernel/module\npanic if code attempts to clear workqueue that was not initialized.\n\nThis scenario is possible when resuming suspended driver in stmmac_resume(),\nbecause there is no handling for failed stmmac_hw_setup(),\nwhich can fail and return if DMA engine has failed to initialize,\nand workqueue is initialized after DMA engine.\nShould DMA engine fail to initialize, resume will proceed normally,\nbut interface won't work and TX queue will eventually timeout,\ncausing 'Reset adapter' error.\nThis then does destroy workqueue during reset process.\nAnd since workqueue is initialized after DMA engine and can be skipped,\nit will cause kernel/module panic.\n\nTo secure against this possible crash, set workqueue variable to NULL when\ndestroying workqueue.\n\nLog/backtrace from crash goes as follows:\n[88.031977]------------[ cut here ]------------\n[88.031985]NETDEV WATCHDOG: eth0 (sxgmac): transmit queue 1 timed out\n[88.032017]WARNING: CPU: 0 PID: 0 at net/sched/sch_generic.c:477 dev_watchdog+0x390/0x398\n           <Skipping backtrace for watchdog timeout>\n[88.032251]---[ end trace e70de432e4d5c2c0 ]---\n[88.032282]sxgmac 16d88000.ethernet eth0: Reset adapter.\n[88.036359]------------[ cut here ]------------\n[88.036519]Call trace:\n[88.036523] flush_workqueue+0x3e4/0x430\n[88.036528] drain_workqueue+0xc4/0x160\n[88.036533] destroy_workqueue+0x40/0x270\n[88.036537] stmmac_fpe_stop_wq+0x4c/0x70\n[88.036541] stmmac_release+0x278/0x280\n[88.036546] __dev_close_many+0xcc/0x158\n[88.036551] dev_close_many+0xbc/0x190\n[88.036555] dev_close.part.0+0x70/0xc0\n[88.036560] dev_close+0x24/0x30\n[88.036564] stmmac_service_task+0x110/0x140\n[88.036569] process_one_work+0x1d8/0x4a0\n[88.036573] worker_thread+0x54/0x408\n[88.036578] kthread+0x164/0x170\n[88.036583] ret_from_fork+0x10/0x20\n[88.036588]---[ end trace e70de432e4d5c2c1 ]---\n[88.036597]Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8e99556301172465c8fe33c7f78c39a3d4ce8462",
      "https://git.kernel.org/stable/c/17ccd9798fe0beda3db212cfa3ebe373f605cbd6",
      "https://git.kernel.org/stable/c/699b103e48ce32d03fc86c35b37ee8ae4288c7e3",
      "https://git.kernel.org/stable/c/f72cf22dccc94038cbbaa1029cb575bf52e5cbc8",
      "https://git.kernel.org/stable/c/8af411bbba1f457c33734795f024d0ef26d0963f"
    ],
    "受影响版本": [
      "5a5586112b929546e16029261a987c9197bfdfa2",
      "5a5586112b929546e16029261a987c9197bfdfa2",
      "5a5586112b929546e16029261a987c9197bfdfa2",
      "5a5586112b929546e16029261a987c9197bfdfa2",
      "5a5586112b929546e16029261a987c9197bfdfa2"
    ],
    "公开日期": "2024年04月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26801",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Avoid potential use-after-free in hci_error_reset\n\nWhile handling the HCI_EV_HARDWARE_ERROR event, if the underlying\nBT controller is not responding, the GPIO reset mechanism would\nfree the hci_dev and lead to a use-after-free in hci_error_reset.\n\nHere's the call trace observed on a ChromeOS device with Intel AX201:\n   queue_work_on+0x3e/0x6c\n   __hci_cmd_sync_sk+0x2ee/0x4c0 [bluetooth <HASH:3b4a6>]\n   ? init_wait_entry+0x31/0x31\n   __hci_cmd_sync+0x16/0x20 [bluetooth <HASH:3b4a 6>]\n   hci_error_reset+0x4f/0xa4 [bluetooth <HASH:3b4a 6>]\n   process_one_work+0x1d8/0x33f\n   worker_thread+0x21b/0x373\n   kthread+0x13a/0x152\n   ? pr_cont_work+0x54/0x54\n   ? kthread_blkcg+0x31/0x31\n    ret_from_fork+0x1f/0x30\n\nThis patch holds the reference count on the hci_dev while processing\na HCI_EV_HARDWARE_ERROR event to avoid potential crash.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e0b278650f07acf2e0932149183458468a731c03",
      "https://git.kernel.org/stable/c/98fb98fd37e42fd4ce13ff657ea64503e24b6090",
      "https://git.kernel.org/stable/c/6dd0a9dfa99f8990a08eb8fdd8e79bee31c7d8e2",
      "https://git.kernel.org/stable/c/da4569d450b193e39e87119fd316c0291b585d14",
      "https://git.kernel.org/stable/c/45085686b9559bfbe3a4f41d3d695a520668f5e1",
      "https://git.kernel.org/stable/c/2ab9a19d896f5a0dd386e1f001c5309bc35f433b",
      "https://git.kernel.org/stable/c/dd594cdc24f2e48dab441732e6dfcafd6b0711d1",
      "https://git.kernel.org/stable/c/2449007d3f73b2842c9734f45f0aadb522daf592"
    ],
    "受影响版本": [
      "c7741d16a57cbf97eebe53f27e8216b1ff20e20c",
      "c7741d16a57cbf97eebe53f27e8216b1ff20e20c",
      "c7741d16a57cbf97eebe53f27e8216b1ff20e20c",
      "c7741d16a57cbf97eebe53f27e8216b1ff20e20c",
      "c7741d16a57cbf97eebe53f27e8216b1ff20e20c",
      "c7741d16a57cbf97eebe53f27e8216b1ff20e20c",
      "c7741d16a57cbf97eebe53f27e8216b1ff20e20c",
      "c7741d16a57cbf97eebe53f27e8216b1ff20e20c"
    ],
    "公开日期": "2024年04月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26792",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix double free of anonymous device after snapshot creation failure\n\nWhen creating a snapshot we may do a double free of an anonymous device\nin case there's an error committing the transaction. The second free may\nresult in freeing an anonymous device number that was allocated by some\nother subsystem in the kernel or another btrfs filesystem.\n\nThe steps that lead to this:\n\n1) At ioctl.c:create_snapshot() we allocate an anonymous device number\n   and assign it to pending_snapshot->anon_dev;\n\n2) Then we call btrfs_commit_transaction() and end up at\n   transaction.c:create_pending_snapshot();\n\n3) There we call btrfs_get_new_fs_root() and pass it the anonymous device\n   number stored in pending_snapshot->anon_dev;\n\n4) btrfs_get_new_fs_root() frees that anonymous device number because\n   btrfs_lookup_fs_root() returned a root - someone else did a lookup\n   of the new root already, which could some task doing backref walking;\n\n5) After that some error happens in the transaction commit path, and at\n   ioctl.c:create_snapshot() we jump to the 'fail' label, and after\n   that we free again the same anonymous device number, which in the\n   meanwhile may have been reallocated somewhere else, because\n   pending_snapshot->anon_dev still has the same value as in step 1.\n\nRecently syzbot ran into this and reported the following trace:\n\n  ------------[ cut here ]------------\n  ida_free called for id=51 which is not allocated.\n  WARNING: CPU: 1 PID: 31038 at lib/idr.c:525 ida_free+0x370/0x420 lib/idr.c:525\n  Modules linked in:\n  CPU: 1 PID: 31038 Comm: syz-executor.2 Not tainted 6.8.0-rc4-syzkaller-00410-gc02197fc9076 #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024\n  RIP: 0010:ida_free+0x370/0x420 lib/idr.c:525\n  Code: 10 42 80 3c 28 (...)\n  RSP: 0018:ffffc90015a67300 EFLAGS: 00010246\n  RAX: be5130472f5dd000 RBX: 0000000000000033 RCX: 0000000000040000\n  RDX: ffffc90009a7a000 RSI: 000000000003ffff RDI: 0000000000040000\n  RBP: ffffc90015a673f0 R08: ffffffff81577992 R09: 1ffff92002b4cdb4\n  R10: dffffc0000000000 R11: fffff52002b4cdb5 R12: 0000000000000246\n  R13: dffffc0000000000 R14: ffffffff8e256b80 R15: 0000000000000246\n  FS:  00007fca3f4b46c0(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007f167a17b978 CR3: 000000001ed26000 CR4: 0000000000350ef0\n  Call Trace:\n   <TASK>\n   btrfs_get_root_ref+0xa48/0xaf0 fs/btrfs/disk-io.c:1346\n   create_pending_snapshot+0xff2/0x2bc0 fs/btrfs/transaction.c:1837\n   create_pending_snapshots+0x195/0x1d0 fs/btrfs/transaction.c:1931\n   btrfs_commit_transaction+0xf1c/0x3740 fs/btrfs/transaction.c:2404\n   create_snapshot+0x507/0x880 fs/btrfs/ioctl.c:848\n   btrfs_mksubvol+0x5d0/0x750 fs/btrfs/ioctl.c:998\n   btrfs_mksnapshot+0xb5/0xf0 fs/btrfs/ioctl.c:1044\n   __btrfs_ioctl_snap_create+0x387/0x4b0 fs/btrfs/ioctl.c:1306\n   btrfs_ioctl_snap_create_v2+0x1ca/0x400 fs/btrfs/ioctl.c:1393\n   btrfs_ioctl+0xa74/0xd40\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:871 [inline]\n   __se_sys_ioctl+0xfe/0x170 fs/ioctl.c:857\n   do_syscall_64+0xfb/0x240\n   entry_SYSCALL_64_after_hwframe+0x6f/0x77\n  RIP: 0033:0x7fca3e67dda9\n  Code: 28 00 00 00 (...)\n  RSP: 002b:00007fca3f4b40c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n  RAX: ffffffffffffffda RBX: 00007fca3e7abf80 RCX: 00007fca3e67dda9\n  RDX: 00000000200005c0 RSI: 0000000050009417 RDI: 0000000000000003\n  RBP: 00007fca3e6ca47a R08: 0000000000000000 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\n  R13: 000000000000000b R14: 00007fca3e7abf80 R15: 00007fff6bf95658\n   </TASK>\n\nWhere we get an explicit message where we attempt to free an anonymous\ndevice number that is not currently allocated. It happens in a different\ncode path from the example below, at btrfs_get_root_ref(), so this change\nmay not fix the case triggered by sy\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c34adc20b91a8e55e048b18d63f4f4ae003ecf8f",
      "https://git.kernel.org/stable/c/eb3441093aad251418921246fc3b224fd1575701",
      "https://git.kernel.org/stable/c/c8ab7521665bd0f8bc4a900244d1d5a7095cc3b9",
      "https://git.kernel.org/stable/c/e2b54eaf28df0c978626c9736b94f003b523b451"
    ],
    "受影响版本": [
      "66b317a2fc45b2ef66527ee3f8fa08fb5beab88d",
      "833775656d447c545133a744a0ed1e189ce61430",
      "5a172344bfdabb46458e03708735d7b1a918c468",
      "e03ee2fe873eb68c1f9ba5112fee70303ebf9dfb",
      "3f5d47eb163bceb1b9e613c9003bae5fefc0046f",
      "e31546b0f34af21738c4ceac47d662c00ee6382f"
    ],
    "公开日期": "2024年04月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26780",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Fix task hung while purging oob_skb in GC.\n\nsyzbot reported a task hung; at the same time, GC was looping infinitely\nin list_for_each_entry_safe() for OOB skb.  [0]\n\nsyzbot demonstrated that the list_for_each_entry_safe() was not actually\nsafe in this case.\n\nA single skb could have references for multiple sockets.  If we free such\na skb in the list_for_each_entry_safe(), the current and next sockets could\nbe unlinked in a single iteration.\n\nunix_notinflight() uses list_del_init() to unlink the socket, so the\nprefetched next socket forms a loop itself and list_for_each_entry_safe()\nnever stops.\n\nHere, we must use while() and make sure we always fetch the first socket.\n\n[0]:\nSending NMI from CPU 0 to CPUs 1:\nNMI backtrace for cpu 1\nCPU: 1 PID: 5065 Comm: syz-executor236 Not tainted 6.8.0-rc3-syzkaller-00136-g1f719a2f3fa6 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024\nRIP: 0010:preempt_count arch/x86/include/asm/preempt.h:26 [inline]\nRIP: 0010:check_kcov_mode kernel/kcov.c:173 [inline]\nRIP: 0010:__sanitizer_cov_trace_pc+0xd/0x60 kernel/kcov.c:207\nCode: cc cc cc cc 66 0f 1f 84 00 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 65 48 8b 14 25 40 c2 03 00 <65> 8b 05 b4 7c 78 7e a9 00 01 ff 00 48 8b 34 24 74 0f f6 c4 01 74\nRSP: 0018:ffffc900033efa58 EFLAGS: 00000283\nRAX: ffff88807b077800 RBX: ffff88807b077800 RCX: 1ffffffff27b1189\nRDX: ffff88802a5a3b80 RSI: ffffffff8968488d RDI: ffff88807b077f70\nRBP: ffffc900033efbb0 R08: 0000000000000001 R09: fffffbfff27a900c\nR10: ffffffff93d48067 R11: ffffffff8ae000eb R12: ffff88807b077800\nR13: dffffc0000000000 R14: ffff88807b077e40 R15: 0000000000000001\nFS:  0000000000000000(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000564f4fc1e3a8 CR3: 000000000d57a000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <NMI>\n </NMI>\n <TASK>\n unix_gc+0x563/0x13b0 net/unix/garbage.c:319\n unix_release_sock+0xa93/0xf80 net/unix/af_unix.c:683\n unix_release+0x91/0xf0 net/unix/af_unix.c:1064\n __sock_release+0xb0/0x270 net/socket.c:659\n sock_close+0x1c/0x30 net/socket.c:1421\n __fput+0x270/0xb80 fs/file_table.c:376\n task_work_run+0x14f/0x250 kernel/task_work.c:180\n exit_task_work include/linux/task_work.h:38 [inline]\n do_exit+0xa8a/0x2ad0 kernel/exit.c:871\n do_group_exit+0xd4/0x2a0 kernel/exit.c:1020\n __do_sys_exit_group kernel/exit.c:1031 [inline]\n __se_sys_exit_group kernel/exit.c:1029 [inline]\n __x64_sys_exit_group+0x3e/0x50 kernel/exit.c:1029\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xd5/0x270 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x6f/0x77\nRIP: 0033:0x7f9d6cbdac09\nCode: Unable to access opcode bytes at 0x7f9d6cbdabdf.\nRSP: 002b:00007fff5952feb8 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f9d6cbdac09\nRDX: 000000000000003c RSI: 00000000000000e7 RDI: 0000000000000000\nRBP: 00007f9d6cc552b0 R08: ffffffffffffffb8 R09: 0000000000000006\nR10: 0000000000000006 R11: 0000000000000246 R12: 00007f9d6cc552b0\nR13: 0000000000000000 R14: 00007f9d6cc55d00 R15: 00007f9d6cbabe70\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/36f7371de977f805750748e80279be7e370df85c",
      "https://git.kernel.org/stable/c/2a3d40b4025fcfe51b04924979f1653993b17669",
      "https://git.kernel.org/stable/c/69e0f04460f4037e01e29f0d9675544f62aafca3",
      "https://git.kernel.org/stable/c/cb8890318dde26fc89c6ea67d6e9070ab50b6e91",
      "https://git.kernel.org/stable/c/25236c91b5ab4a26a56ba2e79b8060cf4e047839"
    ],
    "受影响版本": [
      "4fe505c63aa3273135a57597fda761e9aecc7668",
      "e0e09186d8821ad59806115d347ea32efa43ca4b",
      "b74aa9ce13d02b7fd37c5325b99854f91b9b4276",
      "82ae47c5c3a6b27fdc0f9e83c1499cb439c56140",
      "1279f9d9dec2d7462823a18c29ad61359e0a007d"
    ],
    "公开日期": "2024年04月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26746",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: idxd: Ensure safe user copy of completion record\n\nIf CONFIG_HARDENED_USERCOPY is enabled, copying completion record from\nevent log cache to user triggers a kernel bug.\n\n[ 1987.159822] usercopy: Kernel memory exposure attempt detected from SLUB object 'dsa0' (offset 74, size 31)!\n[ 1987.170845] ------------[ cut here ]------------\n[ 1987.176086] kernel BUG at mm/usercopy.c:102!\n[ 1987.180946] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n[ 1987.186866] CPU: 17 PID: 528 Comm: kworker/17:1 Not tainted 6.8.0-rc2+ #5\n[ 1987.194537] Hardware name: Intel Corporation AvenueCity/AvenueCity, BIOS BHSDCRB1.86B.2492.D03.2307181620 07/18/2023\n[ 1987.206405] Workqueue: wq0.0 idxd_evl_fault_work [idxd]\n[ 1987.212338] RIP: 0010:usercopy_abort+0x72/0x90\n[ 1987.217381] Code: 58 65 9c 50 48 c7 c2 17 85 61 9c 57 48 c7 c7 98 fd 6b 9c 48 0f 44 d6 48 c7 c6 b3 08 62 9c 4c 89 d1 49 0f 44 f3 e8 1e 2e d5 ff <0f> 0b 49 c7 c1 9e 42 61 9c 4c 89 cf 4d 89 c8 eb a9 66 66 2e 0f 1f\n[ 1987.238505] RSP: 0018:ff62f5cf20607d60 EFLAGS: 00010246\n[ 1987.244423] RAX: 000000000000005f RBX: 000000000000001f RCX: 0000000000000000\n[ 1987.252480] RDX: 0000000000000000 RSI: ffffffff9c61429e RDI: 00000000ffffffff\n[ 1987.260538] RBP: ff62f5cf20607d78 R08: ff2a6a89ef3fffe8 R09: 00000000fffeffff\n[ 1987.268595] R10: ff2a6a89eed00000 R11: 0000000000000003 R12: ff2a66934849c89a\n[ 1987.276652] R13: 0000000000000001 R14: ff2a66934849c8b9 R15: ff2a66934849c899\n[ 1987.284710] FS:  0000000000000000(0000) GS:ff2a66b22fe40000(0000) knlGS:0000000000000000\n[ 1987.293850] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 1987.300355] CR2: 00007fe291a37000 CR3: 000000010fbd4005 CR4: 0000000000f71ef0\n[ 1987.308413] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 1987.316470] DR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400\n[ 1987.324527] PKRU: 55555554\n[ 1987.327622] Call Trace:\n[ 1987.330424]  <TASK>\n[ 1987.332826]  ? show_regs+0x6e/0x80\n[ 1987.336703]  ? die+0x3c/0xa0\n[ 1987.339988]  ? do_trap+0xd4/0xf0\n[ 1987.343662]  ? do_error_trap+0x75/0xa0\n[ 1987.347922]  ? usercopy_abort+0x72/0x90\n[ 1987.352277]  ? exc_invalid_op+0x57/0x80\n[ 1987.356634]  ? usercopy_abort+0x72/0x90\n[ 1987.360988]  ? asm_exc_invalid_op+0x1f/0x30\n[ 1987.365734]  ? usercopy_abort+0x72/0x90\n[ 1987.370088]  __check_heap_object+0xb7/0xd0\n[ 1987.374739]  __check_object_size+0x175/0x2d0\n[ 1987.379588]  idxd_copy_cr+0xa9/0x130 [idxd]\n[ 1987.384341]  idxd_evl_fault_work+0x127/0x390 [idxd]\n[ 1987.389878]  process_one_work+0x13e/0x300\n[ 1987.394435]  ? __pfx_worker_thread+0x10/0x10\n[ 1987.399284]  worker_thread+0x2f7/0x420\n[ 1987.403544]  ? _raw_spin_unlock_irqrestore+0x2b/0x50\n[ 1987.409171]  ? __pfx_worker_thread+0x10/0x10\n[ 1987.414019]  kthread+0x107/0x140\n[ 1987.417693]  ? __pfx_kthread+0x10/0x10\n[ 1987.421954]  ret_from_fork+0x3d/0x60\n[ 1987.426019]  ? __pfx_kthread+0x10/0x10\n[ 1987.430281]  ret_from_fork_asm+0x1b/0x30\n[ 1987.434744]  </TASK>\n\nThe issue arises because event log cache is created using\nkmem_cache_create() which is not suitable for user copy.\n\nFix the issue by creating event log cache with\nkmem_cache_create_usercopy(), ensuring safe user copy.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5e3022ea42e490a36ec6f2cfa6fc603deb0bace4",
      "https://git.kernel.org/stable/c/bb71e040323175e18c233a9afef32ba14fa64eb7",
      "https://git.kernel.org/stable/c/d3ea125df37dc37972d581b74a5d3785c3f283ab"
    ],
    "受影响版本": [
      "c2f156bf168fb42cd6ecd0a8e2204dbe542b8516",
      "c2f156bf168fb42cd6ecd0a8e2204dbe542b8516",
      "c2f156bf168fb42cd6ecd0a8e2204dbe542b8516"
    ],
    "公开日期": "2024年04月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26743",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/qedr: Fix qedr_create_user_qp error flow\n\nAvoid the following warning by making sure to free the allocated\nresources in case that qedr_init_user_queue() fail.\n\n-----------[ cut here ]-----------\nWARNING: CPU: 0 PID: 143192 at drivers/infiniband/core/rdma_core.c:874 uverbs_destroy_ufile_hw+0xcf/0xf0 [ib_uverbs]\nModules linked in: tls target_core_user uio target_core_pscsi target_core_file target_core_iblock ib_srpt ib_srp scsi_transport_srp nfsd nfs_acl rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache netfs 8021q garp mrp stp llc ext4 mbcache jbd2 opa_vnic ib_umad ib_ipoib sunrpc rdma_ucm ib_isert iscsi_target_mod target_core_mod ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm hfi1 intel_rapl_msr intel_rapl_common mgag200 qedr sb_edac drm_shmem_helper rdmavt x86_pkg_temp_thermal drm_kms_helper intel_powerclamp ib_uverbs coretemp i2c_algo_bit kvm_intel dell_wmi_descriptor ipmi_ssif sparse_keymap kvm ib_core rfkill syscopyarea sysfillrect video sysimgblt irqbypass ipmi_si ipmi_devintf fb_sys_fops rapl iTCO_wdt mxm_wmi iTCO_vendor_support intel_cstate pcspkr dcdbas intel_uncore ipmi_msghandler lpc_ich acpi_power_meter mei_me mei fuse drm xfs libcrc32c qede sd_mod ahci libahci t10_pi sg crct10dif_pclmul crc32_pclmul crc32c_intel qed libata tg3\nghash_clmulni_intel megaraid_sas crc8 wmi [last unloaded: ib_srpt]\nCPU: 0 PID: 143192 Comm: fi_rdm_tagged_p Kdump: loaded Not tainted 5.14.0-408.el9.x86_64 #1\nHardware name: Dell Inc. PowerEdge R430/03XKDV, BIOS 2.14.0 01/25/2022\nRIP: 0010:uverbs_destroy_ufile_hw+0xcf/0xf0 [ib_uverbs]\nCode: 5d 41 5c 41 5d 41 5e e9 0f 26 1b dd 48 89 df e8 67 6a ff ff 49 8b 86 10 01 00 00 48 85 c0 74 9c 4c 89 e7 e8 83 c0 cb dd eb 92 <0f> 0b eb be 0f 0b be 04 00 00 00 48 89 df e8 8e f5 ff ff e9 6d ff\nRSP: 0018:ffffb7c6cadfbc60 EFLAGS: 00010286\nRAX: ffff8f0889ee3f60 RBX: ffff8f088c1a5200 RCX: 00000000802a0016\nRDX: 00000000802a0017 RSI: 0000000000000001 RDI: ffff8f0880042600\nRBP: 0000000000000001 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff8f11fffd5000 R11: 0000000000039000 R12: ffff8f0d5b36cd80\nR13: ffff8f088c1a5250 R14: ffff8f1206d91000 R15: 0000000000000000\nFS: 0000000000000000(0000) GS:ffff8f11d7c00000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000147069200e20 CR3: 00000001c7210002 CR4: 00000000001706f0\nCall Trace:\n<TASK>\n? show_trace_log_lvl+0x1c4/0x2df\n? show_trace_log_lvl+0x1c4/0x2df\n? ib_uverbs_close+0x1f/0xb0 [ib_uverbs]\n? uverbs_destroy_ufile_hw+0xcf/0xf0 [ib_uverbs]\n? __warn+0x81/0x110\n? uverbs_destroy_ufile_hw+0xcf/0xf0 [ib_uverbs]\n? report_bug+0x10a/0x140\n? handle_bug+0x3c/0x70\n? exc_invalid_op+0x14/0x70\n? asm_exc_invalid_op+0x16/0x20\n? uverbs_destroy_ufile_hw+0xcf/0xf0 [ib_uverbs]\nib_uverbs_close+0x1f/0xb0 [ib_uverbs]\n__fput+0x94/0x250\ntask_work_run+0x5c/0x90\ndo_exit+0x270/0x4a0\ndo_group_exit+0x2d/0x90\nget_signal+0x87c/0x8c0\narch_do_signal_or_restart+0x25/0x100\n? ib_uverbs_ioctl+0xc2/0x110 [ib_uverbs]\nexit_to_user_mode_loop+0x9c/0x130\nexit_to_user_mode_prepare+0xb6/0x100\nsyscall_exit_to_user_mode+0x12/0x40\ndo_syscall_64+0x69/0x90\n? syscall_exit_work+0x103/0x130\n? syscall_exit_to_user_mode+0x22/0x40\n? do_syscall_64+0x69/0x90\n? syscall_exit_work+0x103/0x130\n? syscall_exit_to_user_mode+0x22/0x40\n? do_syscall_64+0x69/0x90\n? do_syscall_64+0x69/0x90\n? common_interrupt+0x43/0xa0\nentry_SYSCALL_64_after_hwframe+0x72/0xdc\nRIP: 0033:0x1470abe3ec6b\nCode: Unable to access opcode bytes at RIP 0x1470abe3ec41.\nRSP: 002b:00007fff13ce9108 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: fffffffffffffffc RBX: 00007fff13ce9218 RCX: 00001470abe3ec6b\nRDX: 00007fff13ce9200 RSI: 00000000c0181b01 RDI: 0000000000000004\nRBP: 00007fff13ce91e0 R08: 0000558d9655da10 R09: 0000558d9655dd00\nR10: 00007fff13ce95c0 R11: 0000000000000246 R12: 00007fff13ce9358\nR13: 0000000000000013 R14: 0000558d9655db50 R15: 00007fff13ce9470\n</TASK>\n--[ end trace 888a9b92e04c5c97 ]--",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5639414a52a29336ffa1ede80a67c6d927acbc5a",
      "https://git.kernel.org/stable/c/135e5465fefa463c5ec93c4eede48b9fedac894a",
      "https://git.kernel.org/stable/c/7f31a244c753aacf40b71d01f03ca6742f81bbbc",
      "https://git.kernel.org/stable/c/95175dda017cd4982cd47960536fa1de003d3298",
      "https://git.kernel.org/stable/c/bab8875c06ebda5e01c5c4cab30022aed85c14e6",
      "https://git.kernel.org/stable/c/5ba4e6d5863c53e937f49932dee0ecb004c65928"
    ],
    "受影响版本": [
      "df15856132bc837b512caa36d2227d2350cf64d8",
      "df15856132bc837b512caa36d2227d2350cf64d8",
      "df15856132bc837b512caa36d2227d2350cf64d8",
      "df15856132bc837b512caa36d2227d2350cf64d8",
      "df15856132bc837b512caa36d2227d2350cf64d8",
      "df15856132bc837b512caa36d2227d2350cf64d8"
    ],
    "公开日期": "2024年04月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26733",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\narp: Prevent overflow in arp_req_get().\n\nsyzkaller reported an overflown write in arp_req_get(). [0]\n\nWhen ioctl(SIOCGARP) is issued, arp_req_get() looks up an neighbour\nentry and copies neigh->ha to struct arpreq.arp_ha.sa_data.\n\nThe arp_ha here is struct sockaddr, not struct sockaddr_storage, so\nthe sa_data buffer is just 14 bytes.\n\nIn the splat below, 2 bytes are overflown to the next int field,\narp_flags.  We initialise the field just after the memcpy(), so it's\nnot a problem.\n\nHowever, when dev->addr_len is greater than 22 (e.g. MAX_ADDR_LEN),\narp_netmask is overwritten, which could be set as htonl(0xFFFFFFFFUL)\nin arp_ioctl() before calling arp_req_get().\n\nTo avoid the overflow, let's limit the max length of memcpy().\n\nNote that commit b5f0de6df6dc (\"net: dev: Convert sa_data to flexible\narray in struct sockaddr\") just silenced syzkaller.\n\n[0]:\nmemcpy: detected field-spanning write (size 16) of single field \"r->arp_ha.sa_data\" at net/ipv4/arp.c:1128 (size 14)\nWARNING: CPU: 0 PID: 144638 at net/ipv4/arp.c:1128 arp_req_get+0x411/0x4a0 net/ipv4/arp.c:1128\nModules linked in:\nCPU: 0 PID: 144638 Comm: syz-executor.4 Not tainted 6.1.74 #31\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-debian-1.16.0-5 04/01/2014\nRIP: 0010:arp_req_get+0x411/0x4a0 net/ipv4/arp.c:1128\nCode: fd ff ff e8 41 42 de fb b9 0e 00 00 00 4c 89 fe 48 c7 c2 20 6d ab 87 48 c7 c7 80 6d ab 87 c6 05 25 af 72 04 01 e8 5f 8d ad fb <0f> 0b e9 6c fd ff ff e8 13 42 de fb be 03 00 00 00 4c 89 e7 e8 a6\nRSP: 0018:ffffc900050b7998 EFLAGS: 00010286\nRAX: 0000000000000000 RBX: ffff88803a815000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffffffff8641a44a RDI: 0000000000000001\nRBP: ffffc900050b7a98 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000000 R11: 203a7970636d656d R12: ffff888039c54000\nR13: 1ffff92000a16f37 R14: ffff88803a815084 R15: 0000000000000010\nFS:  00007f172bf306c0(0000) GS:ffff88805aa00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f172b3569f0 CR3: 0000000057f12005 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n <TASK>\n arp_ioctl+0x33f/0x4b0 net/ipv4/arp.c:1261\n inet_ioctl+0x314/0x3a0 net/ipv4/af_inet.c:981\n sock_do_ioctl+0xdf/0x260 net/socket.c:1204\n sock_ioctl+0x3ef/0x650 net/socket.c:1321\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:870 [inline]\n __se_sys_ioctl fs/ioctl.c:856 [inline]\n __x64_sys_ioctl+0x18e/0x220 fs/ioctl.c:856\n do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n do_syscall_64+0x37/0x90 arch/x86/entry/common.c:81\n entry_SYSCALL_64_after_hwframe+0x64/0xce\nRIP: 0033:0x7f172b262b8d\nCode: 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f172bf300b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007f172b3abf80 RCX: 00007f172b262b8d\nRDX: 0000000020000000 RSI: 0000000000008954 RDI: 0000000000000003\nRBP: 00007f172b2d3493 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000000b R14: 00007f172b3abf80 R15: 00007f172bf10000\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/dbc9b22d0ed319b4e29034ce0a3fe32a3ee2c587",
      "https://git.kernel.org/stable/c/97eaa2955db4120ce6ec2ef123e860bc32232c50",
      "https://git.kernel.org/stable/c/f119f2325ba70cbfdec701000dcad4d88805d5b0",
      "https://git.kernel.org/stable/c/a3f2c083cb575d80a7627baf3339e78fedccbb91",
      "https://git.kernel.org/stable/c/3ab0d6f8289ba8402ca95a9fc61a34909d5e1f3a",
      "https://git.kernel.org/stable/c/a7d6027790acea24446ddd6632d394096c0f4667"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年04月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26727",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: do not ASSERT() if the newly created subvolume already got read\n\n[BUG]\nThere is a syzbot crash, triggered by the ASSERT() during subvolume\ncreation:\n\n assertion failed: !anon_dev, in fs/btrfs/disk-io.c:1319\n ------------[ cut here ]------------\n kernel BUG at fs/btrfs/disk-io.c:1319!\n invalid opcode: 0000 [#1] PREEMPT SMP KASAN\n RIP: 0010:btrfs_get_root_ref.part.0+0x9aa/0xa60\n  <TASK>\n  btrfs_get_new_fs_root+0xd3/0xf0\n  create_subvol+0xd02/0x1650\n  btrfs_mksubvol+0xe95/0x12b0\n  __btrfs_ioctl_snap_create+0x2f9/0x4f0\n  btrfs_ioctl_snap_create+0x16b/0x200\n  btrfs_ioctl+0x35f0/0x5cf0\n  __x64_sys_ioctl+0x19d/0x210\n  do_syscall_64+0x3f/0xe0\n  entry_SYSCALL_64_after_hwframe+0x63/0x6b\n ---[ end trace 0000000000000000 ]---\n\n[CAUSE]\nDuring create_subvol(), after inserting root item for the newly created\nsubvolume, we would trigger btrfs_get_new_fs_root() to get the\nbtrfs_root of that subvolume.\n\nThe idea here is, we have preallocated an anonymous device number for\nthe subvolume, thus we can assign it to the new subvolume.\n\nBut there is really nothing preventing things like backref walk to read\nthe new subvolume.\nIf that happens before we call btrfs_get_new_fs_root(), the subvolume\nwould be read out, with a new anonymous device number assigned already.\n\nIn that case, we would trigger ASSERT(), as we really expect no one to\nread out that subvolume (which is not yet accessible from the fs).\nBut things like backref walk is still possible to trigger the read on\nthe subvolume.\n\nThus our assumption on the ASSERT() is not correct in the first place.\n\n[FIX]\nFix it by removing the ASSERT(), and just free the @anon_dev, reset it\nto 0, and continue.\n\nIf the subvolume tree is read out by something else, it should have\nalready get a new anon_dev assigned thus we only need to free the\npreallocated one.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3f5d47eb163bceb1b9e613c9003bae5fefc0046f",
      "https://git.kernel.org/stable/c/e31546b0f34af21738c4ceac47d662c00ee6382f",
      "https://git.kernel.org/stable/c/66b317a2fc45b2ef66527ee3f8fa08fb5beab88d",
      "https://git.kernel.org/stable/c/833775656d447c545133a744a0ed1e189ce61430",
      "https://git.kernel.org/stable/c/5a172344bfdabb46458e03708735d7b1a918c468",
      "https://git.kernel.org/stable/c/e03ee2fe873eb68c1f9ba5112fee70303ebf9dfb"
    ],
    "受影响版本": [
      "2dfb1e43f57dd3aeaa66f7cf05d068db2d4c8788",
      "2dfb1e43f57dd3aeaa66f7cf05d068db2d4c8788",
      "2dfb1e43f57dd3aeaa66f7cf05d068db2d4c8788",
      "2dfb1e43f57dd3aeaa66f7cf05d068db2d4c8788",
      "2dfb1e43f57dd3aeaa66f7cf05d068db2d4c8788",
      "2dfb1e43f57dd3aeaa66f7cf05d068db2d4c8788",
      "917d608fe375041eb7f29befa6a6d7fd3cf32dde"
    ],
    "公开日期": "2024年04月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26726",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: don't drop extent_map for free space inode on write error\n\nWhile running the CI for an unrelated change I hit the following panic\nwith generic/648 on btrfs_holes_spacecache.\n\nassertion failed: block_start != EXTENT_MAP_HOLE, in fs/btrfs/extent_io.c:1385\n------------[ cut here ]------------\nkernel BUG at fs/btrfs/extent_io.c:1385!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 1 PID: 2695096 Comm: fsstress Kdump: loaded Tainted: G        W          6.8.0-rc2+ #1\nRIP: 0010:__extent_writepage_io.constprop.0+0x4c1/0x5c0\nCall Trace:\n <TASK>\n extent_write_cache_pages+0x2ac/0x8f0\n extent_writepages+0x87/0x110\n do_writepages+0xd5/0x1f0\n filemap_fdatawrite_wbc+0x63/0x90\n __filemap_fdatawrite_range+0x5c/0x80\n btrfs_fdatawrite_range+0x1f/0x50\n btrfs_write_out_cache+0x507/0x560\n btrfs_write_dirty_block_groups+0x32a/0x420\n commit_cowonly_roots+0x21b/0x290\n btrfs_commit_transaction+0x813/0x1360\n btrfs_sync_file+0x51a/0x640\n __x64_sys_fdatasync+0x52/0x90\n do_syscall_64+0x9c/0x190\n entry_SYSCALL_64_after_hwframe+0x6e/0x76\n\nThis happens because we fail to write out the free space cache in one\ninstance, come back around and attempt to write it again.  However on\nthe second pass through we go to call btrfs_get_extent() on the inode to\nget the extent mapping.  Because this is a new block group, and with the\nfree space inode we always search the commit root to avoid deadlocking\nwith the tree, we find nothing and return a EXTENT_MAP_HOLE for the\nrequested range.\n\nThis happens because the first time we try to write the space cache out\nwe hit an error, and on an error we drop the extent mapping.  This is\nnormal for normal files, but the free space cache inode is special.  We\nalways expect the extent map to be correct.  Thus the second time\nthrough we end up with a bogus extent map.\n\nSince we're deprecating this feature, the most straightforward way to\nfix this is to simply skip dropping the extent map range for this failed\nrange.\n\nI shortened the test by using error injection to stress the area to make\nit easier to reproduce.  With this patch in place we no longer panic\nwith my error injection test.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/02f2b95b00bf57d20320ee168b30fb7f3db8e555",
      "https://git.kernel.org/stable/c/7bddf18f474f166c19f91b2baf67bf7c5eda03f7",
      "https://git.kernel.org/stable/c/a4b7741c8302e28073bfc6dd1c2e73598e5e535e",
      "https://git.kernel.org/stable/c/5571e41ec6e56e35f34ae9f5b3a335ef510e0ade"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年04月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26703",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/timerlat: Move hrtimer_init to timerlat_fd open()\n\nCurrently, the timerlat's hrtimer is initialized at the first read of\ntimerlat_fd, and destroyed at close(). It works, but it causes an error\nif the user program open() and close() the file without reading.\n\nHere's an example:\n\n # echo NO_OSNOISE_WORKLOAD > /sys/kernel/debug/tracing/osnoise/options\n # echo timerlat > /sys/kernel/debug/tracing/current_tracer\n\n # cat <<EOF > ./timerlat_load.py\n # !/usr/bin/env python3\n\n timerlat_fd = open(\"/sys/kernel/tracing/osnoise/per_cpu/cpu0/timerlat_fd\", 'r')\n timerlat_fd.close();\n EOF\n\n # ./taskset -c 0 ./timerlat_load.py\n<BOOM>\n\n BUG: kernel NULL pointer dereference, address: 0000000000000010\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 1 PID: 2673 Comm: python3 Not tainted 6.6.13-200.fc39.x86_64 #1\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-1.fc39 04/01/2014\n RIP: 0010:hrtimer_active+0xd/0x50\n Code: 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 48 8b 57 30 <8b> 42 10 a8 01 74 09 f3 90 8b 42 10 a8 01 75 f7 80 7f 38 00 75 1d\n RSP: 0018:ffffb031009b7e10 EFLAGS: 00010286\n RAX: 000000000002db00 RBX: ffff9118f786db08 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: ffff9117a0e64400 RDI: ffff9118f786db08\n RBP: ffff9118f786db80 R08: ffff9117a0ddd420 R09: ffff9117804d4f70\n R10: 0000000000000000 R11: 0000000000000000 R12: ffff9118f786db08\n R13: ffff91178fdd5e20 R14: ffff9117840978c0 R15: 0000000000000000\n FS:  00007f2ffbab1740(0000) GS:ffff9118f7840000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000010 CR3: 00000001b402e000 CR4: 0000000000750ee0\n PKRU: 55555554\n Call Trace:\n  <TASK>\n  ? __die+0x23/0x70\n  ? page_fault_oops+0x171/0x4e0\n  ? srso_alias_return_thunk+0x5/0x7f\n  ? avc_has_extended_perms+0x237/0x520\n  ? exc_page_fault+0x7f/0x180\n  ? asm_exc_page_fault+0x26/0x30\n  ? hrtimer_active+0xd/0x50\n  hrtimer_cancel+0x15/0x40\n  timerlat_fd_release+0x48/0xe0\n  __fput+0xf5/0x290\n  __x64_sys_close+0x3d/0x80\n  do_syscall_64+0x60/0x90\n  ? srso_alias_return_thunk+0x5/0x7f\n  ? __x64_sys_ioctl+0x72/0xd0\n  ? srso_alias_return_thunk+0x5/0x7f\n  ? syscall_exit_to_user_mode+0x2b/0x40\n  ? srso_alias_return_thunk+0x5/0x7f\n  ? do_syscall_64+0x6c/0x90\n  ? srso_alias_return_thunk+0x5/0x7f\n  ? exit_to_user_mode_prepare+0x142/0x1f0\n  ? srso_alias_return_thunk+0x5/0x7f\n  ? syscall_exit_to_user_mode+0x2b/0x40\n  ? srso_alias_return_thunk+0x5/0x7f\n  ? do_syscall_64+0x6c/0x90\n  entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n RIP: 0033:0x7f2ffb321594\n Code: 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 80 3d d5 cd 0d 00 00 74 13 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 3c c3 0f 1f 00 55 48 89 e5 48 83 ec 10 89 7d\n RSP: 002b:00007ffe8d8eef18 EFLAGS: 00000202 ORIG_RAX: 0000000000000003\n RAX: ffffffffffffffda RBX: 00007f2ffba4e668 RCX: 00007f2ffb321594\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003\n RBP: 00007ffe8d8eef40 R08: 0000000000000000 R09: 0000000000000000\n R10: 55c926e3167eae79 R11: 0000000000000202 R12: 0000000000000003\n R13: 00007ffe8d8ef030 R14: 0000000000000000 R15: 00007f2ffba4e668\n  </TASK>\n CR2: 0000000000000010\n ---[ end trace 0000000000000000 ]---\n\nMove hrtimer_init to timerlat_fd open() to avoid this problem.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5f703935fdb559642d85b2088442ee55a557ae6d",
      "https://git.kernel.org/stable/c/2354d29986ebd138f89c2b73fecf8237e0a4ad6b",
      "https://git.kernel.org/stable/c/1389358bb008e7625942846e9f03554319b7fecc"
    ],
    "受影响版本": [
      "e88ed227f639ebcb31ed4e5b88756b47d904584b",
      "e88ed227f639ebcb31ed4e5b88756b47d904584b",
      "e88ed227f639ebcb31ed4e5b88756b47d904584b"
    ],
    "公开日期": "2024年04月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26694",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: fix double-free bug\n\nThe storage for the TLV PC register data wasn't done like all\nthe other storage in the drv->fw area, which is cleared at the\nend of deallocation. Therefore, the freeing must also be done\ndifferently, explicitly NULL'ing it out after the free, since\notherwise there's a nasty double-free bug here if a file fails\nto load after this has been parsed, and we get another free\nlater (e.g. because no other file exists.) Fix that by adding\nthe missing NULL assignment.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ab9d4bb9a1892439b3123fc52b19e32b9cdf80ad",
      "https://git.kernel.org/stable/c/d24eb9a27bea8fe5237fa71be274391d9d51eff2",
      "https://git.kernel.org/stable/c/353d321f63f7dbfc9ef58498cc732c9fe886a596"
    ],
    "受影响版本": [
      "5e31b3df86ec6fbb925eee77fe2c450099c61dff",
      "5e31b3df86ec6fbb925eee77fe2c450099c61dff",
      "5e31b3df86ec6fbb925eee77fe2c450099c61dff"
    ],
    "公开日期": "2024年04月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26689",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nceph: prevent use-after-free in encode_cap_msg()\n\nIn fs/ceph/caps.c, in encode_cap_msg(), \"use after free\" error was\ncaught by KASAN at this line - 'ceph_buffer_get(arg->xattr_buf);'. This\nimplies before the refcount could be increment here, it was freed.\n\nIn same file, in \"handle_cap_grant()\" refcount is decremented by this\nline - 'ceph_buffer_put(ci->i_xattrs.blob);'. It appears that a race\noccurred and resource was freed by the latter line before the former\nline could increment it.\n\nencode_cap_msg() is called by __send_cap() and __send_cap() is called by\nceph_check_caps() after calling __prep_cap(). __prep_cap() is where\narg->xattr_buf is assigned to ci->i_xattrs.blob. This is the spot where\nthe refcount must be increased to prevent \"use after free\" error.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8180d0c27b93a6eb60da1b08ea079e3926328214",
      "https://git.kernel.org/stable/c/70e329b440762390258a6fe8c0de93c9fdd56c77",
      "https://git.kernel.org/stable/c/f3f98d7d84b31828004545e29fd7262b9f444139",
      "https://git.kernel.org/stable/c/ae20db45e482303a20e56f2db667a9d9c54ac7e7",
      "https://git.kernel.org/stable/c/7958c1bf5b03c6f1f58e724dbdec93f8f60b96fc",
      "https://git.kernel.org/stable/c/cda4672da1c26835dcbd7aec2bfed954eda9b5ef"
    ],
    "受影响版本": [
      "9030aaf9bf0a1eee47a154c316c789e959638b0f",
      "9030aaf9bf0a1eee47a154c316c789e959638b0f",
      "9030aaf9bf0a1eee47a154c316c789e959638b0f",
      "9030aaf9bf0a1eee47a154c316c789e959638b0f",
      "9030aaf9bf0a1eee47a154c316c789e959638b0f",
      "9030aaf9bf0a1eee47a154c316c789e959638b0f"
    ],
    "公开日期": "2024年04月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26687",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nxen/events: close evtchn after mapping cleanup\n\nshutdown_pirq and startup_pirq are not taking the\nirq_mapping_update_lock because they can't due to lock inversion. Both\nare called with the irq_desc->lock being taking. The lock order,\nhowever, is first irq_mapping_update_lock and then irq_desc->lock.\n\nThis opens multiple races:\n- shutdown_pirq can be interrupted by a function that allocates an event\n  channel:\n\n  CPU0                        CPU1\n  shutdown_pirq {\n    xen_evtchn_close(e)\n                              __startup_pirq {\n                                EVTCHNOP_bind_pirq\n                                  -> returns just freed evtchn e\n                                set_evtchn_to_irq(e, irq)\n                              }\n    xen_irq_info_cleanup() {\n      set_evtchn_to_irq(e, -1)\n    }\n  }\n\n  Assume here event channel e refers here to the same event channel\n  number.\n  After this race the evtchn_to_irq mapping for e is invalid (-1).\n\n- __startup_pirq races with __unbind_from_irq in a similar way. Because\n  __startup_pirq doesn't take irq_mapping_update_lock it can grab the\n  evtchn that __unbind_from_irq is currently freeing and cleaning up. In\n  this case even though the event channel is allocated, its mapping can\n  be unset in evtchn_to_irq.\n\nThe fix is to first cleanup the mappings and then close the event\nchannel. In this way, when an event channel gets allocated it's\npotential previous evtchn_to_irq mappings are guaranteed to be unset already.\nThis is also the reverse order of the allocation where first the event\nchannel is allocated and then the mappings are setup.\n\nOn a 5.10 kernel prior to commit 3fcdaf3d7634 (\"xen/events: modify internal\n[un]bind interfaces\"), we hit a BUG like the following during probing of NVMe\ndevices. The issue is that during nvme_setup_io_queues, pci_free_irq\nis called for every device which results in a call to shutdown_pirq.\nWith many nvme devices it's therefore likely to hit this race during\nboot because there will be multiple calls to shutdown_pirq and\nstartup_pirq are running potentially in parallel.\n\n  ------------[ cut here ]------------\n  blkfront: xvda: barrier or flush: disabled; persistent grants: enabled; indirect descriptors: enabled; bounce buffer: enabled\n  kernel BUG at drivers/xen/events/events_base.c:499!\n  invalid opcode: 0000 [#1] SMP PTI\n  CPU: 44 PID: 375 Comm: kworker/u257:23 Not tainted 5.10.201-191.748.amzn2.x86_64 #1\n  Hardware name: Xen HVM domU, BIOS 4.11.amazon 08/24/2006\n  Workqueue: nvme-reset-wq nvme_reset_work\n  RIP: 0010:bind_evtchn_to_cpu+0xdf/0xf0\n  Code: 5d 41 5e c3 cc cc cc cc 44 89 f7 e8 2b 55 ad ff 49 89 c5 48 85 c0 0f 84 64 ff ff ff 4c 8b 68 30 41 83 fe ff 0f 85 60 ff ff ff <0f> 0b 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 0f 1f 44 00 00\n  RSP: 0000:ffffc9000d533b08 EFLAGS: 00010046\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000006\n  RDX: 0000000000000028 RSI: 00000000ffffffff RDI: 00000000ffffffff\n  RBP: ffff888107419680 R08: 0000000000000000 R09: ffffffff82d72b00\n  R10: 0000000000000000 R11: 0000000000000000 R12: 00000000000001ed\n  R13: 0000000000000000 R14: 00000000ffffffff R15: 0000000000000002\n  FS:  0000000000000000(0000) GS:ffff88bc8b500000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000000 CR3: 0000000002610001 CR4: 00000000001706e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   ? show_trace_log_lvl+0x1c1/0x2d9\n   ? show_trace_log_lvl+0x1c1/0x2d9\n   ? set_affinity_irq+0xdc/0x1c0\n   ? __die_body.cold+0x8/0xd\n   ? die+0x2b/0x50\n   ? do_trap+0x90/0x110\n   ? bind_evtchn_to_cpu+0xdf/0xf0\n   ? do_error_trap+0x65/0x80\n   ? bind_evtchn_to_cpu+0xdf/0xf0\n   ? exc_invalid_op+0x4e/0x70\n   ? bind_evtchn_to_cpu+0xdf/0xf0\n   ? asm_exc_invalid_op+0x12/0x20\n   ? bind_evtchn_to_cpu+0xdf/0x\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9470f5b2503cae994098dea9682aee15b313fa44",
      "https://git.kernel.org/stable/c/0fc88aeb2e32b76db3fe6a624b8333dbe621b8fd",
      "https://git.kernel.org/stable/c/ea592baf9e41779fe9a0424c03dd2f324feca3b3",
      "https://git.kernel.org/stable/c/585a344af6bcac222608a158fc2830ff02712af5",
      "https://git.kernel.org/stable/c/20980195ec8d2e41653800c45c8c367fa1b1f2b4",
      "https://git.kernel.org/stable/c/9be71aa12afa91dfe457b3fb4a444c42b1ee036b",
      "https://git.kernel.org/stable/c/fa765c4b4aed2d64266b694520ecb025c862c5a9"
    ],
    "受影响版本": [
      "d46a78b05c0e37f76ddf4a7a67bf0b6c68bada55",
      "d46a78b05c0e37f76ddf4a7a67bf0b6c68bada55",
      "d46a78b05c0e37f76ddf4a7a67bf0b6c68bada55",
      "d46a78b05c0e37f76ddf4a7a67bf0b6c68bada55",
      "d46a78b05c0e37f76ddf4a7a67bf0b6c68bada55",
      "d46a78b05c0e37f76ddf4a7a67bf0b6c68bada55",
      "d46a78b05c0e37f76ddf4a7a67bf0b6c68bada55"
    ],
    "公开日期": "2024年04月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26680",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: atlantic: Fix DMA mapping for PTP hwts ring\n\nFunction aq_ring_hwts_rx_alloc() maps extra AQ_CFG_RXDS_DEF bytes\nfor PTP HWTS ring but then generic aq_ring_free() does not take this\ninto account.\nCreate and use a specific function to free HWTS ring to fix this\nissue.\n\nTrace:\n[  215.351607] ------------[ cut here ]------------\n[  215.351612] DMA-API: atlantic 0000:4b:00.0: device driver frees DMA memory with different size [device address=0x00000000fbdd0000] [map size=34816 bytes] [unmap size=32768 bytes]\n[  215.351635] WARNING: CPU: 33 PID: 10759 at kernel/dma/debug.c:988 check_unmap+0xa6f/0x2360\n...\n[  215.581176] Call Trace:\n[  215.583632]  <TASK>\n[  215.585745]  ? show_trace_log_lvl+0x1c4/0x2df\n[  215.590114]  ? show_trace_log_lvl+0x1c4/0x2df\n[  215.594497]  ? debug_dma_free_coherent+0x196/0x210\n[  215.599305]  ? check_unmap+0xa6f/0x2360\n[  215.603147]  ? __warn+0xca/0x1d0\n[  215.606391]  ? check_unmap+0xa6f/0x2360\n[  215.610237]  ? report_bug+0x1ef/0x370\n[  215.613921]  ? handle_bug+0x3c/0x70\n[  215.617423]  ? exc_invalid_op+0x14/0x50\n[  215.621269]  ? asm_exc_invalid_op+0x16/0x20\n[  215.625480]  ? check_unmap+0xa6f/0x2360\n[  215.629331]  ? mark_lock.part.0+0xca/0xa40\n[  215.633445]  debug_dma_free_coherent+0x196/0x210\n[  215.638079]  ? __pfx_debug_dma_free_coherent+0x10/0x10\n[  215.643242]  ? slab_free_freelist_hook+0x11d/0x1d0\n[  215.648060]  dma_free_attrs+0x6d/0x130\n[  215.651834]  aq_ring_free+0x193/0x290 [atlantic]\n[  215.656487]  aq_ptp_ring_free+0x67/0x110 [atlantic]\n...\n[  216.127540] ---[ end trace 6467e5964dd2640b ]---\n[  216.132160] DMA-API: Mapped at:\n[  216.132162]  debug_dma_alloc_coherent+0x66/0x2f0\n[  216.132165]  dma_alloc_attrs+0xf5/0x1b0\n[  216.132168]  aq_ring_hwts_rx_alloc+0x150/0x1f0 [atlantic]\n[  216.132193]  aq_ptp_ring_alloc+0x1bb/0x540 [atlantic]\n[  216.132213]  aq_nic_init+0x4a1/0x760 [atlantic]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/466ceebe48cbba3f4506f165fca7111f9eb8bb12",
      "https://git.kernel.org/stable/c/004fe5b7f59286a926a45e0cafc7870e9cdddd56",
      "https://git.kernel.org/stable/c/e42e334c645575be5432adee224975d4f536fdb1",
      "https://git.kernel.org/stable/c/2e7d3b67630dfd8f178c41fa2217aa00e79a5887"
    ],
    "受影响版本": [
      "94ad94558b0fbf18dd6fb0987540af1693157556",
      "94ad94558b0fbf18dd6fb0987540af1693157556",
      "94ad94558b0fbf18dd6fb0987540af1693157556",
      "94ad94558b0fbf18dd6fb0987540af1693157556"
    ],
    "公开日期": "2024年04月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26672",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix variable 'mca_funcs' dereferenced before NULL check in 'amdgpu_mca_smu_get_mca_entry()'\n\nFixes the below:\n\ndrivers/gpu/drm/amd/amdgpu/amdgpu_mca.c:377 amdgpu_mca_smu_get_mca_entry() warn: variable dereferenced before check 'mca_funcs' (see line 368)\n\n357 int amdgpu_mca_smu_get_mca_entry(struct amdgpu_device *adev,\n\t\t\t\t     enum amdgpu_mca_error_type type,\n358                                  int idx, struct mca_bank_entry *entry)\n359 {\n360         const struct amdgpu_mca_smu_funcs *mca_funcs =\n\t\t\t\t\t\tadev->mca.mca_funcs;\n361         int count;\n362\n363         switch (type) {\n364         case AMDGPU_MCA_ERROR_TYPE_UE:\n365                 count = mca_funcs->max_ue_count;\n\nmca_funcs is dereferenced here.\n\n366                 break;\n367         case AMDGPU_MCA_ERROR_TYPE_CE:\n368                 count = mca_funcs->max_ce_count;\n\nmca_funcs is dereferenced here.\n\n369                 break;\n370         default:\n371                 return -EINVAL;\n372         }\n373\n374         if (idx >= count)\n375                 return -EINVAL;\n376\n377         if (mca_funcs && mca_funcs->mca_get_mca_entry)\n\t        ^^^^^^^^^\n\nChecked too late!",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7b5d58c07024516c0e81b95e98f37710cf402c53",
      "https://git.kernel.org/stable/c/4f32504a2f85a7b40fe149436881381f48e9c0c0"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年04月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26660",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Implement bounds check for stream encoder creation in DCN301\n\n'stream_enc_regs' array is an array of dcn10_stream_enc_registers\nstructures. The array is initialized with four elements, corresponding\nto the four calls to stream_enc_regs() in the array initializer. This\nmeans that valid indices for this array are 0, 1, 2, and 3.\n\nThe error message 'stream_enc_regs' 4 <= 5 below, is indicating that\nthere is an attempt to access this array with an index of 5, which is\nout of bounds. This could lead to undefined behavior\n\nHere, eng_id is used as an index to access the stream_enc_regs array. If\neng_id is 5, this would result in an out-of-bounds access on the\nstream_enc_regs array.\n\nThus fixing Buffer overflow error in dcn301_stream_encoder_create\nreported by Smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn301/dcn301_resource.c:1011 dcn301_stream_encoder_create() error: buffer overflow 'stream_enc_regs' 4 <= 5",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/42442f74314d41ddc68227047036fa3e78940054",
      "https://git.kernel.org/stable/c/efdd665ce1a1634b8c1dad5e7f6baaef3e131d0a",
      "https://git.kernel.org/stable/c/cd9bd10c59e3c1446680514fd3097c5b00d3712d",
      "https://git.kernel.org/stable/c/a938eab9586eea31cfd129a507f552efae14d738",
      "https://git.kernel.org/stable/c/58fca355ad37dcb5f785d9095db5f748b79c5dc2"
    ],
    "受影响版本": [
      "3a83e4e64bb1522ddac67ffc787d1c38291e1a65",
      "3a83e4e64bb1522ddac67ffc787d1c38291e1a65",
      "3a83e4e64bb1522ddac67ffc787d1c38291e1a65",
      "3a83e4e64bb1522ddac67ffc787d1c38291e1a65",
      "3a83e4e64bb1522ddac67ffc787d1c38291e1a65"
    ],
    "公开日期": "2024年04月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26645",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Ensure visibility when inserting an element into tracing_map\n\nRunning the following two commands in parallel on a multi-processor\nAArch64 machine can sporadically produce an unexpected warning about\nduplicate histogram entries:\n\n $ while true; do\n     echo hist:key=id.syscall:val=hitcount > \\\n       /sys/kernel/debug/tracing/events/raw_syscalls/sys_enter/trigger\n     cat /sys/kernel/debug/tracing/events/raw_syscalls/sys_enter/hist\n     sleep 0.001\n   done\n $ stress-ng --sysbadaddr $(nproc)\n\nThe warning looks as follows:\n\n[ 2911.172474] ------------[ cut here ]------------\n[ 2911.173111] Duplicates detected: 1\n[ 2911.173574] WARNING: CPU: 2 PID: 12247 at kernel/trace/tracing_map.c:983 tracing_map_sort_entries+0x3e0/0x408\n[ 2911.174702] Modules linked in: iscsi_ibft(E) iscsi_boot_sysfs(E) rfkill(E) af_packet(E) nls_iso8859_1(E) nls_cp437(E) vfat(E) fat(E) ena(E) tiny_power_button(E) qemu_fw_cfg(E) button(E) fuse(E) efi_pstore(E) ip_tables(E) x_tables(E) xfs(E) libcrc32c(E) aes_ce_blk(E) aes_ce_cipher(E) crct10dif_ce(E) polyval_ce(E) polyval_generic(E) ghash_ce(E) gf128mul(E) sm4_ce_gcm(E) sm4_ce_ccm(E) sm4_ce(E) sm4_ce_cipher(E) sm4(E) sm3_ce(E) sm3(E) sha3_ce(E) sha512_ce(E) sha512_arm64(E) sha2_ce(E) sha256_arm64(E) nvme(E) sha1_ce(E) nvme_core(E) nvme_auth(E) t10_pi(E) sg(E) scsi_mod(E) scsi_common(E) efivarfs(E)\n[ 2911.174738] Unloaded tainted modules: cppc_cpufreq(E):1\n[ 2911.180985] CPU: 2 PID: 12247 Comm: cat Kdump: loaded Tainted: G            E      6.7.0-default #2 1b58bbb22c97e4399dc09f92d309344f69c44a01\n[ 2911.182398] Hardware name: Amazon EC2 c7g.8xlarge/, BIOS 1.0 11/1/2018\n[ 2911.183208] pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)\n[ 2911.184038] pc : tracing_map_sort_entries+0x3e0/0x408\n[ 2911.184667] lr : tracing_map_sort_entries+0x3e0/0x408\n[ 2911.185310] sp : ffff8000a1513900\n[ 2911.185750] x29: ffff8000a1513900 x28: ffff0003f272fe80 x27: 0000000000000001\n[ 2911.186600] x26: ffff0003f272fe80 x25: 0000000000000030 x24: 0000000000000008\n[ 2911.187458] x23: ffff0003c5788000 x22: ffff0003c16710c8 x21: ffff80008017f180\n[ 2911.188310] x20: ffff80008017f000 x19: ffff80008017f180 x18: ffffffffffffffff\n[ 2911.189160] x17: 0000000000000000 x16: 0000000000000000 x15: ffff8000a15134b8\n[ 2911.190015] x14: 0000000000000000 x13: 205d373432323154 x12: 5b5d313131333731\n[ 2911.190844] x11: 00000000fffeffff x10: 00000000fffeffff x9 : ffffd1b78274a13c\n[ 2911.191716] x8 : 000000000017ffe8 x7 : c0000000fffeffff x6 : 000000000057ffa8\n[ 2911.192554] x5 : ffff0012f6c24ec0 x4 : 0000000000000000 x3 : ffff2e5b72b5d000\n[ 2911.193404] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0003ff254480\n[ 2911.194259] Call trace:\n[ 2911.194626]  tracing_map_sort_entries+0x3e0/0x408\n[ 2911.195220]  hist_show+0x124/0x800\n[ 2911.195692]  seq_read_iter+0x1d4/0x4e8\n[ 2911.196193]  seq_read+0xe8/0x138\n[ 2911.196638]  vfs_read+0xc8/0x300\n[ 2911.197078]  ksys_read+0x70/0x108\n[ 2911.197534]  __arm64_sys_read+0x24/0x38\n[ 2911.198046]  invoke_syscall+0x78/0x108\n[ 2911.198553]  el0_svc_common.constprop.0+0xd0/0xf8\n[ 2911.199157]  do_el0_svc+0x28/0x40\n[ 2911.199613]  el0_svc+0x40/0x178\n[ 2911.200048]  el0t_64_sync_handler+0x13c/0x158\n[ 2911.200621]  el0t_64_sync+0x1a8/0x1b0\n[ 2911.201115] ---[ end trace 0000000000000000 ]---\n\nThe problem appears to be caused by CPU reordering of writes issued from\n__tracing_map_insert().\n\nThe check for the presence of an element with a given key in this\nfunction is:\n\n val = READ_ONCE(entry->val);\n if (val && keys_match(key, val->key, map->key_size)) ...\n\nThe write of a new entry is:\n\n elt = get_free_elt(map);\n memcpy(elt->key, key, map->key_size);\n entry->val = elt;\n\nThe \"memcpy(elt->key, key, map->key_size);\" and \"entry->val = elt;\"\nstores may become visible in the reversed order on another CPU. This\nsecond CPU might then incorrectly determine that a new key doesn't match\nan already present val->key and subse\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5022b331c041e8c54b9a6a3251579bd1e8c0fc0b",
      "https://git.kernel.org/stable/c/dad9b28f675ed99b4dec261db2a397efeb80b74c",
      "https://git.kernel.org/stable/c/ef70dfa0b1e5084f32635156c9a5c795352ad860",
      "https://git.kernel.org/stable/c/aef1cb00856ccfd614467cfb50b791278992e177",
      "https://git.kernel.org/stable/c/f4f7e696db0274ff560482cc52eddbf0551d4b7a",
      "https://git.kernel.org/stable/c/a1eebe76e187dbe11ca299f8dbb6e45d5b1889e7",
      "https://git.kernel.org/stable/c/bf4aeff7da85c3becd39fb73bac94122331c30fb",
      "https://git.kernel.org/stable/c/2b44760609e9eaafc9d234a6883d042fc21132a7"
    ],
    "受影响版本": [
      "c193707dde77ace92a649cd59a17e105e2fbeaef",
      "c193707dde77ace92a649cd59a17e105e2fbeaef",
      "c193707dde77ace92a649cd59a17e105e2fbeaef",
      "c193707dde77ace92a649cd59a17e105e2fbeaef",
      "c193707dde77ace92a649cd59a17e105e2fbeaef",
      "c193707dde77ace92a649cd59a17e105e2fbeaef",
      "c193707dde77ace92a649cd59a17e105e2fbeaef",
      "c193707dde77ace92a649cd59a17e105e2fbeaef"
    ],
    "公开日期": "2024年03月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26607",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/bridge: sii902x: Fix probing race issue\n\nA null pointer dereference crash has been observed rarely on TI\nplatforms using sii9022 bridge:\n\n[   53.271356]  sii902x_get_edid+0x34/0x70 [sii902x]\n[   53.276066]  sii902x_bridge_get_edid+0x14/0x20 [sii902x]\n[   53.281381]  drm_bridge_get_edid+0x20/0x34 [drm]\n[   53.286305]  drm_bridge_connector_get_modes+0x8c/0xcc [drm_kms_helper]\n[   53.292955]  drm_helper_probe_single_connector_modes+0x190/0x538 [drm_kms_helper]\n[   53.300510]  drm_client_modeset_probe+0x1f0/0xbd4 [drm]\n[   53.305958]  __drm_fb_helper_initial_config_and_unlock+0x50/0x510 [drm_kms_helper]\n[   53.313611]  drm_fb_helper_initial_config+0x48/0x58 [drm_kms_helper]\n[   53.320039]  drm_fbdev_dma_client_hotplug+0x84/0xd4 [drm_dma_helper]\n[   53.326401]  drm_client_register+0x5c/0xa0 [drm]\n[   53.331216]  drm_fbdev_dma_setup+0xc8/0x13c [drm_dma_helper]\n[   53.336881]  tidss_probe+0x128/0x264 [tidss]\n[   53.341174]  platform_probe+0x68/0xc4\n[   53.344841]  really_probe+0x188/0x3c4\n[   53.348501]  __driver_probe_device+0x7c/0x16c\n[   53.352854]  driver_probe_device+0x3c/0x10c\n[   53.357033]  __device_attach_driver+0xbc/0x158\n[   53.361472]  bus_for_each_drv+0x88/0xe8\n[   53.365303]  __device_attach+0xa0/0x1b4\n[   53.369135]  device_initial_probe+0x14/0x20\n[   53.373314]  bus_probe_device+0xb0/0xb4\n[   53.377145]  deferred_probe_work_func+0xcc/0x124\n[   53.381757]  process_one_work+0x1f0/0x518\n[   53.385770]  worker_thread+0x1e8/0x3dc\n[   53.389519]  kthread+0x11c/0x120\n[   53.392750]  ret_from_fork+0x10/0x20\n\nThe issue here is as follows:\n\n- tidss probes, but is deferred as sii902x is still missing.\n- sii902x starts probing and enters sii902x_init().\n- sii902x calls drm_bridge_add(). Now the sii902x bridge is ready from\n  DRM's perspective.\n- sii902x calls sii902x_audio_codec_init() and\n  platform_device_register_data()\n- The registration of the audio platform device causes probing of the\n  deferred devices.\n- tidss probes, which eventually causes sii902x_bridge_get_edid() to be\n  called.\n- sii902x_bridge_get_edid() tries to use the i2c to read the edid.\n  However, the sii902x driver has not set up the i2c part yet, leading\n  to the crash.\n\nFix this by moving the drm_bridge_add() to the end of the\nsii902x_init(), which is also at the very end of sii902x_probe().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e0f83c234ea7a3dec1f84e5d02caa1c51664a076",
      "https://git.kernel.org/stable/c/56f96cf6eb11a1c2d594367c3becbfb06a855ec1",
      "https://git.kernel.org/stable/c/2a4c6af7934a7b4c304542c38fee35e09cc1770c",
      "https://git.kernel.org/stable/c/08ac6f132dd77e40f786d8af51140c96c6d739c9"
    ],
    "受影响版本": [
      "21d808405fe49028036932dd969920f4fee4f481",
      "21d808405fe49028036932dd969920f4fee4f481",
      "21d808405fe49028036932dd969920f4fee4f481",
      "21d808405fe49028036932dd969920f4fee4f481"
    ],
    "公开日期": "2024年02月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-26597",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: qualcomm: rmnet: fix global oob in rmnet_policy\n\nThe variable rmnet_link_ops assign a *bigger* maxtype which leads to a\nglobal out-of-bounds read when parsing the netlink attributes. See bug\ntrace below:\n\n==================================================================\nBUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:386 [inline]\nBUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600\nRead of size 1 at addr ffffffff92c438d0 by task syz-executor.6/84207\n\nCPU: 0 PID: 84207 Comm: syz-executor.6 Tainted: G                 N 6.1.0 #3\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x8b/0xb3 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:284 [inline]\n print_report+0x172/0x475 mm/kasan/report.c:395\n kasan_report+0xbb/0x1c0 mm/kasan/report.c:495\n validate_nla lib/nlattr.c:386 [inline]\n __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600\n __nla_parse+0x3e/0x50 lib/nlattr.c:697\n nla_parse_nested_deprecated include/net/netlink.h:1248 [inline]\n __rtnl_newlink+0x50a/0x1880 net/core/rtnetlink.c:3485\n rtnl_newlink+0x64/0xa0 net/core/rtnetlink.c:3594\n rtnetlink_rcv_msg+0x43c/0xd70 net/core/rtnetlink.c:6091\n netlink_rcv_skb+0x14f/0x410 net/netlink/af_netlink.c:2540\n netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]\n netlink_unicast+0x54e/0x800 net/netlink/af_netlink.c:1345\n netlink_sendmsg+0x930/0xe50 net/netlink/af_netlink.c:1921\n sock_sendmsg_nosec net/socket.c:714 [inline]\n sock_sendmsg+0x154/0x190 net/socket.c:734\n ____sys_sendmsg+0x6df/0x840 net/socket.c:2482\n ___sys_sendmsg+0x110/0x1b0 net/socket.c:2536\n __sys_sendmsg+0xf3/0x1c0 net/socket.c:2565\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7fdcf2072359\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fdcf13e3168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007fdcf219ff80 RCX: 00007fdcf2072359\nRDX: 0000000000000000 RSI: 0000000020000200 RDI: 0000000000000003\nRBP: 00007fdcf20bd493 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007fffbb8d7bdf R14: 00007fdcf13e3300 R15: 0000000000022000\n </TASK>\n\nThe buggy address belongs to the variable:\n rmnet_policy+0x30/0xe0\n\nThe buggy address belongs to the physical page:\npage:0000000065bdeb3c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x155243\nflags: 0x200000000001000(reserved|node=0|zone=2)\nraw: 0200000000001000 ffffea00055490c8 ffffea00055490c8 0000000000000000\nraw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffffffff92c43780: f9 f9 f9 f9 00 00 00 02 f9 f9 f9 f9 00 00 00 07\n ffffffff92c43800: f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9 06 f9 f9 f9\n>ffffffff92c43880: f9 f9 f9 f9 00 00 00 00 00 00 f9 f9 f9 f9 f9 f9\n                                                 ^\n ffffffff92c43900: 00 00 00 00 00 00 00 00 07 f9 f9 f9 f9 f9 f9 f9\n ffffffff92c43980: 00 00 00 07 f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9\n\nAccording to the comment of `nla_parse_nested_deprecated`, the maxtype\nshould be len(destination array) - 1. Hence use `IFLA_RMNET_MAX` here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/093dab655808207f7a9f54cf156240aeafc70590",
      "https://git.kernel.org/stable/c/02467ab8b404d80429107588e0f3425cf5fcd2e5",
      "https://git.kernel.org/stable/c/2295c22348faf795e1ccdf618f6eb7afdb2f7447",
      "https://git.kernel.org/stable/c/3b5254862258b595662a0ccca6e9eeb88d6e7468",
      "https://git.kernel.org/stable/c/ee1dc3bf86f2df777038506b139371a9add02534",
      "https://git.kernel.org/stable/c/c4734535034672f59f2652e1e0058c490da62a5c",
      "https://git.kernel.org/stable/c/17d06a5c44d8fd2e8e61bac295b09153496f87e1",
      "https://git.kernel.org/stable/c/b33fb5b801c6db408b774a68e7c8722796b59ecc"
    ],
    "受影响版本": [
      "14452ca3b5ce304fb2fea96dbc9ca1e4e7978551",
      "14452ca3b5ce304fb2fea96dbc9ca1e4e7978551",
      "14452ca3b5ce304fb2fea96dbc9ca1e4e7978551",
      "14452ca3b5ce304fb2fea96dbc9ca1e4e7978551",
      "14452ca3b5ce304fb2fea96dbc9ca1e4e7978551",
      "14452ca3b5ce304fb2fea96dbc9ca1e4e7978551",
      "14452ca3b5ce304fb2fea96dbc9ca1e4e7978551",
      "14452ca3b5ce304fb2fea96dbc9ca1e4e7978551"
    ],
    "公开日期": "2024年02月23日"
  },
  {
    "设备品牌": "EBM Technologies",
    "设备类型": "OTA",
    "产品型号": "RISWEB ",
    "CVE编号": "CVE-2024-26264",
    "漏洞描述": "EBM Technologies RISWEB's specific query function parameter does not properly restrict user input, and this feature page is accessible without login. This allows remote attackers to inject SQL commands without authentication, enabling them to read, modify, and delete database records.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.twcert.org.tw/tw/cp-132-7677-b1c0f-1.html"
    ],
    "受影响版本": [
      "1.x",
      "2.x"
    ],
    "公开日期": "2024年02月15日"
  },
  {
    "设备品牌": "EBM Technologies",
    "设备类型": "OTA",
    "产品型号": "RISWEB",
    "CVE编号": "CVE-2024-26263",
    "漏洞描述": "EBM Technologies RISWEB's specific URL path is not properly controlled by permission, allowing attackers to browse specific pages and query sensitive data without login.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.twcert.org.tw/tw/cp-132-7676-9418d-1.html"
    ],
    "受影响版本": [
      "1.*",
      "2.*"
    ],
    "公开日期": "2024年02月15日"
  },
  {
    "设备品牌": "EBM Technologies",
    "设备类型": "OTA",
    "产品型号": "Uniweb/SoliPACS WebServer",
    "CVE编号": "CVE-2024-26262",
    "漏洞描述": "EBM Technologies Uniweb/SoliPACS WebServer's query functionality lacks proper restrictions of user input, allowing remote attackers authenticated as regular user to inject SQL commands for reading, modifying, and deleting database records, as well as executing system commands. Attackers may even leverage the dbo privilege in the database for privilege escalation, elevating their privileges to administrator .",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.twcert.org.tw/tw/cp-132-7674-bdb40-1.html"
    ],
    "受影响版本": [
      " "
    ],
    "公开日期": "2024年02月15日"
  },
  {
    "设备品牌": "vantage6",
    "设备类型": "OTA",
    "产品型号": "vantage6",
    "CVE编号": "CVE-2024-24770",
    "漏洞描述": "vantage6 is an open source framework built to enable, manage and deploy privacy enhancing technologies like Federated Learning and Multi-Party Computation. Much like GHSA-45gq-q4xh-cp53, it is possible to find which usernames exist in vantage6 by calling the API routes `/recover/lost` and `/2fa/lost`. These routes send emails to users if they have lost their password or MFA token. This issue has been addressed in commit `aecfd6d0e` and is expected to ship in subsequent releases. Users are advised to upgrade as soon as a new release is available. There are no known workarounds for this vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/vantage6/vantage6/security/advisories/GHSA-5h3x-6gwf-73jm",
      "https://github.com/vantage6/vantage6/security/advisories/GHSA-45gq-q4xh-cp53",
      "https://github.com/vantage6/vantage6/commit/aecfd6d0e83165a41a60ebd52d2287b0217be26b"
    ],
    "受影响版本": [
      "<= 4.2.2"
    ],
    "公开日期": "2024年03月14日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2024-24313",
    "漏洞描述": "An issue in Vaales Technologies V_QRS v.2024-01-17 allows a remote attacker to obtain sensitive information via the Models/FormModel.php and QRModel.php component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www2.deloitte.com/xe/en/pages/about-deloitte/articles/sustainable-strategies/unveiling-vulnerabilities-in-cybersecurity.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2024-24312",
    "漏洞描述": "SQL injection vulnerability in Vaales Technologies V_QRS v.2024-01-17 allows a remote attacker to obtain sensitive information via the Models/UserModel.php component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www2.deloitte.com/xe/en/pages/about-deloitte/articles/sustainable-strategies/unveiling-vulnerabilities-in-cybersecurity.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年05月01日"
  },
  {
    "设备品牌": "vantage6",
    "设备类型": "OTA",
    "产品型号": "vantage6",
    "CVE编号": "CVE-2024-23823",
    "漏洞描述": "vantage6 is an open source framework built to enable, manage and deploy privacy enhancing technologies like Federated Learning and Multi-Party Computation. The vantage6 server has no restrictions on CORS settings. It should be possible for people to set the allowed origins of the server.  The impact is limited because v6 does not use session cookies. This issue has been addressed in commit `70bb4e1d8` and is expected to ship in subsequent releases. Users are advised to upgrade as soon as a new release is available. There are no known workarounds for this vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/vantage6/vantage6/security/advisories/GHSA-4946-85pr-fvxh",
      "https://github.com/vantage6/vantage6/commit/70bb4e1d889230a841eb364d6c03accd7dd01a41"
    ],
    "受影响版本": [
      "<= 4.2.2"
    ],
    "公开日期": "2024年03月14日"
  },
  {
    "设备品牌": "honojs",
    "设备类型": "OTA",
    "产品型号": "node-server",
    "CVE编号": "CVE-2024-23340",
    "漏洞描述": "@hono/node-server is an adapter that allows users to run Hono applications on Node.js. Since v1.3.0, @hono/node-server has used its own Request object with `url` behavior that is unexpected. In the standard API, if the URL contains `..`, here called \"double dots\", the URL string returned by Request will be in the resolved path. However, the `url` in @hono/node-server's Request as does not resolve double dots, so `http://localhost/static/.. /foo.txt` is returned. This causes vulnerabilities when using `serveStatic`. Modern web browsers and a latest `curl` command resolve double dots on the client side, so this issue doesn't affect those using either of those tools. However, problems may occur if accessed by a client that does not resolve them. Version 1.4.1 includes the change to fix this issue. As a workaround, don't use `serveStatic`.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/honojs/node-server/security/advisories/GHSA-rjq5-w47x-x359",
      "https://github.com/honojs/node-server/commit/dd9b9a9b23e3896403c90a740e7f1f0892feb402",
      "https://github.com/honojs/node-server/blob/8cea466fd05e6d2e99c28011fc0e2c2d3f3397c9/src/request.ts#L43-L45"
    ],
    "受影响版本": [
      ">= 1.3.0, < 1.4.1"
    ],
    "公开日期": "2024年01月22日"
  },
  {
    "设备品牌": "",
    "设备类型": "OTA",
    "产品型号": "",
    "CVE编号": "CVE-2024-22413",
    "漏洞描述": "",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "无官方补丁，建议联系厂商或及时更新系统"
    ],
    "受影响版本": [],
    "公开日期": ""
  },
  {
    "设备品牌": "vantage6",
    "设备类型": "OTA",
    "产品型号": "vantage6",
    "CVE编号": "CVE-2024-22193",
    "漏洞描述": "The vantage6 technology enables to manage and deploy privacy enhancing technologies like Federated Learning (FL) and Multi-Party Computation (MPC). There are no checks on whether the input is encrypted if a task is created in an encrypted collaboration. Therefore, a user may accidentally create a task with sensitive input data that will then be stored unencrypted in a database.  Users should ensure they set the encryption setting correctly.  This vulnerability is patched in 4.2.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/vantage6/vantage6/security/advisories/GHSA-rjmv-52mp-gjrr",
      "https://github.com/vantage6/vantage6/commit/6383283733b81abfcacfec7538dc4dc882e98074"
    ],
    "受影响版本": [
      "< 4.2.0"
    ],
    "公开日期": "2024年01月30日"
  },
  {
    "设备品牌": "MC Technologies",
    "设备类型": "OTA",
    "产品型号": "MC LR Router",
    "CVE编号": "CVE-2024-21786",
    "漏洞描述": "An OS command injection vulnerability exists in the web interface configuration upload functionality of MC Technologies MC LR Router 2.10.5. A specially crafted HTTP request can lead to arbitrary command execution. An attacker can make an authenticated HTTP request to trigger this vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://talosintelligence.com/vulnerability_reports/TALOS-2024-1954"
    ],
    "受影响版本": [
      "2.10.5 (QEMU)"
    ],
    "公开日期": "2024年11月21日"
  },
  {
    "设备品牌": "vantage6",
    "设备类型": "OTA",
    "产品型号": "vantage6",
    "CVE编号": "CVE-2024-21671",
    "漏洞描述": "The vantage6 technology enables to manage and deploy privacy enhancing technologies like Federated Learning (FL) and Multi-Party Computation (MPC).  It is possible to find out usernames from the response time of login requests. This could aid attackers in credential attacks.  Version 4.2.0 patches this vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/vantage6/vantage6/security/advisories/GHSA-45gq-q4xh-cp53",
      "https://github.com/vantage6/vantage6/commit/389f416c445da4f2438c72f34c3b1084485c4e30"
    ],
    "受影响版本": [
      "< 4.2.0"
    ],
    "公开日期": "2024年01月30日"
  },
  {
    "设备品牌": "lestrrat-go",
    "设备类型": "OTA",
    "产品型号": "jwx",
    "CVE编号": "CVE-2024-21664",
    "漏洞描述": "jwx is a Go module implementing various JWx (JWA/JWE/JWK/JWS/JWT, otherwise known as JOSE) technologies. Calling `jws.Parse` with a JSON serialized payload where the `signature` field is present while `protected` is absent can lead to a nil pointer dereference. The vulnerability can be used to crash/DOS a system doing JWS verification. This vulnerability has been patched in versions 2.0.19 and 1.2.28.\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/lestrrat-go/jwx/security/advisories/GHSA-pvcr-v8j8-j5q3",
      "https://github.com/lestrrat-go/jwx/commit/0e8802ce6842625845d651456493e7c87625601f",
      "https://github.com/lestrrat-go/jwx/commit/8c53d0ae52d5ab1e2b37c5abb67def9e7958fd65",
      "https://github.com/lestrrat-go/jwx/commit/d69a721931a5c48b9850a42404f18e143704adcd"
    ],
    "受影响版本": [
      ">= 2.0.0, < 2.0.19",
      ">= 1.0.8, < 1.2.28"
    ],
    "公开日期": "2024年01月09日"
  },
  {
    "设备品牌": "vantage6",
    "设备类型": "OTA",
    "产品型号": "vantage6",
    "CVE编号": "CVE-2024-21653",
    "漏洞描述": "The vantage6 technology enables to manage and deploy privacy enhancing technologies like Federated Learning (FL) and Multi-Party Computation (MPC).  Nodes and servers get a ssh config by default that permits root login with password authentication. In a proper deployment, the SSH service is not exposed so there is no risk, but not all deployments are ideal. The default should therefore be less permissive.  The vulnerability can be mitigated by removing the ssh part from the docker file and rebuilding the docker image.  Version 4.2.0 patches the vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/vantage6/vantage6/security/advisories/GHSA-2wgc-48g2-cj5w",
      "https://github.com/vantage6/vantage6/commit/3fcc6e6a8bd1142fd7a558d8fdd2b246e55c8841"
    ],
    "受影响版本": [
      "< 4.2.0"
    ],
    "公开日期": "2024年01月30日"
  },
  {
    "设备品牌": "vantage6",
    "设备类型": "OTA",
    "产品型号": "vantage6",
    "CVE编号": "CVE-2024-21649",
    "漏洞描述": "The vantage6 technology enables to manage and deploy privacy enhancing technologies like Federated Learning (FL) and Multi-Party Computation (MPC). Prior to 4.2.0, authenticated users could inject code into algorithm environment variables, resulting in remote code execution.  This vulnerability is patched in 4.2.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/vantage6/vantage6/security/advisories/GHSA-w9h2-px87-74vx",
      "https://github.com/vantage6/vantage6/commit/eac19db737145d3ca987adf037a454fae0790ddd"
    ],
    "受影响版本": [
      "< 4.2.0"
    ],
    "公开日期": "2024年01月30日"
  },
  {
    "设备品牌": "Fedora",
    "设备类型": "OTA",
    "产品型号": "dnf5daemon-server",
    "CVE编号": "CVE-2024-1929",
    "漏洞描述": "Local Root Exploit via Configuration Dictionary  in dnf5daemon-server before 5.1.17 allows a malicious user to impact Confidentiality and Integrity via Configuration Dictionary.\n\nThere are issues with the D-Bus interface long before Polkit is invoked. The `org.rpm.dnf.v0.SessionManager.open_session` method takes a key/value map of configuration entries. A sub-entry in this map, placed under the \"config\" key, is another key/value map. The configuration values found in it will be forwarded as configuration overrides to the `libdnf5::Base` configuration. \n\nPractically all libdnf5 configuration aspects can be influenced here. Already when opening the session via D-Bus, the libdnf5 will be initialized using these override configuration values. There is no sanity checking of the content of this \"config\" map, which is untrusted data. It is possible to make the library loading a plug-in shared library under control of an unprivileged user, hence achieving root access. \n\n",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://www.openwall.com/lists/oss-security/2024/03/04/2"
    ],
    "受影响版本": [
      "5.1.16<="
    ],
    "公开日期": "2024年05月08日"
  },
  {
    "设备品牌": "codepeople",
    "设备类型": "OTA",
    "产品型号": "Form Builder CP",
    "CVE编号": "CVE-2024-13680",
    "漏洞描述": "The Form Builder CP plugin for WordPress is vulnerable to SQL Injection via the 'id' parameter of the 'CP_EASY_FORM_WILL_APPEAR_HERE' shortcode in all versions up to, and including, 1.2.41 due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query.  This makes it possible for authenticated attackers, with Contributor-level access and above, to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.wordfence.com/threat-intel/vulnerabilities/id/a018fcb1-b7a6-456f-ab0b-59ccc1fd5b67?source=cve",
      "https://plugins.trac.wordpress.org/browser/cp-easy-form-builder/tags/1.2.41/cp_easy_form_builder.php#L297",
      "https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&old=3214984%40cp-easy-form-builder&new=3214984%40cp-easy-form-builder&sfp_email=&sfph_mail="
    ],
    "受影响版本": [
      "*"
    ],
    "公开日期": "2025年01月24日"
  },
  {
    "设备品牌": "Tapandsign Technologies",
    "设备类型": "OTA",
    "产品型号": "Tap&Sign App",
    "CVE编号": "CVE-2024-12604",
    "漏洞描述": "Cleartext Storage of Sensitive Information in an Environment Variable, Weak Password Recovery Mechanism for Forgotten Password vulnerability in Tapandsign Technologies Tap&Sign App allows Password Recovery Exploitation, Functionality Misuse.This issue affects Tap&Sign App: before V.1.025.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://docs.tapandsign.com/tap-and-sign/tap-and-sign-v.1.025-surum-notlari",
      "https://www.usom.gov.tr/bildirim/tr-25-0063"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2025年03月10日"
  },
  {
    "设备品牌": "aliakro",
    "设备类型": "OTA",
    "产品型号": "Snippet Shortcodes",
    "CVE编号": "CVE-2024-12018",
    "漏洞描述": "The Snippet Shortcodes plugin for WordPress is vulnerable to unauthorized Shortcode Deletion due to missing authorization in all versions up to, and including, 4.1.6. Note that a nonce is used as authentication here, but the value is leaked. This makes it possible for authenticated attackers, with Subscriber-level access and above, to delete the plugin's Shortcodes.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.wordfence.com/threat-intel/vulnerabilities/id/4e6e8f68-6977-478a-b62e-0ec9385eb2af?source=cve",
      "https://wordpress.org/plugins/shortcode-variables/",
      "https://plugins.trac.wordpress.org/changeset/3205481/shortcode-variables/trunk/includes/hooks.php"
    ],
    "受影响版本": [
      "*"
    ],
    "公开日期": "2024年12月12日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "PostgreSQL",
    "CVE编号": "CVE-2024-10978",
    "漏洞描述": "Incorrect privilege assignment in PostgreSQL allows a less-privileged application user to view or change different rows from those intended.  An attack requires the application to use SET ROLE, SET SESSION AUTHORIZATION, or an equivalent feature.  The problem arises when an application query uses parameters from the attacker or conveys query results to the attacker.  If that query reacts to current_setting('role') or the current user ID, it may modify or return data as though the session had not used SET ROLE or SET SESSION AUTHORIZATION.  The attacker does not control which incorrect user ID applies.  Query text from less-privileged sources is not a concern here, because SET ROLE and SET SESSION AUTHORIZATION are not sandboxes for unvetted queries.  Versions before PostgreSQL 17.1, 16.5, 15.9, 14.14, 13.17, and 12.21 are affected.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.postgresql.org/support/security/CVE-2024-10978/"
    ],
    "受影响版本": [
      "17",
      "16",
      "15",
      "14",
      "13",
      "0"
    ],
    "公开日期": "2024年11月14日"
  },
  {
    "设备品牌": "BG-TEK Informatics Security Technologies",
    "设备类型": "OTA",
    "产品型号": "CoslatV3",
    "CVE编号": "CVE-2024-10035",
    "漏洞描述": "Improper Control of Generation of Code ('Code Injection') vulnerability in BG-TEK Informatics Security Technologies CoslatV3 allows Command Injection.This issue affects CoslatV3: through 3.1069. \n\n\n\nNOTE: The vendor was contacted and it was learned that the product is not supported.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-24-1814"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年11月04日"
  },
  {
    "设备品牌": "Macroturk Software and Internet Technologies",
    "设备类型": "OTA",
    "产品型号": "Macro-Bel",
    "CVE编号": "CVE-2023-7153",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Macroturk Software and Internet Technologies Macro-Bel allows Reflected XSS.This issue affects Macro-Bel: before V.1.0.1.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-24-0041"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年01月18日"
  },
  {
    "设备品牌": "Biges Safe Life Technologies Electronics Inc.",
    "设备类型": "OTA",
    "产品型号": "VGuard",
    "CVE编号": "CVE-2023-6919",
    "漏洞描述": "Path Traversal: '/../filedir' vulnerability in Biges Safe Life Technologies Electronics Inc. VGuard allows Absolute Path Traversal.This issue affects VGuard: before V500.0003.R008.4011.C0012.B351.C.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-24-0054"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年01月26日"
  },
  {
    "设备品牌": "Tyler Technologies",
    "设备类型": "OTA",
    "产品型号": "Court Case Management Plus",
    "CVE编号": "CVE-2023-6375",
    "漏洞描述": "Tyler Technologies Court Case Management Plus may store backups in a location that can be accessed by a remote, unauthenticated attacker. Backups may contain sensitive information such as database credentials.\n\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.tylertech.com/solutions/courts-public-safety/courts-justice",
      "https://github.com/qwell/disorder-in-the-court/blob/main/README-TylerTechnologies.md",
      "https://techcrunch.com/2023/11/30/us-court-records-systems-vulnerabilities-exposed-sealed-documents/",
      "https://www.cisa.gov/news-events/alerts/2023/11/30/multiple-vulnerabilities-affecting-web-based-court-case-and-document-management-systems"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年11月30日"
  },
  {
    "设备品牌": "Tyler Technologies",
    "设备类型": "OTA",
    "产品型号": "Magistrate Court Case Management Plus",
    "CVE编号": "CVE-2023-6354",
    "漏洞描述": "Tyler Technologies Magistrate Court Case Management Plus allows an unauthenticated, remote attacker to upload, delete, and view files by manipulating the PDFViewer.aspx 'filename' parameter.\n\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.tylertech.com/solutions/courts-public-safety/courts-justice",
      "https://github.com/qwell/disorder-in-the-court/blob/main/README-TylerTechnologies.md",
      "https://techcrunch.com/2023/11/30/us-court-records-systems-vulnerabilities-exposed-sealed-documents/",
      "https://www.cisa.gov/news-events/alerts/2023/11/30/multiple-vulnerabilities-affecting-web-based-court-case-and-document-management-systems"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年11月30日"
  },
  {
    "设备品牌": "Tyler Technologies",
    "设备类型": "OTA",
    "产品型号": "Civil and Criminal Electronic Filing",
    "CVE编号": "CVE-2023-6353",
    "漏洞描述": "Tyler Technologies Civil and Criminal Electronic Filing allows an unauthenticated, remote attacker to upload, delete, and view files by manipulating the Upload.aspx 'enky' parameter.\n\n\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.tylertech.com/solutions/courts-public-safety/courts-justice",
      "https://github.com/qwell/disorder-in-the-court/blob/main/README-TylerTechnologies.md",
      "https://techcrunch.com/2023/11/30/us-court-records-systems-vulnerabilities-exposed-sealed-documents/",
      "https://www.cisa.gov/news-events/alerts/2023/11/30/multiple-vulnerabilities-affecting-web-based-court-case-and-document-management-systems"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年11月30日"
  },
  {
    "设备品牌": "Tyler Technologies",
    "设备类型": "OTA",
    "产品型号": "Court Case Management Plus",
    "CVE编号": "CVE-2023-6344",
    "漏洞描述": "Tyler Technologies Court Case Management Plus allows a remote, unauthenticated attacker to enumerate directories using the tiffserver/te003.aspx or te004.aspx 'ifolder' parameter. This behavior is related to the use of a deprecated version of Aquaforest TIFF Server, possibly 2.x. The vulnerable Aquaforest TIFF Server feature was removed on or around 2023-11-01. Insecure configuration issues in Aquaforest TIFF Server are identified separately as CVE-2023-6352. CVE-2023-6343 is related to or partially caused by CVE-2023-6352.\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.tylertech.com/solutions/courts-public-safety/courts-justice",
      "https://www.aquaforest.com/blog/tiff-server-security-update",
      "https://www.aquaforest.com/blog/aquaforest-tiff-server-sunsetting",
      "https://github.com/qwell/disorder-in-the-court/blob/main/README-TylerTechnologies.md",
      "https://techcrunch.com/2023/11/30/us-court-records-systems-vulnerabilities-exposed-sealed-documents/",
      "https://www.cisa.gov/news-events/alerts/2023/11/30/multiple-vulnerabilities-affecting-web-based-court-case-and-document-management-systems"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年11月30日"
  },
  {
    "设备品牌": "Tyler Technologies",
    "设备类型": "OTA",
    "产品型号": "Court Case Management Plus",
    "CVE编号": "CVE-2023-6343",
    "漏洞描述": "Tyler Technologies Court Case Management Plus allows a remote, unauthenticated attacker to enumerate and access sensitive files using the tiffserver/tssp.aspx 'FN' and 'PN' parameters. This behavior is related to the use of a deprecated version of Aquaforest TIFF Server, possibly 2.x. The vulnerable Aquaforest TIFF Server feature was removed on or around 2023-11-01. Insecure configuration issues in Aquaforest TIFF Server are identified separately as CVE-2023-6352. CVE-2023-6343 is similar to CVE-2020-9323. CVE-2023-6343 is related to or partially caused by CVE-2023-6352.\n\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.tylertech.com/solutions/courts-public-safety/courts-justice",
      "https://www.aquaforest.com/blog/tiff-server-security-update",
      "https://www.aquaforest.com/blog/aquaforest-tiff-server-sunsetting",
      "https://github.com/qwell/disorder-in-the-court/blob/main/README-TylerTechnologies.md",
      "https://techcrunch.com/2023/11/30/us-court-records-systems-vulnerabilities-exposed-sealed-documents/",
      "https://www.cisa.gov/news-events/alerts/2023/11/30/multiple-vulnerabilities-affecting-web-based-court-case-and-document-management-systems"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年11月30日"
  },
  {
    "设备品牌": "Tyler Technologies",
    "设备类型": "OTA",
    "产品型号": "Court Case Management Plus",
    "CVE编号": "CVE-2023-6342",
    "漏洞描述": "Tyler Technologies Court Case Management Plus allows a remote attacker to authenticate as any user by manipulating at least the 'CmWebSearchPfp/Login.aspx?xyzldk=' and \n'payforprint_CM/Redirector.ashx?userid=' parameters. The vulnerable \"pay for print\" feature was removed on or around 2023-11-01.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.tylertech.com/solutions/courts-public-safety/courts-justice",
      "https://github.com/qwell/disorder-in-the-court/blob/main/README-TylerTechnologies.md",
      "https://techcrunch.com/2023/11/30/us-court-records-systems-vulnerabilities-exposed-sealed-documents/",
      "https://www.cisa.gov/news-events/alerts/2023/11/30/multiple-vulnerabilities-affecting-web-based-court-case-and-document-management-systems"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年11月30日"
  },
  {
    "设备品牌": "ray-project",
    "设备类型": "OTA",
    "产品型号": "ray-project/ray",
    "CVE编号": "CVE-2023-6021",
    "漏洞描述": "LFI in Ray's log API endpoint allows attackers to read any file on the server without authentication. The issue is fixed in version 2.8.1+. Ray maintainers' response can be found here: https://www.anyscale.com/blog/update-on-ray-cves-cve-2023-6019-cve-2023-6020-cve-2023-6021-cve-2023-48022-cve-2023-48023",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://huntr.com/bounties/5039c045-f986-4cbc-81ac-370fe4b0d3f8"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2023年11月16日"
  },
  {
    "设备品牌": "ray-project",
    "设备类型": "OTA",
    "产品型号": "ray-project/ray",
    "CVE编号": "CVE-2023-6019",
    "漏洞描述": "A command injection existed in Ray's cpu_profile URL parameter allowing attackers to execute os commands on the system running the ray dashboard remotely without authentication. The issue is fixed in version 2.8.1+. Ray maintainers' response can be found here: https://www.anyscale.com/blog/update-on-ray-cves-cve-2023-6019-cve-2023-6020-cve-2023-6021-cve-2023-48022-cve-2023-48023",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://huntr.com/bounties/d0290f3c-b302-4161-89f2-c13bb28b4cfe"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2023年11月16日"
  },
  {
    "设备品牌": "Uyumsoft Information System and Technologies",
    "设备类型": "OTA",
    "产品型号": "LioXERP",
    "CVE编号": "CVE-2023-5989",
    "漏洞描述": "An Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Uyumsoft Information System and Technologies' LioXERP allows an authenticated user to execute Stored XSS.\n\nThis issue affects LioXERP: before v.146.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0721"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年12月21日"
  },
  {
    "设备品牌": " Uyumsoft Information System and Technologies",
    "设备类型": "OTA",
    "产品型号": "LioXERP",
    "CVE编号": "CVE-2023-5988",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in Uyumsoft Information System and Technologies LioXERP allows Reflected XSS.This issue affects LioXERP: before v.146.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0721"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年12月21日"
  },
  {
    "设备品牌": "vnotex",
    "设备类型": "OTA",
    "产品型号": "vnote",
    "CVE编号": "CVE-2023-5701",
    "漏洞描述": "A vulnerability has been found in vnotex vnote up to 3.17.0 and classified as problematic. Affected by this vulnerability is an unknown functionality of the component Markdown File Handler. The manipulation with the input <xss onclick=\"alert(1)\" style=display:block>Click here</xss> leads to cross site scripting. The attack can be launched remotely. The exploit has been disclosed to the public and may be used. The associated identifier of this vulnerability is VDB-243139. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/victorootnice/victorootnice.github.io/blob/main/2023/bbp-01.md"
    ],
    "受影响版本": [
      "3.0",
      "3.1",
      "3.2",
      "3.3",
      "3.4",
      "3.5",
      "3.6",
      "3.7",
      "3.8",
      "3.9",
      "3.10",
      "3.11",
      "3.12",
      "3.13",
      "3.14",
      "3.15",
      "3.16",
      "3.17"
    ],
    "公开日期": "2023年10月23日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53143",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix another off-by-one fsmap error on 1k block filesystems\n\nApparently syzbot figured out that issuing this FSMAP call:\n\nstruct fsmap_head cmd = {\n\t.fmh_count\t= ...;\n\t.fmh_keys\t= {\n\t\t{ .fmr_device = /* ext4 dev */, .fmr_physical = 0, },\n\t\t{ .fmr_device = /* ext4 dev */, .fmr_physical = 0, },\n\t},\n...\n};\nret = ioctl(fd, FS_IOC_GETFSMAP, &cmd);\n\nProduces this crash if the underlying filesystem is a 1k-block ext4\nfilesystem:\n\nkernel BUG at fs/ext4/ext4.h:3331!\ninvalid opcode: 0000 [#1] PREEMPT SMP\nCPU: 3 PID: 3227965 Comm: xfs_io Tainted: G        W  O       6.2.0-rc8-achx\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014\nRIP: 0010:ext4_mb_load_buddy_gfp+0x47c/0x570 [ext4]\nRSP: 0018:ffffc90007c03998 EFLAGS: 00010246\nRAX: ffff888004978000 RBX: ffffc90007c03a20 RCX: ffff888041618000\nRDX: 0000000000000000 RSI: 00000000000005a4 RDI: ffffffffa0c99b11\nRBP: ffff888012330000 R08: ffffffffa0c2b7d0 R09: 0000000000000400\nR10: ffffc90007c03950 R11: 0000000000000000 R12: 0000000000000001\nR13: 00000000ffffffff R14: 0000000000000c40 R15: ffff88802678c398\nFS:  00007fdf2020c880(0000) GS:ffff88807e100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffd318a5fe8 CR3: 000000007f80f001 CR4: 00000000001706e0\nCall Trace:\n <TASK>\n ext4_mballoc_query_range+0x4b/0x210 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]\n ext4_getfsmap_datadev+0x713/0x890 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]\n ext4_getfsmap+0x2b7/0x330 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]\n ext4_ioc_getfsmap+0x153/0x2b0 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]\n __ext4_ioctl+0x2a7/0x17e0 [ext4 dfa189daddffe8fecd3cdfd00564e0f265a8ab80]\n __x64_sys_ioctl+0x82/0xa0\n do_syscall_64+0x2b/0x80\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\nRIP: 0033:0x7fdf20558aff\nRSP: 002b:00007ffd318a9e30 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00000000000200c0 RCX: 00007fdf20558aff\nRDX: 00007fdf1feb2010 RSI: 00000000c0c0583b RDI: 0000000000000003\nRBP: 00005625c0634be0 R08: 00005625c0634c40 R09: 0000000000000001\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007fdf1feb2010\nR13: 00005625be70d994 R14: 0000000000000800 R15: 0000000000000000\n\nFor GETFSMAP calls, the caller selects a physical block device by\nwriting its block number into fsmap_head.fmh_keys[01].fmr_device.\nTo query mappings for a subrange of the device, the starting byte of the\nrange is written to fsmap_head.fmh_keys[0].fmr_physical and the last\nbyte of the range goes in fsmap_head.fmh_keys[1].fmr_physical.\n\nIOWs, to query what mappings overlap with bytes 3-14 of /dev/sda, you'd\nset the inputs as follows:\n\n\tfmh_keys[0] = { .fmr_device = major(8, 0), .fmr_physical = 3},\n\tfmh_keys[1] = { .fmr_device = major(8, 0), .fmr_physical = 14},\n\nWhich would return you whatever is mapped in the 12 bytes starting at\nphysical offset 3.\n\nThe crash is due to insufficient range validation of keys[1] in\next4_getfsmap_datadev.  On 1k-block filesystems, block 0 is not part of\nthe filesystem, which means that s_first_data_block is nonzero.\next4_get_group_no_and_offset subtracts this quantity from the blocknr\nargument before cracking it into a group number and a block number\nwithin a group.  IOWs, block group 0 spans blocks 1-8192 (1-based)\ninstead of 0-8191 (0-based) like what happens with larger blocksizes.\n\nThe net result of this encoding is that blocknr < s_first_data_block is\nnot a valid input to this function.  The end_fsb variable is set from\nthe keys that are copied from userspace, which means that in the above\nexample, its value is zero.  That leads to an underflow here:\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\nThe division then operates on -1:\n\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\nLeaving an impossibly large group number (2^32-1) in blocknr.\next4_getfsmap_check_keys checked that keys[0\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a70b49dc7eee5dbe3775a650ce598e3557ff5475",
      "https://git.kernel.org/stable/c/f16054ac1774915160ca4e1c73ff7a269465a1b9",
      "https://git.kernel.org/stable/c/c24f838493792b5e78a3596b4ca96375aa0af4c2",
      "https://git.kernel.org/stable/c/1d2366624b4c19a2ba6baf67fe57f4a1b0f67c05",
      "https://git.kernel.org/stable/c/c5d7c31e17224d847a330180ec1b03bf390632b2",
      "https://git.kernel.org/stable/c/eb3a695aa71a514f2e7f5778e05faba3733b70a0",
      "https://git.kernel.org/stable/c/15ebade3266b300da9cd1edce4004fe8fd6a2b88",
      "https://git.kernel.org/stable/c/c993799baf9c5861f8df91beb80e1611b12efcbd"
    ],
    "受影响版本": [
      "4a4956249dac0b9b0027949907bff0cd1a9b57fa",
      "4a4956249dac0b9b0027949907bff0cd1a9b57fa",
      "4a4956249dac0b9b0027949907bff0cd1a9b57fa",
      "4a4956249dac0b9b0027949907bff0cd1a9b57fa",
      "4a4956249dac0b9b0027949907bff0cd1a9b57fa",
      "4a4956249dac0b9b0027949907bff0cd1a9b57fa",
      "4a4956249dac0b9b0027949907bff0cd1a9b57fa",
      "4a4956249dac0b9b0027949907bff0cd1a9b57fa"
    ],
    "公开日期": "2025年05月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53103",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbonding: restore bond's IFF_SLAVE flag if a non-eth dev enslave fails\n\nsyzbot reported a warning[1] where the bond device itself is a slave and\nwe try to enslave a non-ethernet device as the first slave which fails\nbut then in the error path when ether_setup() restores the bond device\nit also clears all flags. In my previous fix[2] I restored the\nIFF_MASTER flag, but I didn't consider the case that the bond device\nitself might also be a slave with IFF_SLAVE set, so we need to restore\nthat flag as well. Use the bond_ether_setup helper which does the right\nthing and restores the bond's flags properly.\n\nSteps to reproduce using a nlmon dev:\n $ ip l add nlmon0 type nlmon\n $ ip l add bond1 type bond\n $ ip l add bond2 type bond\n $ ip l set bond1 master bond2\n $ ip l set dev nlmon0 master bond1\n $ ip -d l sh dev bond1\n 22: bond1: <BROADCAST,MULTICAST,MASTER> mtu 1500 qdisc noqueue master bond2 state DOWN mode DEFAULT group default qlen 1000\n (now bond1's IFF_SLAVE flag is gone and we'll hit a warning[3] if we\n  try to delete it)\n\n[1] https://syzkaller.appspot.com/bug?id=391c7b1f6522182899efba27d891f1743e8eb3ef\n[2] commit 7d5cd2ce5292 (\"bonding: correctly handle bonding type change on enslave failure\")\n[3] example warning:\n [   27.008664] bond1: (slave nlmon0): The slave device specified does not support setting the MAC address\n [   27.008692] bond1: (slave nlmon0): Error -95 calling set_mac_address\n [   32.464639] bond1 (unregistering): Released all slaves\n [   32.464685] ------------[ cut here ]------------\n [   32.464686] WARNING: CPU: 1 PID: 2004 at net/core/dev.c:10829 unregister_netdevice_many+0x72a/0x780\n [   32.464694] Modules linked in: br_netfilter bridge bonding virtio_net\n [   32.464699] CPU: 1 PID: 2004 Comm: ip Kdump: loaded Not tainted 5.18.0-rc3+ #47\n [   32.464703] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.1-2.fc37 04/01/2014\n [   32.464704] RIP: 0010:unregister_netdevice_many+0x72a/0x780\n [   32.464707] Code: 99 fd ff ff ba 90 1a 00 00 48 c7 c6 f4 02 66 96 48 c7 c7 20 4d 35 96 c6 05 fa c7 2b 02 01 e8 be 6f 4a 00 0f 0b e9 73 fd ff ff <0f> 0b e9 5f fd ff ff 80 3d e3 c7 2b 02 00 0f 85 3b fd ff ff ba 59\n [   32.464710] RSP: 0018:ffffa006422d7820 EFLAGS: 00010206\n [   32.464712] RAX: ffff8f6e077140a0 RBX: ffffa006422d7888 RCX: 0000000000000000\n [   32.464714] RDX: ffff8f6e12edbe58 RSI: 0000000000000296 RDI: ffffffff96d4a520\n [   32.464716] RBP: ffff8f6e07714000 R08: ffffffff96d63600 R09: ffffa006422d7728\n [   32.464717] R10: 0000000000000ec0 R11: ffffffff9698c988 R12: ffff8f6e12edb140\n [   32.464719] R13: dead000000000122 R14: dead000000000100 R15: ffff8f6e12edb140\n [   32.464723] FS:  00007f297c2f1740(0000) GS:ffff8f6e5d900000(0000) knlGS:0000000000000000\n [   32.464725] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n [   32.464726] CR2: 00007f297bf1c800 CR3: 00000000115e8000 CR4: 0000000000350ee0\n [   32.464730] Call Trace:\n [   32.464763]  <TASK>\n [   32.464767]  rtnl_dellink+0x13e/0x380\n [   32.464776]  ? cred_has_capability.isra.0+0x68/0x100\n [   32.464780]  ? __rtnl_unlock+0x33/0x60\n [   32.464783]  ? bpf_lsm_capset+0x10/0x10\n [   32.464786]  ? security_capable+0x36/0x50\n [   32.464790]  rtnetlink_rcv_msg+0x14e/0x3b0\n [   32.464792]  ? _copy_to_iter+0xb1/0x790\n [   32.464796]  ? post_alloc_hook+0xa0/0x160\n [   32.464799]  ? rtnl_calcit.isra.0+0x110/0x110\n [   32.464802]  netlink_rcv_skb+0x50/0xf0\n [   32.464806]  netlink_unicast+0x216/0x340\n [   32.464809]  netlink_sendmsg+0x23f/0x480\n [   32.464812]  sock_sendmsg+0x5e/0x60\n [   32.464815]  ____sys_sendmsg+0x22c/0x270\n [   32.464818]  ? import_iovec+0x17/0x20\n [   32.464821]  ? sendmsg_copy_msghdr+0x59/0x90\n [   32.464823]  ? do_set_pte+0xa0/0xe0\n [   32.464828]  ___sys_sendmsg+0x81/0xc0\n [   32.464832]  ? mod_objcg_state+0xc6/0x300\n [   32.464835]  ? refill_obj_stock+0xa9/0x160\n [   32.464838]  ? memcg_slab_free_hook+0x1a5/0x1f0\n [   32.464842]  __sys_sendm\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/93c8cbeb1b2b8ff670b3dfd01b3abd843995c80f",
      "https://git.kernel.org/stable/c/ecb1b5135bd3f232d5335b3935e2c2ac11bfa02f",
      "https://git.kernel.org/stable/c/0276813b8ab08d9bf5ca4159f301d0829ecf13fc",
      "https://git.kernel.org/stable/c/e667d469098671261d558be0cd93dca4d285ce1e"
    ],
    "受影响版本": [
      "7d5cd2ce5292b45e555de776cb9e72975a07460d",
      "7d5cd2ce5292b45e555de776cb9e72975a07460d",
      "7d5cd2ce5292b45e555de776cb9e72975a07460d",
      "7d5cd2ce5292b45e555de776cb9e72975a07460d"
    ],
    "公开日期": "2025年05月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53100",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix WARNING in ext4_update_inline_data\n\nSyzbot found the following issue:\nEXT4-fs (loop0): mounted filesystem 00000000-0000-0000-0000-000000000000 without journal. Quota mode: none.\nfscrypt: AES-256-CTS-CBC using implementation \"cts-cbc-aes-aesni\"\nfscrypt: AES-256-XTS using implementation \"xts-aes-aesni\"\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 5071 at mm/page_alloc.c:5525 __alloc_pages+0x30a/0x560 mm/page_alloc.c:5525\nModules linked in:\nCPU: 1 PID: 5071 Comm: syz-executor263 Not tainted 6.2.0-rc1-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022\nRIP: 0010:__alloc_pages+0x30a/0x560 mm/page_alloc.c:5525\nRSP: 0018:ffffc90003c2f1c0 EFLAGS: 00010246\nRAX: ffffc90003c2f220 RBX: 0000000000000014 RCX: 0000000000000000\nRDX: 0000000000000028 RSI: 0000000000000000 RDI: ffffc90003c2f248\nRBP: ffffc90003c2f2d8 R08: dffffc0000000000 R09: ffffc90003c2f220\nR10: fffff52000785e49 R11: 1ffff92000785e44 R12: 0000000000040d40\nR13: 1ffff92000785e40 R14: dffffc0000000000 R15: 1ffff92000785e3c\nFS:  0000555556c0d300(0000) GS:ffff8880b9800000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f95d5e04138 CR3: 00000000793aa000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n __alloc_pages_node include/linux/gfp.h:237 [inline]\n alloc_pages_node include/linux/gfp.h:260 [inline]\n __kmalloc_large_node+0x95/0x1e0 mm/slab_common.c:1113\n __do_kmalloc_node mm/slab_common.c:956 [inline]\n __kmalloc+0xfe/0x190 mm/slab_common.c:981\n kmalloc include/linux/slab.h:584 [inline]\n kzalloc include/linux/slab.h:720 [inline]\n ext4_update_inline_data+0x236/0x6b0 fs/ext4/inline.c:346\n ext4_update_inline_dir fs/ext4/inline.c:1115 [inline]\n ext4_try_add_inline_entry+0x328/0x990 fs/ext4/inline.c:1307\n ext4_add_entry+0x5a4/0xeb0 fs/ext4/namei.c:2385\n ext4_add_nondir+0x96/0x260 fs/ext4/namei.c:2772\n ext4_create+0x36c/0x560 fs/ext4/namei.c:2817\n lookup_open fs/namei.c:3413 [inline]\n open_last_lookups fs/namei.c:3481 [inline]\n path_openat+0x12ac/0x2dd0 fs/namei.c:3711\n do_filp_open+0x264/0x4f0 fs/namei.c:3741\n do_sys_openat2+0x124/0x4e0 fs/open.c:1310\n do_sys_open fs/open.c:1326 [inline]\n __do_sys_openat fs/open.c:1342 [inline]\n __se_sys_openat fs/open.c:1337 [inline]\n __x64_sys_openat+0x243/0x290 fs/open.c:1337\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nAbove issue happens as follows:\next4_iget\n   ext4_find_inline_data_nolock ->i_inline_off=164 i_inline_size=60\next4_try_add_inline_entry\n   __ext4_mark_inode_dirty\n      ext4_expand_extra_isize_ea ->i_extra_isize=32 s_want_extra_isize=44\n         ext4_xattr_shift_entries\n\t ->after shift i_inline_off is incorrect, actually is change to 176\next4_try_add_inline_entry\n  ext4_update_inline_dir\n    get_max_inline_xattr_value_size\n      if (EXT4_I(inode)->i_inline_off)\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\tEXT4_I(inode)->i_inline_off);\n        free += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size));\n\t->As entry is incorrect, then 'free' may be negative\n   ext4_update_inline_data\n      value = kzalloc(len, GFP_NOFS);\n      -> len is unsigned int, maybe very large, then trigger warning when\n         'kzalloc()'\n\nTo resolve the above issue we need to update 'i_inline_off' after\n'ext4_xattr_shift_entries()'.  We do not need to set\nEXT4_STATE_MAY_INLINE_DATA flag here, since ext4_mark_inode_dirty()\nalready sets this flag if needed.  Setting EXT4_STATE_MAY_INLINE_DATA\nwhen it is needed may trigger a BUG_ON in ext4_writepages().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c5aa102b433b1890e1ccaa40c06826c77dda1665",
      "https://git.kernel.org/stable/c/39c5df2ca544368b44b59d0f6d80131e90763371",
      "https://git.kernel.org/stable/c/74d775083e9f3d9dadf9e3b5f3e0028d1ad0bd5c",
      "https://git.kernel.org/stable/c/a9bd94f67b27739bbe8583c52256502bd4cc7e83",
      "https://git.kernel.org/stable/c/ca500cf2eceb5a8e93bf71ab97b5f7a18ecabce2",
      "https://git.kernel.org/stable/c/35161cec76772f74526f5886ad4082ec48511d5c",
      "https://git.kernel.org/stable/c/92eee6a82a9a6f9f83559e17a2b6b935e1a5cd25",
      "https://git.kernel.org/stable/c/2b96b4a5d9443ca4cad58b0040be455803c05a42"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53095",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/ttm: Fix a NULL pointer dereference\n\nThe LRU mechanism may look up a resource in the process of being removed\nfrom an object. The locking rules here are a bit unclear but it looks\ncurrently like res->bo assignment is protected by the LRU lock, whereas\nbo->resource is protected by the object lock, while *clearing* of\nbo->resource is also protected by the LRU lock. This means that if\nwe check that bo->resource points to the LRU resource under the LRU\nlock we should be safe.\nSo perform that check before deciding to swap out a bo. That avoids\ndereferencing a NULL bo->resource in ttm_bo_swapout().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9ba1720f6c4a0f13c3f3cb5c28132ee75555d04f",
      "https://git.kernel.org/stable/c/9d9b1f9f7a72d83ebf173534e76b246349f32374",
      "https://git.kernel.org/stable/c/9a9a8fe26751334b7739193a94eba741073b8a55"
    ],
    "受影响版本": [
      "6a9b028994025f5033f10d1da30b29dfdc713384",
      "6a9b028994025f5033f10d1da30b29dfdc713384",
      "6a9b028994025f5033f10d1da30b29dfdc713384"
    ],
    "公开日期": "2025年05月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53090",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdkfd: Fix an illegal memory access\n\nIn the kfd_wait_on_events() function, the kfd_event_waiter structure is\nallocated by alloc_event_waiters(), but the event field of the waiter\nstructure is not initialized; When copy_from_user() fails in the\nkfd_wait_on_events() function, it will enter exception handling to\nrelease the previously allocated memory of the waiter structure;\nDue to the event field of the waiters structure being accessed\nin the free_waiters() function, this results in illegal memory access\nand system crash, here is the crash log:\n\nlocalhost kernel: RIP: 0010:native_queued_spin_lock_slowpath+0x185/0x1e0\nlocalhost kernel: RSP: 0018:ffffaa53c362bd60 EFLAGS: 00010082\nlocalhost kernel: RAX: ff3d3d6bff4007cb RBX: 0000000000000282 RCX: 00000000002c0000\nlocalhost kernel: RDX: ffff9e855eeacb80 RSI: 000000000000279c RDI: ffffe7088f6a21d0\nlocalhost kernel: RBP: ffffe7088f6a21d0 R08: 00000000002c0000 R09: ffffaa53c362be64\nlocalhost kernel: R10: ffffaa53c362bbd8 R11: 0000000000000001 R12: 0000000000000002\nlocalhost kernel: R13: ffff9e7ead15d600 R14: 0000000000000000 R15: ffff9e7ead15d698\nlocalhost kernel: FS:  0000152a3d111700(0000) GS:ffff9e855ee80000(0000) knlGS:0000000000000000\nlocalhost kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nlocalhost kernel: CR2: 0000152938000010 CR3: 000000044d7a4000 CR4: 00000000003506e0\nlocalhost kernel: Call Trace:\nlocalhost kernel: _raw_spin_lock_irqsave+0x30/0x40\nlocalhost kernel: remove_wait_queue+0x12/0x50\nlocalhost kernel: kfd_wait_on_events+0x1b6/0x490 [hydcu]\nlocalhost kernel: ? ftrace_graph_caller+0xa0/0xa0\nlocalhost kernel: kfd_ioctl+0x38c/0x4a0 [hydcu]\nlocalhost kernel: ? kfd_ioctl_set_trap_handler+0x70/0x70 [hydcu]\nlocalhost kernel: ? kfd_ioctl_create_queue+0x5a0/0x5a0 [hydcu]\nlocalhost kernel: ? ftrace_graph_caller+0xa0/0xa0\nlocalhost kernel: __x64_sys_ioctl+0x8e/0xd0\nlocalhost kernel: ? syscall_trace_enter.isra.18+0x143/0x1b0\nlocalhost kernel: do_syscall_64+0x33/0x80\nlocalhost kernel: entry_SYSCALL_64_after_hwframe+0x44/0xa9\nlocalhost kernel: RIP: 0033:0x152a4dff68d7\n\nAllocate the structure with kcalloc, and remove redundant 0-initialization\nand a redundant loop condition check.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5a3fb3b745af0ce46ec2e0c8e507bae45b937334",
      "https://git.kernel.org/stable/c/bbf5eada4334a96e3a204b2307ff5b14dc380b0b",
      "https://git.kernel.org/stable/c/6936525142a015e854d0a23e9ad9ea0a28b3843d",
      "https://git.kernel.org/stable/c/2fece63b55c5d74cd6f5de51159e2cde37e10555",
      "https://git.kernel.org/stable/c/d9923e7214a870b312bf61f6a89c7554d0966985",
      "https://git.kernel.org/stable/c/61f306f8df0d5559659c5578cf6d95236bcdcb25",
      "https://git.kernel.org/stable/c/4fc8fff378b2f2039f2a666d9f8c570f4e58352c"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53067",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nLoongArch: Only call get_timer_irq() once in constant_clockevent_init()\n\nUnder CONFIG_DEBUG_ATOMIC_SLEEP=y and CONFIG_DEBUG_PREEMPT=y, we can see\nthe following messages on LoongArch, this is because using might_sleep()\nin preemption disable context.\n\n[    0.001127] smp: Bringing up secondary CPUs ...\n[    0.001222] Booting CPU#1...\n[    0.001244] 64-bit Loongson Processor probed (LA464 Core)\n[    0.001247] CPU1 revision is: 0014c012 (Loongson-64bit)\n[    0.001250] FPU1 revision is: 00000000\n[    0.001252] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:283\n[    0.001255] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 0, name: swapper/1\n[    0.001257] preempt_count: 1, expected: 0\n[    0.001258] RCU nest depth: 0, expected: 0\n[    0.001259] Preemption disabled at:\n[    0.001261] [<9000000000223800>] arch_dup_task_struct+0x20/0x110\n[    0.001272] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 6.2.0-rc7+ #43\n[    0.001275] Hardware name: Loongson Loongson-3A5000-7A1000-1w-A2101/Loongson-LS3A5000-7A1000-1w-A2101, BIOS vUDK2018-LoongArch-V4.0.05132-beta10 12/13/202\n[    0.001277] Stack : 0072617764726148 0000000000000000 9000000000222f1c 90000001001e0000\n[    0.001286]         90000001001e3be0 90000001001e3be8 0000000000000000 0000000000000000\n[    0.001292]         90000001001e3be8 0000000000000040 90000001001e3cb8 90000001001e3a50\n[    0.001297]         9000000001642000 90000001001e3be8 be694d10ce4139dd 9000000100174500\n[    0.001303]         0000000000000001 0000000000000001 00000000ffffe0a2 0000000000000020\n[    0.001309]         000000000000002f 9000000001354116 00000000056b0000 ffffffffffffffff\n[    0.001314]         0000000000000000 0000000000000000 90000000014f6e90 9000000001642000\n[    0.001320]         900000000022b69c 0000000000000001 0000000000000000 9000000001736a90\n[    0.001325]         9000000100038000 0000000000000000 9000000000222f34 0000000000000000\n[    0.001331]         00000000000000b0 0000000000000004 0000000000000000 0000000000070000\n[    0.001337]         ...\n[    0.001339] Call Trace:\n[    0.001342] [<9000000000222f34>] show_stack+0x5c/0x180\n[    0.001346] [<90000000010bdd80>] dump_stack_lvl+0x60/0x88\n[    0.001352] [<9000000000266418>] __might_resched+0x180/0x1cc\n[    0.001356] [<90000000010c742c>] mutex_lock+0x20/0x64\n[    0.001359] [<90000000002a8ccc>] irq_find_matching_fwspec+0x48/0x124\n[    0.001364] [<90000000002259c4>] constant_clockevent_init+0x68/0x204\n[    0.001368] [<900000000022acf4>] start_secondary+0x40/0xa8\n[    0.001371] [<90000000010c0124>] smpboot_entry+0x60/0x64\n\nHere are the complete call chains:\n\nsmpboot_entry()\n  start_secondary()\n    constant_clockevent_init()\n      get_timer_irq()\n        irq_find_matching_fwnode()\n          irq_find_matching_fwspec()\n            mutex_lock()\n              might_sleep()\n                __might_sleep()\n                  __might_resched()\n\nIn order to avoid the above issue, we should break the call chains,\nusing timer_irq_installed variable as check condition to only call\nget_timer_irq() once in constant_clockevent_init() is a simple and\nproper way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b9c379e1d7e141b102f41858c9b8f6f36e7c89a4",
      "https://git.kernel.org/stable/c/acadbd058fa12b510fbecca11eae22bd6f654250",
      "https://git.kernel.org/stable/c/bb7a78e343468873bf00b2b181fcfd3c02d8cb56"
    ],
    "受影响版本": [
      "fa96b57c149061f71a70bd6582d995f6424fbbf4",
      "fa96b57c149061f71a70bd6582d995f6424fbbf4",
      "fa96b57c149061f71a70bd6582d995f6424fbbf4"
    ],
    "公开日期": "2025年05月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53054",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc2: fix a devres leak in hw_enable upon suspend resume\n\nEach time the platform goes to low power, PM suspend / resume routines\ncall: __dwc2_lowlevel_hw_enable -> devm_add_action_or_reset().\nThis adds a new devres each time.\nThis may also happen at runtime, as dwc2_lowlevel_hw_enable() can be\ncalled from udc_start().\n\nThis can be seen with tracing:\n- echo 1 > /sys/kernel/debug/tracing/events/dev/devres_log/enable\n- go to low power\n- cat /sys/kernel/debug/tracing/trace\n\nA new \"ADD\" entry is found upon each low power cycle:\n... devres_log: 49000000.usb-otg ADD 82a13bba devm_action_release (8 bytes)\n... devres_log: 49000000.usb-otg ADD 49889daf devm_action_release (8 bytes)\n...\n\nA second issue is addressed here:\n- regulator_bulk_enable() is called upon each PM cycle (suspend/resume).\n- regulator_bulk_disable() never gets called.\n\nSo the reference count for these regulators constantly increase, by one\nupon each low power cycle, due to missing regulator_bulk_disable() call\nin __dwc2_lowlevel_hw_disable().\n\nThe original fix that introduced the devm_add_action_or_reset() call,\nfixed an issue during probe, that happens due to other errors in\ndwc2_driver_probe() -> dwc2_core_reset(). Then the probe fails without\ndisabling regulators, when dr_mode == USB_DR_MODE_PERIPHERAL.\n\nRather fix the error path: disable all the low level hardware in the\nerror path, by using the \"hsotg->ll_hw_enabled\" flag. Checking dr_mode\nhas been introduced to avoid a dual call to dwc2_lowlevel_hw_disable().\n\"ll_hw_enabled\" should achieve the same (and is used currently in the\nremove() routine).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1f01027c51eb16145e8e07fafea3ca07ef102d06",
      "https://git.kernel.org/stable/c/cba76e1fb896b573f09f51aa299223276a77bc90",
      "https://git.kernel.org/stable/c/ffb8ab6f87bd28d700ab5c20d9d3a7e75067630d",
      "https://git.kernel.org/stable/c/6485fc381b6528b6f547ee1ff10bdbcbe31a6e4c",
      "https://git.kernel.org/stable/c/f747313249b74f323ddf841a9c8db14d989f296a"
    ],
    "受影响版本": [
      "33a06f1300a79cfd461cea0268f05e969d4f34ec",
      "33a06f1300a79cfd461cea0268f05e969d4f34ec",
      "33a06f1300a79cfd461cea0268f05e969d4f34ec",
      "33a06f1300a79cfd461cea0268f05e969d4f34ec",
      "33a06f1300a79cfd461cea0268f05e969d4f34ec",
      "c95e1f67b9a84479d1a6d2e9b123a1553af2a75e",
      "7d2a4749e1589295c69183f7d79d5b62664b34d6",
      "8a8841b9f3eb1f46e3fc6d56a9b9299c53f4f86f",
      "fa7fd9ba18533e9aa5f718a06de3deb522a4b587",
      "b2c2b88b049684b89776036f9a03fcc2d1bb3c22",
      "e7c4b79d70a70b4b7b0a04c640238a2ef0a7a8c8",
      "88dcd13872b11bd60e6d4cb6317821e1d367e524"
    ],
    "公开日期": "2025年05月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53048",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: tcpm: fix warning when handle discover_identity message\n\nSince both source and sink device can send discover_identity message in\nPD3, kernel may dump below warning:\n\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 169 at drivers/usb/typec/tcpm/tcpm.c:1446 tcpm_queue_vdm+0xe0/0xf0\nModules linked in:\nCPU: 0 PID: 169 Comm: 1-0050 Not tainted 6.1.1-00038-g6a3c36cf1da2-dirty #567\nHardware name: NXP i.MX8MPlus EVK board (DT)\npstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : tcpm_queue_vdm+0xe0/0xf0\nlr : tcpm_queue_vdm+0x2c/0xf0\nsp : ffff80000c19bcd0\nx29: ffff80000c19bcd0 x28: 0000000000000001 x27: ffff0000d11c8ab8\nx26: ffff0000d11cc000 x25: 0000000000000000 x24: 00000000ff008081\nx23: 0000000000000001 x22: 00000000ff00a081 x21: ffff80000c19bdbc\nx20: 0000000000000000 x19: ffff0000d11c8080 x18: ffffffffffffffff\nx17: 0000000000000000 x16: 0000000000000000 x15: ffff0000d716f580\nx14: 0000000000000001 x13: ffff0000d716f507 x12: 0000000000000001\nx11: 0000000000000000 x10: 0000000000000020 x9 : 00000000000ee098\nx8 : 00000000ffffffff x7 : 000000000000001c x6 : ffff0000d716f580\nx5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000\nx2 : ffff80000c19bdbc x1 : 00000000ff00a081 x0 : 0000000000000004\nCall trace:\ntcpm_queue_vdm+0xe0/0xf0\ntcpm_pd_rx_handler+0x340/0x1ab0\nkthread_worker_fn+0xcc/0x18c\nkthread+0x10c/0x110\nret_from_fork+0x10/0x20\n---[ end trace 0000000000000000 ]---\n\nBelow sequences may trigger this warning:\n\ntcpm_send_discover_work(work)\n  tcpm_send_vdm(port, USB_SID_PD, CMD_DISCOVER_IDENT, NULL, 0);\n   tcpm_queue_vdm(port, header, data, count);\n    port->vdm_state = VDM_STATE_READY;\n\nvdm_state_machine_work(work);\n\t\t\t<-- received discover_identity from partner\n vdm_run_state_machine(port);\n  port->vdm_state = VDM_STATE_SEND_MESSAGE;\n   mod_vdm_delayed_work(port, x);\n\ntcpm_pd_rx_handler(work);\n tcpm_pd_data_request(port, msg);\n  tcpm_handle_vdm_request(port, msg->payload, cnt);\n   tcpm_queue_vdm(port, response[0], &response[1], rlen - 1);\n--> WARN_ON(port->vdm_state > VDM_STATE_DONE);\n\nFor this case, the state machine could still send out discover\nidentity message later if we skip current discover_identity message.\nSo we should handle the received message firstly and override the pending\ndiscover_identity message without warning in this case. Then, a delayed\nsend_discover work will send discover_identity message again.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/bb579b3f75c60bf488a7c36e092e8be583407d53",
      "https://git.kernel.org/stable/c/d55ca2d2ea1a7ec553213986993fba8c0257381c",
      "https://git.kernel.org/stable/c/e37d2c489d71e94ed4a39529bc9520a7fd983d42",
      "https://git.kernel.org/stable/c/abfc4fa28f0160df61c7149567da4f6494dfb488"
    ],
    "受影响版本": [
      "e00943e916782ae17ca05d654779a84f09481ab8",
      "e00943e916782ae17ca05d654779a84f09481ab8",
      "e00943e916782ae17ca05d654779a84f09481ab8",
      "e00943e916782ae17ca05d654779a84f09481ab8"
    ],
    "公开日期": "2025年05月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53046",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Fix race condition in hci_cmd_sync_clear\n\nThere is a potential race condition in hci_cmd_sync_work and\nhci_cmd_sync_clear, and could lead to use-after-free. For instance,\nhci_cmd_sync_work is added to the 'req_workqueue' after cancel_work_sync\nThe entry of 'cmd_sync_work_list' may be freed in hci_cmd_sync_clear, and\ncausing kernel panic when it is used in 'hci_cmd_sync_work'.\n\nHere's the call trace:\n\ndump_stack_lvl+0x49/0x63\nprint_report.cold+0x5e/0x5d3\n? hci_cmd_sync_work+0x282/0x320\nkasan_report+0xaa/0x120\n? hci_cmd_sync_work+0x282/0x320\n__asan_report_load8_noabort+0x14/0x20\nhci_cmd_sync_work+0x282/0x320\nprocess_one_work+0x77b/0x11c0\n? _raw_spin_lock_irq+0x8e/0xf0\nworker_thread+0x544/0x1180\n? poll_idle+0x1e0/0x1e0\nkthread+0x285/0x320\n? process_one_work+0x11c0/0x11c0\n? kthread_complete_and_exit+0x30/0x30\nret_from_fork+0x22/0x30\n</TASK>\n\nAllocated by task 266:\nkasan_save_stack+0x26/0x50\n__kasan_kmalloc+0xae/0xe0\nkmem_cache_alloc_trace+0x191/0x350\nhci_cmd_sync_queue+0x97/0x2b0\nhci_update_passive_scan+0x176/0x1d0\nle_conn_complete_evt+0x1b5/0x1a00\nhci_le_conn_complete_evt+0x234/0x340\nhci_le_meta_evt+0x231/0x4e0\nhci_event_packet+0x4c5/0xf00\nhci_rx_work+0x37d/0x880\nprocess_one_work+0x77b/0x11c0\nworker_thread+0x544/0x1180\nkthread+0x285/0x320\nret_from_fork+0x22/0x30\n\nFreed by task 269:\nkasan_save_stack+0x26/0x50\nkasan_set_track+0x25/0x40\nkasan_set_free_info+0x24/0x40\n____kasan_slab_free+0x176/0x1c0\n__kasan_slab_free+0x12/0x20\nslab_free_freelist_hook+0x95/0x1a0\nkfree+0xba/0x2f0\nhci_cmd_sync_clear+0x14c/0x210\nhci_unregister_dev+0xff/0x440\nvhci_release+0x7b/0xf0\n__fput+0x1f3/0x970\n____fput+0xe/0x20\ntask_work_run+0xd4/0x160\ndo_exit+0x8b0/0x22a0\ndo_group_exit+0xba/0x2a0\nget_signal+0x1e4a/0x25b0\narch_do_signal_or_restart+0x93/0x1f80\nexit_to_user_mode_prepare+0xf5/0x1a0\nsyscall_exit_to_user_mode+0x26/0x50\nret_from_fork+0x15/0x30",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/608901a77c945ac15dea23f6098c9882ef19d9f0",
      "https://git.kernel.org/stable/c/be586211a3ab40a4f4ca60450e0d31606afc55ec",
      "https://git.kernel.org/stable/c/1c66bee492a5fe00ae3fe890bb693bfc99f994c6"
    ],
    "受影响版本": [
      "6a98e3836fa2077b169f10a35c2ca9952d53f987",
      "6a98e3836fa2077b169f10a35c2ca9952d53f987",
      "6a98e3836fa2077b169f10a35c2ca9952d53f987"
    ],
    "公开日期": "2025年05月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53024",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix pointer-leak due to insufficient speculative store bypass mitigation\n\nTo mitigate Spectre v4, 2039f26f3aca (\"bpf: Fix leakage due to\ninsufficient speculative store bypass mitigation\") inserts lfence\ninstructions after 1) initializing a stack slot and 2) spilling a\npointer to the stack.\n\nHowever, this does not cover cases where a stack slot is first\ninitialized with a pointer (subject to sanitization) but then\noverwritten with a scalar (not subject to sanitization because\nthe slot was already initialized). In this case, the second write\nmay be subject to speculative store bypass (SSB) creating a\nspeculative pointer-as-scalar type confusion. This allows the\nprogram to subsequently leak the numerical pointer value using,\nfor example, a branch-based cache side channel.\n\nTo fix this, also sanitize scalars if they write a stack slot\nthat previously contained a pointer. Assuming that pointer-spills\nare only generated by LLVM on register-pressure, the performance\nimpact on most real-world BPF programs should be small.\n\nThe following unprivileged BPF bytecode drafts a minimal exploit\nand the mitigation:\n\n  [...]\n  // r6 = 0 or 1 (skalar, unknown user input)\n  // r7 = accessible ptr for side channel\n  // r10 = frame pointer (fp), to be leaked\n  //\n  r9 = r10 # fp alias to encourage ssb\n  *(u64 *)(r9 - 8) = r10 // fp[-8] = ptr, to be leaked\n  // lfence added here because of pointer spill to stack.\n  //\n  // Ommitted: Dummy bpf_ringbuf_output() here to train alias predictor\n  // for no r9-r10 dependency.\n  //\n  *(u64 *)(r10 - 8) = r6 // fp[-8] = scalar, overwrites ptr\n  // 2039f26f3aca: no lfence added because stack slot was not STACK_INVALID,\n  // store may be subject to SSB\n  //\n  // fix: also add an lfence when the slot contained a ptr\n  //\n  r8 = *(u64 *)(r9 - 8)\n  // r8 = architecturally a scalar, speculatively a ptr\n  //\n  // leak ptr using branch-based cache side channel:\n  r8 &= 1 // choose bit to leak\n  if r8 == 0 goto SLOW // no mispredict\n  // architecturally dead code if input r6 is 0,\n  // only executes speculatively iff ptr bit is 1\n  r8 = *(u64 *)(r7 + 0) # encode bit in cache (0: slow, 1: fast)\nSLOW:\n  [...]\n\nAfter running this, the program can time the access to *(r7 + 0) to\ndetermine whether the chosen pointer bit was 0 or 1. Repeat this 64\ntimes to recover the whole address on amd64.\n\nIn summary, sanitization can only be skipped if one scalar is\noverwritten with another scalar. Scalar-confusion due to speculative\nstore bypass can not lead to invalid accesses because the pointer\nbounds deducted during verification are enforced using branchless\nlogic. See 979d63d50c0c (\"bpf: prevent out of bounds speculation on\npointer arithmetic\") for details.\n\nDo not make the mitigation depend on !env->allow_{uninit_stack,ptr_leaks}\nbecause speculative leaks are likely unexpected if these were enabled.\nFor example, leaking the address to a protected log file may be acceptable\nwhile disabling the mitigation might unintentionally leak the address\ninto the cached-state of a map that is accessible to unprivileged\nprocesses.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/aae109414a57ab4164218f36e2e4a17f027fcaaa",
      "https://git.kernel.org/stable/c/81b3374944d201872cfcf82730a7860f8e7c31dd",
      "https://git.kernel.org/stable/c/da75dec7c6617bddad418159ffebcb133f008262",
      "https://git.kernel.org/stable/c/01bdcc73dbe7be3ad4d4ee9a59b71e42f461a528",
      "https://git.kernel.org/stable/c/b0c89ef025562161242a7c19b213bd6b272e93df",
      "https://git.kernel.org/stable/c/e4f4db47794c9f474b184ee1418f42e6a07412b6"
    ],
    "受影响版本": [
      "872968502114d68c21419cf7eb5ab97717e7b803",
      "f5893af2704eb763eb982f01d573f5b19f06b623",
      "0e9280654aa482088ee6ef3deadef331f5ac5fb0",
      "2039f26f3aca5b0e419b98f65dd36481337b86ee",
      "2039f26f3aca5b0e419b98f65dd36481337b86ee",
      "2039f26f3aca5b0e419b98f65dd36481337b86ee",
      "0b27bdf02c400684225ee5ee99970bcbf5082282"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53016",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: Fix possible deadlock in rfcomm_sk_state_change\n\nsyzbot reports a possible deadlock in rfcomm_sk_state_change [1].\nWhile rfcomm_sock_connect acquires the sk lock and waits for\nthe rfcomm lock, rfcomm_sock_release could have the rfcomm\nlock and hit a deadlock for acquiring the sk lock.\nHere's a simplified flow:\n\nrfcomm_sock_connect:\n  lock_sock(sk)\n  rfcomm_dlc_open:\n    rfcomm_lock()\n\nrfcomm_sock_release:\n  rfcomm_sock_shutdown:\n    rfcomm_lock()\n    __rfcomm_dlc_close:\n        rfcomm_k_state_change:\n\t  lock_sock(sk)\n\nThis patch drops the sk lock before calling rfcomm_dlc_open to\navoid the possible deadlock and holds sk's reference count to\nprevent use-after-free after rfcomm_dlc_open completes.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/98aec50ff7f60cc6f2d6a4396b475c547e58b04d",
      "https://git.kernel.org/stable/c/17511bd84871f4a6106cb335616e086880313f3f",
      "https://git.kernel.org/stable/c/1d80d57ffcb55488f0ec0b77928d4f82d16b6a90"
    ],
    "受影响版本": [
      "1804fdf6e494e5e2938c65d8391690b59bcff897",
      "1804fdf6e494e5e2938c65d8391690b59bcff897",
      "1804fdf6e494e5e2938c65d8391690b59bcff897"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-53013",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nptdma: pt_core_execute_cmd() should use spinlock\n\nThe interrupt handler (pt_core_irq_handler()) of the ptdma\ndriver can be called from interrupt context. The code flow\nin this function can lead down to pt_core_execute_cmd() which\nwill attempt to grab a mutex, which is not appropriate in\ninterrupt context and ultimately leads to a kernel panic.\nThe fix here changes this mutex to a spinlock, which has\nbeen verified to resolve the issue.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ed0d8f731e0bf1bb12a7a37698ac613db20e2794",
      "https://git.kernel.org/stable/c/13ba563c2c8055ba8a637c9f70bb833b43cb4207",
      "https://git.kernel.org/stable/c/95e5fda3b5f9ed8239b145da3fa01e641cf5d53c"
    ],
    "受影响版本": [
      "fa5d823b16a9442d609617abeec31da8b6afa224",
      "fa5d823b16a9442d609617abeec31da8b6afa224",
      "fa5d823b16a9442d609617abeec31da8b6afa224"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52934",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/MADV_COLLAPSE: catch !none !huge !bad pmd lookups\n\nIn commit 34488399fa08 (\"mm/madvise: add file and shmem support to\nMADV_COLLAPSE\") we make the following change to find_pmd_or_thp_or_none():\n\n\t-       if (!pmd_present(pmde))\n\t-               return SCAN_PMD_NULL;\n\t+       if (pmd_none(pmde))\n\t+               return SCAN_PMD_NONE;\n\nThis was for-use by MADV_COLLAPSE file/shmem codepaths, where\nMADV_COLLAPSE might identify a pte-mapped hugepage, only to have\nkhugepaged race-in, free the pte table, and clear the pmd.  Such codepaths\ninclude:\n\nA) If we find a suitably-aligned compound page of order HPAGE_PMD_ORDER\n   already in the pagecache.\nB) In retract_page_tables(), if we fail to grab mmap_lock for the target\n   mm/address.\n\nIn these cases, collapse_pte_mapped_thp() really does expect a none (not\njust !present) pmd, and we want to suitably identify that case separate\nfrom the case where no pmd is found, or it's a bad-pmd (of course, many\nthings could happen once we drop mmap_lock, and the pmd could plausibly\nundergo multiple transitions due to intervening fault, split, etc). \nRegardless, the code is prepared install a huge-pmd only when the existing\npmd entry is either a genuine pte-table-mapping-pmd, or the none-pmd.\n\nHowever, the commit introduces a logical hole; namely, that we've allowed\n!none- && !huge- && !bad-pmds to be classified as genuine\npte-table-mapping-pmds.  One such example that could leak through are swap\nentries.  The pmd values aren't checked again before use in\npte_offset_map_lock(), which is expecting nothing less than a genuine\npte-table-mapping-pmd.\n\nWe want to put back the !pmd_present() check (below the pmd_none() check),\nbut need to be careful to deal with subtleties in pmd transitions and\ntreatments by various arch.\n\nThe issue is that __split_huge_pmd_locked() temporarily clears the present\nbit (or otherwise marks the entry as invalid), but pmd_present() and\npmd_trans_huge() still need to return true while the pmd is in this\ntransitory state.  For example, x86's pmd_present() also checks the\n_PAGE_PSE , riscv's version also checks the _PAGE_LEAF bit, and arm64 also\nchecks a PMD_PRESENT_INVALID bit.\n\nCovering all 4 cases for x86 (all checks done on the same pmd value):\n\n1) pmd_present() && pmd_trans_huge()\n   All we actually know here is that the PSE bit is set. Either:\n   a) We aren't racing with __split_huge_page(), and PRESENT or PROTNONE\n      is set.\n      => huge-pmd\n   b) We are currently racing with __split_huge_page().  The danger here\n      is that we proceed as-if we have a huge-pmd, but really we are\n      looking at a pte-mapping-pmd.  So, what is the risk of this\n      danger?\n\n      The only relevant path is:\n\n\tmadvise_collapse() -> collapse_pte_mapped_thp()\n\n      Where we might just incorrectly report back \"success\", when really\n      the memory isn't pmd-backed.  This is fine, since split could\n      happen immediately after (actually) successful madvise_collapse().\n      So, it should be safe to just assume huge-pmd here.\n\n2) pmd_present() && !pmd_trans_huge()\n   Either:\n   a) PSE not set and either PRESENT or PROTNONE is.\n      => pte-table-mapping pmd (or PROT_NONE)\n   b) devmap.  This routine can be called immediately after\n      unlocking/locking mmap_lock -- or called with no locks held (see\n      khugepaged_scan_mm_slot()), so previous VMA checks have since been\n      invalidated.\n\n3) !pmd_present() && pmd_trans_huge()\n  Not possible.\n\n4) !pmd_present() && !pmd_trans_huge()\n  Neither PRESENT nor PROTNONE set\n  => not present\n\nI've checked all archs that implement pmd_trans_huge() (arm64, riscv,\npowerpc, longarch, x86, mips, s390) and this logic roughly translates\n(though devmap treatment is unique to x86 and powerpc, and (3) doesn't\nnecessarily hold in general -- but that doesn't matter since\n!pmd_present() always takes failure path).\n\nAlso, add a comment above find_pmd_or_thp_or_none()\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/96aaaf8666010a39430cecf8a65c7ce2908a030f",
      "https://git.kernel.org/stable/c/edb5d0cf5525357652aff6eacd9850b8ced07143"
    ],
    "受影响版本": [
      "34488399fa08faaf664743fa54b271eb6f9e1321",
      "34488399fa08faaf664743fa54b271eb6f9e1321"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52928",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Skip invalid kfunc call in backtrack_insn\n\nThe verifier skips invalid kfunc call in check_kfunc_call(), which\nwould be captured in fixup_kfunc_call() if such insn is not eliminated\nby dead code elimination. However, this can lead to the following\nwarning in backtrack_insn(), also see [1]:\n\n  ------------[ cut here ]------------\n  verifier backtracking bug\n  WARNING: CPU: 6 PID: 8646 at kernel/bpf/verifier.c:2756 backtrack_insn\n  kernel/bpf/verifier.c:2756\n\t__mark_chain_precision kernel/bpf/verifier.c:3065\n\tmark_chain_precision kernel/bpf/verifier.c:3165\n\tadjust_reg_min_max_vals kernel/bpf/verifier.c:10715\n\tcheck_alu_op kernel/bpf/verifier.c:10928\n\tdo_check kernel/bpf/verifier.c:13821 [inline]\n\tdo_check_common kernel/bpf/verifier.c:16289\n  [...]\n\nSo make backtracking conservative with this by returning ENOTSUPP.\n\n  [1] https://lore.kernel.org/bpf/CACkBjsaXNceR8ZjkLG=dT3P=4A8SBsg0Z5h5PWLryF5=ghKq=g@mail.gmail.com/",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6e2fac197de2c4c041bdd8982cffb104689113f1",
      "https://git.kernel.org/stable/c/74eec8266f37aff609db6a2f2b093e56a11c28c4",
      "https://git.kernel.org/stable/c/d3178e8a434b58678d99257c0387810a24042fb6"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52899",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nAdd exception protection processing for vd in axi_chan_handle_err function\n\nSince there is no protection for vd, a kernel panic will be\ntriggered here in exceptional cases.\n\nYou can refer to the processing of axi_chan_block_xfer_complete function\n\nThe triggered kernel panic is as follows:\n\n[   67.848444] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000060\n[   67.848447] Mem abort info:\n[   67.848449]   ESR = 0x96000004\n[   67.848451]   EC = 0x25: DABT (current EL), IL = 32 bits\n[   67.848454]   SET = 0, FnV = 0\n[   67.848456]   EA = 0, S1PTW = 0\n[   67.848458] Data abort info:\n[   67.848460]   ISV = 0, ISS = 0x00000004\n[   67.848462]   CM = 0, WnR = 0\n[   67.848465] user pgtable: 4k pages, 48-bit VAs, pgdp=00000800c4c0b000\n[   67.848468] [0000000000000060] pgd=0000000000000000, p4d=0000000000000000\n[   67.848472] Internal error: Oops: 96000004 [#1] SMP\n[   67.848475] Modules linked in: dmatest\n[   67.848479] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.10.100-emu_x2rc+ #11\n[   67.848483] pstate: 62000085 (nZCv daIf -PAN -UAO +TCO BTYPE=--)\n[   67.848487] pc : axi_chan_handle_err+0xc4/0x230\n[   67.848491] lr : axi_chan_handle_err+0x30/0x230\n[   67.848493] sp : ffff0803fe55ae50\n[   67.848495] x29: ffff0803fe55ae50 x28: ffff800011212200\n[   67.848500] x27: ffff0800c42c0080 x26: ffff0800c097c080\n[   67.848504] x25: ffff800010d33880 x24: ffff80001139d850\n[   67.848508] x23: ffff0800c097c168 x22: 0000000000000000\n[   67.848512] x21: 0000000000000080 x20: 0000000000002000\n[   67.848517] x19: ffff0800c097c080 x18: 0000000000000000\n[   67.848521] x17: 0000000000000000 x16: 0000000000000000\n[   67.848525] x15: 0000000000000000 x14: 0000000000000000\n[   67.848529] x13: 0000000000000000 x12: 0000000000000040\n[   67.848533] x11: ffff0800c0400248 x10: ffff0800c040024a\n[   67.848538] x9 : ffff800010576cd4 x8 : ffff0800c0400270\n[   67.848542] x7 : 0000000000000000 x6 : ffff0800c04003e0\n[   67.848546] x5 : ffff0800c0400248 x4 : ffff0800c4294480\n[   67.848550] x3 : dead000000000100 x2 : dead000000000122\n[   67.848555] x1 : 0000000000000100 x0 : ffff0800c097c168\n[   67.848559] Call trace:\n[   67.848562]  axi_chan_handle_err+0xc4/0x230\n[   67.848566]  dw_axi_dma_interrupt+0xf4/0x590\n[   67.848569]  __handle_irq_event_percpu+0x60/0x220\n[   67.848573]  handle_irq_event+0x64/0x120\n[   67.848576]  handle_fasteoi_irq+0xc4/0x220\n[   67.848580]  __handle_domain_irq+0x80/0xe0\n[   67.848583]  gic_handle_irq+0xc0/0x138\n[   67.848585]  el1_irq+0xc8/0x180\n[   67.848588]  arch_cpu_idle+0x14/0x2c\n[   67.848591]  default_idle_call+0x40/0x16c\n[   67.848594]  do_idle+0x1f0/0x250\n[   67.848597]  cpu_startup_entry+0x2c/0x60\n[   67.848600]  rest_init+0xc0/0xcc\n[   67.848603]  arch_call_rest_init+0x14/0x1c\n[   67.848606]  start_kernel+0x4cc/0x500\n[   67.848610] Code: eb0002ff 9a9f12d6 f2fbd5a2 f2fbd5a3 (a94602c1)\n[   67.848613] ---[ end trace 585a97036f88203a ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f534dc438828cc3f1f8c6895b8bdfbef079521fb",
      "https://git.kernel.org/stable/c/53dd833fd0a2d8f0118d01ea063a70652689d31e",
      "https://git.kernel.org/stable/c/20d0a6d17e85a8a816a64fa7d7cae616f1617833",
      "https://git.kernel.org/stable/c/5054d001ffaf76155637c5e5b922c11016cd6a5d",
      "https://git.kernel.org/stable/c/51a7ad5b60efac65691729d10745c28fa1016b96",
      "https://git.kernel.org/stable/c/57054fe516d59d03a7bcf1888e82479ccc244f87"
    ],
    "受影响版本": [
      "1fe20f1b84548bbcf48b6659ea171cd46618ea3a",
      "1fe20f1b84548bbcf48b6659ea171cd46618ea3a",
      "1fe20f1b84548bbcf48b6659ea171cd46618ea3a",
      "1fe20f1b84548bbcf48b6659ea171cd46618ea3a",
      "1fe20f1b84548bbcf48b6659ea171cd46618ea3a",
      "1fe20f1b84548bbcf48b6659ea171cd46618ea3a"
    ],
    "公开日期": "2024年08月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52894",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: f_ncm: fix potential NULL ptr deref in ncm_bitrate()\n\nIn Google internal bug 265639009 we've received an (as yet) unreproducible\ncrash report from an aarch64 GKI 5.10.149-android13 running device.\n\nAFAICT the source code is at:\n  https://android.googlesource.com/kernel/common/+/refs/tags/ASB-2022-12-05_13-5.10\n\nThe call stack is:\n  ncm_close() -> ncm_notify() -> ncm_do_notify()\nwith the crash at:\n  ncm_do_notify+0x98/0x270\nCode: 79000d0b b9000a6c f940012a f9400269 (b9405d4b)\n\nWhich I believe disassembles to (I don't know ARM assembly, but it looks sane enough to me...):\n\n  // halfword (16-bit) store presumably to event->wLength (at offset 6 of struct usb_cdc_notification)\n  0B 0D 00 79    strh w11, [x8, #6]\n\n  // word (32-bit) store presumably to req->Length (at offset 8 of struct usb_request)\n  6C 0A 00 B9    str  w12, [x19, #8]\n\n  // x10 (NULL) was read here from offset 0 of valid pointer x9\n  // IMHO we're reading 'cdev->gadget' and getting NULL\n  // gadget is indeed at offset 0 of struct usb_composite_dev\n  2A 01 40 F9    ldr  x10, [x9]\n\n  // loading req->buf pointer, which is at offset 0 of struct usb_request\n  69 02 40 F9    ldr  x9, [x19]\n\n  // x10 is null, crash, appears to be attempt to read cdev->gadget->max_speed\n  4B 5D 40 B9    ldr  w11, [x10, #0x5c]\n\nwhich seems to line up with ncm_do_notify() case NCM_NOTIFY_SPEED code fragment:\n\n  event->wLength = cpu_to_le16(8);\n  req->length = NCM_STATUS_BYTECOUNT;\n\n  /* SPEED_CHANGE data is up/down speeds in bits/sec */\n  data = req->buf + sizeof *event;\n  data[0] = cpu_to_le32(ncm_bitrate(cdev->gadget));\n\nMy analysis of registers and NULL ptr deref crash offset\n  (Unable to handle kernel NULL pointer dereference at virtual address 000000000000005c)\nheavily suggests that the crash is due to 'cdev->gadget' being NULL when executing:\n  data[0] = cpu_to_le32(ncm_bitrate(cdev->gadget));\nwhich calls:\n  ncm_bitrate(NULL)\nwhich then calls:\n  gadget_is_superspeed(NULL)\nwhich reads\n  ((struct usb_gadget *)NULL)->max_speed\nand hits a panic.\n\nAFAICT, if I'm counting right, the offset of max_speed is indeed 0x5C.\n(remember there's a GKI KABI reservation of 16 bytes in struct work_struct)\n\nIt's not at all clear to me how this is all supposed to work...\nbut returning 0 seems much better than panic-ing...",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fef6b29671b66dfb71f17e337c1ad14b5a2cedae",
      "https://git.kernel.org/stable/c/63d161f29cd39c050e8873aa36e0c9fc013bb763",
      "https://git.kernel.org/stable/c/a21da7f7aae618c785f7e4a275d43c06dc8412b6",
      "https://git.kernel.org/stable/c/e92c70059178da751e5af7de02384b7dfadb5ec7",
      "https://git.kernel.org/stable/c/a69c8dfb85b44be9cc223be07d35cc3a9baefbea",
      "https://git.kernel.org/stable/c/09e4507ec8ef2d44da6ba4092b8ee2d81f216497",
      "https://git.kernel.org/stable/c/c6ec929595c7443250b2a4faea988c62019d5cd2"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年08月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52884",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nInput: cyapa - add missing input core locking to suspend/resume functions\n\nGrab input->mutex during suspend/resume functions like it is done in\nother input drivers. This fixes the following warning during system\nsuspend/resume cycle on Samsung Exynos5250-based Snow Chromebook:\n\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 1680 at drivers/input/input.c:2291 input_device_enabled+0x68/0x6c\nModules linked in: ...\nCPU: 1 PID: 1680 Comm: kworker/u4:12 Tainted: G        W          6.6.0-rc5-next-20231009 #14109\nHardware name: Samsung Exynos (Flattened Device Tree)\nWorkqueue: events_unbound async_run_entry_fn\n unwind_backtrace from show_stack+0x10/0x14\n show_stack from dump_stack_lvl+0x58/0x70\n dump_stack_lvl from __warn+0x1a8/0x1cc\n __warn from warn_slowpath_fmt+0x18c/0x1b4\n warn_slowpath_fmt from input_device_enabled+0x68/0x6c\n input_device_enabled from cyapa_gen3_set_power_mode+0x13c/0x1dc\n cyapa_gen3_set_power_mode from cyapa_reinitialize+0x10c/0x15c\n cyapa_reinitialize from cyapa_resume+0x48/0x98\n cyapa_resume from dpm_run_callback+0x90/0x298\n dpm_run_callback from device_resume+0xb4/0x258\n device_resume from async_resume+0x20/0x64\n async_resume from async_run_entry_fn+0x40/0x15c\n async_run_entry_fn from process_scheduled_works+0xbc/0x6a8\n process_scheduled_works from worker_thread+0x188/0x454\n worker_thread from kthread+0x108/0x140\n kthread from ret_from_fork+0x14/0x28\nException stack(0xf1625fb0 to 0xf1625ff8)\n...\n---[ end trace 0000000000000000 ]---\n...\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 1680 at drivers/input/input.c:2291 input_device_enabled+0x68/0x6c\nModules linked in: ...\nCPU: 1 PID: 1680 Comm: kworker/u4:12 Tainted: G        W          6.6.0-rc5-next-20231009 #14109\nHardware name: Samsung Exynos (Flattened Device Tree)\nWorkqueue: events_unbound async_run_entry_fn\n unwind_backtrace from show_stack+0x10/0x14\n show_stack from dump_stack_lvl+0x58/0x70\n dump_stack_lvl from __warn+0x1a8/0x1cc\n __warn from warn_slowpath_fmt+0x18c/0x1b4\n warn_slowpath_fmt from input_device_enabled+0x68/0x6c\n input_device_enabled from cyapa_gen3_set_power_mode+0x13c/0x1dc\n cyapa_gen3_set_power_mode from cyapa_reinitialize+0x10c/0x15c\n cyapa_reinitialize from cyapa_resume+0x48/0x98\n cyapa_resume from dpm_run_callback+0x90/0x298\n dpm_run_callback from device_resume+0xb4/0x258\n device_resume from async_resume+0x20/0x64\n async_resume from async_run_entry_fn+0x40/0x15c\n async_run_entry_fn from process_scheduled_works+0xbc/0x6a8\n process_scheduled_works from worker_thread+0x188/0x454\n worker_thread from kthread+0x108/0x140\n kthread from ret_from_fork+0x14/0x28\nException stack(0xf1625fb0 to 0xf1625ff8)\n...\n---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f99809fdeb50d65bcbc1661ef391af94eebb8a75",
      "https://git.kernel.org/stable/c/9400caf566f65c703e99d95f87b00c4b445627a7",
      "https://git.kernel.org/stable/c/a4c638ab25786bd5aab5978fe51b2b9be16a4ebd",
      "https://git.kernel.org/stable/c/a5fc298fa8f67cf1f0e1fc126eab70578cd40adc",
      "https://git.kernel.org/stable/c/7b4e0b39182cf5e677c1fc092a3ec40e621c25b6"
    ],
    "受影响版本": [
      "d69f0a43c677e8afc67a222e1e7b51b9acc69cd3",
      "d69f0a43c677e8afc67a222e1e7b51b9acc69cd3",
      "d69f0a43c677e8afc67a222e1e7b51b9acc69cd3",
      "d69f0a43c677e8afc67a222e1e7b51b9acc69cd3",
      "d69f0a43c677e8afc67a222e1e7b51b9acc69cd3"
    ],
    "公开日期": "2024年06月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52879",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Have trace_event_file have ref counters\n\nThe following can crash the kernel:\n\n # cd /sys/kernel/tracing\n # echo 'p:sched schedule' > kprobe_events\n # exec 5>>events/kprobes/sched/enable\n # > kprobe_events\n # exec 5>&-\n\nThe above commands:\n\n 1. Change directory to the tracefs directory\n 2. Create a kprobe event (doesn't matter what one)\n 3. Open bash file descriptor 5 on the enable file of the kprobe event\n 4. Delete the kprobe event (removes the files too)\n 5. Close the bash file descriptor 5\n\nThe above causes a crash!\n\n BUG: kernel NULL pointer dereference, address: 0000000000000028\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP PTI\n CPU: 6 PID: 877 Comm: bash Not tainted 6.5.0-rc4-test-00008-g2c6b6b1029d4-dirty #186\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-debian-1.16.2-1 04/01/2014\n RIP: 0010:tracing_release_file_tr+0xc/0x50\n\nWhat happens here is that the kprobe event creates a trace_event_file\n\"file\" descriptor that represents the file in tracefs to the event. It\nmaintains state of the event (is it enabled for the given instance?).\nOpening the \"enable\" file gets a reference to the event \"file\" descriptor\nvia the open file descriptor. When the kprobe event is deleted, the file is\nalso deleted from the tracefs system which also frees the event \"file\"\ndescriptor.\n\nBut as the tracefs file is still opened by user space, it will not be\ntotally removed until the final dput() is called on it. But this is not\ntrue with the event \"file\" descriptor that is already freed. If the user\ndoes a write to or simply closes the file descriptor it will reference the\nevent \"file\" descriptor that was just freed, causing a use-after-free bug.\n\nTo solve this, add a ref count to the event \"file\" descriptor as well as a\nnew flag called \"FREED\". The \"file\" will not be freed until the last\nreference is released. But the FREE flag will be set when the event is\nremoved to prevent any more modifications to that event from happening,\neven if there's still a reference to the event \"file\" descriptor.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/961c4511c7578d6b8f39118be919016ec3db1c1e",
      "https://git.kernel.org/stable/c/a98172e36e5f1b3d29ad71fade2d611cfcc2fe6f",
      "https://git.kernel.org/stable/c/cbc7c29dff0fa18162f2a3889d82eeefd67305e0",
      "https://git.kernel.org/stable/c/2fa74d29fc1899c237d51bf9a6e132ea5c488976",
      "https://git.kernel.org/stable/c/2c9de867ca285c397cd71af703763fe416265706",
      "https://git.kernel.org/stable/c/9034c87d61be8cff989017740a91701ac8195a1d",
      "https://git.kernel.org/stable/c/bb32500fb9b78215e4ef6ee8b4345c5f5d7eafb4"
    ],
    "受影响版本": [
      "e6807c873d8791ae5a5186ad05ec66cab926539a",
      "407bf1c140f0757706c0b28604bcc90837d45ce2",
      "fa6d449e4d024d8c17f4288e0567d28ace69415c",
      "a46bf337a20f9edd3c8041b025639842280d0575",
      "9beec04370132a7a6cd1aa9897f6fffc6262ff28",
      "f5ca233e2e66dc1c249bf07eefa37e34a6c9346a",
      "f5ca233e2e66dc1c249bf07eefa37e34a6c9346a"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52849",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncxl/mem: Fix shutdown order\n\nIra reports that removing cxl_mock_mem causes a crash with the following\ntrace:\n\n BUG: kernel NULL pointer dereference, address: 0000000000000044\n [..]\n RIP: 0010:cxl_region_decode_reset+0x7f/0x180 [cxl_core]\n [..]\n Call Trace:\n  <TASK>\n  cxl_region_detach+0xe8/0x210 [cxl_core]\n  cxl_decoder_kill_region+0x27/0x40 [cxl_core]\n  cxld_unregister+0x29/0x40 [cxl_core]\n  devres_release_all+0xb8/0x110\n  device_unbind_cleanup+0xe/0x70\n  device_release_driver_internal+0x1d2/0x210\n  bus_remove_device+0xd7/0x150\n  device_del+0x155/0x3e0\n  device_unregister+0x13/0x60\n  devm_release_action+0x4d/0x90\n  ? __pfx_unregister_port+0x10/0x10 [cxl_core]\n  delete_endpoint+0x121/0x130 [cxl_core]\n  devres_release_all+0xb8/0x110\n  device_unbind_cleanup+0xe/0x70\n  device_release_driver_internal+0x1d2/0x210\n  bus_remove_device+0xd7/0x150\n  device_del+0x155/0x3e0\n  ? lock_release+0x142/0x290\n  cdev_device_del+0x15/0x50\n  cxl_memdev_unregister+0x54/0x70 [cxl_core]\n\nThis crash is due to the clearing out the cxl_memdev's driver context\n(@cxlds) before the subsystem is done with it. This is ultimately due to\nthe region(s), that this memdev is a member, being torn down and expecting\nto be able to de-reference @cxlds, like here:\n\nstatic int cxl_region_decode_reset(struct cxl_region *cxlr, int count)\n...\n                if (cxlds->rcd)\n                        goto endpoint_reset;\n...\n\nFix it by keeping the driver context valid until memdev-device\nunregistration, and subsequently the entire stack of related\ndependencies, unwinds.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/20bd0198bebdd706bd4614b3933ef70d7c19618f",
      "https://git.kernel.org/stable/c/7c7371b41a14e86f53e7dbe5baa7b1d3e0ab324b",
      "https://git.kernel.org/stable/c/cad22a757029c3a1985c221a2d4a6491ad4035ae",
      "https://git.kernel.org/stable/c/0ca074f7d788627a4e0b047ca5fbdb5fc567220c",
      "https://git.kernel.org/stable/c/88d3917f82ed4215a2154432c26de1480a61b209"
    ],
    "受影响版本": [
      "9cc238c7a526dba9ee8c210fa2828886fc65db66",
      "9cc238c7a526dba9ee8c210fa2828886fc65db66",
      "9cc238c7a526dba9ee8c210fa2828886fc65db66",
      "9cc238c7a526dba9ee8c210fa2828886fc65db66",
      "9cc238c7a526dba9ee8c210fa2828886fc65db66",
      "964a9834492210f48b360baa9e20a9eedf4d08ff"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52835",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/core: Bail out early if the request AUX area is out of bound\n\nWhen perf-record with a large AUX area, e.g 4GB, it fails with:\n\n    #perf record -C 0 -m ,4G -e arm_spe_0// -- sleep 1\n    failed to mmap with 12 (Cannot allocate memory)\n\nand it reveals a WARNING with __alloc_pages():\n\n\t------------[ cut here ]------------\n\tWARNING: CPU: 44 PID: 17573 at mm/page_alloc.c:5568 __alloc_pages+0x1ec/0x248\n\tCall trace:\n\t __alloc_pages+0x1ec/0x248\n\t __kmalloc_large_node+0xc0/0x1f8\n\t __kmalloc_node+0x134/0x1e8\n\t rb_alloc_aux+0xe0/0x298\n\t perf_mmap+0x440/0x660\n\t mmap_region+0x308/0x8a8\n\t do_mmap+0x3c0/0x528\n\t vm_mmap_pgoff+0xf4/0x1b8\n\t ksys_mmap_pgoff+0x18c/0x218\n\t __arm64_sys_mmap+0x38/0x58\n\t invoke_syscall+0x50/0x128\n\t el0_svc_common.constprop.0+0x58/0x188\n\t do_el0_svc+0x34/0x50\n\t el0_svc+0x34/0x108\n\t el0t_64_sync_handler+0xb8/0xc0\n\t el0t_64_sync+0x1a4/0x1a8\n\n'rb->aux_pages' allocated by kcalloc() is a pointer array which is used to\nmaintains AUX trace pages. The allocated page for this array is physically\ncontiguous (and virtually contiguous) with an order of 0..MAX_ORDER. If the\nsize of pointer array crosses the limitation set by MAX_ORDER, it reveals a\nWARNING.\n\nSo bail out early with -ENOMEM if the request AUX area is out of bound,\ne.g.:\n\n    #perf record -C 0 -m ,4G -e arm_spe_0// -- sleep 1\n    failed to mmap with 12 (Cannot allocate memory)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8c504f615d7ed60ae035c51d0c789137ced6797f",
      "https://git.kernel.org/stable/c/788c0b3442ead737008934947730a6d1ff703734",
      "https://git.kernel.org/stable/c/1a2a4202c60fcdffbf04f259002ce9bff39edece",
      "https://git.kernel.org/stable/c/fd0df3f8719201dbe61a4d39083d5aecd705399a",
      "https://git.kernel.org/stable/c/9ce4e87a8efd37c85766ec08b15e885cab08553a",
      "https://git.kernel.org/stable/c/2424410f94a94d91230ced094062d859714c984a",
      "https://git.kernel.org/stable/c/2e905e608e38cf7f8dcddcf8a6036e91a78444cb",
      "https://git.kernel.org/stable/c/54aee5f15b83437f23b2b2469bcf21bdd9823916"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52828",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Detect IP == ksym.end as part of BPF program\n\nNow that bpf_throw kfunc is the first such call instruction that has\nnoreturn semantics within the verifier, this also kicks in dead code\nelimination in unprecedented ways. For one, any instruction following\na bpf_throw call will never be marked as seen. Moreover, if a callchain\nends up throwing, any instructions after the call instruction to the\neventually throwing subprog in callers will also never be marked as\nseen.\n\nThe tempting way to fix this would be to emit extra 'int3' instructions\nwhich bump the jited_len of a program, and ensure that during runtime\nwhen a program throws, we can discover its boundaries even if the call\ninstruction to bpf_throw (or to subprogs that always throw) is emitted\nas the final instruction in the program.\n\nAn example of such a program would be this:\n\ndo_something():\n\t...\n\tr0 = 0\n\texit\n\nfoo():\n\tr1 = 0\n\tcall bpf_throw\n\tr0 = 0\n\texit\n\nbar(cond):\n\tif r1 != 0 goto pc+2\n\tcall do_something\n\texit\n\tcall foo\n\tr0 = 0  // Never seen by verifier\n\texit\t//\n\nmain(ctx):\n\tr1 = ...\n\tcall bar\n\tr0 = 0\n\texit\n\nHere, if we do end up throwing, the stacktrace would be the following:\n\nbpf_throw\nfoo\nbar\nmain\n\nIn bar, the final instruction emitted will be the call to foo, as such,\nthe return address will be the subsequent instruction (which the JIT\nemits as int3 on x86). This will end up lying outside the jited_len of\nthe program, thus, when unwinding, we will fail to discover the return\naddress as belonging to any program and end up in a panic due to the\nunreliable stack unwinding of BPF programs that we never expect.\n\nTo remedy this case, make bpf_prog_ksym_find treat IP == ksym.end as\npart of the BPF program, so that is_bpf_text_address returns true when\nsuch a case occurs, and we are able to unwind reliably when the final\ninstruction ends up being a call instruction.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6058e4829696412457729a00734969acc6fd1d18",
      "https://git.kernel.org/stable/c/cf353904a82873e952633fcac4385c2fcd3a46e1",
      "https://git.kernel.org/stable/c/aa42a7cb92647786719fe9608685da345883878f",
      "https://git.kernel.org/stable/c/327b92e8cb527ae097961ffd1610c720481947f5",
      "https://git.kernel.org/stable/c/821a7e4143af115b840ec199eb179537e18af922",
      "https://git.kernel.org/stable/c/66d9111f3517f85ef2af0337ece02683ce0faf21"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52707",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched/psi: Fix use-after-free in ep_remove_wait_queue()\n\nIf a non-root cgroup gets removed when there is a thread that registered\ntrigger and is polling on a pressure file within the cgroup, the polling\nwaitqueue gets freed in the following path:\n\n do_rmdir\n   cgroup_rmdir\n     kernfs_drain_open_files\n       cgroup_file_release\n         cgroup_pressure_release\n           psi_trigger_destroy\n\nHowever, the polling thread still has a reference to the pressure file and\nwill access the freed waitqueue when the file is closed or upon exit:\n\n fput\n   ep_eventpoll_release\n     ep_free\n       ep_remove_wait_queue\n         remove_wait_queue\n\nThis results in use-after-free as pasted below.\n\nThe fundamental problem here is that cgroup_file_release() (and\nconsequently waitqueue's lifetime) is not tied to the file's real lifetime.\nUsing wake_up_pollfree() here might be less than ideal, but it is in line\nwith the comment at commit 42288cb44c4b (\"wait: add wake_up_pollfree()\")\nsince the waitqueue's lifetime is not tied to file's one and can be\nconsidered as another special case. While this would be fixable by somehow\nmaking cgroup_file_release() be tied to the fput(), it would require\nsizable refactoring at cgroups or higher layer which might be more\njustifiable if we identify more cases like this.\n\n  BUG: KASAN: use-after-free in _raw_spin_lock_irqsave+0x60/0xc0\n  Write of size 4 at addr ffff88810e625328 by task a.out/4404\n\n\tCPU: 19 PID: 4404 Comm: a.out Not tainted 6.2.0-rc6 #38\n\tHardware name: Amazon EC2 c5a.8xlarge/, BIOS 1.0 10/16/2017\n\tCall Trace:\n\t<TASK>\n\tdump_stack_lvl+0x73/0xa0\n\tprint_report+0x16c/0x4e0\n\tkasan_report+0xc3/0xf0\n\tkasan_check_range+0x2d2/0x310\n\t_raw_spin_lock_irqsave+0x60/0xc0\n\tremove_wait_queue+0x1a/0xa0\n\tep_free+0x12c/0x170\n\tep_eventpoll_release+0x26/0x30\n\t__fput+0x202/0x400\n\ttask_work_run+0x11d/0x170\n\tdo_exit+0x495/0x1130\n\tdo_group_exit+0x100/0x100\n\tget_signal+0xd67/0xde0\n\tarch_do_signal_or_restart+0x2a/0x2b0\n\texit_to_user_mode_prepare+0x94/0x100\n\tsyscall_exit_to_user_mode+0x20/0x40\n\tdo_syscall_64+0x52/0x90\n\tentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\t</TASK>\n\n Allocated by task 4404:\n\n\tkasan_set_track+0x3d/0x60\n\t__kasan_kmalloc+0x85/0x90\n\tpsi_trigger_create+0x113/0x3e0\n\tpressure_write+0x146/0x2e0\n\tcgroup_file_write+0x11c/0x250\n\tkernfs_fop_write_iter+0x186/0x220\n\tvfs_write+0x3d8/0x5c0\n\tksys_write+0x90/0x110\n\tdo_syscall_64+0x43/0x90\n\tentry_SYSCALL_64_after_hwframe+0x63/0xcd\n\n Freed by task 4407:\n\n\tkasan_set_track+0x3d/0x60\n\tkasan_save_free_info+0x27/0x40\n\t____kasan_slab_free+0x11d/0x170\n\tslab_free_freelist_hook+0x87/0x150\n\t__kmem_cache_free+0xcb/0x180\n\tpsi_trigger_destroy+0x2e8/0x310\n\tcgroup_file_release+0x4f/0xb0\n\tkernfs_drain_open_files+0x165/0x1f0\n\tkernfs_drain+0x162/0x1a0\n\t__kernfs_remove+0x1fb/0x310\n\tkernfs_remove_by_name_ns+0x95/0xe0\n\tcgroup_addrm_files+0x67f/0x700\n\tcgroup_destroy_locked+0x283/0x3c0\n\tcgroup_rmdir+0x29/0x100\n\tkernfs_iop_rmdir+0xd1/0x140\n\tvfs_rmdir+0xfe/0x240\n\tdo_rmdir+0x13d/0x280\n\t__x64_sys_rmdir+0x2c/0x30\n\tdo_syscall_64+0x43/0x90\n\tentry_SYSCALL_64_after_hwframe+0x63/0xcd",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7caeb5457bd01ccba0df1d6f4872f20d28e50b38",
      "https://git.kernel.org/stable/c/ec9c7aa08819f976b2492fa63c41b5712d2924b5",
      "https://git.kernel.org/stable/c/cca2b3feb70170ef6f0fbc4b4d91eea235a2b73a",
      "https://git.kernel.org/stable/c/c6879a4dcefe92d870ab68cabaa9caeda4f2af5a",
      "https://git.kernel.org/stable/c/c2dbe32d5db5c4ead121cf86dabd5ab691fb47fe"
    ],
    "受影响版本": [
      "0e94682b73bfa6c44c98af7a26771c9c08c055d5",
      "0e94682b73bfa6c44c98af7a26771c9c08c055d5",
      "0e94682b73bfa6c44c98af7a26771c9c08c055d5",
      "0e94682b73bfa6c44c98af7a26771c9c08c055d5",
      "0e94682b73bfa6c44c98af7a26771c9c08c055d5"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52701",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: use a bounce buffer for copying skb->mark\n\nsyzbot found arm64 builds would crash in sock_recv_mark()\nwhen CONFIG_HARDENED_USERCOPY=y\n\nx86 and powerpc are not detecting the issue because\nthey define user_access_begin.\nThis will be handled in a different patch,\nbecause a check_object_size() is missing.\n\nOnly data from skb->cb[] can be copied directly to/from user space,\nas explained in commit 79a8a642bf05 (\"net: Whitelist\nthe skbuff_head_cache \"cb\" field\")\n\nsyzbot report was:\nusercopy: Kernel memory exposure attempt detected from SLUB object 'skbuff_head_cache' (offset 168, size 4)!\n------------[ cut here ]------------\nkernel BUG at mm/usercopy.c:102 !\nInternal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\nModules linked in:\nCPU: 0 PID: 4410 Comm: syz-executor533 Not tainted 6.2.0-rc7-syzkaller-17907-g2d3827b3f393 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/21/2023\npstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\npc : usercopy_abort+0x90/0x94 mm/usercopy.c:90\nlr : usercopy_abort+0x90/0x94 mm/usercopy.c:90\nsp : ffff80000fb9b9a0\nx29: ffff80000fb9b9b0 x28: ffff0000c6073400 x27: 0000000020001a00\nx26: 0000000000000014 x25: ffff80000cf52000 x24: fffffc0000000000\nx23: 05ffc00000000200 x22: fffffc000324bf80 x21: ffff0000c92fe1a8\nx20: 0000000000000001 x19: 0000000000000004 x18: 0000000000000000\nx17: 656a626f2042554c x16: ffff0000c6073dd0 x15: ffff80000dbd2118\nx14: ffff0000c6073400 x13: 00000000ffffffff x12: ffff0000c6073400\nx11: ff808000081bbb4c x10: 0000000000000000 x9 : 7b0572d7cc0ccf00\nx8 : 7b0572d7cc0ccf00 x7 : ffff80000bf650d4 x6 : 0000000000000000\nx5 : 0000000000000001 x4 : 0000000000000001 x3 : 0000000000000000\nx2 : ffff0001fefbff08 x1 : 0000000100000000 x0 : 000000000000006c\nCall trace:\nusercopy_abort+0x90/0x94 mm/usercopy.c:90\n__check_heap_object+0xa8/0x100 mm/slub.c:4761\ncheck_heap_object mm/usercopy.c:196 [inline]\n__check_object_size+0x208/0x6b8 mm/usercopy.c:251\ncheck_object_size include/linux/thread_info.h:199 [inline]\n__copy_to_user include/linux/uaccess.h:115 [inline]\nput_cmsg+0x408/0x464 net/core/scm.c:238\nsock_recv_mark net/socket.c:975 [inline]\n__sock_recv_cmsgs+0x1fc/0x248 net/socket.c:984\nsock_recv_cmsgs include/net/sock.h:2728 [inline]\npacket_recvmsg+0x2d8/0x678 net/packet/af_packet.c:3482\n____sys_recvmsg+0x110/0x3a0\n___sys_recvmsg net/socket.c:2737 [inline]\n__sys_recvmsg+0x194/0x210 net/socket.c:2767\n__do_sys_recvmsg net/socket.c:2777 [inline]\n__se_sys_recvmsg net/socket.c:2774 [inline]\n__arm64_sys_recvmsg+0x2c/0x3c net/socket.c:2774\n__invoke_syscall arch/arm64/kernel/syscall.c:38 [inline]\ninvoke_syscall+0x64/0x178 arch/arm64/kernel/syscall.c:52\nel0_svc_common+0xbc/0x180 arch/arm64/kernel/syscall.c:142\ndo_el0_svc+0x48/0x110 arch/arm64/kernel/syscall.c:193\nel0_svc+0x58/0x14c arch/arm64/kernel/entry-common.c:637\nel0t_64_sync_handler+0x84/0xf0 arch/arm64/kernel/entry-common.c:655\nel0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:591\nCode: 91388800 aa0903e1 f90003e8 94e6d752 (d4210000)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/863a7de987f02a901bf215509276a7de0370e0f9",
      "https://git.kernel.org/stable/c/2558b8039d059342197610498c8749ad294adee5"
    ],
    "受影响版本": [
      "6fd1d51cfa253b5ee7dae18d7cf1df830e9b6137",
      "6fd1d51cfa253b5ee7dae18d7cf1df830e9b6137"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52644",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: b43: Stop/wake correct queue in DMA Tx path when QoS is disabled\n\nWhen QoS is disabled, the queue priority value will not map to the correct\nieee80211 queue since there is only one queue. Stop/wake queue 0 when QoS\nis disabled to prevent trying to stop/wake a non-existent queue and failing\nto stop/wake the actual queue instantiated.\n\nLog of issue before change (with kernel parameter qos=0):\n    [  +5.112651] ------------[ cut here ]------------\n    [  +0.000005] WARNING: CPU: 7 PID: 25513 at net/mac80211/util.c:449 __ieee80211_wake_queue+0xd5/0x180 [mac80211]\n    [  +0.000067] Modules linked in: b43(O) snd_seq_dummy snd_hrtimer snd_seq snd_seq_device nft_chain_nat xt_MASQUERADE nf_nat xfrm_user xfrm_algo xt_addrtype overlay ccm af_packet amdgpu snd_hda_codec_cirrus snd_hda_codec_generic ledtrig_audio drm_exec amdxcp gpu_sched xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip6t_rpfilter ipt_rpfilter xt_pkttype xt_LOG nf_log_syslog xt_tcpudp nft_compat nf_tables nfnetlink sch_fq_codel btusb uinput iTCO_wdt ctr btrtl intel_pmc_bxt i915 intel_rapl_msr mei_hdcp mei_pxp joydev at24 watchdog btintel atkbd libps2 serio radeon btbcm vivaldi_fmap btmtk intel_rapl_common snd_hda_codec_hdmi bluetooth uvcvideo nls_iso8859_1 applesmc nls_cp437 x86_pkg_temp_thermal snd_hda_intel intel_powerclamp vfat videobuf2_vmalloc coretemp fat snd_intel_dspcfg crc32_pclmul uvc polyval_clmulni snd_intel_sdw_acpi loop videobuf2_memops snd_hda_codec tun drm_suballoc_helper polyval_generic drm_ttm_helper drm_buddy tap ecdh_generic videobuf2_v4l2 gf128mul macvlan ttm ghash_clmulni_intel ecc tg3\n    [  +0.000044]  videodev bridge snd_hda_core rapl crc16 drm_display_helper cec mousedev snd_hwdep evdev intel_cstate bcm5974 hid_appleir videobuf2_common stp mac_hid libphy snd_pcm drm_kms_helper acpi_als mei_me intel_uncore llc mc snd_timer intel_gtt industrialio_triggered_buffer apple_mfi_fastcharge i2c_i801 mei snd lpc_ich agpgart ptp i2c_smbus thunderbolt apple_gmux i2c_algo_bit kfifo_buf video industrialio soundcore pps_core wmi tiny_power_button sbs sbshc button ac cordic bcma mac80211 cfg80211 ssb rfkill libarc4 kvm_intel kvm drm irqbypass fuse backlight firmware_class efi_pstore configfs efivarfs dmi_sysfs ip_tables x_tables autofs4 dm_crypt cbc encrypted_keys trusted asn1_encoder tee tpm rng_core input_leds hid_apple led_class hid_generic usbhid hid sd_mod t10_pi crc64_rocksoft crc64 crc_t10dif crct10dif_generic ahci libahci libata uhci_hcd ehci_pci ehci_hcd crct10dif_pclmul crct10dif_common sha512_ssse3 sha512_generic sha256_ssse3 sha1_ssse3 aesni_intel usbcore scsi_mod libaes crypto_simd cryptd scsi_common\n    [  +0.000055]  usb_common rtc_cmos btrfs blake2b_generic libcrc32c crc32c_generic crc32c_intel xor raid6_pq dm_snapshot dm_bufio dm_mod dax [last unloaded: b43(O)]\n    [  +0.000009] CPU: 7 PID: 25513 Comm: irq/17-b43 Tainted: G        W  O       6.6.7 #1-NixOS\n    [  +0.000003] Hardware name: Apple Inc. MacBookPro8,3/Mac-942459F5819B171B, BIOS 87.0.0.0.0 06/13/2019\n    [  +0.000001] RIP: 0010:__ieee80211_wake_queue+0xd5/0x180 [mac80211]\n    [  +0.000046] Code: 00 45 85 e4 0f 85 9b 00 00 00 48 8d bd 40 09 00 00 f0 48 0f ba ad 48 09 00 00 00 72 0f 5b 5d 41 5c 41 5d 41 5e e9 cb 6d 3c d0 <0f> 0b 5b 5d 41 5c 41 5d 41 5e c3 cc cc cc cc 48 8d b4 16 94 00 00\n    [  +0.000002] RSP: 0018:ffffc90003c77d60 EFLAGS: 00010097\n    [  +0.000001] RAX: 0000000000000001 RBX: 0000000000000002 RCX: 0000000000000000\n    [  +0.000001] RDX: 0000000000000000 RSI: 0000000000000002 RDI: ffff88820b924900\n    [  +0.000002] RBP: ffff88820b924900 R08: ffffc90003c77d90 R09: 000000000003bfd0\n    [  +0.000001] R10: ffff88820b924900 R11: ffffc90003c77c68 R12: 0000000000000000\n    [  +0.000001] R13: 0000000000000000 R14: ffffc90003c77d90 R15: ffffffffc0fa6f40\n    [  +0.000001] FS:  0000000000000000(0000) GS:ffff88846fb80000(0000) knlGS:0000000000000000\n    [  +0.000001] CS:  0010 DS: 0\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1824f942527f784a19e01eac2d9679a21623d010",
      "https://git.kernel.org/stable/c/31aaf17200c336fe258b70d39c40645ae19d0240",
      "https://git.kernel.org/stable/c/49f067726ab01c87cf57566797a8a719badbbf08",
      "https://git.kernel.org/stable/c/04a2b6eff2ae1c19cb7f41e803bcbfaf94c06455",
      "https://git.kernel.org/stable/c/c67698325c68f8768db858f5c87c34823421746d",
      "https://git.kernel.org/stable/c/bc845e2e42cae95172c04bf29807c480f51a2a83",
      "https://git.kernel.org/stable/c/4049a9f80513a6739c5677736a4c88f96df1b436",
      "https://git.kernel.org/stable/c/f1cf77bb870046a6111a604f7f7fe83d1c8c9610",
      "https://git.kernel.org/stable/c/9636951e4468f02c72cc75a82dc65d003077edbc"
    ],
    "受影响版本": [
      "e6f5b934fba8c44c87c551e066aa7ca6fde2939e",
      "e6f5b934fba8c44c87c551e066aa7ca6fde2939e",
      "e6f5b934fba8c44c87c551e066aa7ca6fde2939e",
      "e6f5b934fba8c44c87c551e066aa7ca6fde2939e",
      "e6f5b934fba8c44c87c551e066aa7ca6fde2939e",
      "e6f5b934fba8c44c87c551e066aa7ca6fde2939e",
      "e6f5b934fba8c44c87c551e066aa7ca6fde2939e",
      "e6f5b934fba8c44c87c551e066aa7ca6fde2939e",
      "e6f5b934fba8c44c87c551e066aa7ca6fde2939e"
    ],
    "公开日期": "2024年04月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52635",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nPM / devfreq: Synchronize devfreq_monitor_[start/stop]\n\nThere is a chance if a frequent switch of the governor\ndone in a loop result in timer list corruption where\ntimer cancel being done from two place one from\ncancel_delayed_work_sync() and followed by expire_timers()\ncan be seen from the traces[1].\n\nwhile true\ndo\n        echo \"simple_ondemand\" > /sys/class/devfreq/1d84000.ufshc/governor\n        echo \"performance\" > /sys/class/devfreq/1d84000.ufshc/governor\ndone\n\nIt looks to be issue with devfreq driver where\ndevice_monitor_[start/stop] need to synchronized so that\ndelayed work should get corrupted while it is either\nbeing queued or running or being cancelled.\n\nLet's use polling flag and devfreq lock to synchronize the\nqueueing the timer instance twice and work data being\ncorrupted.\n\n[1]\n...\n..\n<idle>-0    [003]   9436.209662:  timer_cancel   timer=0xffffff80444f0428\n<idle>-0    [003]   9436.209664:  timer_expire_entry   timer=0xffffff80444f0428  now=0x10022da1c  function=__typeid__ZTSFvP10timer_listE_global_addr  baseclk=0x10022da1c\n<idle>-0    [003]   9436.209718:  timer_expire_exit   timer=0xffffff80444f0428\nkworker/u16:6-14217    [003]   9436.209863:  timer_start   timer=0xffffff80444f0428  function=__typeid__ZTSFvP10timer_listE_global_addr  expires=0x10022da2b  now=0x10022da1c  flags=182452227\nvendor.xxxyyy.ha-1593    [004]   9436.209888:  timer_cancel   timer=0xffffff80444f0428\nvendor.xxxyyy.ha-1593    [004]   9436.216390:  timer_init   timer=0xffffff80444f0428\nvendor.xxxyyy.ha-1593    [004]   9436.216392:  timer_start   timer=0xffffff80444f0428  function=__typeid__ZTSFvP10timer_listE_global_addr  expires=0x10022da2c  now=0x10022da1d  flags=186646532\nvendor.xxxyyy.ha-1593    [005]   9436.220992:  timer_cancel   timer=0xffffff80444f0428\nxxxyyyTraceManag-7795    [004]   9436.261641:  timer_cancel   timer=0xffffff80444f0428\n\n[2]\n\n 9436.261653][    C4] Unable to handle kernel paging request at virtual address dead00000000012a\n[ 9436.261664][    C4] Mem abort info:\n[ 9436.261666][    C4]   ESR = 0x96000044\n[ 9436.261669][    C4]   EC = 0x25: DABT (current EL), IL = 32 bits\n[ 9436.261671][    C4]   SET = 0, FnV = 0\n[ 9436.261673][    C4]   EA = 0, S1PTW = 0\n[ 9436.261675][    C4] Data abort info:\n[ 9436.261677][    C4]   ISV = 0, ISS = 0x00000044\n[ 9436.261680][    C4]   CM = 0, WnR = 1\n[ 9436.261682][    C4] [dead00000000012a] address between user and kernel address ranges\n[ 9436.261685][    C4] Internal error: Oops: 96000044 [#1] PREEMPT SMP\n[ 9436.261701][    C4] Skip md ftrace buffer dump for: 0x3a982d0\n...\n\n[ 9436.262138][    C4] CPU: 4 PID: 7795 Comm: TraceManag Tainted: G S      W  O      5.10.149-android12-9-o-g17f915d29d0c #1\n[ 9436.262141][    C4] Hardware name: Qualcomm Technologies, Inc.  (DT)\n[ 9436.262144][    C4] pstate: 22400085 (nzCv daIf +PAN -UAO +TCO BTYPE=--)\n[ 9436.262161][    C4] pc : expire_timers+0x9c/0x438\n[ 9436.262164][    C4] lr : expire_timers+0x2a4/0x438\n[ 9436.262168][    C4] sp : ffffffc010023dd0\n[ 9436.262171][    C4] x29: ffffffc010023df0 x28: ffffffd0636fdc18\n[ 9436.262178][    C4] x27: ffffffd063569dd0 x26: ffffffd063536008\n[ 9436.262182][    C4] x25: 0000000000000001 x24: ffffff88f7c69280\n[ 9436.262185][    C4] x23: 00000000000000e0 x22: dead000000000122\n[ 9436.262188][    C4] x21: 000000010022da29 x20: ffffff8af72b4e80\n[ 9436.262191][    C4] x19: ffffffc010023e50 x18: ffffffc010025038\n[ 9436.262195][    C4] x17: 0000000000000240 x16: 0000000000000201\n[ 9436.262199][    C4] x15: ffffffffffffffff x14: ffffff889f3c3100\n[ 9436.262203][    C4] x13: ffffff889f3c3100 x12: 00000000049f56b8\n[ 9436.262207][    C4] x11: 00000000049f56b8 x10: 00000000ffffffff\n[ 9436.262212][    C4] x9 : ffffffc010023e50 x8 : dead000000000122\n[ 9436.262216][    C4] x7 : ffffffffffffffff x6 : ffffffc0100239d8\n[ 9436.262220][    C4] x5 : 0000000000000000 x4 : 0000000000000101\n[ 9436.262223][    C4] x3 : 0000000000000080 x2 : ffffff8\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3399cc7013e761fee9d6eec795e9b31ab0cbe475",
      "https://git.kernel.org/stable/c/099f6a9edbe30b142c1d97fe9a4748601d995675",
      "https://git.kernel.org/stable/c/31569995fc65007b73a3fff605ec2b3401b435e9",
      "https://git.kernel.org/stable/c/0aedb319ef3ed39e9e5a7b7726c8264ca627bbd9",
      "https://git.kernel.org/stable/c/ae815e2fdc284ab31651d52460698bd89c0fce22",
      "https://git.kernel.org/stable/c/aed5ed595960c6d301dcd4ed31aeaa7a8054c0c6"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年04月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52631",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/ntfs3: Fix an NULL dereference bug\n\nThe issue here is when this is called from ntfs_load_attr_list().  The\n\"size\" comes from le32_to_cpu(attr->res.data_size) so it can't overflow\non a 64bit systems but on 32bit systems the \"+ 1023\" can overflow and\nthe result is zero.  This means that the kmalloc will succeed by\nreturning the ZERO_SIZE_PTR and then the memcpy() will crash with an\nOops on the next line.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ae4acad41b0f93f1c26cc0fc9135bb79d8282d0b",
      "https://git.kernel.org/stable/c/ec1bedd797588fe38fc11cba26d77bb1d9b194c6",
      "https://git.kernel.org/stable/c/fb7bcd1722bc9bc55160378f5f99c01198fd14a7",
      "https://git.kernel.org/stable/c/686820fe141ea0220fc6fdfc7e5694f915cf64b2",
      "https://git.kernel.org/stable/c/b2dd7b953c25ffd5912dda17e980e7168bebcf6c"
    ],
    "受影响版本": [
      "be71b5cba2e6485e8959da7a9f9a44461a1bb074",
      "be71b5cba2e6485e8959da7a9f9a44461a1bb074",
      "be71b5cba2e6485e8959da7a9f9a44461a1bb074",
      "be71b5cba2e6485e8959da7a9f9a44461a1bb074",
      "be71b5cba2e6485e8959da7a9f9a44461a1bb074"
    ],
    "公开日期": "2024年04月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52610",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: act_ct: fix skb leak and crash on ooo frags\n\nact_ct adds skb->users before defragmentation. If frags arrive in order,\nthe last frag's reference is reset in:\n\n  inet_frag_reasm_prepare\n    skb_morph\n\nwhich is not straightforward.\n\nHowever when frags arrive out of order, nobody unref the last frag, and\nall frags are leaked. The situation is even worse, as initiating packet\ncapture can lead to a crash[0] when skb has been cloned and shared at the\nsame time.\n\nFix the issue by removing skb_get() before defragmentation. act_ct\nreturns TC_ACT_CONSUMED when defrag failed or in progress.\n\n[0]:\n[  843.804823] ------------[ cut here ]------------\n[  843.809659] kernel BUG at net/core/skbuff.c:2091!\n[  843.814516] invalid opcode: 0000 [#1] PREEMPT SMP\n[  843.819296] CPU: 7 PID: 0 Comm: swapper/7 Kdump: loaded Tainted: G S 6.7.0-rc3 #2\n[  843.824107] Hardware name: XFUSION 1288H V6/BC13MBSBD, BIOS 1.29 11/25/2022\n[  843.828953] RIP: 0010:pskb_expand_head+0x2ac/0x300\n[  843.833805] Code: 8b 70 28 48 85 f6 74 82 48 83 c6 08 bf 01 00 00 00 e8 38 bd ff ff 8b 83 c0 00 00 00 48 03 83 c8 00 00 00 e9 62 ff ff ff 0f 0b <0f> 0b e8 8d d0 ff ff e9 b3 fd ff ff 81 7c 24 14 40 01 00 00 4c 89\n[  843.843698] RSP: 0018:ffffc9000cce07c0 EFLAGS: 00010202\n[  843.848524] RAX: 0000000000000002 RBX: ffff88811a211d00 RCX: 0000000000000820\n[  843.853299] RDX: 0000000000000640 RSI: 0000000000000000 RDI: ffff88811a211d00\n[  843.857974] RBP: ffff888127d39518 R08: 00000000bee97314 R09: 0000000000000000\n[  843.862584] R10: 0000000000000000 R11: ffff8881109f0000 R12: 0000000000000880\n[  843.867147] R13: ffff888127d39580 R14: 0000000000000640 R15: ffff888170f7b900\n[  843.871680] FS:  0000000000000000(0000) GS:ffff889ffffc0000(0000) knlGS:0000000000000000\n[  843.876242] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  843.880778] CR2: 00007fa42affcfb8 CR3: 000000011433a002 CR4: 0000000000770ef0\n[  843.885336] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  843.889809] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  843.894229] PKRU: 55555554\n[  843.898539] Call Trace:\n[  843.902772]  <IRQ>\n[  843.906922]  ? __die_body+0x1e/0x60\n[  843.911032]  ? die+0x3c/0x60\n[  843.915037]  ? do_trap+0xe2/0x110\n[  843.918911]  ? pskb_expand_head+0x2ac/0x300\n[  843.922687]  ? do_error_trap+0x65/0x80\n[  843.926342]  ? pskb_expand_head+0x2ac/0x300\n[  843.929905]  ? exc_invalid_op+0x50/0x60\n[  843.933398]  ? pskb_expand_head+0x2ac/0x300\n[  843.936835]  ? asm_exc_invalid_op+0x1a/0x20\n[  843.940226]  ? pskb_expand_head+0x2ac/0x300\n[  843.943580]  inet_frag_reasm_prepare+0xd1/0x240\n[  843.946904]  ip_defrag+0x5d4/0x870\n[  843.950132]  nf_ct_handle_fragments+0xec/0x130 [nf_conntrack]\n[  843.953334]  tcf_ct_act+0x252/0xd90 [act_ct]\n[  843.956473]  ? tcf_mirred_act+0x516/0x5a0 [act_mirred]\n[  843.959657]  tcf_action_exec+0xa1/0x160\n[  843.962823]  fl_classify+0x1db/0x1f0 [cls_flower]\n[  843.966010]  ? skb_clone+0x53/0xc0\n[  843.969173]  tcf_classify+0x24d/0x420\n[  843.972333]  tc_run+0x8f/0xf0\n[  843.975465]  __netif_receive_skb_core+0x67a/0x1080\n[  843.978634]  ? dev_gro_receive+0x249/0x730\n[  843.981759]  __netif_receive_skb_list_core+0x12d/0x260\n[  843.984869]  netif_receive_skb_list_internal+0x1cb/0x2f0\n[  843.987957]  ? mlx5e_handle_rx_cqe_mpwrq_rep+0xfa/0x1a0 [mlx5_core]\n[  843.991170]  napi_complete_done+0x72/0x1a0\n[  843.994305]  mlx5e_napi_poll+0x28c/0x6d0 [mlx5_core]\n[  843.997501]  __napi_poll+0x25/0x1b0\n[  844.000627]  net_rx_action+0x256/0x330\n[  844.003705]  __do_softirq+0xb3/0x29b\n[  844.006718]  irq_exit_rcu+0x9e/0xc0\n[  844.009672]  common_interrupt+0x86/0xa0\n[  844.012537]  </IRQ>\n[  844.015285]  <TASK>\n[  844.017937]  asm_common_interrupt+0x26/0x40\n[  844.020591] RIP: 0010:acpi_safe_halt+0x1b/0x20\n[  844.023247] Code: ff 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 65 48 8b 04 25 00 18 03 00 48 8b 00 a8 08 75 0c 66 90 0f 00 2d 81 d0 44 00 fb\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/172ba7d46c202e679f3ccb10264c67416aaeb1c4",
      "https://git.kernel.org/stable/c/0b5b831122fc3789fff75be433ba3e4dd7b779d4",
      "https://git.kernel.org/stable/c/73f7da5fd124f2cda9161e2e46114915e6e82e97",
      "https://git.kernel.org/stable/c/f5346df0591d10bc948761ca854b1fae6d2ef441",
      "https://git.kernel.org/stable/c/3f14b377d01d8357eba032b4cabc8c1149b458b6"
    ],
    "受影响版本": [
      "b57dc7c13ea90e09ae15f821d2583fa0231b4935",
      "b57dc7c13ea90e09ae15f821d2583fa0231b4935",
      "b57dc7c13ea90e09ae15f821d2583fa0231b4935",
      "b57dc7c13ea90e09ae15f821d2583fa0231b4935",
      "b57dc7c13ea90e09ae15f821d2583fa0231b4935"
    ],
    "公开日期": "2024年03月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52587",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nIB/ipoib: Fix mcast list locking\n\nReleasing the `priv->lock` while iterating the `priv->multicast_list` in\n`ipoib_mcast_join_task()` opens a window for `ipoib_mcast_dev_flush()` to\nremove the items while in the middle of iteration. If the mcast is removed\nwhile the lock was dropped, the for loop spins forever resulting in a hard\nlockup (as was reported on RHEL 4.18.0-372.75.1.el8_6 kernel):\n\n    Task A (kworker/u72:2 below)       | Task B (kworker/u72:0 below)\n    -----------------------------------+-----------------------------------\n    ipoib_mcast_join_task(work)        | ipoib_ib_dev_flush_light(work)\n      spin_lock_irq(&priv->lock)       | __ipoib_ib_dev_flush(priv, ...)\n      list_for_each_entry(mcast,       | ipoib_mcast_dev_flush(dev = priv->dev)\n          &priv->multicast_list, list) |\n        ipoib_mcast_join(dev, mcast)   |\n          spin_unlock_irq(&priv->lock) |\n                                       |   spin_lock_irqsave(&priv->lock, flags)\n                                       |   list_for_each_entry_safe(mcast, tmcast,\n                                       |                  &priv->multicast_list, list)\n                                       |     list_del(&mcast->list);\n                                       |     list_add_tail(&mcast->list, &remove_list)\n                                       |   spin_unlock_irqrestore(&priv->lock, flags)\n          spin_lock_irq(&priv->lock)   |\n                                       |   ipoib_mcast_remove_list(&remove_list)\n   (Here, `mcast` is no longer on the  |     list_for_each_entry_safe(mcast, tmcast,\n    `priv->multicast_list` and we keep |                            remove_list, list)\n    spinning on the `remove_list` of   |  >>>  wait_for_completion(&mcast->done)\n    the other thread which is blocked  |\n    and the list is still valid on     |\n    it's stack.)\n\nFix this by keeping the lock held and changing to GFP_ATOMIC to prevent\neventual sleeps.\nUnfortunately we could not reproduce the lockup and confirm this fix but\nbased on the code review I think this fix should address such lockups.\n\ncrash> bc 31\nPID: 747      TASK: ff1c6a1a007e8000  CPU: 31   COMMAND: \"kworker/u72:2\"\n--\n    [exception RIP: ipoib_mcast_join_task+0x1b1]\n    RIP: ffffffffc0944ac1  RSP: ff646f199a8c7e00  RFLAGS: 00000002\n    RAX: 0000000000000000  RBX: ff1c6a1a04dc82f8  RCX: 0000000000000000\n                                  work (&priv->mcast_task{,.work})\n    RDX: ff1c6a192d60ac68  RSI: 0000000000000286  RDI: ff1c6a1a04dc8000\n           &mcast->list\n    RBP: ff646f199a8c7e90   R8: ff1c699980019420   R9: ff1c6a1920c9a000\n    R10: ff646f199a8c7e00  R11: ff1c6a191a7d9800  R12: ff1c6a192d60ac00\n                                                         mcast\n    R13: ff1c6a1d82200000  R14: ff1c6a1a04dc8000  R15: ff1c6a1a04dc82d8\n           dev                    priv (&priv->lock)     &priv->multicast_list (aka head)\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n--- <NMI exception stack> ---\n #5 [ff646f199a8c7e00] ipoib_mcast_join_task+0x1b1 at ffffffffc0944ac1 [ib_ipoib]\n #6 [ff646f199a8c7e98] process_one_work+0x1a7 at ffffffff9bf10967\n\ncrash> rx ff646f199a8c7e68\nff646f199a8c7e68:  ff1c6a1a04dc82f8 <<< work = &priv->mcast_task.work\n\ncrash> list -hO ipoib_dev_priv.multicast_list ff1c6a1a04dc8000\n(empty)\n\ncrash> ipoib_dev_priv.mcast_task.work.func,mcast_mutex.owner.counter ff1c6a1a04dc8000\n  mcast_task.work.func = 0xffffffffc0944910 <ipoib_mcast_join_task>,\n  mcast_mutex.owner.counter = 0xff1c69998efec000\n\ncrash> b 8\nPID: 8        TASK: ff1c69998efec000  CPU: 33   COMMAND: \"kworker/u72:0\"\n--\n #3 [ff646f1980153d50] wait_for_completion+0x96 at ffffffff9c7d7646\n #4 [ff646f1980153d90] ipoib_mcast_remove_list+0x56 at ffffffffc0944dc6 [ib_ipoib]\n #5 [ff646f1980153de8] ipoib_mcast_dev_flush+0x1a7 at ffffffffc09455a7 [ib_ipoib]\n #6 [ff646f1980153e58] __ipoib_ib_dev_flush+0x1a4 at ffffffffc09431a4 [ib_ipoib]\n #7 [ff\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4c8922ae8eb8dcc1e4b7d1059d97a8334288d825",
      "https://git.kernel.org/stable/c/615e3adc2042b7be4ad122a043fc9135e6342c90",
      "https://git.kernel.org/stable/c/ac2630fd3c90ffec34a0bfc4d413668538b0e8f2",
      "https://git.kernel.org/stable/c/ed790bd0903ed3352ebf7f650d910f49b7319b34",
      "https://git.kernel.org/stable/c/5108a2dc2db5630fb6cd58b8be80a0c134bc310a",
      "https://git.kernel.org/stable/c/342258fb46d66c1b4c7e2c3717ac01e10c03cf18",
      "https://git.kernel.org/stable/c/7c7bd4d561e9dc6f5b7df9e184974915f6701a89",
      "https://git.kernel.org/stable/c/4f973e211b3b1c6d36f7c6a19239d258856749f9"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年03月06日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52582",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfs: Only call folio_start_fscache() one time for each folio\n\nIf a network filesystem using netfs implements a clamp_length()\nfunction, it can set subrequest lengths smaller than a page size.\n\nWhen we loop through the folios in netfs_rreq_unlock_folios() to\nset any folios to be written back, we need to make sure we only\ncall folio_start_fscache() once for each folio.\n\nOtherwise, this simple testcase:\n\n  mount -o fsc,rsize=1024,wsize=1024 127.0.0.1:/export /mnt/nfs\n  dd if=/dev/zero of=/mnt/nfs/file.bin bs=4096 count=1\n  1+0 records in\n  1+0 records out\n  4096 bytes (4.1 kB, 4.0 KiB) copied, 0.0126359 s, 324 kB/s\n  echo 3 > /proc/sys/vm/drop_caches\n  cat /mnt/nfs/file.bin > /dev/null\n\nwill trigger an oops similar to the following:\n\n  page dumped because: VM_BUG_ON_FOLIO(folio_test_private_2(folio))\n  ------------[ cut here ]------------\n  kernel BUG at include/linux/netfs.h:44!\n  ...\n  CPU: 5 PID: 134 Comm: kworker/u16:5 Kdump: loaded Not tainted 6.4.0-rc5\n  ...\n  RIP: 0010:netfs_rreq_unlock_folios+0x68e/0x730 [netfs]\n  ...\n  Call Trace:\n    netfs_rreq_assess+0x497/0x660 [netfs]\n    netfs_subreq_terminated+0x32b/0x610 [netfs]\n    nfs_netfs_read_completion+0x14e/0x1a0 [nfs]\n    nfs_read_completion+0x2f9/0x330 [nfs]\n    rpc_free_task+0x72/0xa0 [sunrpc]\n    rpc_async_release+0x46/0x70 [sunrpc]\n    process_one_work+0x3bd/0x710\n    worker_thread+0x89/0x610\n    kthread+0x181/0x1c0\n    ret_from_fork+0x29/0x50",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/df9950d37df113db59495fa09d060754366a2b7c",
      "https://git.kernel.org/stable/c/d9f5537479d4ec97ea92ff24e81a517d5772581a",
      "https://git.kernel.org/stable/c/df1c357f25d808e30b216188330e708e09e1a412"
    ],
    "受影响版本": [
      "3d3c95046742e4eebaa4b891b0b01cbbed94ebbd",
      "3d3c95046742e4eebaa4b891b0b01cbbed94ebbd",
      "3d3c95046742e4eebaa4b891b0b01cbbed94ebbd"
    ],
    "公开日期": "2024年03月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52580",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/core: Fix ETH_P_1588 flow dissector\n\nWhen a PTP ethernet raw frame with a size of more than 256 bytes followed\nby a 0xff pattern is sent to __skb_flow_dissect, nhoff value calculation\nis wrong. For example: hdr->message_length takes the wrong value (0xffff)\nand it does not replicate real header length. In this case, 'nhoff' value\nwas overridden and the PTP header was badly dissected. This leads to a\nkernel crash.\n\nnet/core: flow_dissector\nnet/core flow dissector nhoff = 0x0000000e\nnet/core flow dissector hdr->message_length = 0x0000ffff\nnet/core flow dissector nhoff = 0x0001000d (u16 overflow)\n...\nskb linear:   00000000: 00 a0 c9 00 00 00 00 a0 c9 00 00 00 88\nskb frag:     00000000: f7 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n\nUsing the size of the ptp_header struct will allow the corrected\ncalculation of the nhoff value.\n\nnet/core flow dissector nhoff = 0x0000000e\nnet/core flow dissector nhoff = 0x00000030 (sizeof ptp_header)\n...\nskb linear:   00000000: 00 a0 c9 00 00 00 00 a0 c9 00 00 00 88 f7 ff ff\nskb linear:   00000010: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\nskb linear:   00000020: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\nskb frag:     00000000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n\nKernel trace:\n[   74.984279] ------------[ cut here ]------------\n[   74.989471] kernel BUG at include/linux/skbuff.h:2440!\n[   74.995237] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n[   75.001098] CPU: 4 PID: 0 Comm: swapper/4 Tainted: G     U            5.15.85-intel-ese-standard-lts #1\n[   75.011629] Hardware name: Intel Corporation A-Island (CPU:AlderLake)/A-Island (ID:06), BIOS SB_ADLP.01.01.00.01.03.008.D-6A9D9E73-dirty Mar 30 2023\n[   75.026507] RIP: 0010:eth_type_trans+0xd0/0x130\n[   75.031594] Code: 03 88 47 78 eb c7 8b 47 68 2b 47 6c 48 8b 97 c0 00 00 00 83 f8 01 7e 1b 48 85 d2 74 06 66 83 3a ff 74 09 b8 00 04 00 00 eb ab <0f> 0b b8 00 01 00 00 eb a2 48 85 ff 74 eb 48 8d 54 24 06 31 f6 b9\n[   75.052612] RSP: 0018:ffff9948c0228de0 EFLAGS: 00010297\n[   75.058473] RAX: 00000000000003f2 RBX: ffff8e47047dc300 RCX: 0000000000001003\n[   75.066462] RDX: ffff8e4e8c9ea040 RSI: ffff8e4704e0a000 RDI: ffff8e47047dc300\n[   75.074458] RBP: ffff8e4704e2acc0 R08: 00000000000003f3 R09: 0000000000000800\n[   75.082466] R10: 000000000000000d R11: ffff9948c0228dec R12: ffff8e4715e4e010\n[   75.090461] R13: ffff9948c0545018 R14: 0000000000000001 R15: 0000000000000800\n[   75.098464] FS:  0000000000000000(0000) GS:ffff8e4e8fb00000(0000) knlGS:0000000000000000\n[   75.107530] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   75.113982] CR2: 00007f5eb35934a0 CR3: 0000000150e0a002 CR4: 0000000000770ee0\n[   75.121980] PKRU: 55555554\n[   75.125035] Call Trace:\n[   75.127792]  <IRQ>\n[   75.130063]  ? eth_get_headlen+0xa4/0xc0\n[   75.134472]  igc_process_skb_fields+0xcd/0x150\n[   75.139461]  igc_poll+0xc80/0x17b0\n[   75.143272]  __napi_poll+0x27/0x170\n[   75.147192]  net_rx_action+0x234/0x280\n[   75.151409]  __do_softirq+0xef/0x2f4\n[   75.155424]  irq_exit_rcu+0xc7/0x110\n[   75.159432]  common_interrupt+0xb8/0xd0\n[   75.163748]  </IRQ>\n[   75.166112]  <TASK>\n[   75.168473]  asm_common_interrupt+0x22/0x40\n[   75.173175] RIP: 0010:cpuidle_enter_state+0xe2/0x350\n[   75.178749] Code: 85 c0 0f 8f 04 02 00 00 31 ff e8 39 6c 67 ff 45 84 ff 74 12 9c 58 f6 c4 02 0f 85 50 02 00 00 31 ff e8 52 b0 6d ff fb 45 85 f6 <0f> 88 b1 00 00 00 49 63 ce 4c 2b 2c 24 48 89 c8 48 6b d1 68 48 c1\n[   75.199757] RSP: 0018:ffff9948c013bea8 EFLAGS: 00000202\n[   75.205614] RAX: ffff8e4e8fb00000 RBX: ffffb948bfd23900 RCX: 000000000000001f\n[   75.213619] RDX: 0000000000000004 RSI: ffffffff94206161 RDI: ffffffff94212e20\n[   75.221620] RBP: 0000000000000004 R08: 000000117568973a R09: 0000000000000001\n[   75.229622] R10: 000000000000afc8 R11: ffff8e4e8fb29ce4 R12: ffffffff945ae980\n[   75.237628] R13: 000000117568973a R14: 0000000000000004 R15: 0000000000000000\n[   75.245635]  ? \n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f90a7b9586d72f907092078a9f394733ca502cc9",
      "https://git.kernel.org/stable/c/488ea2a3e2666022f79abfdd7d12e8305fc27a40",
      "https://git.kernel.org/stable/c/48e105a2a1a10adc21c0ae717969f5e8e990ba48",
      "https://git.kernel.org/stable/c/75ad80ed88a182ab2ad5513e448cf07b403af5c3"
    ],
    "受影响版本": [
      "4f1cc51f34886d645cd3e8fc2915cc9b7a55c3b6",
      "4f1cc51f34886d645cd3e8fc2915cc9b7a55c3b6",
      "4f1cc51f34886d645cd3e8fc2915cc9b7a55c3b6",
      "4f1cc51f34886d645cd3e8fc2915cc9b7a55c3b6"
    ],
    "公开日期": "2024年03月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52562",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slab_common: fix slab_caches list corruption after kmem_cache_destroy()\n\nAfter the commit in Fixes:, if a module that created a slab cache does not\nrelease all of its allocated objects before destroying the cache (at rmmod\ntime), we might end up releasing the kmem_cache object without removing it\nfrom the slab_caches list thus corrupting the list as kmem_cache_destroy()\nignores the return value from shutdown_cache(), which in turn never removes\nthe kmem_cache object from slabs_list in case __kmem_cache_shutdown() fails\nto release all of the cache's slabs.\n\nThis is easily observable on a kernel built with CONFIG_DEBUG_LIST=y\nas after that ill release the system will immediately trip on list_add,\nor list_del, assertions similar to the one shown below as soon as another\nkmem_cache gets created, or destroyed:\n\n  [ 1041.213632] list_del corruption. next->prev should be ffff89f596fb5768, but was 52f1e5016aeee75d. (next=ffff89f595a1b268)\n  [ 1041.219165] ------------[ cut here ]------------\n  [ 1041.221517] kernel BUG at lib/list_debug.c:62!\n  [ 1041.223452] invalid opcode: 0000 [#1] PREEMPT SMP PTI\n  [ 1041.225408] CPU: 2 PID: 1852 Comm: rmmod Kdump: loaded Tainted: G    B   W  OE      6.5.0 #15\n  [ 1041.228244] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS edk2-20230524-3.fc37 05/24/2023\n  [ 1041.231212] RIP: 0010:__list_del_entry_valid+0xae/0xb0\n\nAnother quick way to trigger this issue, in a kernel with CONFIG_SLUB=y,\nis to set slub_debug to poison the released objects and then just run\ncat /proc/slabinfo after removing the module that leaks slab objects,\nin which case the kernel will panic:\n\n  [   50.954843] general protection fault, probably for non-canonical address 0xa56b6b6b6b6b6b8b: 0000 [#1] PREEMPT SMP PTI\n  [   50.961545] CPU: 2 PID: 1495 Comm: cat Kdump: loaded Tainted: G    B   W  OE      6.5.0 #15\n  [   50.966808] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS edk2-20230524-3.fc37 05/24/2023\n  [   50.972663] RIP: 0010:get_slabinfo+0x42/0xf0\n\nThis patch fixes this issue by properly checking shutdown_cache()'s\nreturn value before taking the kmem_cache_release() branch.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a5569bb187521432f509b69dda7d29f78b2d38b0",
      "https://git.kernel.org/stable/c/51988be187b041e5355245957b0b9751fa382e0d",
      "https://git.kernel.org/stable/c/46a9ea6681907a3be6b6b0d43776dccc62cad6cf"
    ],
    "受影响版本": [
      "0495e337b7039191dfce6e03f5f830454b1fae6b",
      "0495e337b7039191dfce6e03f5f830454b1fae6b",
      "0495e337b7039191dfce6e03f5f830454b1fae6b",
      "357321557920c805de2b14832002465c320eea4f"
    ],
    "公开日期": "2024年03月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52559",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/vt-d: Avoid memory allocation in iommu_suspend()\n\nThe iommu_suspend() syscore suspend callback is invoked with IRQ disabled.\nAllocating memory with the GFP_KERNEL flag may re-enable IRQs during\nthe suspend callback, which can cause intermittent suspend/hibernation\nproblems with the following kernel traces:\n\nCalling iommu_suspend+0x0/0x1d0\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 15 at kernel/time/timekeeping.c:868 ktime_get+0x9b/0xb0\n...\nCPU: 0 PID: 15 Comm: rcu_preempt Tainted: G     U      E      6.3-intel #r1\nRIP: 0010:ktime_get+0x9b/0xb0\n...\nCall Trace:\n <IRQ>\n tick_sched_timer+0x22/0x90\n ? __pfx_tick_sched_timer+0x10/0x10\n __hrtimer_run_queues+0x111/0x2b0\n hrtimer_interrupt+0xfa/0x230\n __sysvec_apic_timer_interrupt+0x63/0x140\n sysvec_apic_timer_interrupt+0x7b/0xa0\n </IRQ>\n <TASK>\n asm_sysvec_apic_timer_interrupt+0x1f/0x30\n...\n------------[ cut here ]------------\nInterrupts enabled after iommu_suspend+0x0/0x1d0\nWARNING: CPU: 0 PID: 27420 at drivers/base/syscore.c:68 syscore_suspend+0x147/0x270\nCPU: 0 PID: 27420 Comm: rtcwake Tainted: G     U  W   E      6.3-intel #r1\nRIP: 0010:syscore_suspend+0x147/0x270\n...\nCall Trace:\n <TASK>\n hibernation_snapshot+0x25b/0x670\n hibernate+0xcd/0x390\n state_store+0xcf/0xe0\n kobj_attr_store+0x13/0x30\n sysfs_kf_write+0x3f/0x50\n kernfs_fop_write_iter+0x128/0x200\n vfs_write+0x1fd/0x3c0\n ksys_write+0x6f/0xf0\n __x64_sys_write+0x1d/0x30\n do_syscall_64+0x3b/0x90\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nGiven that only 4 words memory is needed, avoid the memory allocation in\niommu_suspend().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/29298c85a81abdc512e87537515ed4b1a9601d0e",
      "https://git.kernel.org/stable/c/c12ef025add77ca3a0902e8719d552b6d47b4282",
      "https://git.kernel.org/stable/c/496c591f0b389eb782f36d9d4c2564b9a865eed0",
      "https://git.kernel.org/stable/c/59df44bfb0ca4c3ee1f1c3c5d0ee8e314844799e"
    ],
    "受影响版本": [
      "33e07157105e472b746b70b3ed4197c57c43ab68",
      "33e07157105e472b746b70b3ed4197c57c43ab68",
      "33e07157105e472b746b70b3ed4197c57c43ab68",
      "33e07157105e472b746b70b3ed4197c57c43ab68"
    ],
    "公开日期": "2024年03月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52487",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Fix peer flow lists handling\n\nThe cited change refactored mlx5e_tc_del_fdb_peer_flow() to only clear DUP\nflag when list of peer flows has become empty. However, if any concurrent\nuser holds a reference to a peer flow (for example, the neighbor update\nworkqueue task is updating peer flow's parent encap entry concurrently),\nthen the flow will not be removed from the peer list and, consecutively,\nDUP flag will remain set. Since mlx5e_tc_del_fdb_peers_flow() calls\nmlx5e_tc_del_fdb_peer_flow() for every possible peer index the algorithm\nwill try to remove the flow from eswitch instances that it has never peered\nwith causing either NULL pointer dereference when trying to remove the flow\npeer list head of peer_index that was never initialized or a warning if the\nlist debug config is enabled[0].\n\nFix the issue by always removing the peer flow from the list even when not\nreleasing the last reference to it.\n\n[0]:\n\n[ 3102.985806] ------------[ cut here ]------------\n[ 3102.986223] list_del corruption, ffff888139110698->next is NULL\n[ 3102.986757] WARNING: CPU: 2 PID: 22109 at lib/list_debug.c:53 __list_del_entry_valid_or_report+0x4f/0xc0\n[ 3102.987561] Modules linked in: act_ct nf_flow_table bonding act_tunnel_key act_mirred act_skbedit vxlan cls_matchall nfnetlink_cttimeout act_gact cls_flower sch_ingress mlx5_vdpa vringh vhost_iotlb vdpa openvswitch nsh xt_MASQUERADE nf_conntrack_netlink nfnetlink iptable_nat xt_addrtype xt_conntrack nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcg\nss oid_registry overlay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core mlx5_core [last unloaded: bonding]\n[ 3102.991113] CPU: 2 PID: 22109 Comm: revalidator28 Not tainted 6.6.0-rc6+ #3\n[ 3102.991695] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n[ 3102.992605] RIP: 0010:__list_del_entry_valid_or_report+0x4f/0xc0\n[ 3102.993122] Code: 39 c2 74 56 48 8b 32 48 39 fe 75 62 48 8b 51 08 48 39 f2 75 73 b8 01 00 00 00 c3 48 89 fe 48 c7 c7 48 fd 0a 82 e8 41 0b ad ff <0f> 0b 31 c0 c3 48 89 fe 48 c7 c7 70 fd 0a 82 e8 2d 0b ad ff 0f 0b\n[ 3102.994615] RSP: 0018:ffff8881383e7710 EFLAGS: 00010286\n[ 3102.995078] RAX: 0000000000000000 RBX: 0000000000000002 RCX: 0000000000000000\n[ 3102.995670] RDX: 0000000000000001 RSI: ffff88885f89b640 RDI: ffff88885f89b640\n[ 3102.997188] DEL flow 00000000be367878 on port 0\n[ 3102.998594] RBP: dead000000000122 R08: 0000000000000000 R09: c0000000ffffdfff\n[ 3102.999604] R10: 0000000000000008 R11: ffff8881383e7598 R12: dead000000000100\n[ 3103.000198] R13: 0000000000000002 R14: ffff888139110000 R15: ffff888101901240\n[ 3103.000790] FS:  00007f424cde4700(0000) GS:ffff88885f880000(0000) knlGS:0000000000000000\n[ 3103.001486] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 3103.001986] CR2: 00007fd42e8dcb70 CR3: 000000011e68a003 CR4: 0000000000370ea0\n[ 3103.002596] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 3103.003190] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ 3103.003787] Call Trace:\n[ 3103.004055]  <TASK>\n[ 3103.004297]  ? __warn+0x7d/0x130\n[ 3103.004623]  ? __list_del_entry_valid_or_report+0x4f/0xc0\n[ 3103.005094]  ? report_bug+0xf1/0x1c0\n[ 3103.005439]  ? console_unlock+0x4a/0xd0\n[ 3103.005806]  ? handle_bug+0x3f/0x70\n[ 3103.006149]  ? exc_invalid_op+0x13/0x60\n[ 3103.006531]  ? asm_exc_invalid_op+0x16/0x20\n[ 3103.007430]  ? __list_del_entry_valid_or_report+0x4f/0xc0\n[ 3103.007910]  mlx5e_tc_del_fdb_peers_flow+0xcf/0x240 [mlx5_core]\n[ 3103.008463]  mlx5e_tc_del_flow+0x46/0x270 [mlx5_core]\n[ 3103.008944]  mlx5e_flow_put+0x26/0x50 [mlx5_core]\n[ 3103.009401]  mlx5e_delete_flower+0x25f/0x380 [mlx5_core]\n[ 3103.009901]  tc_setup_cb_destroy+0xab/0x180\n[ 3103.010292]  fl_hw_destroy_filter+0x99/0xc0 [cls_flower]\n[ 3103.010779]  __fl_delete+0x2d4/0x2f0 [cls_flower]\n[ 3103.0\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/74cec142f89bf85c6c99c5db957da9f663f9f16f",
      "https://git.kernel.org/stable/c/e24d6f5a7f2d95a98a46257a5a5a5381d572894f",
      "https://git.kernel.org/stable/c/d76fdd31f953ac5046555171620f2562715e9b71"
    ],
    "受影响版本": [
      "9be6c21fdcf8a7ec48262bb76f78c17ac2761ac6",
      "9be6c21fdcf8a7ec48262bb76f78c17ac2761ac6",
      "9be6c21fdcf8a7ec48262bb76f78c17ac2761ac6"
    ],
    "公开日期": "2024年02月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52478",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: logitech-hidpp: Fix kernel crash on receiver USB disconnect\n\nhidpp_connect_event() has *four* time-of-check vs time-of-use (TOCTOU)\nraces when it races with itself.\n\nhidpp_connect_event() primarily runs from a workqueue but it also runs\non probe() and if a \"device-connected\" packet is received by the hw\nwhen the thread running hidpp_connect_event() from probe() is waiting on\nthe hw, then a second thread running hidpp_connect_event() will be\nstarted from the workqueue.\n\nThis opens the following races (note the below code is simplified):\n\n1. Retrieving + printing the protocol (harmless race):\n\n\tif (!hidpp->protocol_major) {\n\t\thidpp_root_get_protocol_version()\n\t\thidpp->protocol_major = response.rap.params[0];\n\t}\n\nWe can actually see this race hit in the dmesg in the abrt output\nattached to rhbz#2227968:\n\n[ 3064.624215] logitech-hidpp-device 0003:046D:4071.0049: HID++ 4.5 device connected.\n[ 3064.658184] logitech-hidpp-device 0003:046D:4071.0049: HID++ 4.5 device connected.\n\nTesting with extra logging added has shown that after this the 2 threads\ntake turn grabbing the hw access mutex (send_mutex) so they ping-pong\nthrough all the other TOCTOU cases managing to hit all of them:\n\n2. Updating the name to the HIDPP name (harmless race):\n\n\tif (hidpp->name == hdev->name) {\n\t\t...\n\t\thidpp->name = new_name;\n\t}\n\n3. Initializing the power_supply class for the battery (problematic!):\n\nhidpp_initialize_battery()\n{\n        if (hidpp->battery.ps)\n                return 0;\n\n\tprobe_battery(); /* Blocks, threads take turns executing this */\n\n\thidpp->battery.desc.properties =\n\t\tdevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);\n\n\thidpp->battery.ps =\n\t\tdevm_power_supply_register(&hidpp->hid_dev->dev,\n\t\t\t\t\t   &hidpp->battery.desc, cfg);\n}\n\n4. Creating delayed input_device (potentially problematic):\n\n\tif (hidpp->delayed_input)\n\t\treturn;\n\n\thidpp->delayed_input = hidpp_allocate_input(hdev);\n\nThe really big problem here is 3. Hitting the race leads to the following\nsequence:\n\n\thidpp->battery.desc.properties =\n\t\tdevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);\n\n\thidpp->battery.ps =\n\t\tdevm_power_supply_register(&hidpp->hid_dev->dev,\n\t\t\t\t\t   &hidpp->battery.desc, cfg);\n\n\t...\n\n\thidpp->battery.desc.properties =\n\t\tdevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);\n\n\thidpp->battery.ps =\n\t\tdevm_power_supply_register(&hidpp->hid_dev->dev,\n\t\t\t\t\t   &hidpp->battery.desc, cfg);\n\nSo now we have registered 2 power supplies for the same battery,\nwhich looks a bit weird from userspace's pov but this is not even\nthe really big problem.\n\nNotice how:\n\n1. This is all devm-maganaged\n2. The hidpp->battery.desc struct is shared between the 2 power supplies\n3. hidpp->battery.desc.properties points to the result from the second\n   devm_kmemdup()\n\nThis causes a use after free scenario on USB disconnect of the receiver:\n1. The last registered power supply class device gets unregistered\n2. The memory from the last devm_kmemdup() call gets freed,\n   hidpp->battery.desc.properties now points to freed memory\n3. The first registered power supply class device gets unregistered,\n   this involves sending a remove uevent to userspace which invokes\n   power_supply_uevent() to fill the uevent data\n4. power_supply_uevent() uses hidpp->battery.desc.properties which\n   now points to freed memory leading to backtraces like this one:\n\nSep 22 20:01:35 eric kernel: BUG: unable to handle page fault for address: ffffb2140e017f08\n...\nSep 22 20:01:35 eric kernel: Workqueue: usb_hub_wq hub_event\nSep 22 20:01:35 eric kernel: RIP: 0010:power_supply_uevent+0xee/0x1d0\n...\nSep 22 20:01:35 eric kernel:  ? asm_exc_page_fault+0x26/0x30\nSep 22 20:01:35 eric kernel:  ? power_supply_uevent+0xee/0x1d0\nSep 22 20:01:35 eric kernel:  ? power_supply_uevent+0x10d/0x1d0\nSep 22 20:01:35 eric kernel:  dev_uevent+0x10f/0x2d0\nSep 22 20:01:35 eric kernel:  kobject_uevent_env+0x291/0x680\nSep 22 20:01:35 eric kernel:  \n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ca0c4cc1d215dc22ab0e738c9f017c650f3183f5",
      "https://git.kernel.org/stable/c/44481b244fcaa2b895a53081d6204c574720c38c",
      "https://git.kernel.org/stable/c/cd0e2bf7fb22fe9b989c59c42dca06367fd10e6b",
      "https://git.kernel.org/stable/c/093af62c023537f097d2ebdfaa0bc7c1a6e874e1",
      "https://git.kernel.org/stable/c/28ddc1e0b898291323b62d770b1b931de131a528",
      "https://git.kernel.org/stable/c/fd72ac9556a473fc7daf54efb6ca8a97180d621d",
      "https://git.kernel.org/stable/c/f7b2c7d9831af99369fe8ad9b2a68d78942f414e",
      "https://git.kernel.org/stable/c/dac501397b9d81e4782232c39f94f4307b137452"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年02月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52474",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nIB/hfi1: Fix bugs with non-PAGE_SIZE-end multi-iovec user SDMA requests\n\nhfi1 user SDMA request processing has two bugs that can cause data\ncorruption for user SDMA requests that have multiple payload iovecs\nwhere an iovec other than the tail iovec does not run up to the page\nboundary for the buffer pointed to by that iovec.a\n\nHere are the specific bugs:\n1. user_sdma_txadd() does not use struct user_sdma_iovec->iov.iov_len.\n   Rather, user_sdma_txadd() will add up to PAGE_SIZE bytes from iovec\n   to the packet, even if some of those bytes are past\n   iovec->iov.iov_len and are thus not intended to be in the packet.\n2. user_sdma_txadd() and user_sdma_send_pkts() fail to advance to the\n   next iovec in user_sdma_request->iovs when the current iovec\n   is not PAGE_SIZE and does not contain enough data to complete the\n   packet. The transmitted packet will contain the wrong data from the\n   iovec pages.\n\nThis has not been an issue with SDMA packets from hfi1 Verbs or PSM2\nbecause they only produce iovecs that end short of PAGE_SIZE as the tail\niovec of an SDMA request.\n\nFixing these bugs exposes other bugs with the SDMA pin cache\n(struct mmu_rb_handler) that get in way of supporting user SDMA requests\nwith multiple payload iovecs whose buffers do not end at PAGE_SIZE. So\nthis commit fixes those issues as well.\n\nHere are the mmu_rb_handler bugs that non-PAGE_SIZE-end multi-iovec\npayload user SDMA requests can hit:\n1. Overlapping memory ranges in mmu_rb_handler will result in duplicate\n   pinnings.\n2. When extending an existing mmu_rb_handler entry (struct mmu_rb_node),\n   the mmu_rb code (1) removes the existing entry under a lock, (2)\n   releases that lock, pins the new pages, (3) then reacquires the lock\n   to insert the extended mmu_rb_node.\n\n   If someone else comes in and inserts an overlapping entry between (2)\n   and (3), insert in (3) will fail.\n\n   The failure path code in this case unpins _all_ pages in either the\n   original mmu_rb_node or the new mmu_rb_node that was inserted between\n   (2) and (3).\n3. In hfi1_mmu_rb_remove_unless_exact(), mmu_rb_node->refcount is\n   incremented outside of mmu_rb_handler->lock. As a result, mmu_rb_node\n   could be evicted by another thread that gets mmu_rb_handler->lock and\n   checks mmu_rb_node->refcount before mmu_rb_node->refcount is\n   incremented.\n4. Related to #2 above, SDMA request submission failure path does not\n   check mmu_rb_node->refcount before freeing mmu_rb_node object.\n\n   If there are other SDMA requests in progress whose iovecs have\n   pointers to the now-freed mmu_rb_node(s), those pointers to the\n   now-freed mmu_rb nodes will be dereferenced when those SDMA requests\n   complete.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9c4c6512d7330b743c4ffd18bd999a86ca26db0d",
      "https://git.kernel.org/stable/c/a2bd706ab63509793b5cd5065e685b7ef5cba678",
      "https://git.kernel.org/stable/c/dce59b5443700fbd0d2433ec6e4d4cf063448844",
      "https://git.kernel.org/stable/c/c76cb8f4bdf26d04cfa5485a93ce297dba5e6a80",
      "https://git.kernel.org/stable/c/7e6010f79b58f45b204cf18aa58f4b73c3f30adc",
      "https://git.kernel.org/stable/c/00cbce5cbf88459cd1aa1d60d0f1df15477df127"
    ],
    "受影响版本": [
      "7724105686e718ac476a6ad3304fea2fbcfcffde",
      "7724105686e718ac476a6ad3304fea2fbcfcffde",
      "7724105686e718ac476a6ad3304fea2fbcfcffde",
      "7724105686e718ac476a6ad3304fea2fbcfcffde",
      "7724105686e718ac476a6ad3304fea2fbcfcffde",
      "7724105686e718ac476a6ad3304fea2fbcfcffde"
    ],
    "公开日期": "2024年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2023-52459",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l: async: Fix duplicated list deletion\n\nThe list deletion call dropped here is already called from the\nhelper function in the line before. Having a second list_del()\ncall results in either a warning (with CONFIG_DEBUG_LIST=y):\n\nlist_del corruption, c46c8198->next is LIST_POISON1 (00000100)\n\nIf CONFIG_DEBUG_LIST is disabled the operation results in a\nkernel error due to NULL pointer dereference.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b7062628caeaec90e8f691ebab2d70f31b7b6b91",
      "https://git.kernel.org/stable/c/49d82811428469566667f22749610b8c132cdb3e",
      "https://git.kernel.org/stable/c/3de6ee94aae701fa949cd3b5df6b6a440ddfb8f2"
    ],
    "受影响版本": [
      "28a1295795d85a25f2e7dd391c43969e95fcb341",
      "28a1295795d85a25f2e7dd391c43969e95fcb341",
      "28a1295795d85a25f2e7dd391c43969e95fcb341"
    ],
    "公开日期": "2024年02月23日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-52240",
    "漏洞描述": "The Kantega SAML SSO OIDC Kerberos Single Sign-on apps before 6.20.0 for Atlassian products allow XSS if SAML POST Binding is enabled. This affects 4.4.2 through 4.14.8 before 4.14.9, 5.0.0 through 5.11.4 before 5.11.5, and 6.0.0 through 6.19.0 before 6.20.0. The full product names are Kantega SAML SSO OIDC Kerberos Single Sign-on for Jira Data Center & Server (Kantega SSO Enterprise), Kantega SAML SSO OIDC Kerberos Single Sign-on for Confluence Data Center & Server (Kantega SSO Enterprise), Kantega SAML SSO OIDC Kerberos Single Sign-on for Bitbucket Data Center & Server (Kantega SSO Enterprise), Kantega SAML SSO OIDC Kerberos Single Sign-on for Bamboo Data Center & Server (Kantega SSO Enterprise), and Kantega SAML SSO OIDC Kerberos Single Sign-on for FeCru Server (Kantega SSO Enterprise). (Here, FeCru refers to the Atlassian Fisheye and Crucible products running together.)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://kantega-sso.atlassian.net/wiki/spaces/KSE/pages/1226473473/Security+Vulnerability+HTML+injection+Cross-site+scripting+in+SAML+POST+binding+Kantega+SSO+Enterprise",
      "https://marketplace.atlassian.com/apps/1211923/kantega-saml-sso-oidc-kerberos-single-sign-on-for-jira?hosting=datacenter&tab=versions",
      "https://marketplace.atlassian.com/apps/1212126/kantega-saml-sso-oidc-kerberos-single-sign-on-for-confluence?hosting=datacenter&tab=overview",
      "https://marketplace.atlassian.com/apps/1213019/kantega-saml-sso-oidc-kerberos-single-sign-on-for-bitbucket?hosting=datacenter&tab=overview",
      "https://marketplace.atlassian.com/apps/1215262/kantega-saml-sso-oidc-kerberos-single-sign-on-for-bamboo?hosting=datacenter&tab=overview",
      "https://marketplace.atlassian.com/apps/1215263/kantega-saml-sso-oidc-kerberos-single-sign-on-for-fecru?hosting=server&tab=overview"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年12月29日"
  },
  {
    "设备品牌": "Utarit Information Technologies",
    "设备类型": "OTA",
    "产品型号": "SoliPay Mobile App",
    "CVE编号": "CVE-2023-5155",
    "漏洞描述": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in Utarit Information Technologies SoliPay Mobile App allows SQL Injection.This issue affects SoliPay Mobile App: before 5.0.8.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-24-0104"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年02月15日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-50630",
    "漏洞描述": "Cross Site Scripting (XSS) vulnerability in xiweicheng TMS v.2.28.0 allows a remote attacker to execute arbitrary code via a crafted script to the click here function.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/xiweicheng/tms/issues/19"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年01月04日"
  },
  {
    "设备品牌": "Utarit Information Technologies",
    "设备类型": "OTA",
    "产品型号": "SoliPay Mobile App",
    "CVE编号": "CVE-2023-4993",
    "漏洞描述": "Incorrect Use of Privileged APIs vulnerability in Utarit Information Technologies SoliPay Mobile App allows Collect Data as Provided by Users.This issue affects SoliPay Mobile App: before 5.0.8.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-24-0104"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年02月15日"
  },
  {
    "设备品牌": "Yogesh Pawar, Clarion Technologies",
    "设备类型": "OTA",
    "产品型号": "Bulk Edit Post Titles",
    "CVE编号": "CVE-2023-49754",
    "漏洞描述": "Missing Authorization vulnerability in Yogesh Pawar, Clarion Technologies Bulk Edit Post Titles allows Exploiting Incorrectly Configured Access Control Security Levels.This issue affects Bulk Edit Post Titles: from n/a through 5.0.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/bulk-edit-post-titles/vulnerability/wordpress-bulk-edit-post-titles-plugin-5-0-0-broken-access-control-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年12月09日"
  },
  {
    "设备品牌": "Zebra Technologies",
    "设备类型": "OTA",
    "产品型号": "ZTC ZT410",
    "CVE编号": "CVE-2023-4957",
    "漏洞描述": " A vulnerability of authentication bypass has been found on a Zebra Technologies ZTC ZT410-203dpi ZPL printer. This vulnerability allows an attacker that is in the same network as the printer, to change the username and password for the Web Page by sending a specially crafted POST request to the setvarsResults.cgi file. For this vulnerability to be exploitable, the printers protected mode must be disabled.",
    "攻击向量": "ADJACENT_NETWORK",
    "厂商补丁链接": [
      "https://www.incibe.es/en/incibe-cert/notices/aviso-sci/authentication-bypass-zebra-ztc"
    ],
    "受影响版本": [
      "203dpi ZPL 18J150703184"
    ],
    "公开日期": "2023年10月11日"
  },
  {
    "设备品牌": "lestrrat-go",
    "设备类型": "OTA",
    "产品型号": "jwx",
    "CVE编号": "CVE-2023-49290",
    "漏洞描述": "lestrrat-go/jwx is a Go module implementing various JWx (JWA/JWE/JWK/JWS/JWT, otherwise known as JOSE) technologies. A p2c parameter set too high in JWE's algorithm PBES2-* could lead to a denial of service. The JWE key management algorithms based on PBKDF2 require a JOSE Header Parameter called p2c (PBES2 Count). This parameter dictates the number of PBKDF2 iterations needed to derive a CEK wrapping key. Its primary purpose is to intentionally slow down the key derivation function, making password brute-force and dictionary attacks more resource- intensive. Therefore, if an attacker sets the p2c parameter in JWE to a very large number, it can cause a lot of computational consumption, resulting in a denial of service. This vulnerability has been addressed in commit `64f2a229b` which has been included in release version 1.2.27 and 2.0.18. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/lestrrat-go/jwx/security/advisories/GHSA-7f9x-gw85-8grf",
      "https://github.com/lestrrat-go/jwx/commit/64f2a229b8e18605f47361d292b526bdc4aee01c"
    ],
    "受影响版本": [
      "< 1.2.27",
      ">= 2.0.0, < 2.0.18"
    ],
    "公开日期": "2023年12月04日"
  },
  {
    "设备品牌": "louislam",
    "设备类型": "OTA",
    "产品型号": "uptime-kuma",
    "CVE编号": "CVE-2023-49276",
    "漏洞描述": "Uptime Kuma is an open source self-hosted monitoring tool. In affected versions the Google Analytics element in vulnerable to Attribute Injection leading to Cross-Site-Scripting (XSS). Since the custom status interface can set an independent Google Analytics ID and the template has not been sanitized, there is an attribute injection vulnerability here, which can lead to XSS attacks. This vulnerability has been addressed in commit `f28dccf4e` which is included in release version 1.23.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/louislam/uptime-kuma/security/advisories/GHSA-v4v2-8h88-65qj",
      "https://github.com/louislam/uptime-kuma/commit/f28dccf4e11f041564293e4f407e69ab9ee2277f"
    ],
    "受影响版本": [
      ">= 1.20.0, < 1.23.7"
    ],
    "公开日期": "2023年12月01日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-49002",
    "漏洞描述": "An issue in Xenom Technologies (sinous) Phone Dialer-voice Call Dialer v.1.2.5 allows an attacker to bypass intended access restrictions via interaction with com.funprime.calldialer.ui.activities.OutgoingActivity.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/actuator/com.sinous.voice.dialer/blob/main/CWE-928.md",
      "https://github.com/actuator/cve/blob/main/CVE-2023-49002"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年12月27日"
  },
  {
    "设备品牌": "discourse",
    "设备类型": "OTA",
    "产品型号": "discourse",
    "CVE编号": "CVE-2023-48297",
    "漏洞描述": "Discourse is a platform for community discussion. The message serializer uses the full list of expanded chat mentions (@all and @here) which can lead to a very long array of users. This issue was patched in versions 3.1.4 and beta 3.2.0.beta5.\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/discourse/discourse/security/advisories/GHSA-hf2v-r5xm-8p37"
    ],
    "受影响版本": [
      "< 3.1.4",
      ">= 3.2.0beta1, < 3.2.0.beta4"
    ],
    "公开日期": "2024年01月12日"
  },
  {
    "设备品牌": "Matat Technologies",
    "设备类型": "OTA",
    "产品型号": "TextMe SMS",
    "CVE编号": "CVE-2023-48287",
    "漏洞描述": "Missing Authorization vulnerability in Matat Technologies TextMe SMS allows Exploiting Incorrectly Configured Access Control Security Levels.This issue affects TextMe SMS: from n/a through 1.9.0.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/wordpress/plugin/textme-sms-integration/vulnerability/wordpress-textme-sms-plugin-1-9-0-broken-access-control-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年12月09日"
  },
  {
    "设备品牌": "labring",
    "设备类型": "OTA",
    "产品型号": "laf",
    "CVE编号": "CVE-2023-48225",
    "漏洞描述": "Laf is a cloud development platform. Prior to version 1.0.0-beta.13, the control of LAF app enV is not strict enough, and in certain scenarios of privatization environment, it may lead to sensitive information leakage in secret and configmap. In ES6 syntax, if an obj directly references another obj, the name of the obj itself will be used as the key, and the entire object structure will be integrated intact. When constructing the deployment instance of the app, env was found from the database and directly inserted into the template, resulting in controllability here. Sensitive information in the secret and configmap can be read through the k8s envFrom field. In a privatization environment, when `namespaceConf. fixed` is marked, it may lead to the leakage of sensitive information in the system. As of time of publication, it is unclear whether any patches or workarounds exist.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/labring/laf/security/advisories/GHSA-hv2g-gxx4-fwxp",
      "https://github.com/labring/laf/blob/main/server/src/application/environment.controller.ts#L50",
      "https://github.com/labring/laf/blob/main/server/src/instance/instance.service.ts#L306"
    ],
    "受影响版本": [
      "< 1.0.0-beta13"
    ],
    "公开日期": "2023年12月12日"
  },
  {
    "设备品牌": "pimcore",
    "设备类型": "OTA",
    "产品型号": "admin-ui-classic-bundle",
    "CVE编号": "CVE-2023-47636",
    "漏洞描述": "The Pimcore Admin Classic Bundle provides a Backend UI for Pimcore. Full Path Disclosure (FPD) vulnerabilities enable the attacker to see the path to the webroot/file. e.g.: /home/omg/htdocs/file/. Certain vulnerabilities, such as using the load_file() (within a SQL Injection) query to view the page source, require the attacker to have the full path to the file they wish to view. In the case of pimcore, the fopen() function here doesn't have an error handle when the file doesn't exist on the server so the server response raises the full path \"fopen(/var/www/html/var/tmp/export-{ uniqe id}.csv)\". This issue has been patched in commit `10d178ef771` which has been included in release version 1.2.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/pimcore/admin-ui-classic-bundle/security/advisories/GHSA-c8hj-w239-5gvf",
      "https://github.com/pimcore/admin-ui-classic-bundle/commit/10d178ef771097604a256c1192b098af9ec57a87",
      "https://huntr.com/bounties/4af4db18-9fd4-43e9-8bc6-c88aaf76839c/"
    ],
    "受影响版本": [
      "< 1.2.1"
    ],
    "公开日期": "2023年11月15日"
  },
  {
    "设备品牌": "vantage6",
    "设备类型": "OTA",
    "产品型号": "vantage6",
    "CVE编号": "CVE-2023-47631",
    "漏洞描述": "vantage6 is a framework to manage and deploy privacy enhancing technologies like Federated Learning (FL) and Multi-Party Computation (MPC). In affected versions a node does not check if an image is allowed to run if a `parent_id` is set. A malicious party that breaches the server may modify it to set a fake `parent_id` and send a task of a non-whitelisted algorithm. The node will then execute it because the `parent_id` that is set prevents checks from being run. This impacts all servers that are breached by an expert user. This vulnerability has been patched in version 4.1.2. All users are advised to upgrade. There are no known workarounds for this vulnerability.\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/vantage6/vantage6/security/advisories/GHSA-vc3v-ppc7-v486",
      "https://github.com/vantage6/vantage6/commit/bf83521eb12fa80aa5fc92ef1692010a9a7f8243",
      "https://github.com/vantage6/vantage6/blob/version/4.1.1/vantage6-node/vantage6/node/docker/docker_manager.py#L265-L268"
    ],
    "受影响版本": [
      "< 4.1.2"
    ],
    "公开日期": "2023年11月14日"
  },
  {
    "设备品牌": "GM Information Technologies",
    "设备类型": "OTA",
    "产品型号": "MDO",
    "CVE编号": "CVE-2023-4675",
    "漏洞描述": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in GM Information Technologies MDO allows SQL Injection.This issue affects MDO: through 20231229. \n\nNOTE: The vendor was contacted early about this disclosure but did not respond in any way.\n\n\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0742"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年12月29日"
  },
  {
    "设备品牌": "Yaztek Software Technologies and Computer Systems",
    "设备类型": "OTA",
    "产品型号": "E-Commerce Software",
    "CVE编号": "CVE-2023-4674",
    "漏洞描述": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in Yaztek Software Technologies and Computer Systems E-Commerce Software allows SQL Injection.This issue affects E-Commerce Software: through 20231229. \n\nNOTE: The vendor was contacted early about this disclosure but did not respond in any way.\n\n\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0741"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年12月29日"
  },
  {
    "设备品牌": "South River Technologies",
    "设备类型": "OTA",
    "产品型号": "Titan MFT",
    "CVE编号": "CVE-2023-45690",
    "漏洞描述": "Default file permissions on South River Technologies' Titan MFT and Titan SFTP servers on Linux allows a user that's authentication to the OS to read sensitive files on the filesystem",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.rapid7.com/blog/post/2023/10/16/multiple-vulnerabilities-in-south-river-technologies-titan-mft-and-titan-sftp-fixed/",
      "https://helpdesk.southrivertech.com/portal/en/kb/articles/security-patch-for-issues-cve-2023-45685-through-cve-2023-45690"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年10月16日"
  },
  {
    "设备品牌": "South River Technologies",
    "设备类型": "OTA",
    "产品型号": "Titan MFT",
    "CVE编号": "CVE-2023-45689",
    "漏洞描述": "Lack of sufficient path validation in South River Technologies' Titan MFT and Titan SFTP servers on Windows and Linux allows an authenticated attacker with administrative privileges to read any file on the filesystem via path traversal",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.rapid7.com/blog/post/2023/10/16/multiple-vulnerabilities-in-south-river-technologies-titan-mft-and-titan-sftp-fixed/",
      "https://helpdesk.southrivertech.com/portal/en/kb/articles/security-patch-for-issues-cve-2023-45685-through-cve-2023-45690"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年10月16日"
  },
  {
    "设备品牌": "South River Technologies",
    "设备类型": "OTA",
    "产品型号": "Titan MFT",
    "CVE编号": "CVE-2023-45688",
    "漏洞描述": "Lack of sufficient path validation in South River Technologies' Titan MFT and Titan SFTP servers on Linux allows an authenticated attacker to get the size of an arbitrary file on the filesystem using path traversal in the ftp \"SIZE\" command",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.rapid7.com/blog/post/2023/10/16/multiple-vulnerabilities-in-south-river-technologies-titan-mft-and-titan-sftp-fixed/",
      "https://helpdesk.southrivertech.com/portal/en/kb/articles/security-patch-for-issues-cve-2023-45685-through-cve-2023-45690"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年10月16日"
  },
  {
    "设备品牌": "South River Technologies",
    "设备类型": "OTA",
    "产品型号": "Titan MFT",
    "CVE编号": "CVE-2023-45687",
    "漏洞描述": "A session fixation vulnerability in South River Technologies' Titan MFT and Titan SFTP servers on Linux and Windows allows an attacker to bypass the server's authentication if they can trick an administrator into authorizating a session id of their choosing",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.rapid7.com/blog/post/2023/10/16/multiple-vulnerabilities-in-south-river-technologies-titan-mft-and-titan-sftp-fixed/",
      "https://helpdesk.southrivertech.com/portal/en/kb/articles/security-patch-for-issues-cve-2023-45685-through-cve-2023-45690"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年10月16日"
  },
  {
    "设备品牌": "South River Technologies",
    "设备类型": "OTA",
    "产品型号": "Titan MFT",
    "CVE编号": "CVE-2023-45686",
    "漏洞描述": "Insufficient path validation when writing a file via WebDAV in South River Technologies' Titan MFT and Titan SFTP servers on Linux allows an authenticated attacker to write a file to any location on the filesystem via path traversal",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.rapid7.com/blog/post/2023/10/16/multiple-vulnerabilities-in-south-river-technologies-titan-mft-and-titan-sftp-fixed/",
      "https://helpdesk.southrivertech.com/portal/en/kb/articles/security-patch-for-issues-cve-2023-45685-through-cve-2023-45690"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年10月16日"
  },
  {
    "设备品牌": "South River Technologies",
    "设备类型": "OTA",
    "产品型号": "Titan MFT",
    "CVE编号": "CVE-2023-45685",
    "漏洞描述": "Insufficient path validation when extracting a zip archive in South River Technologies' Titan MFT and Titan SFTP servers on Windows and Linux allows an authenticated attacker to write a file to any location on the filesystem via path traversal",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.rapid7.com/blog/post/2023/10/16/multiple-vulnerabilities-in-south-river-technologies-titan-mft-and-titan-sftp-fixed/",
      "https://helpdesk.southrivertech.com/portal/en/kb/articles/security-patch-for-issues-cve-2023-45685-through-cve-2023-45690"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年10月16日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "LiteSpeed Cache",
    "CVE编号": "CVE-2023-45000",
    "漏洞描述": "Missing Authorization vulnerability in LiteSpeed Technologies LiteSpeed Cache.This issue affects LiteSpeed Cache: from n/a through 5.7.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/litespeed-cache/wordpress-litespeed-cache-plugin-5-7-unauthenticated-broken-access-control-on-api-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年04月16日"
  },
  {
    "设备品牌": "Piwigo",
    "设备类型": "OTA",
    "产品型号": "Piwigo",
    "CVE编号": "CVE-2023-44393",
    "漏洞描述": "Piwigo is an open source photo gallery application. Prior to version 14.0.0beta4, a reflected cross-site scripting (XSS) vulnerability is in the` /admin.php?page=plugins&tab=new&installstatus=ok&plugin_id=[here]` page. This vulnerability can be exploited by an attacker to inject malicious HTML and JS code into the HTML page, which could then be executed by admin users when they visit the URL with the payload. The vulnerability is caused by the insecure injection of the `plugin_id` value from the URL into the HTML page. An attacker can exploit this vulnerability by crafting a malicious URL that contains a specially crafted `plugin_id` value. When a victim who is logged in as an administrator visits this URL, the malicious code will be injected into the HTML page and executed. This vulnerability can be exploited by any attacker who has access to a malicious URL. However, only users who are logged in as administrators are affected. This is because the vulnerability is only present on the `/admin.php?page=plugins&tab=new&installstatus=ok&plugin_id=[here]` page, which is only accessible to administrators. Version 14.0.0.beta4 contains a patch for this issue.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/Piwigo/Piwigo/security/advisories/GHSA-qg85-957m-7vgg",
      "https://github.com/Piwigo/Piwigo/commit/cc99c0f1e967c5f1722a0cce30ff42374a7bbc23"
    ],
    "受影响版本": [
      "< 14.0.0beta4"
    ],
    "公开日期": "2023年10月09日"
  },
  {
    "设备品牌": "Juniper Networks",
    "设备类型": "OTA",
    "产品型号": "Junos OS",
    "CVE编号": "CVE-2023-44183",
    "漏洞描述": "\nAn Improper Input Validation vulnerability in the VxLAN packet forwarding engine (PFE) of Juniper Networks Junos OS on QFX5000 Series, EX4600 Series devices allows an unauthenticated, adjacent attacker, sending two or more genuine packets in the same VxLAN topology to possibly cause a DMA memory leak to occur under various specific operational conditions. The scenario described here is the worst-case scenario. There are other scenarios that require operator action to occur.\n\nAn indicator of compromise may be seen when multiple devices indicate that FPC0 has gone missing when issuing a show chassis fpc command for about 10 to 20 minutes, and a number of interfaces have also gone missing.\n\nUse the following command to determine if FPC0 has gone missing from the device.\n\nshow chassis fpc detail\nThis issue affects:\n\nJuniper Networks Junos OS on QFX5000 Series, EX4600 Series:\n\n\n\n  *  18.4 version 18.4R2 and later versions prior to 20.4R3-S8;\n  *  21.1 version 21.1R1 and later versions prior to 21.2R3-S6;\n  *  21.3 versions prior to 21.3R3-S5;\n  *  21.4 versions prior to 21.4R3-S4;\n  *  22.1 versions prior to 22.1R3-S3;\n  *  22.2 versions prior to 22.2R3-S1;\n  *  22.3 versions prior to 22.3R2-S2, 22.3R3;\n  *  22.4 versions prior to 22.4R2.\n\n\n\n\n\n\n",
    "攻击向量": "ADJACENT_NETWORK",
    "厂商补丁链接": [
      "https://supportportal.juniper.net/JSA73148",
      "https://www.juniper.net/documentation/us/en/software/junos/multicast-l2/topics/topic-map/redundant-trunk-groups.html",
      "https://www.juniper.net/documentation/us/en/software/junos/evpn-vxlan/topics/topic-map/sdn-vxlan.html"
    ],
    "受影响版本": [
      "18.4R2",
      "20.4",
      "21.1R1",
      "21.2",
      "21.3",
      "21.4",
      "22.1",
      "22.2",
      "22.3",
      "22.4"
    ],
    "公开日期": "2023年10月12日"
  },
  {
    "设备品牌": " LF-Edge, Zededa",
    "设备类型": "OTA",
    "产品型号": "EVE OS",
    "CVE编号": "CVE-2023-43635",
    "漏洞描述": "\nVault Key Sealed With SHA1 PCRs\n\n\n\n\n\n\nThe measured boot solution implemented in EVE OS leans on a PCR locking mechanism.\n\nDifferent parts of the system update different PCR values in the TPM, resulting in a unique\nvalue for each PCR entry.\n\nThese PCRs are then used in order to seal/unseal a key from the TPM which is used to\nencrypt/decrypt the “vault” directory.\n\nThis “vault” directory is the most sensitive point in the system and as such, its content should\nbe protected.\n\nThis mechanism is noted in Zededa’s documentation as the “measured boot” mechanism,\ndesigned to protect said “vault”.\n\nThe code that’s responsible for generating and fetching the key from the TPM assumes that\nSHA256 PCRs are used in order to seal/unseal the key, and as such their presence is being\nchecked.\n\nThe issue here is that the key is not sealed using SHA256 PCRs, but using SHA1 PCRs.\nThis leads to several issues:\n\n• Machines that have their SHA256 PCRs enabled but SHA1 PCRs disabled, as well\nas not sealing their keys at all, meaning the “vault” is not protected from an attacker.\n\n• SHA1 is considered insecure and reduces the complexity level required to unseal the\nkey in machines which have their SHA1 PCRs enabled.\n\n\n\nAn attacker can very easily retrieve the contents of the “vault”, which will effectively render\nthe “measured boot” mechanism meaningless.\n\n\n\n\n\n",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://asrg.io/security-advisories/cve-2023-43635/"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年09月20日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-43336",
    "漏洞描述": "Sangoma Technologies FreePBX before cdr 15.0.18, 16.0.40, 15.0.16, and 16.0.17 was discovered to contain an access control issue via a modified parameter value, e.g., changing extension=self to extension=101.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "http://freepbx.com",
      "http://sangoma.com",
      "https://medium.com/%40janirudransh/security-disclosure-of-vulnerability-cve-2023-23336-4429d416f826"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年11月02日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-41442",
    "漏洞描述": "An issue in Kloudq Technologies Limited Tor Equip 1.0, Tor Loco Mini 1.0 through 3.1 allows a remote attacker to execute arbitrary code via a crafted request to the MQTT component.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://writeups.ayyappan.me/v/tor-iot-mqtt/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年11月15日"
  },
  {
    "设备品牌": "rust-lang",
    "设备类型": "OTA",
    "产品型号": "cargo",
    "CVE编号": "CVE-2023-40030",
    "漏洞描述": "Cargo downloads a Rust project’s dependencies and compiles the project. Starting in Rust 1.60.0 and prior to 1.72, Cargo did not escape Cargo feature names when including them in the report generated by `cargo build --timings`. A malicious package included as a dependency may inject nearly arbitrary HTML here, potentially leading to cross-site scripting if the report is subsequently uploaded somewhere. The vulnerability affects users relying on dependencies from git, local paths, or alternative registries. Users who solely depend on crates.io are unaffected.\n\nRust 1.60.0 introduced `cargo build --timings`, which produces a report of how long the different steps of the build process took. It includes lists of Cargo features for each crate. Prior to Rust 1.72, Cargo feature names were allowed to contain almost any characters (with some exceptions as used by the feature syntax), but it would produce a future incompatibility warning about them since Rust 1.49. crates.io is far more stringent about what it considers a valid feature name and has not allowed such feature names. As the feature names were included unescaped in the timings report, they could be used to inject Javascript into the page, for example with a feature name like `features = [\"<img src='' onerror=alert(0)\"]`. If this report were subsequently uploaded to a domain that uses credentials, the injected Javascript could access resources from the website visitor.\n\nThis issue was fixed in Rust 1.72 by turning the future incompatibility warning into an error. Users should still exercise care in which package they download, by only including trusted dependencies in their projects. Please note that even with these vulnerabilities fixed, by design Cargo allows arbitrary code execution at build time thanks to build scripts and procedural macros: a malicious dependency will be able to cause damage regardless of these vulnerabilities. crates.io has server-side checks preventing this attack, and there are no packages on crates.io exploiting these vulnerabilities. crates.io users still need to excercise care in choosing their dependencies though, as remote code execution is allowed by design there as well.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/rust-lang/cargo/security/advisories/GHSA-wrrj-h57r-vx9p",
      "https://github.com/rust-lang/cargo/pull/12291",
      "https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33",
      "https://github.com/rust-lang/cargo/commit/f975722a0eac934c0722f111f107c4ea2f5c4365"
    ],
    "受影响版本": [
      ">= 1.60.0, < 1.72"
    ],
    "公开日期": "2023年08月24日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "LiteSpeed Cache",
    "CVE编号": "CVE-2023-40000",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in LiteSpeed Technologies LiteSpeed Cache allows Stored XSS.This issue affects LiteSpeed Cache: from n/a through 5.7.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/litespeed-cache/wordpress-litespeed-cache-plugin-5-7-unauthenticated-site-wide-stored-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年04月16日"
  },
  {
    "设备品牌": "Teplitsa of social technologies",
    "设备类型": "OTA",
    "产品型号": "Leyka",
    "CVE编号": "CVE-2023-39314",
    "漏洞描述": "Unauth. Reflected Cross-Site Scripting (XSS) vulnerability in Teplitsa of social technologies Leyka plugin <= 3.30.2 versions.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/leyka/wordpress-leyka-plugin-3-30-2-reflected-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年08月10日"
  },
  {
    "设备品牌": "CODESYS",
    "设备类型": "OTA",
    "产品型号": "CODESYS Control for BeagleBone SL",
    "CVE编号": "CVE-2023-37551",
    "漏洞描述": "In multiple Codesys products in multiple versions, after successful authentication as a user, specially crafted network communication requests can utilize the CmpApp component to download files with any file extensions to the controller. In contrast to the regular file download via CmpFileTransfer, no filtering of certain file types is performed here. As a result, the integrity of the CODESYS control runtime system may be compromised by the files loaded onto the controller.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://cert.vde.com/en/advisories/VDE-2023-019/"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年08月03日"
  },
  {
    "设备品牌": "N-Able",
    "设备类型": "OTA",
    "产品型号": "AutomationManagerAgent",
    "CVE编号": "CVE-2023-37244",
    "漏洞描述": "The affected AutomationManager.AgentService.exe application contains a TOCTOU race condition vulnerability that allows standard users to create a pseudo-symlink at C:\\ProgramData\\N-Able Technologies\\AutomationManager\\Temp, which could be leveraged by an attacker to manipulate the process into performing arbitrary file deletions. We recommend upgrading to version 2.91.0.0",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/mandiant/Vulnerability-Disclosures/blob/master/2023/MNDT-2023-0016.md"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年05月02日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-34838",
    "漏洞描述": "A Cross Site Scripting vulnerability in Microworld Technologies eScan Management console v.14.0.1400.2281 allows a remote attacker to execute arbitrary code via a crafted script to the Description parameter.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/sahiloj/CVE-2023-34838/blob/main/README.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月27日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-34837",
    "漏洞描述": "A Cross Site Scripting vulnerability in Microworld Technologies eScan Management console v.14.0.1400.2281 allows a remote attacker to execute arbitrary code via a vulnerable parameter GrpPath.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/sahiloj/CVE-2023-34837/blob/main/README.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月27日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-34836",
    "漏洞描述": "A Cross Site Scripting vulnerability in Microworld Technologies eScan Management console v.14.0.1400.2281 allows a remote attacker to execute arbitrary code via a crafted script to the Dtltyp and ListName parameters.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/sahiloj/CVE-2023-34836/blob/main/README.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月27日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-34835",
    "漏洞描述": "A Cross Site Scripting vulnerability in Microworld Technologies eScan Management console v.14.0.1400.2281 allows a remote attacker to execute arbitrary JavaScript code via a vulnerable delete_file parameter.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/sahiloj/CVE-2023-34835/blob/main/README.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月27日"
  },
  {
    "设备品牌": "netty",
    "设备类型": "OTA",
    "产品型号": "netty",
    "CVE编号": "CVE-2023-34462",
    "漏洞描述": "Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. The `SniHandler` can allocate up to 16MB of heap for each channel during the TLS handshake. When the handler or the channel does not have an idle timeout, it can be used to make a TCP server using the `SniHandler` to allocate 16MB of heap. The `SniHandler` class is a handler that waits for the TLS handshake to configure a `SslHandler` according to the indicated server name by the `ClientHello` record. For this matter it allocates a `ByteBuf` using the value defined in the `ClientHello` record. Normally the value of the packet should be smaller than the handshake packet but there are not checks done here and the way the code is written, it is possible to craft a packet that makes the `SslClientHelloHandler`. This vulnerability has been fixed in version 4.1.94.Final.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/netty/netty/security/advisories/GHSA-6mjq-h674-j845",
      "https://github.com/netty/netty/commit/535da17e45201ae4278c0479e6162bb4127d4c32",
      "https://security.netapp.com/advisory/ntap-20230803-0001/",
      "https://www.debian.org/security/2023/dsa-5558",
      "https://security.netapp.com/advisory/ntap-20240621-0007/"
    ],
    "受影响版本": [
      "< 4.1.94.Final"
    ],
    "公开日期": "2023年06月22日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-33732",
    "漏洞描述": "Cross Site Scripting (XSS) in the New Policy form in Microworld Technologies eScan management console 14.0.1400.2281 allows a remote attacker to inject arbitrary code via the vulnerable parameters type, txtPolicyType, and Deletefileval.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/sahiloj/CVE-2023-33733/blob/main/CVE-2023-33733.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年05月31日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-33731",
    "漏洞描述": "Reflected Cross Site Scripting (XSS) in the view dashboard detail feature in Microworld Technologies eScan management console 14.0.1400.2281 allows remote attacker to inject arbitrary code via the URL directly.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://owasp.org/www-community/attacks/xss/",
      "https://github.com/sahiloj/CVE-2023-33731/blob/main/CVE-2023-33731.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月02日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-33730",
    "漏洞描述": "Privilege Escalation in the \"GetUserCurrentPwd\" function in Microworld Technologies eScan Management Console 14.0.1400.2281 allows any remote attacker to retrieve password of any admin or normal user in plain text format.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/sahiloj/CVE-2023-33730/blob/main/CVE-2023-33730.md"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年05月31日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-33553",
    "漏洞描述": "An issue in Planet Technologies WDRT-1800AX v1.01-CP21 allows attackers to bypass authentication and escalate privileges to root via manipulation of the LoginStatus cookie.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/0xfml/poc/blob/main/PLANET/WDRT-1800AX.md",
      "https://www.planet.com.tw/en/product/wdrt-1800ax"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月07日"
  },
  {
    "设备品牌": "Teplitsa of social technologies",
    "设备类型": "OTA",
    "产品型号": "Leyka",
    "CVE编号": "CVE-2023-33327",
    "漏洞描述": "Improper Privilege Management vulnerability in Teplitsa of social technologies Leyka allows Privilege Escalation.This issue affects Leyka: from n/a through 3.30.2.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/leyka/wordpress-leyka-plugin-3-29-2-privilege-escalation-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2024年05月14日"
  },
  {
    "设备品牌": "Teplitsa of social technologies",
    "设备类型": "OTA",
    "产品型号": "Leyka",
    "CVE编号": "CVE-2023-33325",
    "漏洞描述": "Unauth. Reflected Cross-Site Scripting (XSS) vulnerability in Teplitsa of social technologies Leyka plugin <= 3.30.1 versions.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/leyka/wordpress-leyka-plugin-3-29-2-reflected-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年08月30日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-31703",
    "漏洞描述": "Cross Site Scripting (XSS) in the edit user form in Microworld Technologies eScan management console 14.0.1400.2281 allows remote attacker to inject arbitrary code via the from parameter.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/sahiloj/CVE-2023-31703/blob/main/README.md",
      "http://packetstormsecurity.com/files/172540/eScan-Management-Console-14.0.1400.2281-Cross-Site-Scripting.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年05月17日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-31497",
    "漏洞描述": "Incorrect access control in Quick Heal Technologies Limited Seqrite Endpoint Security (EPS) all versions prior to v8.0 allows attackers to escalate privileges to root via supplying a crafted binary to the target system.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/0xInfection/EPScalate"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年05月11日"
  },
  {
    "设备品牌": "Apache Software Foundation",
    "设备类型": "OTA",
    "产品型号": "Apache Log4cxx",
    "CVE编号": "CVE-2023-31038",
    "漏洞描述": "SQL injection in Log4cxx when using the ODBC appender to send log messages to a database.  No fields sent to the database were properly escaped for SQL injection.  This has been the case since at least version 0.9.0(released 2003-08-06)\n\n\n\n\nNote that Log4cxx is a C++ framework, so only C++ applications are affected.\n\nBefore version 1.1.0, the ODBC appender was automatically part of Log4cxx if the library was found when compiling the library.  As of version 1.1.0, this must be both explicitly enabled in order to be compiled in.\n\n\n\n\nThree preconditions must be met for this vulnerability to be possible:\n\n1. Log4cxx compiled with ODBC support(before version 1.1.0, this was auto-detected at compile time)\n\n2. ODBCAppender enabled for logging messages to, generally done via a config file\n\n3. User input is logged at some point. If your application does not have user input, it is unlikely to be affected.\n\n\n\n\n\nUsers are recommended to upgrade to version 1.1.0 which properly binds the parameters to the SQL statement, or migrate to the new DBAppender class which supports an ODBC connection in addition to other databases. \nNote that this fix does require a configuration file update, as the old configuration files will not configure properly.  An example is shown below, and more information may be found in the Log4cxx documentation on the ODBCAppender.\n\n\n\n\n\nExample of old configuration snippet:\n\n<appender name=\"SqlODBCAppender\" class=\"ODBCAppender\">\n\n    <param name=\"sql\" value=\"INSERT INTO logs (message) VALUES ('%m')\" />\n\n    ... other params here ...\n\n</appender>\n\n\n\n\nThe migrated configuration snippet with new ColumnMapping parameters:\n\n\n<appender name=\"SqlODBCAppender\" class=\"ODBCAppender\">\n\n\n\n\n    <param name=\"sql\" value=\"INSERT INTO logs (message) VALUES (?)\" />\n\n    <param name=\"ColumnMapping\" value=\"message\"/>\n    ... other params here ...\n\n\n</appender>\n\n\n\n\n\n",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://lists.apache.org/thread/vgjlpdf353vv91gryspwxrzj6p0fbjd9"
    ],
    "受影响版本": [
      "0.9.0"
    ],
    "公开日期": "2023年05月08日"
  },
  {
    "设备品牌": "Hitron Technologies Inc.",
    "设备类型": "OTA",
    "产品型号": "Hitron CODA-5310",
    "CVE编号": "CVE-2023-30604",
    "漏洞描述": "It is identified a vulnerability of insufficient authentication in the system configuration interface of Hitron Technologies CODA-5310. An unauthorized remote attacker can exploit this vulnerability to access system configuration interface, resulting in performing arbitrary system operation or disrupt service.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.twcert.org.tw/tw/cp-132-7086-35622-1.html"
    ],
    "受影响版本": [
      "v7.2.4.7.1b3"
    ],
    "公开日期": "2023年06月02日"
  },
  {
    "设备品牌": "Hitron Technologies Inc.",
    "设备类型": "OTA",
    "产品型号": "Hitron CODA-5310",
    "CVE编号": "CVE-2023-30603",
    "漏洞描述": "Hitron Technologies CODA-5310 Telnet function with the default account and password, and there is no warning or prompt to ask users to change the default password and account. An unauthenticated remote attackers can exploit this vulnerability to obtain the administrator’s privilege, resulting in performing arbitrary system operation or disrupt service.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.twcert.org.tw/tw/cp-132-7085-13321-1.html"
    ],
    "受影响版本": [
      "v7.2.4.7.1b3"
    ],
    "公开日期": "2023年06月02日"
  },
  {
    "设备品牌": "Hitron Technologies Inc.",
    "设备类型": "OTA",
    "产品型号": "Hitron CODA-5310",
    "CVE编号": "CVE-2023-30602",
    "漏洞描述": "Hitron Technologies CODA-5310’s Telnet function transfers sensitive data in plaintext. An unauthenticated remote attacker can exploit this vulnerability to access credentials of normal users and administrator.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.twcert.org.tw/tw/cp-132-7084-74e83-1.html"
    ],
    "受影响版本": [
      "v7.2.4.7.1b3"
    ],
    "公开日期": "2023年06月02日"
  },
  {
    "设备品牌": "Xpdf",
    "设备类型": "OTA",
    "产品型号": "Xpdf",
    "CVE编号": "CVE-2023-3044",
    "漏洞描述": "An excessively large PDF page size (found in fuzz testing, unlikely in normal PDF files) can result in a divide-by-zero in Xpdf's text extraction code.\n\n\n\n\nThis is related to CVE-2022-30524, but the problem here is caused by a very large page size, rather than by a very large character coordinate.\n\n\n",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://www.xpdfreader.com/security-bug/CVE-2023-3044.html",
      "https://github.com/baker221/poc-xpdf"
    ],
    "受影响版本": [
      "4.04"
    ],
    "公开日期": "2023年06月02日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-30297",
    "漏洞描述": "An issue found in N-able Technologies N-central Server before 2023.4 allows a local attacker to execute arbitrary code via the monitoring function of the server.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.n-able.com/",
      "https://status.n-able.com/2023/07/27/cve-2023-30297-release-note/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年08月03日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-29486",
    "漏洞描述": "An issue was discovered in Heimdal Thor agent versions 3.4.2 and before 3.7.0 on Windows, allows attackers to bypass USB access restrictions, execute arbitrary code, and obtain sensitive information via Next-Gen Antivirus component. NOTE: Heimdal argues that the limitation described here is a Microsoft Windows issue, not a Heimdal specific vulnerability. The USB control solution by Heimdal is meant to manage Microsoft Windows native USB restrictions. They maintain that their solution functions as a management layer over Windows settings and is not to blame for limitations in Windows' detection capabilities.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://medium.com/%40drabek.a/weaknesses-in-heimdal-thors-line-of-products-9d0e5095fb93"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年12月21日"
  },
  {
    "设备品牌": "Go standard library",
    "设备类型": "OTA",
    "产品型号": "crypto/tls",
    "CVE编号": "CVE-2023-29409",
    "漏洞描述": "Extremely large RSA keys in certificate chains can cause a client/server to expend significant CPU time verifying signatures. With fix, the size of RSA keys transmitted during handshakes is restricted to <= 8192 bits. Based on a survey of publicly trusted RSA keys, there are currently only three certificates in circulation with keys larger than this, and all three appear to be test certificates that are not actively deployed. It is possible there are larger keys in use in private PKIs, but we target the web PKI, so causing breakage here in the interests of increasing the default safety of users of crypto/tls seems reasonable.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://go.dev/issue/61460",
      "https://go.dev/cl/515257",
      "https://groups.google.com/g/golang-announce/c/X0b6CsSAaYI/m/Efv5DbZ9AwAJ",
      "https://pkg.go.dev/vuln/GO-2023-1987",
      "https://security.netapp.com/advisory/ntap-20230831-0010/",
      "https://security.gentoo.org/glsa/202311-09"
    ],
    "受影响版本": [
      "0",
      "1.20.0-0",
      "1.21.0-0"
    ],
    "公开日期": "2023年08月02日"
  },
  {
    "设备品牌": "Juniper Networks",
    "设备类型": "OTA",
    "产品型号": " Junos OS",
    "CVE编号": "CVE-2023-28968",
    "漏洞描述": "An Improperly Controlled Sequential Memory Allocation vulnerability in the Juniper Networks Deep Packet Inspection-Decoder (JDPI-Decoder) Application Signature component of Junos OS's AppID service on SRX Series devices will stop the JDPI-Decoder from identifying dynamic application traffic, allowing an unauthenticated network-based attacker to send traffic to the target device using the JDPI-Decoder, designed to inspect dynamic application traffic and take action upon this traffic, to instead begin to not take action and to pass the traffic through. An example session can be seen by running the following command and evaluating the output. user@device# run show security flow session source-prefix <address/mask> extensive Session ID: <session ID>, Status: Normal, State: Active Policy name: <name of policy> Dynamic application: junos:UNKNOWN, <<<<< LOOK HERE Please note, the JDPI-Decoder and the AppID SigPack are both affected and both must be upgraded along with the operating system to address the matter. By default, none of this is auto-enabled for automatic updates. This issue affects: Juniper Networks any version of the JDPI-Decoder Engine prior to version 5.7.0-47 with the JDPI-Decoder enabled using any version of the AppID SigPack prior to version 1.550.2-31 (SigPack 3533) on Junos OS on SRX Series: All versions prior to 19.1R3-S10; 19.2 versions prior to 19.2R3-S7; 19.3 versions prior to 19.3R3-S8; 19.4 versions prior to 19.4R3-S11; 20.1 version 20.1R1 and later versions prior to 20.2R3-S7; 20.3 version 20.3R1 and later versions prior to 20.4R3-S6; 21.1 versions prior to 21.1R3-S5; 21.2 versions prior to 21.2R3-S4; 21.3 versions prior to 21.3R3-S3; 21.4 versions prior to 21.4R3-S3; 22.1 versions prior to 22.1R3-S1; 22.2 versions prior to 22.2R2-S1, 22.2R3; 22.3 versions prior to 22.3R1-S2, 22.3R2;",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://supportportal.juniper.net/JSA70592",
      "https://www.juniper.net/documentation/us/en/software/jdpi/release-notes/jdpi-decoder-release-notes-october-2022/jdpi-decoder-release-notes-october-2022.pdf",
      "https://supportportal.juniper.net/s/article/SRX-How-to-update-IDP-signature-database-automatically-on-a-SRX"
    ],
    "受影响版本": [
      "unspecified",
      "19.2",
      "19.3",
      "19.4",
      "20.1R1",
      "20.2",
      "20.3R1",
      "20.4",
      "21.1",
      "21.2",
      "21.3",
      "21.4",
      "22.1",
      "22.2",
      "22.3"
    ],
    "公开日期": "2023年04月17日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-27745",
    "漏洞描述": "An issue in South River Technologies TitanFTP Before v2.0.1.2102 allows attackers with low-level privileges to perform Administrative actions by sending requests to the user server.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.southrivertech.com/software/nextgen/titanftp/en/relnotes.pdf",
      "https://www.whiteoaksecurity.com/blog/titanftp-vulnerability-disclosure/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月02日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-27744",
    "漏洞描述": "An issue was discovered in South River Technologies TitanFTP NextGen server that allows for a vertical privilege escalation leading to remote code execution.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.southrivertech.com/software/nextgen/titanftp/en/relnotes.pdf",
      "https://www.whiteoaksecurity.com/blog/titanftp-vulnerability-disclosure/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月02日"
  },
  {
    "设备品牌": "Teplitsa of social technologies",
    "设备类型": "OTA",
    "产品型号": "Leyka",
    "CVE编号": "CVE-2023-27450",
    "漏洞描述": "Unauth. Stored Cross-Site Scripting (XSS) vulnerability in Teplitsa of social technologies Leyka plugin <= 3.29.2 versions.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/leyka/wordpress-leyka-plugin-3-29-2-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月21日"
  },
  {
    "设备品牌": "Teplitsa of social technologies",
    "设备类型": "OTA",
    "产品型号": "Leyka",
    "CVE编号": "CVE-2023-27442",
    "漏洞描述": "Cross-Site Request Forgery (CSRF) vulnerability in Teplitsa of social technologies Leyka plugin <= 3.29.2 versions.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/leyka/wordpress-leyka-plugin-3-29-2-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年11月22日"
  },
  {
    "设备品牌": "bytecodealliance",
    "设备类型": "OTA",
    "产品型号": "wasmtime",
    "CVE编号": "CVE-2023-26489",
    "漏洞描述": "wasmtime is a fast and secure runtime for WebAssembly. In affected versions wasmtime's code generator, Cranelift, has a bug on x86_64 targets where address-mode computation mistakenly would calculate a 35-bit effective address instead of WebAssembly's defined 33-bit effective address. This bug means that, with default codegen settings, a wasm-controlled load/store operation could read/write addresses up to 35 bits away from the base of linear memory. Due to this bug, however, addresses up to `0xffffffff * 8 + 0x7ffffffc = 36507222004 = ~34G` bytes away from the base of linear memory are possible from guest code. This means that the virtual memory 6G away from the base of linear memory up to ~34G away can be read/written by a malicious module. A guest module can, without the knowledge of the embedder, read/write memory in this region. The memory may belong to other WebAssembly instances when using the pooling allocator, for example. Affected embedders are recommended to analyze preexisting wasm modules to see if they're affected by the incorrect codegen rules and possibly correlate that with an anomalous number of traps during historical execution to locate possibly suspicious modules. The specific bug in Cranelift's x86_64 backend is that a WebAssembly address which is left-shifted by a constant amount from 1 to 3 will get folded into x86_64's addressing modes which perform shifts. For example `(i32.load (i32.shl (local.get 0) (i32.const 3)))` loads from the WebAssembly address `$local0 << 3`. When translated to Cranelift the `$local0 << 3` computation, a 32-bit value, is zero-extended to a 64-bit value and then added to the base address of linear memory. Cranelift would generate an instruction of the form `movl (%base, %local0, 8), %dst` which calculates `%base + %local0 << 3`. The bug here, however, is that the address computation happens with 64-bit values, where the `$local0 << 3` computation was supposed to be truncated to a a 32-bit value. This means that `%local0`, which can use up to 32-bits for an address, gets 3 extra bits of address space to be accessible via this `movl` instruction. The fix in Cranelift is to remove the erroneous lowering rules in the backend which handle these zero-extended expression. The above example is then translated to `movl %local0, %temp; shl $3, %temp; movl (%base, %temp), %dst` which correctly truncates the intermediate computation of `%local0 << 3` to 32-bits inside the `%temp` register which is then added to the `%base` value. Wasmtime version 4.0.1, 5.0.1, and 6.0.1 have been released and have all been patched to no longer contain the erroneous lowering rules. While updating Wasmtime is recommended, there are a number of possible workarounds that embedders can employ to mitigate this issue if updating is not possible. Note that none of these workarounds are on-by-default and require explicit configuration: 1. The `Config::static_memory_maximum_size(0)` option can be used to force all accesses to linear memory to be explicitly bounds-checked. This will perform a bounds check separately from the address-mode computation which correctly calculates the effective address of a load/store. Note that this can have a large impact on the execution performance of WebAssembly modules. 2. The `Config::static_memory_guard_size(1 << 36)` option can be used to greatly increase the guard pages placed after linear memory. This will guarantee that memory accesses up-to-34G away are guaranteed to be semantically correct by reserving unmapped memory for the instance. Note that this reserves a very large amount of virtual memory per-instances and can greatly reduce the maximum number of concurrent instances being run. 3. If using a non-x86_64 host is possible, then that will also work around this bug. This bug does not affect Wasmtime's or Cranelift's AArch64 backend, for example.\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8",
      "https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f",
      "https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size",
      "https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size",
      "https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ"
    ],
    "受影响版本": [
      "cranelift-codegen: >= 0.84.0, < 0.91.1",
      "cranelift-codegen: >= 0.92.0, < 0.92.1",
      "cranelift-codegen: >= 0.93.0, < 0.93.1",
      " wasmtime: >= 0.37.0, < 4.0.1",
      " wasmtime: >= 5.0.0, < 5.0.1",
      " wasmtime: >= 6.0.0, < 6.0.1"
    ],
    "公开日期": "2023年03月08日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2023-25758",
    "漏洞描述": "Onekey Touch devices through 4.0.0 and Onekey Mini devices through 2.10.0 allow man-in-the-middle attackers to obtain the seed phase. The man-in-the-middle access can only be obtained after disassembling a device (i.e., here, \"man-in-the-middle\" does not refer to the attacker's position on an IP network). NOTE: the vendor states that \"our hardware team has updated the security patch without anyone being affected.\"",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/OneKeyHQ/firmware",
      "https://blog.onekey.so/our-response-to-recent-security-fix-reports-13914fea8afd",
      "https://fortune.com/crypto/2023/02/09/cyber-firm-cracks-onekey-crypto-wallets-in-video-raises-questions-hardware-security/amp/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年02月14日"
  },
  {
    "设备品牌": "Apache Software Foundation",
    "设备类型": "OTA",
    "产品型号": "Apache HTTP Server",
    "CVE编号": "CVE-2023-25690",
    "漏洞描述": "Some mod_proxy configurations on Apache HTTP Server versions 2.4.0 through 2.4.55 allow a HTTP Request Smuggling attack.\n\n\n\n\nConfigurations are affected when mod_proxy is enabled along with some form of RewriteRule\n or ProxyPassMatch in which a non-specific pattern matches\n some portion of the user-supplied request-target (URL) data and is then\n re-inserted into the proxied request-target using variable \nsubstitution. For example, something like:\n\n\n\n\nRewriteEngine on\nRewriteRule \"^/here/(.*)\" \"http://example.com:8080/elsewhere?$1\"; [P]\nProxyPassReverse /here/ http://example.com:8080/\n\n\nRequest splitting/smuggling could result in bypass of access controls in the proxy server, proxying unintended URLs to existing origin servers, and cache poisoning. Users are recommended to update to at least version 2.4.56 of Apache HTTP Server.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://httpd.apache.org/security/vulnerabilities_24.html",
      "https://lists.debian.org/debian-lts-announce/2023/04/msg00028.html",
      "https://security.gentoo.org/glsa/202309-01",
      "http://packetstormsecurity.com/files/176334/Apache-2.4.55-mod_proxy-HTTP-Request-Smuggling.html"
    ],
    "受影响版本": [
      "2.4.0"
    ],
    "公开日期": "2023年03月07日"
  },
  {
    "设备品牌": "Softnext",
    "设备类型": "OTA",
    "产品型号": "SPAM SQR",
    "CVE编号": "CVE-2023-24835",
    "漏洞描述": "Softnext Technologies Corp.’s SPAM SQR has a vulnerability of Code Injection within its specific function. An authenticated remote attacker with administrator privilege can exploit this vulnerability to execute arbitrary system command to perform arbitrary system operation or disrupt service.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.twcert.org.tw/tw/cp-132-6955-c7612-1.html"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2023年03月27日"
  },
  {
    "设备品牌": "Zestard Technologies",
    "设备类型": "OTA",
    "产品型号": "Admin side data storage for Contact Form 7",
    "CVE编号": "CVE-2023-24420",
    "漏洞描述": "Unauth. Reflected Cross-Site Scripting (XSS) vulnerability in Zestard Technologies Admin side data storage for Contact Form 7 plugin <= 1.1.1 versions.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/admin-side-data-storage-for-contact-form-7/wordpress-admin-side-data-storage-for-contact-form-7-plugin-1-1-1-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月15日"
  },
  {
    "设备品牌": "Google",
    "设备类型": "OTA",
    "产品型号": "Android",
    "CVE编号": "CVE-2023-21303",
    "漏洞描述": "In Content, here is a possible way to determine whether an app is installed, without query permissions, due to side channel information disclosure. This could lead to local information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://source.android.com/docs/security/bulletin/android-14"
    ],
    "受影响版本": [
      "14"
    ],
    "公开日期": "2023年10月30日"
  },
  {
    "设备品牌": "SDG Technologies",
    "设备类型": "OTA",
    "产品型号": "PnPSCADA",
    "CVE编号": "CVE-2023-1934",
    "漏洞描述": "The PnPSCADA system, a product of SDG Technologies CC, is afflicted by a critical unauthenticated error-based PostgreSQL Injection vulnerability. Present within the hitlogcsv.jsp endpoint, this security flaw permits unauthenticated attackers to engage with the underlying database seamlessly and passively. Consequently, malicious actors could gain access to vital information, such as Industrial Control System (ICS) and OT data, alongside other sensitive records like SMS and SMS Logs. The unauthorized database access exposes compromised systems to potential manipulation or breach of essential infrastructure data, highlighting the severity of this vulnerability.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.cisa.gov/news-events/ics-advisories/icsa-23-131-12",
      "http://packetstormsecurity.com/files/172511/PnPSCADA-2.x-SQL-Injection.html"
    ],
    "受影响版本": [
      "2.*"
    ],
    "公开日期": "2023年05月12日"
  },
  {
    "设备品牌": "Utarit Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Persolus",
    "CVE编号": "CVE-2023-1152",
    "漏洞描述": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in Utarit Information Technologies Persolus allows SQL Injection. This issue affects Persolus: before 2.03.93.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0154-2"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年03月17日"
  },
  {
    "设备品牌": "NTN Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Online Services Software",
    "CVE编号": "CVE-2023-0939",
    "漏洞描述": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') vulnerability in NTN Information Technologies Online Services Software allows SQL Injection.This issue affects Online Services Software: before 1.17.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0103"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年02月23日"
  },
  {
    "设备品牌": "ASOS Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Book Cites",
    "CVE编号": "CVE-2023-0578",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in ASOS Information Technologies Book Cites allows Cross-Site Scripting (XSS).This issue affects Book Cites: before 23.01.05.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0125"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年03月03日"
  },
  {
    "设备品牌": "ASOS Information Technologies",
    "设备类型": "OTA",
    "产品型号": "SOBIAD",
    "CVE编号": "CVE-2023-0577",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') vulnerability in ASOS Information Technologies SOBIAD allows Cross-Site Scripting (XSS).This issue affects SOBIAD: before 23.02.01.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0125"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年03月03日"
  },
  {
    "设备品牌": "Swift Project",
    "设备类型": "OTA",
    "产品型号": "Async HTTP Client",
    "CVE编号": "CVE-2023-0040",
    "漏洞描述": "Versions of Async HTTP Client prior to 1.13.2 are vulnerable to a form of targeted request manipulation called CRLF injection. This vulnerability was the result of insufficient validation of HTTP header field values before sending them to the network. Users are vulnerable if they pass untrusted data into HTTP header field values without prior sanitisation. Common use-cases here might be to place usernames from a database into HTTP header fields. This vulnerability allows attackers to inject new HTTP header fields, or entirely new requests, into the data stream. This can cause requests to be understood very differently by the remote server than was intended. In general, this is unlikely to result in data disclosure, but it can result in a number of logical errors and other misbehaviours.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/swift-server/async-http-client/security/advisories/GHSA-v3r5-pjpm-mwgq"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2023年01月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50224",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86/mmu: Treat NX as a valid SPTE bit for NPT\n\nTreat the NX bit as valid when using NPT, as KVM will set the NX bit when\nthe NX huge page mitigation is enabled (mindblowing) and trigger the WARN\nthat fires on reserved SPTE bits being set.\n\nKVM has required NX support for SVM since commit b26a71a1a5b9 (\"KVM: SVM:\nRefuse to load kvm_amd if NX support is not available\") for exactly this\nreason, but apparently it never occurred to anyone to actually test NPT\nwith the mitigation enabled.\n\n  ------------[ cut here ]------------\n  spte = 0x800000018a600ee7, level = 2, rsvd bits = 0x800f0000001fe000\n  WARNING: CPU: 152 PID: 15966 at arch/x86/kvm/mmu/spte.c:215 make_spte+0x327/0x340 [kvm]\n  Hardware name: Google, Inc. Arcadia_IT_80/Arcadia_IT_80, BIOS 10.48.0 01/27/2022\n  RIP: 0010:make_spte+0x327/0x340 [kvm]\n  Call Trace:\n   <TASK>\n   tdp_mmu_map_handle_target_level+0xc3/0x230 [kvm]\n   kvm_tdp_mmu_map+0x343/0x3b0 [kvm]\n   direct_page_fault+0x1ae/0x2a0 [kvm]\n   kvm_tdp_page_fault+0x7d/0x90 [kvm]\n   kvm_mmu_page_fault+0xfb/0x2e0 [kvm]\n   npf_interception+0x55/0x90 [kvm_amd]\n   svm_invoke_exit_handler+0x31/0xf0 [kvm_amd]\n   svm_handle_exit+0xf6/0x1d0 [kvm_amd]\n   vcpu_enter_guest+0xb6d/0xee0 [kvm]\n   ? kvm_pmu_trigger_event+0x6d/0x230 [kvm]\n   vcpu_run+0x65/0x2c0 [kvm]\n   kvm_arch_vcpu_ioctl_run+0x355/0x610 [kvm]\n   kvm_vcpu_ioctl+0x551/0x610 [kvm]\n   __se_sys_ioctl+0x77/0xc0\n   __x64_sys_ioctl+0x1d/0x20\n   do_syscall_64+0x44/0xa0\n   entry_SYSCALL_64_after_hwframe+0x46/0xb0\n   </TASK>\n  ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6271f2854b9233702e236e576b885a876dde4889",
      "https://git.kernel.org/stable/c/6c6ab524cfae0799e55c82b2c1d61f1af0156f8d"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50223",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nLoongArch: cpuinfo: Fix a warning for CONFIG_CPUMASK_OFFSTACK\n\nWhen CONFIG_CPUMASK_OFFSTACK and CONFIG_DEBUG_PER_CPU_MAPS is selected,\ncpu_max_bits_warn() generates a runtime warning similar as below while\nwe show /proc/cpuinfo. Fix this by using nr_cpu_ids (the runtime limit)\ninstead of NR_CPUS to iterate CPUs.\n\n[    3.052463] ------------[ cut here ]------------\n[    3.059679] WARNING: CPU: 3 PID: 1 at include/linux/cpumask.h:108 show_cpuinfo+0x5e8/0x5f0\n[    3.070072] Modules linked in: efivarfs autofs4\n[    3.076257] CPU: 0 PID: 1 Comm: systemd Not tainted 5.19-rc5+ #1052\n[    3.084034] Hardware name: Loongson Loongson-3A5000-7A1000-1w-V0.1-CRB/Loongson-LS3A5000-7A1000-1w-EVB-V1.21, BIOS Loongson-UDK2018-V2.0.04082-beta7 04/27\n[    3.099465] Stack : 9000000100157b08 9000000000f18530 9000000000cf846c 9000000100154000\n[    3.109127]         9000000100157a50 0000000000000000 9000000100157a58 9000000000ef7430\n[    3.118774]         90000001001578e8 0000000000000040 0000000000000020 ffffffffffffffff\n[    3.128412]         0000000000aaaaaa 1ab25f00eec96a37 900000010021de80 900000000101c890\n[    3.138056]         0000000000000000 0000000000000000 0000000000000000 0000000000aaaaaa\n[    3.147711]         ffff8000339dc220 0000000000000001 0000000006ab4000 0000000000000000\n[    3.157364]         900000000101c998 0000000000000004 9000000000ef7430 0000000000000000\n[    3.167012]         0000000000000009 000000000000006c 0000000000000000 0000000000000000\n[    3.176641]         9000000000d3de08 9000000001639390 90000000002086d8 00007ffff0080286\n[    3.186260]         00000000000000b0 0000000000000004 0000000000000000 0000000000071c1c\n[    3.195868]         ...\n[    3.199917] Call Trace:\n[    3.203941] [<90000000002086d8>] show_stack+0x38/0x14c\n[    3.210666] [<9000000000cf846c>] dump_stack_lvl+0x60/0x88\n[    3.217625] [<900000000023d268>] __warn+0xd0/0x100\n[    3.223958] [<9000000000cf3c90>] warn_slowpath_fmt+0x7c/0xcc\n[    3.231150] [<9000000000210220>] show_cpuinfo+0x5e8/0x5f0\n[    3.238080] [<90000000004f578c>] seq_read_iter+0x354/0x4b4\n[    3.245098] [<90000000004c2e90>] new_sync_read+0x17c/0x1c4\n[    3.252114] [<90000000004c5174>] vfs_read+0x138/0x1d0\n[    3.258694] [<90000000004c55f8>] ksys_read+0x70/0x100\n[    3.265265] [<9000000000cfde9c>] do_syscall+0x7c/0x94\n[    3.271820] [<9000000000202fe4>] handle_syscall+0xc4/0x160\n[    3.281824] ---[ end trace 8b484262b4b8c24c ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/37268c7badd36f5381056d1651a6ee0b63b8ff3c",
      "https://git.kernel.org/stable/c/28e112afa44ad0814120d41c68fa72372a2cd2c2"
    ],
    "受影响版本": [
      "fa96b57c149061f71a70bd6582d995f6424fbbf4",
      "fa96b57c149061f71a70bd6582d995f6424fbbf4"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50214",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncoresight: Clear the connection field properly\n\ncoresight devices track their connections (output connections) and\nhold a reference to the fwnode. When a device goes away, we walk through\nthe devices on the coresight bus and make sure that the references\nare dropped. This happens both ways:\n a) For all output connections from the device, drop the reference to\n    the target device via coresight_release_platform_data()\n\nb) Iterate over all the devices on the coresight bus and drop the\n   reference to fwnode if *this* device is the target of the output\n   connection, via coresight_remove_conns()->coresight_remove_match().\n\nHowever, the coresight_remove_match() doesn't clear the fwnode field,\nafter dropping the reference, this causes use-after-free and\nadditional refcount drops on the fwnode.\n\ne.g., if we have two devices, A and B, with a connection, A -> B.\nIf we remove B first, B would clear the reference on B, from A\nvia coresight_remove_match(). But when A is removed, it still has\na connection with fwnode still pointing to B. Thus it tries to  drops\nthe reference in coresight_release_platform_data(), raising the bells\nlike :\n\n[   91.990153] ------------[ cut here ]------------\n[   91.990163] refcount_t: addition on 0; use-after-free.\n[   91.990212] WARNING: CPU: 0 PID: 461 at lib/refcount.c:25 refcount_warn_saturate+0xa0/0x144\n[   91.990260] Modules linked in: coresight_funnel coresight_replicator coresight_etm4x(-)\n crct10dif_ce coresight ip_tables x_tables ipv6 [last unloaded: coresight_cpu_debug]\n[   91.990398] CPU: 0 PID: 461 Comm: rmmod Tainted: G        W       T 5.19.0-rc2+ #53\n[   91.990418] Hardware name: ARM LTD ARM Juno Development Platform/ARM Juno Development Platform, BIOS EDK II Feb  1 2019\n[   91.990434] pstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[   91.990454] pc : refcount_warn_saturate+0xa0/0x144\n[   91.990476] lr : refcount_warn_saturate+0xa0/0x144\n[   91.990496] sp : ffff80000c843640\n[   91.990509] x29: ffff80000c843640 x28: ffff800009957c28 x27: ffff80000c8439a8\n[   91.990560] x26: ffff00097eff1990 x25: ffff8000092b6ad8 x24: ffff00097eff19a8\n[   91.990610] x23: ffff80000c8439a8 x22: 0000000000000000 x21: ffff80000c8439c2\n[   91.990659] x20: 0000000000000000 x19: ffff00097eff1a10 x18: ffff80000ab99c40\n[   91.990708] x17: 0000000000000000 x16: 0000000000000000 x15: ffff80000abf6fa0\n[   91.990756] x14: 000000000000001d x13: 0a2e656572662d72 x12: 657466612d657375\n[   91.990805] x11: 203b30206e6f206e x10: 6f69746964646120 x9 : ffff8000081aba28\n[   91.990854] x8 : 206e6f206e6f6974 x7 : 69646461203a745f x6 : 746e756f63666572\n[   91.990903] x5 : ffff00097648ec58 x4 : 0000000000000000 x3 : 0000000000000027\n[   91.990952] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff00080260ba00\n[   91.991000] Call trace:\n[   91.991012]  refcount_warn_saturate+0xa0/0x144\n[   91.991034]  kobject_get+0xac/0xb0\n[   91.991055]  of_node_get+0x2c/0x40\n[   91.991076]  of_fwnode_get+0x40/0x60\n[   91.991094]  fwnode_handle_get+0x3c/0x60\n[   91.991116]  fwnode_get_nth_parent+0xf4/0x110\n[   91.991137]  fwnode_full_name_string+0x48/0xc0\n[   91.991158]  device_node_string+0x41c/0x530\n[   91.991178]  pointer+0x320/0x3ec\n[   91.991198]  vsnprintf+0x23c/0x750\n[   91.991217]  vprintk_store+0x104/0x4b0\n[   91.991238]  vprintk_emit+0x8c/0x360\n[   91.991257]  vprintk_default+0x44/0x50\n[   91.991276]  vprintk+0xcc/0xf0\n[   91.991295]  _printk+0x68/0x90\n[   91.991315]  of_node_release+0x13c/0x14c\n[   91.991334]  kobject_put+0x98/0x114\n[   91.991354]  of_node_put+0x24/0x34\n[   91.991372]  of_fwnode_put+0x40/0x5c\n[   91.991390]  fwnode_handle_put+0x38/0x50\n[   91.991411]  coresight_release_platform_data+0x74/0xb0 [coresight]\n[   91.991472]  coresight_unregister+0x64/0xcc [coresight]\n[   91.991525]  etm4_remove_dev+0x64/0x78 [coresight_etm4x]\n[   91.991563]  etm4_remove_amba+0x1c/0x2c [coresight_etm4x]\n[   91.991598]  amba_remove+0x3c/0x19c\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e9205d8dd1cafb7cff689ef9ddf06276a68f54a4",
      "https://git.kernel.org/stable/c/847b9273dd61567fb77617eabc5fa002594db062",
      "https://git.kernel.org/stable/c/b49b29ee113a87997bcca0bb0585bb46582846c1",
      "https://git.kernel.org/stable/c/d43e967963c4d1b2b49f894d2f1b12865f87b098",
      "https://git.kernel.org/stable/c/bc57850fcb7e4cb91b6321d0ce83357cefd55c54",
      "https://git.kernel.org/stable/c/2af89ebacf299b7fba5f3087d35e8a286ec33706"
    ],
    "受影响版本": [
      "37ea1ffddffa63c920ce826786fe610c78f57842",
      "37ea1ffddffa63c920ce826786fe610c78f57842",
      "37ea1ffddffa63c920ce826786fe610c78f57842",
      "37ea1ffddffa63c920ce826786fe610c78f57842",
      "37ea1ffddffa63c920ce826786fe610c78f57842",
      "37ea1ffddffa63c920ce826786fe610c78f57842"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50210",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nMIPS: cpuinfo: Fix a warning for CONFIG_CPUMASK_OFFSTACK\n\nWhen CONFIG_CPUMASK_OFFSTACK and CONFIG_DEBUG_PER_CPU_MAPS is selected,\ncpu_max_bits_warn() generates a runtime warning similar as below while\nwe show /proc/cpuinfo. Fix this by using nr_cpu_ids (the runtime limit)\ninstead of NR_CPUS to iterate CPUs.\n\n[    3.052463] ------------[ cut here ]------------\n[    3.059679] WARNING: CPU: 3 PID: 1 at include/linux/cpumask.h:108 show_cpuinfo+0x5e8/0x5f0\n[    3.070072] Modules linked in: efivarfs autofs4\n[    3.076257] CPU: 0 PID: 1 Comm: systemd Not tainted 5.19-rc5+ #1052\n[    3.084034] Hardware name: Loongson Loongson-3A4000-7A1000-1w-V0.1-CRB/Loongson-LS3A4000-7A1000-1w-EVB-V1.21, BIOS Loongson-UDK2018-V2.0.04082-beta7 04/27\n[    3.099465] Stack : 9000000100157b08 9000000000f18530 9000000000cf846c 9000000100154000\n[    3.109127]         9000000100157a50 0000000000000000 9000000100157a58 9000000000ef7430\n[    3.118774]         90000001001578e8 0000000000000040 0000000000000020 ffffffffffffffff\n[    3.128412]         0000000000aaaaaa 1ab25f00eec96a37 900000010021de80 900000000101c890\n[    3.138056]         0000000000000000 0000000000000000 0000000000000000 0000000000aaaaaa\n[    3.147711]         ffff8000339dc220 0000000000000001 0000000006ab4000 0000000000000000\n[    3.157364]         900000000101c998 0000000000000004 9000000000ef7430 0000000000000000\n[    3.167012]         0000000000000009 000000000000006c 0000000000000000 0000000000000000\n[    3.176641]         9000000000d3de08 9000000001639390 90000000002086d8 00007ffff0080286\n[    3.186260]         00000000000000b0 0000000000000004 0000000000000000 0000000000071c1c\n[    3.195868]         ...\n[    3.199917] Call Trace:\n[    3.203941] [<98000000002086d8>] show_stack+0x38/0x14c\n[    3.210666] [<9800000000cf846c>] dump_stack_lvl+0x60/0x88\n[    3.217625] [<980000000023d268>] __warn+0xd0/0x100\n[    3.223958] [<9800000000cf3c90>] warn_slowpath_fmt+0x7c/0xcc\n[    3.231150] [<9800000000210220>] show_cpuinfo+0x5e8/0x5f0\n[    3.238080] [<98000000004f578c>] seq_read_iter+0x354/0x4b4\n[    3.245098] [<98000000004c2e90>] new_sync_read+0x17c/0x1c4\n[    3.252114] [<98000000004c5174>] vfs_read+0x138/0x1d0\n[    3.258694] [<98000000004c55f8>] ksys_read+0x70/0x100\n[    3.265265] [<9800000000cfde9c>] do_syscall+0x7c/0x94\n[    3.271820] [<9800000000202fe4>] handle_syscall+0xc4/0x160\n[    3.281824] ---[ end trace 8b484262b4b8c24c ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d3ac4e47510ec0753ebe1e418a334ad202784aa8",
      "https://git.kernel.org/stable/c/98aaa511957667ba26d6dabe28dfa210a8f53a63",
      "https://git.kernel.org/stable/c/4cb392956ae392aec4aa06e661a0bb9146b0bace",
      "https://git.kernel.org/stable/c/274e44e2123417e0924c90d4b4531913b5f3aa2e",
      "https://git.kernel.org/stable/c/807adf6ffa8c3beedcd63b20f5a59c7d061df7d2",
      "https://git.kernel.org/stable/c/e41db8a9ce696a3382a4f098878fd4d14bccd201",
      "https://git.kernel.org/stable/c/8916ec149c79cb21f5454fa7840ad96f99cf51cf",
      "https://git.kernel.org/stable/c/7d305823e02217b29d41fca67e3cef87fd7bd688",
      "https://git.kernel.org/stable/c/e1a534f5d074db45ae5cbac41d8912b98e96a006"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50187",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nath11k: fix netdev open race\n\nMake sure to allocate resources needed before registering the device.\n\nThis specifically avoids having a racing open() trigger a BUG_ON() in\nmod_timer() when ath11k_mac_op_start() is called before the\nmon_reap_timer as been set up.\n\nI did not see this issue with next-20220310, but I hit it on every probe\nwith next-20220511. Perhaps some timing changed in between.\n\nHere's the backtrace:\n\n[   51.346947] kernel BUG at kernel/time/timer.c:990!\n[   51.346958] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP\n...\n[   51.578225] Call trace:\n[   51.583293]  __mod_timer+0x298/0x390\n[   51.589518]  mod_timer+0x14/0x20\n[   51.595368]  ath11k_mac_op_start+0x41c/0x4a0 [ath11k]\n[   51.603165]  drv_start+0x38/0x60 [mac80211]\n[   51.610110]  ieee80211_do_open+0x29c/0x7d0 [mac80211]\n[   51.617945]  ieee80211_open+0x60/0xb0 [mac80211]\n[   51.625311]  __dev_open+0x100/0x1c0\n[   51.631420]  __dev_change_flags+0x194/0x210\n[   51.638214]  dev_change_flags+0x24/0x70\n[   51.644646]  do_setlink+0x228/0xdb0\n[   51.650723]  __rtnl_newlink+0x460/0x830\n[   51.657162]  rtnl_newlink+0x4c/0x80\n[   51.663229]  rtnetlink_rcv_msg+0x124/0x390\n[   51.669917]  netlink_rcv_skb+0x58/0x130\n[   51.676314]  rtnetlink_rcv+0x18/0x30\n[   51.682460]  netlink_unicast+0x250/0x310\n[   51.688960]  netlink_sendmsg+0x19c/0x3e0\n[   51.695458]  ____sys_sendmsg+0x220/0x290\n[   51.701938]  ___sys_sendmsg+0x7c/0xc0\n[   51.708148]  __sys_sendmsg+0x68/0xd0\n[   51.714254]  __arm64_sys_sendmsg+0x28/0x40\n[   51.720900]  invoke_syscall+0x48/0x120\n\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a2c45f8c3d18269e641f0c7da2dde47ef8414034",
      "https://git.kernel.org/stable/c/eaff3946a86fc63280a30158a4ae1e141449817c",
      "https://git.kernel.org/stable/c/abb7dc8fbb27c15dcc927df56190f3c5ede58bd5",
      "https://git.kernel.org/stable/c/307ce58270b3b50ca21cfcc910568429b06803f7",
      "https://git.kernel.org/stable/c/d4ba1ff87b17e81686ada8f429300876f55f95ad"
    ],
    "受影响版本": [
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50177",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nrcutorture: Fix ksoftirqd boosting timing and iteration\n\nThe RCU priority boosting can fail in two situations:\n\n1) If (nr_cpus= > maxcpus=), which means if the total number of CPUs\nis higher than those brought online at boot, then torture_onoff() may\nlater bring up CPUs that weren't online on boot. Now since rcutorture\ninitialization only boosts the ksoftirqds of the CPUs that have been\nset online on boot, the CPUs later set online by torture_onoff won't\nbenefit from the boost, making RCU priority boosting fail.\n\n2) The ksoftirqd kthreads are boosted after the creation of\nrcu_torture_boost() kthreads, which opens a window large enough for these\nrcu_torture_boost() kthreads to wait (despite running at FIFO priority)\nfor ksoftirqds that are still running at SCHED_NORMAL priority.\n\nThe issues can trigger for example with:\n\n\t./kvm.sh --configs TREE01 --kconfig \"CONFIG_RCU_BOOST=y\"\n\n\t[   34.968561] rcu-torture: !!!\n\t[   34.968627] ------------[ cut here ]------------\n\t[   35.014054] WARNING: CPU: 4 PID: 114 at kernel/rcu/rcutorture.c:1979 rcu_torture_stats_print+0x5ad/0x610\n\t[   35.052043] Modules linked in:\n\t[   35.069138] CPU: 4 PID: 114 Comm: rcu_torture_sta Not tainted 5.18.0-rc1 #1\n\t[   35.096424] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.14.0-0-g155821a-rebuilt.opensuse.org 04/01/2014\n\t[   35.154570] RIP: 0010:rcu_torture_stats_print+0x5ad/0x610\n\t[   35.198527] Code: 63 1b 02 00 74 02 0f 0b 48 83 3d 35 63 1b 02 00 74 02 0f 0b 48 83 3d 21 63 1b 02 00 74 02 0f 0b 48 83 3d 0d 63 1b 02 00 74 02 <0f> 0b 83 eb 01 0f 8e ba fc ff ff 0f 0b e9 b3 fc ff f82\n\t[   37.251049] RSP: 0000:ffffa92a0050bdf8 EFLAGS: 00010202\n\t[   37.277320] rcu: De-offloading 8\n\t[   37.290367] RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000001\n\t[   37.290387] RDX: 0000000000000000 RSI: 00000000ffffbfff RDI: 00000000ffffffff\n\t[   37.290398] RBP: 000000000000007b R08: 0000000000000000 R09: c0000000ffffbfff\n\t[   37.290407] R10: 000000000000002a R11: ffffa92a0050bc18 R12: ffffa92a0050be20\n\t[   37.290417] R13: ffffa92a0050be78 R14: 0000000000000000 R15: 000000000001bea0\n\t[   37.290427] FS:  0000000000000000(0000) GS:ffff96045eb00000(0000) knlGS:0000000000000000\n\t[   37.290448] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n\t[   37.290460] CR2: 0000000000000000 CR3: 000000001dc0c000 CR4: 00000000000006e0\n\t[   37.290470] Call Trace:\n\t[   37.295049]  <TASK>\n\t[   37.295065]  ? preempt_count_add+0x63/0x90\n\t[   37.295095]  ? _raw_spin_lock_irqsave+0x12/0x40\n\t[   37.295125]  ? rcu_torture_stats_print+0x610/0x610\n\t[   37.295143]  rcu_torture_stats+0x29/0x70\n\t[   37.295160]  kthread+0xe3/0x110\n\t[   37.295176]  ? kthread_complete_and_exit+0x20/0x20\n\t[   37.295193]  ret_from_fork+0x22/0x30\n\t[   37.295218]  </TASK>\n\nFix this with boosting the ksoftirqds kthreads from the boosting\nhotplug callback itself and before the boosting kthreads are created.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/621595f771a6bd458ffbc40679e222ba5d0a7a1e",
      "https://git.kernel.org/stable/c/8e84693621f53bf894af9905a6531e0530402145",
      "https://git.kernel.org/stable/c/7e7472c62c6ded322afd9d5ac8bb20a08e7c5674",
      "https://git.kernel.org/stable/c/3002153a91a9732a6d1d0bb95138593c7da15743"
    ],
    "受影响版本": [
      "ea6d962e80b61996aeacb443661cc3adcb605315",
      "ea6d962e80b61996aeacb443661cc3adcb605315",
      "ea6d962e80b61996aeacb443661cc3adcb605315",
      "ea6d962e80b61996aeacb443661cc3adcb605315"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50173",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/msm/mdp5: Fix global state lock backoff\n\nWe need to grab the lock after the early return for !hwpipe case.\nOtherwise, we could have hit contention yet still returned 0.\n\nFixes an issue that the new CONFIG_DRM_DEBUG_MODESET_LOCK stuff flagged\nin CI:\n\n   WARNING: CPU: 0 PID: 282 at drivers/gpu/drm/drm_modeset_lock.c:296 drm_modeset_lock+0xf8/0x154\n   Modules linked in:\n   CPU: 0 PID: 282 Comm: kms_cursor_lega Tainted: G        W         5.19.0-rc2-15930-g875cc8bc536a #1\n   Hardware name: Qualcomm Technologies, Inc. DB820c (DT)\n   pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n   pc : drm_modeset_lock+0xf8/0x154\n   lr : drm_atomic_get_private_obj_state+0x84/0x170\n   sp : ffff80000cfab6a0\n   x29: ffff80000cfab6a0 x28: 0000000000000000 x27: ffff000083bc4d00\n   x26: 0000000000000038 x25: 0000000000000000 x24: ffff80000957ca58\n   x23: 0000000000000000 x22: ffff000081ace080 x21: 0000000000000001\n   x20: ffff000081acec18 x19: ffff80000cfabb80 x18: 0000000000000038\n   x17: 0000000000000000 x16: 0000000000000000 x15: fffffffffffea0d0\n   x14: 0000000000000000 x13: 284e4f5f4e524157 x12: 5f534b434f4c5f47\n   x11: ffff80000a386aa8 x10: 0000000000000029 x9 : ffff80000cfab610\n   x8 : 0000000000000029 x7 : 0000000000000014 x6 : 0000000000000000\n   x5 : 0000000000000001 x4 : ffff8000081ad904 x3 : 0000000000000029\n   x2 : ffff0000801db4c0 x1 : ffff80000cfabb80 x0 : ffff000081aceb58\n   Call trace:\n    drm_modeset_lock+0xf8/0x154\n    drm_atomic_get_private_obj_state+0x84/0x170\n    mdp5_get_global_state+0x54/0x6c\n    mdp5_pipe_release+0x2c/0xd4\n    mdp5_plane_atomic_check+0x2ec/0x414\n    drm_atomic_helper_check_planes+0xd8/0x210\n    drm_atomic_helper_check+0x54/0xb0\n    ...\n   ---[ end trace 0000000000000000 ]---\n   drm_modeset_lock attempting to lock a contended lock without backoff:\n      drm_modeset_lock+0x148/0x154\n      mdp5_get_global_state+0x30/0x6c\n      mdp5_pipe_release+0x2c/0xd4\n      mdp5_plane_atomic_check+0x290/0x414\n      drm_atomic_helper_check_planes+0xd8/0x210\n      drm_atomic_helper_check+0x54/0xb0\n      drm_atomic_check_only+0x4b0/0x8f4\n      drm_atomic_commit+0x68/0xe0\n\nPatchwork: https://patchwork.freedesktop.org/patch/492701/",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/247f2934324f9a18d18df24ea4bfcc7d4631d0ef",
      "https://git.kernel.org/stable/c/2e34d6c8180a398de6448a93df25068bf3062042",
      "https://git.kernel.org/stable/c/bf386c955f35a0a01bef482b6035d40ff2f6cc75",
      "https://git.kernel.org/stable/c/f4e3a8c7e890049e7ba2b49ad0315dae841dfa55",
      "https://git.kernel.org/stable/c/2fdf5a54ef9376ff69149a48c5616f1141008c9f",
      "https://git.kernel.org/stable/c/0b07f28c23ff50a7fa5dbc3f6b3b6bd53ac9fc70",
      "https://git.kernel.org/stable/c/92ef86ab513593c6329d04146e61f9a670e72fc5"
    ],
    "受影响版本": [
      "776f5c58bfe16cf322d71eeed3c5dda1eeac7e6b",
      "b2aa2c4efe93e2580d6a8774b04fe2b99756a322",
      "49dc28b4b2e28ef7564e355c91487996c1cbebd7",
      "04bef5f1ba8ea6d7c1c8f5f65e0395c62db59cb8",
      "33dc5aac46e0fad8f5eb193e5906ed0eb6b66ceb",
      "d59be579fa932c46b908f37509f319cbd4ca9a68",
      "d59be579fa932c46b908f37509f319cbd4ca9a68",
      "19964dfb39bda4d7716a71009488f0668ecbcf52"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50170",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nkunit: executor: Fix a memory leak on failure in kunit_filter_tests\n\nIt's possible that memory allocation for 'filtered' will fail, but for the\ncopy of the suite to succeed. In this case, the copy could be leaked.\n\nProperly free 'copy' in the error case for the allocation of 'filtered'\nfailing.\n\nNote that there may also have been a similar issue in\nkunit_filter_subsuites, before it was removed in \"kunit: flatten\nkunit_suite*** to kunit_suite** in .kunit_test_suites\".\n\nThis was reported by clang-analyzer via the kernel test robot, here:\nhttps://lore.kernel.org/all/c8073b8e-7b9e-0830-4177-87c12f16349c@intel.com/\n\nAnd by smatch via Dan Carpenter and the kernel test robot:\nhttps://lore.kernel.org/all/202207101328.ASjx88yj-lkp@intel.com/",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a8a7e3ced362b88b659ab54239990196ff975982",
      "https://git.kernel.org/stable/c/7d69764fa3442c7615a75c6b5c02eaa1f274bccf",
      "https://git.kernel.org/stable/c/94681e289bf5d10c9db9db143d1a22d8717205c5"
    ],
    "受影响版本": [
      "bd8b222a0002872bb229f6c755672a093ef93ea4",
      "a02353f491622e49c7ddedc6a6dc4f1d6ed2150a",
      "a02353f491622e49c7ddedc6a6dc4f1d6ed2150a",
      "80cf4932c2545bc231e933d869511008c36af1e0"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50165",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: wil6210: debugfs: fix uninitialized variable use in `wil_write_file_wmi()`\n\nCommit 7a4836560a61 changes simple_write_to_buffer() with memdup_user()\nbut it forgets to change the value to be returned that came from\nsimple_write_to_buffer() call. It results in the following warning:\n\n  warning: variable 'rc' is uninitialized when used here [-Wuninitialized]\n           return rc;\n                  ^~\n\nRemove rc variable and just return the passed in length if the\nmemdup_user() succeeds.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b13c84e877d7a3095bacb14665db304b2c00e95f",
      "https://git.kernel.org/stable/c/c9fde3a44da566d8929070ab6bda4f0dfa9955d0",
      "https://git.kernel.org/stable/c/52b11a48cf073e0aab923ae809a765d756cecf13",
      "https://git.kernel.org/stable/c/6c5fee83bdbeffe8d607d1ab125122a75f40bd1a",
      "https://git.kernel.org/stable/c/689e5caf63e99e15d2f485ec297c1bf9243e0e28",
      "https://git.kernel.org/stable/c/d4742c886043b69d2d058bfde3998ef333b66595",
      "https://git.kernel.org/stable/c/409bd72e544fdf4809ea0dac337bb5a1f11a25a9",
      "https://git.kernel.org/stable/c/d578e0af3a003736f6c440188b156483d451b329"
    ],
    "受影响版本": [
      "ff974e4083341383d3dd4079e52ed30f57f376f0",
      "ff974e4083341383d3dd4079e52ed30f57f376f0",
      "ff974e4083341383d3dd4079e52ed30f57f376f0",
      "ff974e4083341383d3dd4079e52ed30f57f376f0",
      "ff974e4083341383d3dd4079e52ed30f57f376f0",
      "ff974e4083341383d3dd4079e52ed30f57f376f0",
      "ff974e4083341383d3dd4079e52ed30f57f376f0",
      "ff974e4083341383d3dd4079e52ed30f57f376f0"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50164",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: iwlwifi: mvm: fix double list_add at iwl_mvm_mac_wake_tx_queue\n\nAfter successfull station association, if station queues are disabled for\nsome reason, the related lists are not emptied. So if some new element is\nadded to the list in iwl_mvm_mac_wake_tx_queue, it can match with the old\none and produce a BUG like this:\n\n[   46.535263] list_add corruption. prev->next should be next (ffff94c1c318a360), but was 0000000000000000. (prev=ffff94c1d02d3388).\n[   46.535283] ------------[ cut here ]------------\n[   46.535284] kernel BUG at lib/list_debug.c:26!\n[   46.535290] invalid opcode: 0000 [#1] PREEMPT SMP PTI\n[   46.585304] CPU: 0 PID: 623 Comm: wpa_supplicant Not tainted 5.19.0-rc3+ #1\n[   46.592380] Hardware name: Dell Inc. Inspiron 660s/0478VN       , BIOS A07 08/24/2012\n[   46.600336] RIP: 0010:__list_add_valid.cold+0x3d/0x3f\n[   46.605475] Code: f2 4c 89 c1 48 89 fe 48 c7 c7 c8 40 67 93 e8 20 cc fd ff 0f 0b 48 89 d1 4c 89 c6 4c 89 ca 48 c7 c7 70 40 67 93 e8 09 cc fd ff <0f> 0b 48 89 fe 48 c7 c7 00 41 67 93 e8 f8 cb fd ff 0f 0b 48 89 d1\n[   46.624469] RSP: 0018:ffffb20800ab76d8 EFLAGS: 00010286\n[   46.629854] RAX: 0000000000000075 RBX: ffff94c1c318a0e0 RCX: 0000000000000000\n[   46.637105] RDX: 0000000000000201 RSI: ffffffff9365e100 RDI: 00000000ffffffff\n[   46.644356] RBP: ffff94c1c5f43370 R08: 0000000000000075 R09: 3064316334396666\n[   46.651607] R10: 3364323064316334 R11: 39666666663d7665 R12: ffff94c1c5f43388\n[   46.658857] R13: ffff94c1d02d3388 R14: ffff94c1c318a360 R15: ffff94c1cf2289c0\n[   46.666108] FS:  00007f65634ff7c0(0000) GS:ffff94c1da200000(0000) knlGS:0000000000000000\n[   46.674331] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   46.680170] CR2: 00007f7dfe984460 CR3: 000000010e894003 CR4: 00000000000606f0\n[   46.687422] Call Trace:\n[   46.689906]  <TASK>\n[   46.691950]  iwl_mvm_mac_wake_tx_queue+0xec/0x15c [iwlmvm]\n[   46.697601]  ieee80211_queue_skb+0x4b3/0x720 [mac80211]\n[   46.702973]  ? sta_info_get+0x46/0x60 [mac80211]\n[   46.707703]  ieee80211_tx+0xad/0x110 [mac80211]\n[   46.712355]  __ieee80211_tx_skb_tid_band+0x71/0x90 [mac80211]\n...\n\nIn order to avoid this problem, we must also remove the related lists when\nstation queues are disabled.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5cca5f714fe6cedd2df9d8451ad8df21e6464f62",
      "https://git.kernel.org/stable/c/38d71acc15a2e72806b516380af0adb3830d4639",
      "https://git.kernel.org/stable/c/4a40af2b0b9517fca7ae2a030c9c0a16836303c0",
      "https://git.kernel.org/stable/c/ff068c25bf90d26f0aee1751553f18076b797e8d",
      "https://git.kernel.org/stable/c/182d3c1385f44ba7c508bf5b1292a7fe96ad4e9e",
      "https://git.kernel.org/stable/c/14a3aacf517a9de725dd3219dbbcf741e31763c4"
    ],
    "受影响版本": [
      "cfbc6c4c5b91c7725ef14465b98ac347d31f2334",
      "cfbc6c4c5b91c7725ef14465b98ac347d31f2334",
      "cfbc6c4c5b91c7725ef14465b98ac347d31f2334",
      "cfbc6c4c5b91c7725ef14465b98ac347d31f2334",
      "cfbc6c4c5b91c7725ef14465b98ac347d31f2334",
      "cfbc6c4c5b91c7725ef14465b98ac347d31f2334"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50163",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nax25: fix incorrect dev_tracker usage\n\nWhile investigating a separate rose issue [1], and enabling\nCONFIG_NET_DEV_REFCNT_TRACKER=y, Bernard reported an orthogonal ax25 issue [2]\n\nAn ax25_dev can be used by one (or many) struct ax25_cb.\nWe thus need different dev_tracker, one per struct ax25_cb.\n\nAfter this patch is applied, we are able to focus on rose.\n\n[1] https://lore.kernel.org/netdev/fb7544a1-f42e-9254-18cc-c9b071f4ca70@free.fr/\n\n[2]\n[  205.798723] reference already released.\n[  205.798732] allocated in:\n[  205.798734]  ax25_bind+0x1a2/0x230 [ax25]\n[  205.798747]  __sys_bind+0xea/0x110\n[  205.798753]  __x64_sys_bind+0x18/0x20\n[  205.798758]  do_syscall_64+0x5c/0x80\n[  205.798763]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[  205.798768] freed in:\n[  205.798770]  ax25_release+0x115/0x370 [ax25]\n[  205.798778]  __sock_release+0x42/0xb0\n[  205.798782]  sock_close+0x15/0x20\n[  205.798785]  __fput+0x9f/0x260\n[  205.798789]  ____fput+0xe/0x10\n[  205.798792]  task_work_run+0x64/0xa0\n[  205.798798]  exit_to_user_mode_prepare+0x18b/0x190\n[  205.798804]  syscall_exit_to_user_mode+0x26/0x40\n[  205.798808]  do_syscall_64+0x69/0x80\n[  205.798812]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[  205.798827] ------------[ cut here ]------------\n[  205.798829] WARNING: CPU: 2 PID: 2605 at lib/ref_tracker.c:136 ref_tracker_free.cold+0x60/0x81\n[  205.798837] Modules linked in: rose netrom mkiss ax25 rfcomm cmac algif_hash algif_skcipher af_alg bnep snd_hda_codec_hdmi nls_iso8859_1 i915 rtw88_8821ce rtw88_8821c x86_pkg_temp_thermal rtw88_pci intel_powerclamp rtw88_core snd_hda_codec_realtek snd_hda_codec_generic ledtrig_audio coretemp snd_hda_intel kvm_intel snd_intel_dspcfg mac80211 snd_hda_codec kvm i2c_algo_bit drm_buddy drm_dp_helper btusb drm_kms_helper snd_hwdep btrtl snd_hda_core btbcm joydev crct10dif_pclmul btintel crc32_pclmul ghash_clmulni_intel mei_hdcp btmtk intel_rapl_msr aesni_intel bluetooth input_leds snd_pcm crypto_simd syscopyarea processor_thermal_device_pci_legacy sysfillrect cryptd intel_soc_dts_iosf snd_seq sysimgblt ecdh_generic fb_sys_fops rapl libarc4 processor_thermal_device intel_cstate processor_thermal_rfim cec snd_timer ecc snd_seq_device cfg80211 processor_thermal_mbox mei_me processor_thermal_rapl mei rc_core at24 snd intel_pch_thermal intel_rapl_common ttm soundcore int340x_thermal_zone video\n[  205.798948]  mac_hid acpi_pad sch_fq_codel ipmi_devintf ipmi_msghandler drm msr parport_pc ppdev lp parport ramoops pstore_blk reed_solomon pstore_zone efi_pstore ip_tables x_tables autofs4 hid_generic usbhid hid i2c_i801 i2c_smbus r8169 xhci_pci ahci libahci realtek lpc_ich xhci_pci_renesas [last unloaded: ax25]\n[  205.798992] CPU: 2 PID: 2605 Comm: ax25ipd Not tainted 5.18.11-F6BVP #3\n[  205.798996] Hardware name: To be filled by O.E.M. To be filled by O.E.M./CK3, BIOS 5.011 09/16/2020\n[  205.798999] RIP: 0010:ref_tracker_free.cold+0x60/0x81\n[  205.799005] Code: e8 d2 01 9b ff 83 7b 18 00 74 14 48 c7 c7 2f d7 ff 98 e8 10 6e fc ff 8b 7b 18 e8 b8 01 9b ff 4c 89 ee 4c 89 e7 e8 5d fd 07 00 <0f> 0b b8 ea ff ff ff e9 30 05 9b ff 41 0f b6 f7 48 c7 c7 a0 fa 4e\n[  205.799008] RSP: 0018:ffffaf5281073958 EFLAGS: 00010286\n[  205.799011] RAX: 0000000080000000 RBX: ffff9a0bd687ebe0 RCX: 0000000000000000\n[  205.799014] RDX: 0000000000000001 RSI: 0000000000000282 RDI: 00000000ffffffff\n[  205.799016] RBP: ffffaf5281073a10 R08: 0000000000000003 R09: fffffffffffd5618\n[  205.799019] R10: 0000000000ffff10 R11: 000000000000000f R12: ffff9a0bc53384d0\n[  205.799022] R13: 0000000000000282 R14: 00000000ae000001 R15: 0000000000000001\n[  205.799024] FS:  0000000000000000(0000) GS:ffff9a0d0f300000(0000) knlGS:0000000000000000\n[  205.799028] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  205.799031] CR2: 00007ff6b8311554 CR3: 000000001ac10004 CR4: 00000000001706e0\n[  205.799033] Call Trace:\n[  205.799035]  <TASK>\n[  205.799038]  ? ax25_dev_device_down+0xd9/\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d08e3d71e5942f77fbff7f3529ed7fc82fbb3dfa",
      "https://git.kernel.org/stable/c/4294df1374450912b2f64ee3cf575069fc784679",
      "https://git.kernel.org/stable/c/d7c4c9e075f8cc6d88d277bc24e5d99297f03c06"
    ],
    "受影响版本": [
      "feef318c855a361a1eccd880f33e88c460eb63b4",
      "feef318c855a361a1eccd880f33e88c460eb63b4",
      "feef318c855a361a1eccd880f33e88c460eb63b4",
      "b8c07f33aa35dacf5444e7053ed9662d1869f536",
      "b1e0a6fc7f17500484c402ad1cd018c24dfc14b3",
      "7528d0f2210c3a1154186175516ed37aa970f2b1",
      "57cc15f5fd550316e4104eaf84b90fbc640fd7a5",
      "b982492ec3a115e0a136856a1b2dbe32f2d21a0e"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50126",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\njbd2: fix assertion 'jh->b_frozen_data == NULL' failure when journal aborted\n\nFollowing process will fail assertion 'jh->b_frozen_data == NULL' in\njbd2_journal_dirty_metadata():\n\n                   jbd2_journal_commit_transaction\nunlink(dir/a)\n jh->b_transaction = trans1\n jh->b_jlist = BJ_Metadata\n                    journal->j_running_transaction = NULL\n                    trans1->t_state = T_COMMIT\nunlink(dir/b)\n handle->h_trans = trans2\n do_get_write_access\n  jh->b_modified = 0\n  jh->b_frozen_data = frozen_buffer\n  jh->b_next_transaction = trans2\n jbd2_journal_dirty_metadata\n  is_handle_aborted\n   is_journal_aborted // return false\n\n           --> jbd2 abort <--\n\n                     while (commit_transaction->t_buffers)\n                      if (is_journal_aborted)\n                       jbd2_journal_refile_buffer\n                        __jbd2_journal_refile_buffer\n                         WRITE_ONCE(jh->b_transaction,\n\t\t\t\t\t\tjh->b_next_transaction)\n                         WRITE_ONCE(jh->b_next_transaction, NULL)\n                         __jbd2_journal_file_buffer(jh, BJ_Reserved)\n        J_ASSERT_JH(jh, jh->b_frozen_data == NULL) // assertion failure !\n\nThe reproducer (See detail in [Link]) reports:\n ------------[ cut here ]------------\n kernel BUG at fs/jbd2/transaction.c:1629!\n invalid opcode: 0000 [#1] PREEMPT SMP\n CPU: 2 PID: 584 Comm: unlink Tainted: G        W\n 5.19.0-rc6-00115-g4a57a8400075-dirty #697\n RIP: 0010:jbd2_journal_dirty_metadata+0x3c5/0x470\n RSP: 0018:ffffc90000be7ce0 EFLAGS: 00010202\n Call Trace:\n  <TASK>\n  __ext4_handle_dirty_metadata+0xa0/0x290\n  ext4_handle_dirty_dirblock+0x10c/0x1d0\n  ext4_delete_entry+0x104/0x200\n  __ext4_unlink+0x22b/0x360\n  ext4_unlink+0x275/0x390\n  vfs_unlink+0x20b/0x4c0\n  do_unlinkat+0x42f/0x4c0\n  __x64_sys_unlink+0x37/0x50\n  do_syscall_64+0x35/0x80\n\nAfter journal aborting, __jbd2_journal_refile_buffer() is executed with\nholding @jh->b_state_lock, we can fix it by moving 'is_handle_aborted()'\ninto the area protected by @jh->b_state_lock.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0f61c6dc4b714be9d79cf0782ca02ba01c1b7ac3",
      "https://git.kernel.org/stable/c/6073389db83b903678a0920554fa19f5bdc51c48",
      "https://git.kernel.org/stable/c/fa5b65d39332fef7a11ae99cb1f0696012a61527",
      "https://git.kernel.org/stable/c/f7161d0da975adc234161cd0641d0e484f5ce375",
      "https://git.kernel.org/stable/c/e62f79827784f56499a50ea2e893c98317b5407b",
      "https://git.kernel.org/stable/c/731c1662d838fe954c6759e3ee43229b0d928fe4",
      "https://git.kernel.org/stable/c/ddd896792e1718cb84c96f3e618270589b6886dc",
      "https://git.kernel.org/stable/c/4a734f0869f970b8a9b65062ea40b09a5da9dba8"
    ],
    "受影响版本": [
      "470decc613ab2048b619a01028072d932d9086ee",
      "470decc613ab2048b619a01028072d932d9086ee",
      "470decc613ab2048b619a01028072d932d9086ee",
      "470decc613ab2048b619a01028072d932d9086ee",
      "470decc613ab2048b619a01028072d932d9086ee",
      "470decc613ab2048b619a01028072d932d9086ee",
      "470decc613ab2048b619a01028072d932d9086ee",
      "470decc613ab2048b619a01028072d932d9086ee"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50118",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/perf: Optimize clearing the pending PMI and remove WARN_ON for PMI check in power_pmu_disable\n\ncommit 2c9ac51b850d (\"powerpc/perf: Fix PMU callbacks to clear\npending PMI before resetting an overflown PMC\") added a new\nfunction \"pmi_irq_pending\" in hw_irq.h. This function is to check\nif there is a PMI marked as pending in Paca (PACA_IRQ_PMI).This is\nused in power_pmu_disable in a WARN_ON. The intention here is to\nprovide a warning if there is PMI pending, but no counter is found\noverflown.\n\nDuring some of the perf runs, below warning is hit:\n\nWARNING: CPU: 36 PID: 0 at arch/powerpc/perf/core-book3s.c:1332 power_pmu_disable+0x25c/0x2c0\n Modules linked in:\n -----\n\n NIP [c000000000141c3c] power_pmu_disable+0x25c/0x2c0\n LR [c000000000141c8c] power_pmu_disable+0x2ac/0x2c0\n Call Trace:\n [c000000baffcfb90] [c000000000141c8c] power_pmu_disable+0x2ac/0x2c0 (unreliable)\n [c000000baffcfc10] [c0000000003e2f8c] perf_pmu_disable+0x4c/0x60\n [c000000baffcfc30] [c0000000003e3344] group_sched_out.part.124+0x44/0x100\n [c000000baffcfc80] [c0000000003e353c] __perf_event_disable+0x13c/0x240\n [c000000baffcfcd0] [c0000000003dd334] event_function+0xc4/0x140\n [c000000baffcfd20] [c0000000003d855c] remote_function+0x7c/0xa0\n [c000000baffcfd50] [c00000000026c394] flush_smp_call_function_queue+0xd4/0x300\n [c000000baffcfde0] [c000000000065b24] smp_ipi_demux_relaxed+0xa4/0x100\n [c000000baffcfe20] [c0000000000cb2b0] xive_muxed_ipi_action+0x20/0x40\n [c000000baffcfe40] [c000000000207c3c] __handle_irq_event_percpu+0x8c/0x250\n [c000000baffcfee0] [c000000000207e2c] handle_irq_event_percpu+0x2c/0xa0\n [c000000baffcff10] [c000000000210a04] handle_percpu_irq+0x84/0xc0\n [c000000baffcff40] [c000000000205f14] generic_handle_irq+0x54/0x80\n [c000000baffcff60] [c000000000015740] __do_irq+0x90/0x1d0\n [c000000baffcff90] [c000000000016990] __do_IRQ+0xc0/0x140\n [c0000009732f3940] [c000000bafceaca8] 0xc000000bafceaca8\n [c0000009732f39d0] [c000000000016b78] do_IRQ+0x168/0x1c0\n [c0000009732f3a00] [c0000000000090c8] hardware_interrupt_common_virt+0x218/0x220\n\nThis means that there is no PMC overflown among the active events\nin the PMU, but there is a PMU pending in Paca. The function\n\"any_pmc_overflown\" checks the PMCs on active events in\ncpuhw->n_events. Code snippet:\n\n<<>>\nif (any_pmc_overflown(cpuhw))\n \tclear_pmi_irq_pending();\n else\n \tWARN_ON(pmi_irq_pending());\n<<>>\n\nHere the PMC overflown is not from active event. Example: When we do\nperf record, default cycles and instructions will be running on PMC6\nand PMC5 respectively. It could happen that overflowed event is currently\nnot active and pending PMI is for the inactive event. Debug logs from\ntrace_printk:\n\n<<>>\nany_pmc_overflown: idx is 5: pmc value is 0xd9a\npower_pmu_disable: PMC1: 0x0, PMC2: 0x0, PMC3: 0x0, PMC4: 0x0, PMC5: 0xd9a, PMC6: 0x80002011\n<<>>\n\nHere active PMC (from idx) is PMC5 , but overflown PMC is PMC6(0x80002011).\nWhen we handle PMI interrupt for such cases, if the PMC overflown is\nfrom inactive event, it will be ignored. Reference commit:\ncommit bc09c219b2e6 (\"powerpc/perf: Fix finding overflowed PMC in interrupt\")\n\nPatch addresses two changes:\n1) Fix 1 : Removal of warning ( WARN_ON(pmi_irq_pending()); )\n   We were printing warning if no PMC is found overflown among active PMU\n   events, but PMI pending in PACA. But this could happen in cases where\n   PMC overflown is not in active PMC. An inactive event could have caused\n   the overflow. Hence the warning is not needed. To know pending PMI is\n   from an inactive event, we need to loop through all PMC's which will\n   cause more SPR reads via mfspr and increase in context switch. Also in\n   existing function: perf_event_interrupt, already we ignore PMI's\n   overflown when it is from an inactive PMC.\n\n2) Fix 2: optimization in clearing pending PMI.\n   Currently we check for any active PMC overflown before clearing PMI\n   pending in Paca. This is causing additional SP\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/875b2bf469d094754ac2ba9af91dcd529eb12bf6",
      "https://git.kernel.org/stable/c/87b1a9175f08313f40fcb6d6dc536dbe451090eb",
      "https://git.kernel.org/stable/c/0a24ea26c3278216642a43291df7976a73a0a7ee",
      "https://git.kernel.org/stable/c/7e83af3dd4a3afca8f83ffde518cafd52f45b830",
      "https://git.kernel.org/stable/c/890005a7d98f7452cfe86dcfb2aeeb7df01132ce"
    ],
    "受影响版本": [
      "ef798cd035f316a537fee8ed170c127f12407085",
      "fadcafa3959281ce2d96feedece8c75c3f95f8a5",
      "2c9ac51b850d84ee496b0a5d832ce66d411ae552",
      "2c9ac51b850d84ee496b0a5d832ce66d411ae552",
      "2c9ac51b850d84ee496b0a5d832ce66d411ae552",
      "215a90ce3754fe509efbce6b73a4bb643c7e7528"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50094",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nspmi: trace: fix stack-out-of-bound access in SPMI tracing functions\n\ntrace_spmi_write_begin() and trace_spmi_read_end() both call\nmemcpy() with a length of \"len + 1\".  This leads to one extra\nbyte being read beyond the end of the specified buffer.  Fix\nthis out-of-bound memory access by using a length of \"len\"\ninstead.\n\nHere is a KASAN log showing the issue:\n\nBUG: KASAN: stack-out-of-bounds in trace_event_raw_event_spmi_read_end+0x1d0/0x234\nRead of size 2 at addr ffffffc0265b7540 by task thermal@2.0-ser/1314\n...\nCall trace:\n dump_backtrace+0x0/0x3e8\n show_stack+0x2c/0x3c\n dump_stack_lvl+0xdc/0x11c\n print_address_description+0x74/0x384\n kasan_report+0x188/0x268\n kasan_check_range+0x270/0x2b0\n memcpy+0x90/0xe8\n trace_event_raw_event_spmi_read_end+0x1d0/0x234\n spmi_read_cmd+0x294/0x3ac\n spmi_ext_register_readl+0x84/0x9c\n regmap_spmi_ext_read+0x144/0x1b0 [regmap_spmi]\n _regmap_raw_read+0x40c/0x754\n regmap_raw_read+0x3a0/0x514\n regmap_bulk_read+0x418/0x494\n adc5_gen3_poll_wait_hs+0xe8/0x1e0 [qcom_spmi_adc5_gen3]\n ...\n __arm64_sys_read+0x4c/0x60\n invoke_syscall+0x80/0x218\n el0_svc_common+0xec/0x1c8\n ...\n\naddr ffffffc0265b7540 is located in stack of task thermal@2.0-ser/1314 at offset 32 in frame:\n adc5_gen3_poll_wait_hs+0x0/0x1e0 [qcom_spmi_adc5_gen3]\n\nthis frame has 1 object:\n [32, 33) 'status'\n\nMemory state around the buggy address:\n ffffffc0265b7400: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n ffffffc0265b7480: 04 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n>ffffffc0265b7500: 00 00 00 00 f1 f1 f1 f1 01 f3 f3 f3 00 00 00 00\n                                           ^\n ffffffc0265b7580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffffffc0265b7600: f1 f1 f1 f1 01 f2 07 f2 f2 f2 01 f3 00 00 00 00\n==================================================================",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/80f7c93e573ea9f524924bb529c2af8cb28b1c43",
      "https://git.kernel.org/stable/c/dc6033a7761254e5a5ba7df36b64db787a53313c",
      "https://git.kernel.org/stable/c/ac730c72bddc889f5610d51d8a7abf425e08da1a",
      "https://git.kernel.org/stable/c/37690cb8662cec672cacda19e6e4fd2ca7b13f0b",
      "https://git.kernel.org/stable/c/dd02510fb43168310abfd0b9ccf49993a722fb91",
      "https://git.kernel.org/stable/c/1e0ca3d809c36ad3d1f542917718fc22ec6316e7",
      "https://git.kernel.org/stable/c/bcc1b6b1ed3f42ed25858c1f1eb24a2f741db93f",
      "https://git.kernel.org/stable/c/504090815c1ad3fd3fa34618b54d706727f8911c",
      "https://git.kernel.org/stable/c/2af28b241eea816e6f7668d1954f15894b45d7e3"
    ],
    "受影响版本": [
      "a9fce374815d8ab94a3e6259802a944e2cc21408",
      "a9fce374815d8ab94a3e6259802a944e2cc21408",
      "a9fce374815d8ab94a3e6259802a944e2cc21408",
      "a9fce374815d8ab94a3e6259802a944e2cc21408",
      "a9fce374815d8ab94a3e6259802a944e2cc21408",
      "a9fce374815d8ab94a3e6259802a944e2cc21408",
      "a9fce374815d8ab94a3e6259802a944e2cc21408",
      "a9fce374815d8ab94a3e6259802a944e2cc21408",
      "a9fce374815d8ab94a3e6259802a944e2cc21408"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50093",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/vt-d: avoid invalid memory access via node_online(NUMA_NO_NODE)\n\nKASAN reports:\n\n[ 4.668325][ T0] BUG: KASAN: wild-memory-access in dmar_parse_one_rhsa (arch/x86/include/asm/bitops.h:214 arch/x86/include/asm/bitops.h:226 include/asm-generic/bitops/instrumented-non-atomic.h:142 include/linux/nodemask.h:415 drivers/iommu/intel/dmar.c:497)\n[    4.676149][    T0] Read of size 8 at addr 1fffffff85115558 by task swapper/0/0\n[    4.683454][    T0]\n[    4.685638][    T0] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.19.0-rc3-00004-g0e862838f290 #1\n[    4.694331][    T0] Hardware name: Supermicro SYS-5018D-FN4T/X10SDV-8C-TLN4F, BIOS 1.1 03/02/2016\n[    4.703196][    T0] Call Trace:\n[    4.706334][    T0]  <TASK>\n[ 4.709133][ T0] ? dmar_parse_one_rhsa (arch/x86/include/asm/bitops.h:214 arch/x86/include/asm/bitops.h:226 include/asm-generic/bitops/instrumented-non-atomic.h:142 include/linux/nodemask.h:415 drivers/iommu/intel/dmar.c:497)\n\nafter converting the type of the first argument (@nr, bit number)\nof arch_test_bit() from `long` to `unsigned long`[0].\n\nUnder certain conditions (for example, when ACPI NUMA is disabled\nvia command line), pxm_to_node() can return %NUMA_NO_NODE (-1).\nIt is valid 'magic' number of NUMA node, but not valid bit number\nto use in bitops.\nnode_online() eventually descends to test_bit() without checking\nfor the input, assuming it's on caller side (which might be good\nfor perf-critical tasks). There, -1 becomes %ULONG_MAX which leads\nto an insane array index when calculating bit position in memory.\n\nFor now, add an explicit check for @node being not %NUMA_NO_NODE\nbefore calling test_bit(). The actual logics didn't change here\nat all.\n\n[0] https://github.com/norov/linux/commit/0e862838f290147ea9c16db852d8d494b552d38d",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b12304984654d8e58a2b22ff94c4410906d6267f",
      "https://git.kernel.org/stable/c/5659efdadf04b56707d58c1b758df16d2e0eff2c",
      "https://git.kernel.org/stable/c/0b4c0003aeda32a600f95df53b2848da8a5aa3fa",
      "https://git.kernel.org/stable/c/73ce2046e04ad488cecc66757c36cbe1bdf089d4",
      "https://git.kernel.org/stable/c/c2304c50f4d94f56c2e326f25c9dc8cf2ba6f5fa",
      "https://git.kernel.org/stable/c/b0b0b77ea611e3088e9523e60860f4f41b62b235"
    ],
    "受影响版本": [
      "ee34b32d8c2950f66038c8975747ef9aec855289",
      "ee34b32d8c2950f66038c8975747ef9aec855289",
      "ee34b32d8c2950f66038c8975747ef9aec855289",
      "ee34b32d8c2950f66038c8975747ef9aec855289",
      "ee34b32d8c2950f66038c8975747ef9aec855289",
      "ee34b32d8c2950f66038c8975747ef9aec855289"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50090",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: replace BTRFS_MAX_EXTENT_SIZE with fs_info->max_extent_size\n\nOn zoned filesystem, data write out is limited by max_zone_append_size,\nand a large ordered extent is split according the size of a bio. OTOH,\nthe number of extents to be written is calculated using\nBTRFS_MAX_EXTENT_SIZE, and that estimated number is used to reserve the\nmetadata bytes to update and/or create the metadata items.\n\nThe metadata reservation is done at e.g, btrfs_buffered_write() and then\nreleased according to the estimation changes. Thus, if the number of extent\nincreases massively, the reserved metadata can run out.\n\nThe increase of the number of extents easily occurs on zoned filesystem\nif BTRFS_MAX_EXTENT_SIZE > max_zone_append_size. And, it causes the\nfollowing warning on a small RAM environment with disabling metadata\nover-commit (in the following patch).\n\n[75721.498492] ------------[ cut here ]------------\n[75721.505624] BTRFS: block rsv 1 returned -28\n[75721.512230] WARNING: CPU: 24 PID: 2327559 at fs/btrfs/block-rsv.c:537 btrfs_use_block_rsv+0x560/0x760 [btrfs]\n[75721.581854] CPU: 24 PID: 2327559 Comm: kworker/u64:10 Kdump: loaded Tainted: G        W         5.18.0-rc2-BTRFS-ZNS+ #109\n[75721.597200] Hardware name: Supermicro Super Server/H12SSL-NT, BIOS 2.0 02/22/2021\n[75721.607310] Workqueue: btrfs-endio-write btrfs_work_helper [btrfs]\n[75721.616209] RIP: 0010:btrfs_use_block_rsv+0x560/0x760 [btrfs]\n[75721.646649] RSP: 0018:ffffc9000fbdf3e0 EFLAGS: 00010286\n[75721.654126] RAX: 0000000000000000 RBX: 0000000000004000 RCX: 0000000000000000\n[75721.663524] RDX: 0000000000000004 RSI: 0000000000000008 RDI: fffff52001f7be6e\n[75721.672921] RBP: ffffc9000fbdf420 R08: 0000000000000001 R09: ffff889f8d1fc6c7\n[75721.682493] R10: ffffed13f1a3f8d8 R11: 0000000000000001 R12: ffff88980a3c0e28\n[75721.692284] R13: ffff889b66590000 R14: ffff88980a3c0e40 R15: ffff88980a3c0e8a\n[75721.701878] FS:  0000000000000000(0000) GS:ffff889f8d000000(0000) knlGS:0000000000000000\n[75721.712601] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[75721.720726] CR2: 000055d12e05c018 CR3: 0000800193594000 CR4: 0000000000350ee0\n[75721.730499] Call Trace:\n[75721.735166]  <TASK>\n[75721.739886]  btrfs_alloc_tree_block+0x1e1/0x1100 [btrfs]\n[75721.747545]  ? btrfs_alloc_logged_file_extent+0x550/0x550 [btrfs]\n[75721.756145]  ? btrfs_get_32+0xea/0x2d0 [btrfs]\n[75721.762852]  ? btrfs_get_32+0xea/0x2d0 [btrfs]\n[75721.769520]  ? push_leaf_left+0x420/0x620 [btrfs]\n[75721.776431]  ? memcpy+0x4e/0x60\n[75721.781931]  split_leaf+0x433/0x12d0 [btrfs]\n[75721.788392]  ? btrfs_get_token_32+0x580/0x580 [btrfs]\n[75721.795636]  ? push_for_double_split.isra.0+0x420/0x420 [btrfs]\n[75721.803759]  ? leaf_space_used+0x15d/0x1a0 [btrfs]\n[75721.811156]  btrfs_search_slot+0x1bc3/0x2790 [btrfs]\n[75721.818300]  ? lock_downgrade+0x7c0/0x7c0\n[75721.824411]  ? free_extent_buffer.part.0+0x107/0x200 [btrfs]\n[75721.832456]  ? split_leaf+0x12d0/0x12d0 [btrfs]\n[75721.839149]  ? free_extent_buffer.part.0+0x14f/0x200 [btrfs]\n[75721.846945]  ? free_extent_buffer+0x13/0x20 [btrfs]\n[75721.853960]  ? btrfs_release_path+0x4b/0x190 [btrfs]\n[75721.861429]  btrfs_csum_file_blocks+0x85c/0x1500 [btrfs]\n[75721.869313]  ? rcu_read_lock_sched_held+0x16/0x80\n[75721.876085]  ? lock_release+0x552/0xf80\n[75721.881957]  ? btrfs_del_csums+0x8c0/0x8c0 [btrfs]\n[75721.888886]  ? __kasan_check_write+0x14/0x20\n[75721.895152]  ? do_raw_read_unlock+0x44/0x80\n[75721.901323]  ? _raw_write_lock_irq+0x60/0x80\n[75721.907983]  ? btrfs_global_root+0xb9/0xe0 [btrfs]\n[75721.915166]  ? btrfs_csum_root+0x12b/0x180 [btrfs]\n[75721.921918]  ? btrfs_get_global_root+0x820/0x820 [btrfs]\n[75721.929166]  ? _raw_write_unlock+0x23/0x40\n[75721.935116]  ? unpin_extent_cache+0x1e3/0x390 [btrfs]\n[75721.942041]  btrfs_finish_ordered_io.isra.0+0xa0c/0x1dc0 [btrfs]\n[75721.949906]  ? try_to_wake_up+0x30/0x14a0\n[75721.955700]  ? btrfs_unlink_subvol+0xda0/0xda0 [btrfs]\n[75721.962661]  ? rcu\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1aa262c1d056551dd1246115af8b7e351184deae",
      "https://git.kernel.org/stable/c/6cb4b96df97082a54634ba02196516919cda228c",
      "https://git.kernel.org/stable/c/096e8eb9639b342bc35f9b741cf05e26d0106e92",
      "https://git.kernel.org/stable/c/f7b12a62f008a3041f42f2426983e59a6a0a3c59"
    ],
    "受影响版本": [
      "d8e3fb106f393858b90b3befc4f6092a76c86d1c",
      "d8e3fb106f393858b90b3befc4f6092a76c86d1c",
      "d8e3fb106f393858b90b3befc4f6092a76c86d1c",
      "d8e3fb106f393858b90b3befc4f6092a76c86d1c"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50082",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix warning in ext4_iomap_begin as race between bmap and write\n\nWe got issue as follows:\n------------[ cut here ]------------\nWARNING: CPU: 3 PID: 9310 at fs/ext4/inode.c:3441 ext4_iomap_begin+0x182/0x5d0\nRIP: 0010:ext4_iomap_begin+0x182/0x5d0\nRSP: 0018:ffff88812460fa08 EFLAGS: 00010293\nRAX: ffff88811f168000 RBX: 0000000000000000 RCX: ffffffff97793c12\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000003\nRBP: ffff88812c669160 R08: ffff88811f168000 R09: ffffed10258cd20f\nR10: ffff88812c669077 R11: ffffed10258cd20e R12: 0000000000000001\nR13: 00000000000000a4 R14: 000000000000000c R15: ffff88812c6691ee\nFS:  00007fd0d6ff3740(0000) GS:ffff8883af180000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fd0d6dda290 CR3: 0000000104a62000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n iomap_apply+0x119/0x570\n iomap_bmap+0x124/0x150\n ext4_bmap+0x14f/0x250\n bmap+0x55/0x80\n do_vfs_ioctl+0x952/0xbd0\n __x64_sys_ioctl+0xc6/0x170\n do_syscall_64+0x33/0x40\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nAbove issue may happen as follows:\n          bmap                    write\nbmap\n  ext4_bmap\n    iomap_bmap\n      ext4_iomap_begin\n                            ext4_file_write_iter\n\t\t\t      ext4_buffered_write_iter\n\t\t\t        generic_perform_write\n\t\t\t\t  ext4_da_write_begin\n\t\t\t\t    ext4_da_write_inline_data_begin\n\t\t\t\t      ext4_prepare_inline_data\n\t\t\t\t        ext4_create_inline_data\n\t\t\t\t\t  ext4_set_inode_flag(inode,\n\t\t\t\t\t\tEXT4_INODE_INLINE_DATA);\n      if (WARN_ON_ONCE(ext4_has_inline_data(inode))) ->trigger bug_on\n\nTo solved above issue hold inode lock in ext4_bamp.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e1682c7171a6c0ff576fe8116b8cba5b8f538b94",
      "https://git.kernel.org/stable/c/30dfb75e1f8645404a536c74d468d498adcd4e74",
      "https://git.kernel.org/stable/c/a9fe6d1e3d343d7309f501b1f48020ce7127221f",
      "https://git.kernel.org/stable/c/fa6482f374fda29a71ad44d76d35b4842d43cda4",
      "https://git.kernel.org/stable/c/51ae846cff568c8c29921b1b28eb2dfbcd4ac12d"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50074",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\napparmor: Fix memleak in aa_simple_write_to_buffer()\n\nWhen copy_from_user failed, the memory is freed by kvfree. however the\nmanagement struct and data blob are allocated independently, so only\nkvfree(data) cause a memleak issue here. Use aa_put_loaddata(data) to\nfix this issue.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6500eb3a48ac221051b1791818a1ac74744ef617",
      "https://git.kernel.org/stable/c/7db182a2ebeefded86fea542fcc5d6a68bb77f58",
      "https://git.kernel.org/stable/c/8aab4295582eb397a125d2788b829fa62b88dbf7",
      "https://git.kernel.org/stable/c/bf7ebebce2c25071c719fd8a2f1307e0c243c2d7",
      "https://git.kernel.org/stable/c/6583edbf459de2e06b9759f264c0ae27e452b97a",
      "https://git.kernel.org/stable/c/417ea9fe972d2654a268ad66e89c8fcae67017c3"
    ],
    "受影响版本": [
      "a6a52579e52b55448326db88bd9a5740e7c1a037",
      "a6a52579e52b55448326db88bd9a5740e7c1a037",
      "a6a52579e52b55448326db88bd9a5740e7c1a037",
      "a6a52579e52b55448326db88bd9a5740e7c1a037",
      "a6a52579e52b55448326db88bd9a5740e7c1a037",
      "a6a52579e52b55448326db88bd9a5740e7c1a037"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50065",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio_net: fix memory leak inside XPD_TX with mergeable\n\nWhen we call xdp_convert_buff_to_frame() to get xdpf, if it returns\nNULL, we should check if xdp_page was allocated by xdp_linearize_page().\nIf it is newly allocated, it should be freed here alone. Just like any\nother \"goto err_xdp\".",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/faafa2a87f697ee537c29446097e1cc3143506fa",
      "https://git.kernel.org/stable/c/d3723eab11196475ef83279571b2b0bd0924cf82",
      "https://git.kernel.org/stable/c/18e383afbd7047af7b055df6e25436e0ce28f8a5",
      "https://git.kernel.org/stable/c/7a542bee27c6a57e45c33cbbdc963325fd6493af"
    ],
    "受影响版本": [
      "44fa2dbd475996ddc8f3a0e6113dee983e0ee3aa",
      "44fa2dbd475996ddc8f3a0e6113dee983e0ee3aa",
      "44fa2dbd475996ddc8f3a0e6113dee983e0ee3aa",
      "44fa2dbd475996ddc8f3a0e6113dee983e0ee3aa"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50035",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: Fix use-after-free on amdgpu_bo_list mutex\n\nIf amdgpu_cs_vm_handling returns r != 0, then it will unlock the\nbo_list_mutex inside the function amdgpu_cs_vm_handling and again on\namdgpu_cs_parser_fini. This problem results in the following\nuse-after-free problem:\n\n[ 220.280990] ------------[ cut here ]------------\n[ 220.281000] refcount_t: underflow; use-after-free.\n[ 220.281019] WARNING: CPU: 1 PID: 3746 at lib/refcount.c:28 refcount_warn_saturate+0xba/0x110\n[ 220.281029] ------------[ cut here ]------------\n[ 220.281415] CPU: 1 PID: 3746 Comm: chrome:cs0 Tainted: G W L ------- --- 5.20.0-0.rc0.20220812git7ebfc85e2cd7.10.fc38.x86_64 #1\n[ 220.281421] Hardware name: System manufacturer System Product Name/ROG STRIX X570-I GAMING, BIOS 4403 04/27/2022\n[ 220.281426] RIP: 0010:refcount_warn_saturate+0xba/0x110\n[ 220.281431] Code: 01 01 e8 79 4a 6f 00 0f 0b e9 42 47 a5 00 80 3d de\n7e be 01 00 75 85 48 c7 c7 f8 98 8e 98 c6 05 ce 7e be 01 01 e8 56 4a\n6f 00 <0f> 0b e9 1f 47 a5 00 80 3d b9 7e be 01 00 0f 85 5e ff ff ff 48\nc7\n[ 220.281437] RSP: 0018:ffffb4b0d18d7a80 EFLAGS: 00010282\n[ 220.281443] RAX: 0000000000000026 RBX: 0000000000000003 RCX: 0000000000000000\n[ 220.281448] RDX: 0000000000000001 RSI: ffffffff988d06dc RDI: 00000000ffffffff\n[ 220.281452] RBP: 00000000ffffffff R08: 0000000000000000 R09: ffffb4b0d18d7930\n[ 220.281457] R10: 0000000000000003 R11: ffffa0672e2fffe8 R12: ffffa058ca360400\n[ 220.281461] R13: ffffa05846c50a18 R14: 00000000fffffe00 R15: 0000000000000003\n[ 220.281465] FS: 00007f82683e06c0(0000) GS:ffffa066e2e00000(0000) knlGS:0000000000000000\n[ 220.281470] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 220.281475] CR2: 00003590005cc000 CR3: 00000001fca46000 CR4: 0000000000350ee0\n[ 220.281480] Call Trace:\n[ 220.281485] <TASK>\n[ 220.281490] amdgpu_cs_ioctl+0x4e2/0x2070 [amdgpu]\n[ 220.281806] ? amdgpu_cs_find_mapping+0xe0/0xe0 [amdgpu]\n[ 220.282028] drm_ioctl_kernel+0xa4/0x150\n[ 220.282043] drm_ioctl+0x21f/0x420\n[ 220.282053] ? amdgpu_cs_find_mapping+0xe0/0xe0 [amdgpu]\n[ 220.282275] ? lock_release+0x14f/0x460\n[ 220.282282] ? _raw_spin_unlock_irqrestore+0x30/0x60\n[ 220.282290] ? _raw_spin_unlock_irqrestore+0x30/0x60\n[ 220.282297] ? lockdep_hardirqs_on+0x7d/0x100\n[ 220.282305] ? _raw_spin_unlock_irqrestore+0x40/0x60\n[ 220.282317] amdgpu_drm_ioctl+0x4a/0x80 [amdgpu]\n[ 220.282534] __x64_sys_ioctl+0x90/0xd0\n[ 220.282545] do_syscall_64+0x5b/0x80\n[ 220.282551] ? futex_wake+0x6c/0x150\n[ 220.282568] ? lock_is_held_type+0xe8/0x140\n[ 220.282580] ? do_syscall_64+0x67/0x80\n[ 220.282585] ? lockdep_hardirqs_on+0x7d/0x100\n[ 220.282592] ? do_syscall_64+0x67/0x80\n[ 220.282597] ? do_syscall_64+0x67/0x80\n[ 220.282602] ? lockdep_hardirqs_on+0x7d/0x100\n[ 220.282609] entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[ 220.282616] RIP: 0033:0x7f8282a4f8bf\n[ 220.282639] Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10\n00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 44 24 10 b8 10 00 00 00\n0f 05 <89> c2 3d 00 f0 ff ff 77 18 48 8b 44 24 18 64 48 2b 04 25 28 00\n00\n[ 220.282644] RSP: 002b:00007f82683df410 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n[ 220.282651] RAX: ffffffffffffffda RBX: 00007f82683df588 RCX: 00007f8282a4f8bf\n[ 220.282655] RDX: 00007f82683df4d0 RSI: 00000000c0186444 RDI: 0000000000000018\n[ 220.282659] RBP: 00007f82683df4d0 R08: 00007f82683df5e0 R09: 00007f82683df4b0\n[ 220.282663] R10: 00001d04000a0600 R11: 0000000000000246 R12: 00000000c0186444\n[ 220.282667] R13: 0000000000000018 R14: 00007f82683df588 R15: 0000000000000003\n[ 220.282689] </TASK>\n[ 220.282693] irq event stamp: 6232311\n[ 220.282697] hardirqs last enabled at (6232319): [<ffffffff9718cd7e>] __up_console_sem+0x5e/0x70\n[ 220.282704] hardirqs last disabled at (6232326): [<ffffffff9718cd63>] __up_console_sem+0x43/0x70\n[ 220.282709] softirqs last enabled at (6232072): [<ffffffff970ff669>] __irq_exit_rcu+0xf9/0x170\n[ 220.282716] softirqs last disabled at (6232061): [<ffffffff97\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1b38e3b423f0bb41ee6abae5ca9deec1546ba227",
      "https://git.kernel.org/stable/c/bbca24d0a3c11193bafb9e174f89f52a379006e3"
    ],
    "受影响版本": [
      "90af0ca047f3049c4b46e902f432ad6ef1e2ded6",
      "90af0ca047f3049c4b46e902f432ad6ef1e2ded6"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50029",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: ipq8074: dont disable gcc_sleep_clk_src\n\nOnce the usb sleep clocks are disabled, clock framework is trying to\ndisable the sleep clock source also.\n\nHowever, it seems that it cannot be disabled and trying to do so produces:\n[  245.436390] ------------[ cut here ]------------\n[  245.441233] gcc_sleep_clk_src status stuck at 'on'\n[  245.441254] WARNING: CPU: 2 PID: 223 at clk_branch_wait+0x130/0x140\n[  245.450435] Modules linked in: xhci_plat_hcd xhci_hcd dwc3 dwc3_qcom leds_gpio\n[  245.456601] CPU: 2 PID: 223 Comm: sh Not tainted 5.18.0-rc4 #215\n[  245.463889] Hardware name: Xiaomi AX9000 (DT)\n[  245.470050] pstate: 204000c5 (nzCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  245.474307] pc : clk_branch_wait+0x130/0x140\n[  245.481073] lr : clk_branch_wait+0x130/0x140\n[  245.485588] sp : ffffffc009f2bad0\n[  245.489838] x29: ffffffc009f2bad0 x28: ffffff8003e6c800 x27: 0000000000000000\n[  245.493057] x26: 0000000000000000 x25: 0000000000000000 x24: ffffff800226ef20\n[  245.500175] x23: ffffffc0089ff550 x22: 0000000000000000 x21: ffffffc008476ad0\n[  245.507294] x20: 0000000000000000 x19: ffffffc00965ac70 x18: fffffffffffc51a7\n[  245.514413] x17: 68702e3030303837 x16: 3a6d726f6674616c x15: ffffffc089f2b777\n[  245.521531] x14: ffffffc0095c9d18 x13: 0000000000000129 x12: 0000000000000129\n[  245.528649] x11: 00000000ffffffea x10: ffffffc009621d18 x9 : 0000000000000001\n[  245.535767] x8 : 0000000000000001 x7 : 0000000000017fe8 x6 : 0000000000000001\n[  245.542885] x5 : ffffff803fdca6d8 x4 : 0000000000000000 x3 : 0000000000000027\n[  245.550002] x2 : 0000000000000027 x1 : 0000000000000023 x0 : 0000000000000026\n[  245.557122] Call trace:\n[  245.564229]  clk_branch_wait+0x130/0x140\n[  245.566490]  clk_branch2_disable+0x2c/0x40\n[  245.570656]  clk_core_disable+0x60/0xb0\n[  245.574561]  clk_core_disable+0x68/0xb0\n[  245.578293]  clk_disable+0x30/0x50\n[  245.582113]  dwc3_qcom_remove+0x60/0xc0 [dwc3_qcom]\n[  245.585588]  platform_remove+0x28/0x60\n[  245.590361]  device_remove+0x4c/0x80\n[  245.594179]  device_release_driver_internal+0x1dc/0x230\n[  245.597914]  device_driver_detach+0x18/0x30\n[  245.602861]  unbind_store+0xec/0x110\n[  245.607027]  drv_attr_store+0x24/0x40\n[  245.610847]  sysfs_kf_write+0x44/0x60\n[  245.614405]  kernfs_fop_write_iter+0x128/0x1c0\n[  245.618052]  new_sync_write+0xc0/0x130\n[  245.622391]  vfs_write+0x1d4/0x2a0\n[  245.626123]  ksys_write+0x58/0xe0\n[  245.629508]  __arm64_sys_write+0x1c/0x30\n[  245.632895]  invoke_syscall.constprop.0+0x5c/0x110\n[  245.636890]  do_el0_svc+0xa0/0x150\n[  245.641488]  el0_svc+0x18/0x60\n[  245.644872]  el0t_64_sync_handler+0xa4/0x130\n[  245.647914]  el0t_64_sync+0x174/0x178\n[  245.652340] ---[ end trace 0000000000000000 ]---\n\nSo, add CLK_IS_CRITICAL flag to the clock so that the kernel won't try\nto disable the sleep clock.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/38cee0d2b65eed42a44052de1bfdc0177b6c3f05",
      "https://git.kernel.org/stable/c/4203b76abe539f3cac258d4cf1e16e2dd95ea60f",
      "https://git.kernel.org/stable/c/d401611a93b332914cf91eb9bc0b63fa1bdc17e9",
      "https://git.kernel.org/stable/c/6b90ab952401bd6c1a321dcfc0e0df080f2bc905",
      "https://git.kernel.org/stable/c/17d58499dc9c7e059dab7d170e9bae1e7e9c561b",
      "https://git.kernel.org/stable/c/459411b9f0180e3f382d7abfa3028dd3285984c3",
      "https://git.kernel.org/stable/c/1bf7305e79aab095196131bdc87a97796e0e3fac"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50014",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/gup: fix FOLL_FORCE COW security issue and remove FOLL_COW\n\nEver since the Dirty COW (CVE-2016-5195) security issue happened, we know\nthat FOLL_FORCE can be possibly dangerous, especially if there are races\nthat can be exploited by user space.\n\nRight now, it would be sufficient to have some code that sets a PTE of a\nR/O-mapped shared page dirty, in order for it to erroneously become\nwritable by FOLL_FORCE.  The implications of setting a write-protected PTE\ndirty might not be immediately obvious to everyone.\n\nAnd in fact ever since commit 9ae0f87d009c (\"mm/shmem: unconditionally set\npte dirty in mfill_atomic_install_pte\"), we can use UFFDIO_CONTINUE to map\na shmem page R/O while marking the pte dirty.  This can be used by\nunprivileged user space to modify tmpfs/shmem file content even if the\nuser does not have write permissions to the file, and to bypass memfd\nwrite sealing -- Dirty COW restricted to tmpfs/shmem (CVE-2022-2590).\n\nTo fix such security issues for good, the insight is that we really only\nneed that fancy retry logic (FOLL_COW) for COW mappings that are not\nwritable (!VM_WRITE).  And in a COW mapping, we really only broke COW if\nwe have an exclusive anonymous page mapped.  If we have something else\nmapped, or the mapped anonymous page might be shared (!PageAnonExclusive),\nwe have to trigger a write fault to break COW.  If we don't find an\nexclusive anonymous page when we retry, we have to trigger COW breaking\nonce again because something intervened.\n\nLet's move away from this mandatory-retry + dirty handling and rely on our\nPageAnonExclusive() flag for making a similar decision, to use the same\nCOW logic as in other kernel parts here as well.  In case we stumble over\na PTE in a COW mapping that does not map an exclusive anonymous page, COW\nwas not properly broken and we have to trigger a fake write-fault to break\nCOW.\n\nJust like we do in can_change_pte_writable() added via commit 64fe24a3e05e\n(\"mm/mprotect: try avoiding write faults for exclusive anonymous pages\nwhen changing protection\") and commit 76aefad628aa (\"mm/mprotect: fix\nsoft-dirty check in can_change_pte_writable()\"), take care of softdirty\nand uffd-wp manually.\n\nFor example, a write() via /proc/self/mem to a uffd-wp-protected range has\nto fail instead of silently granting write access and bypassing the\nuserspace fault handler.  Note that FOLL_FORCE is not only used for debug\naccess, but also triggered by applications without debug intentions, for\nexample, when pinning pages via RDMA.\n\nThis fixes CVE-2022-2590. Note that only x86_64 and aarch64 are\naffected, because only those support CONFIG_HAVE_ARCH_USERFAULTFD_MINOR.\n\nFortunately, FOLL_COW is no longer required to handle FOLL_FORCE. So\nlet's just get rid of it.\n\nThanks to Nadav Amit for pointing out that the pte_dirty() check in\nFOLL_FORCE code is problematic and might be exploitable.\n\nNote 1: We don't check for the PTE being dirty because it doesn't matter\n\tfor making a \"was COWed\" decision anymore, and whoever modifies the\n\tpage has to set the page dirty either way.\n\nNote 2: Kernels before extended uffd-wp support and before\n\tPageAnonExclusive (< 5.19) can simply revert the problematic\n\tcommit instead and be safe regarding UFFDIO_CONTINUE. A backport to\n\tv5.19 requires minor adjustments due to lack of\n\tvma_soft_dirty_enabled().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9def52eb10baab3b700858003d462fcf17d62873",
      "https://git.kernel.org/stable/c/5535be3099717646781ce1540cf725965d680e7b"
    ],
    "受影响版本": [
      "9ae0f87d009ca6c4aab2882641ddfc319727e3db",
      "9ae0f87d009ca6c4aab2882641ddfc319727e3db"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-50011",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvenus: pm_helpers: Fix warning in OPP during probe\n\nFix the following WARN triggered during Venus driver probe on\n5.19.0-rc8-next-20220728:\n\n WARNING: CPU: 7 PID: 339 at drivers/opp/core.c:2471 dev_pm_opp_set_config+0x49c/0x610\n Modules linked in: qcom_spmi_adc5 rtc_pm8xxx qcom_spmi_adc_tm5 leds_qcom_lpg led_class_multicolor\n  qcom_pon qcom_vadc_common venus_core(+) qcom_spmi_temp_alarm v4l2_mem2mem videobuf2_v4l2 msm(+)\n  videobuf2_common crct10dif_ce spi_geni_qcom snd_soc_sm8250 i2c_qcom_geni gpu_sched\n  snd_soc_qcom_common videodev qcom_q6v5_pas soundwire_qcom drm_dp_aux_bus qcom_stats\n  drm_display_helper qcom_pil_info soundwire_bus snd_soc_lpass_va_macro mc qcom_q6v5\n  phy_qcom_snps_femto_v2 qcom_rng snd_soc_lpass_macro_common snd_soc_lpass_wsa_macro\n  lpass_gfm_sm8250 slimbus qcom_sysmon qcom_common qcom_glink_smem qmi_helpers\n  qcom_wdt mdt_loader socinfo icc_osm_l3 display_connector\n  drm_kms_helper qnoc_sm8250 drm fuse ip_tables x_tables ipv6\n CPU: 7 PID: 339 Comm: systemd-udevd Not tainted 5.19.0-rc8-next-20220728 #4\n Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT)\n pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : dev_pm_opp_set_config+0x49c/0x610\n lr : dev_pm_opp_set_config+0x58/0x610\n sp : ffff8000093c3710\n x29: ffff8000093c3710 x28: ffffbca3959d82b8 x27: ffff8000093c3d00\n x26: ffffbca3959d8e08 x25: ffff4396cac98118 x24: ffff4396c0e24810\n x23: ffff4396c4272c40 x22: ffff4396c0e24810 x21: ffff8000093c3810\n x20: ffff4396cac36800 x19: ffff4396cac96800 x18: 0000000000000000\n x17: 0000000000000003 x16: ffffbca3f4edf198 x15: 0000001cba64a858\n x14: 0000000000000180 x13: 000000000000017e x12: 0000000000000000\n x11: 0000000000000002 x10: 0000000000000a60 x9 : ffff8000093c35c0\n x8 : ffff4396c4273700 x7 : ffff43983efca6c0 x6 : ffff43983efca640\n x5 : 00000000410fd0d0 x4 : ffff4396c4272c40 x3 : ffffbca3f5d1e008\n x2 : 0000000000000000 x1 : ffff4396c2421600 x0 : ffff4396cac96860\n Call trace:\n  dev_pm_opp_set_config+0x49c/0x610\n  devm_pm_opp_set_config+0x18/0x70\n  vcodec_domains_get+0xb8/0x1638 [venus_core]\n  core_get_v4+0x1d8/0x218 [venus_core]\n  venus_probe+0xf4/0x468 [venus_core]\n  platform_probe+0x68/0xd8\n  really_probe+0xbc/0x2a8\n  __driver_probe_device+0x78/0xe0\n  driver_probe_device+0x3c/0xf0\n  __driver_attach+0x70/0x120\n  bus_for_each_dev+0x70/0xc0\n  driver_attach+0x24/0x30\n  bus_add_driver+0x150/0x200\n  driver_register+0x64/0x120\n  __platform_driver_register+0x28/0x38\n  qcom_venus_driver_init+0x24/0x1000 [venus_core]\n  do_one_initcall+0x54/0x1c8\n  do_init_module+0x44/0x1d0\n  load_module+0x16c8/0x1aa0\n  __do_sys_finit_module+0xbc/0x110\n  __arm64_sys_finit_module+0x20/0x30\n  invoke_syscall+0x44/0x108\n  el0_svc_common.constprop.0+0xcc/0xf0\n  do_el0_svc+0x2c/0xb8\n  el0_svc+0x2c/0x88\n  el0t_64_sync_handler+0xb8/0xc0\n  el0t_64_sync+0x18c/0x190\n  qcom-venus: probe of aa00000.video-codec failed with error -16\n\nThe fix is re-ordering the code related to OPP core. The OPP core\nexpects all configuration options to be provided before the OPP\ntable is added.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0bdec5eed69c73886af4cfbb94b663e1e10b8344",
      "https://git.kernel.org/stable/c/8d4eccd78461c3e3555bff67148432bb6c21d059",
      "https://git.kernel.org/stable/c/1d95af02f23031c2e1cca7607c514b86ce85bc6e"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49986",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: storvsc: Remove WQ_MEM_RECLAIM from storvsc_error_wq\n\nstorvsc_error_wq workqueue should not be marked as WQ_MEM_RECLAIM as it\ndoesn't need to make forward progress under memory pressure.  Marking this\nworkqueue as WQ_MEM_RECLAIM may cause deadlock while flushing a\nnon-WQ_MEM_RECLAIM workqueue.  In the current state it causes the following\nwarning:\n\n[   14.506347] ------------[ cut here ]------------\n[   14.506354] workqueue: WQ_MEM_RECLAIM storvsc_error_wq_0:storvsc_remove_lun is flushing !WQ_MEM_RECLAIM events_freezable_power_:disk_events_workfn\n[   14.506360] WARNING: CPU: 0 PID: 8 at <-snip->kernel/workqueue.c:2623 check_flush_dependency+0xb5/0x130\n[   14.506390] CPU: 0 PID: 8 Comm: kworker/u4:0 Not tainted 5.4.0-1086-azure #91~18.04.1-Ubuntu\n[   14.506391] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v4.1 05/09/2022\n[   14.506393] Workqueue: storvsc_error_wq_0 storvsc_remove_lun\n[   14.506395] RIP: 0010:check_flush_dependency+0xb5/0x130\n\t\t<-snip->\n[   14.506408] Call Trace:\n[   14.506412]  __flush_work+0xf1/0x1c0\n[   14.506414]  __cancel_work_timer+0x12f/0x1b0\n[   14.506417]  ? kernfs_put+0xf0/0x190\n[   14.506418]  cancel_delayed_work_sync+0x13/0x20\n[   14.506420]  disk_block_events+0x78/0x80\n[   14.506421]  del_gendisk+0x3d/0x2f0\n[   14.506423]  sr_remove+0x28/0x70\n[   14.506427]  device_release_driver_internal+0xef/0x1c0\n[   14.506428]  device_release_driver+0x12/0x20\n[   14.506429]  bus_remove_device+0xe1/0x150\n[   14.506431]  device_del+0x167/0x380\n[   14.506432]  __scsi_remove_device+0x11d/0x150\n[   14.506433]  scsi_remove_device+0x26/0x40\n[   14.506434]  storvsc_remove_lun+0x40/0x60\n[   14.506436]  process_one_work+0x209/0x400\n[   14.506437]  worker_thread+0x34/0x400\n[   14.506439]  kthread+0x121/0x140\n[   14.506440]  ? process_one_work+0x400/0x400\n[   14.506441]  ? kthread_park+0x90/0x90\n[   14.506443]  ret_from_fork+0x35/0x40\n[   14.506445] ---[ end trace 2d9633159fdc6ee7 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b692c238ddfa61f00d97c4c1f021425d132ba96f",
      "https://git.kernel.org/stable/c/b4c928ace9a123629eeb14ec5d7ee8f73e5ac668",
      "https://git.kernel.org/stable/c/46fcb0fc884db78a0384be92cc2a51927e6581b8",
      "https://git.kernel.org/stable/c/cd2a50d0a097a42b6de283377da98ff757505120",
      "https://git.kernel.org/stable/c/828f57ac75eaccd6607ee4d1468d34e983e32c68",
      "https://git.kernel.org/stable/c/d957e7ffb2c72410bcc1a514153a46719255a5da"
    ],
    "受影响版本": [
      "436ad941335386c5fc7faa915a8fbdfe8c908084",
      "436ad941335386c5fc7faa915a8fbdfe8c908084",
      "436ad941335386c5fc7faa915a8fbdfe8c908084",
      "436ad941335386c5fc7faa915a8fbdfe8c908084",
      "436ad941335386c5fc7faa915a8fbdfe8c908084",
      "436ad941335386c5fc7faa915a8fbdfe8c908084"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49985",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Don't use tnum_range on array range checking for poke descriptors\n\nHsin-Wei reported a KASAN splat triggered by their BPF runtime fuzzer which\nis based on a customized syzkaller:\n\n  BUG: KASAN: slab-out-of-bounds in bpf_int_jit_compile+0x1257/0x13f0\n  Read of size 8 at addr ffff888004e90b58 by task syz-executor.0/1489\n  CPU: 1 PID: 1489 Comm: syz-executor.0 Not tainted 5.19.0 #1\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n  1.13.0-1ubuntu1.1 04/01/2014\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x9c/0xc9\n   print_address_description.constprop.0+0x1f/0x1f0\n   ? bpf_int_jit_compile+0x1257/0x13f0\n   kasan_report.cold+0xeb/0x197\n   ? kvmalloc_node+0x170/0x200\n   ? bpf_int_jit_compile+0x1257/0x13f0\n   bpf_int_jit_compile+0x1257/0x13f0\n   ? arch_prepare_bpf_dispatcher+0xd0/0xd0\n   ? rcu_read_lock_sched_held+0x43/0x70\n   bpf_prog_select_runtime+0x3e8/0x640\n   ? bpf_obj_name_cpy+0x149/0x1b0\n   bpf_prog_load+0x102f/0x2220\n   ? __bpf_prog_put.constprop.0+0x220/0x220\n   ? find_held_lock+0x2c/0x110\n   ? __might_fault+0xd6/0x180\n   ? lock_downgrade+0x6e0/0x6e0\n   ? lock_is_held_type+0xa6/0x120\n   ? __might_fault+0x147/0x180\n   __sys_bpf+0x137b/0x6070\n   ? bpf_perf_link_attach+0x530/0x530\n   ? new_sync_read+0x600/0x600\n   ? __fget_files+0x255/0x450\n   ? lock_downgrade+0x6e0/0x6e0\n   ? fput+0x30/0x1a0\n   ? ksys_write+0x1a8/0x260\n   __x64_sys_bpf+0x7a/0xc0\n   ? syscall_enter_from_user_mode+0x21/0x70\n   do_syscall_64+0x3b/0x90\n   entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  RIP: 0033:0x7f917c4e2c2d\n\nThe problem here is that a range of tnum_range(0, map->max_entries - 1) has\nlimited ability to represent the concrete tight range with the tnum as the\nset of resulting states from value + mask can result in a superset of the\nactual intended range, and as such a tnum_in(range, reg->var_off) check may\nyield true when it shouldn't, for example tnum_range(0, 2) would result in\n00XX -> v = 0000, m = 0011 such that the intended set of {0, 1, 2} is here\nrepresented by a less precise superset of {0, 1, 2, 3}. As the register is\nknown const scalar, really just use the concrete reg->var_off.value for the\nupper index check.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e8979807178434db8ceaa84dfcd44363e71e50bb",
      "https://git.kernel.org/stable/c/4f672112f8665102a5842c170be1713f8ff95919",
      "https://git.kernel.org/stable/c/a36df92c7ff7ecde2fb362241d0ab024dddd0597",
      "https://git.kernel.org/stable/c/a657182a5c5150cdfacb6640aad1d2712571a409"
    ],
    "受影响版本": [
      "d2e4c1e6c2947269346054ac8937ccfe9e0bcc6b",
      "d2e4c1e6c2947269346054ac8937ccfe9e0bcc6b",
      "d2e4c1e6c2947269346054ac8937ccfe9e0bcc6b",
      "d2e4c1e6c2947269346054ac8937ccfe9e0bcc6b"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49983",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nudmabuf: Set the DMA mask for the udmabuf device (v2)\n\nIf the DMA mask is not set explicitly, the following warning occurs\nwhen the userspace tries to access the dma-buf via the CPU as\nreported by syzbot here:\n\nWARNING: CPU: 1 PID: 3595 at kernel/dma/mapping.c:188\n__dma_map_sg_attrs+0x181/0x1f0 kernel/dma/mapping.c:188\nModules linked in:\nCPU: 0 PID: 3595 Comm: syz-executor249 Not tainted\n5.17.0-rc2-syzkaller-00316-g0457e5153e0e #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS\nGoogle 01/01/2011\nRIP: 0010:__dma_map_sg_attrs+0x181/0x1f0 kernel/dma/mapping.c:188\nCode: 00 00 00 00 00 fc ff df 48 c1 e8 03 80 3c 10 00 75 71 4c 8b 3d c0\n83 b5 0d e9 db fe ff ff e8 b6 0f 13 00 0f 0b e8 af 0f 13 00 <0f> 0b 45\n   31 e4 e9 54 ff ff ff e8 a0 0f 13 00 49 8d 7f 50 48 b8 00\nRSP: 0018:ffffc90002a07d68 EFLAGS: 00010293\nRAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: ffff88807e25e2c0 RSI: ffffffff81649e91 RDI: ffff88801b848408\nRBP: ffff88801b848000 R08: 0000000000000002 R09: ffff88801d86c74f\nR10: ffffffff81649d72 R11: 0000000000000001 R12: 0000000000000002\nR13: ffff88801d86c680 R14: 0000000000000001 R15: 0000000000000000\nFS:  0000555556e30300(0000) GS:ffff8880b9d00000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000200000cc CR3: 000000001d74a000 CR4: 00000000003506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n dma_map_sgtable+0x70/0xf0 kernel/dma/mapping.c:264\n get_sg_table.isra.0+0xe0/0x160 drivers/dma-buf/udmabuf.c:72\n begin_cpu_udmabuf+0x130/0x1d0 drivers/dma-buf/udmabuf.c:126\n dma_buf_begin_cpu_access+0xfd/0x1d0 drivers/dma-buf/dma-buf.c:1164\n dma_buf_ioctl+0x259/0x2b0 drivers/dma-buf/dma-buf.c:363\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:874 [inline]\n __se_sys_ioctl fs/ioctl.c:860 [inline]\n __x64_sys_ioctl+0x193/0x200 fs/ioctl.c:860\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7f62fcf530f9\nCode: 28 c3 e8 2a 14 00 00 66 2e 0f 1f 84 00 00 00 00 00 48 89 f8 48 89\nf7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01\nf0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffe3edab9b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f62fcf530f9\nRDX: 0000000020000200 RSI: 0000000040086200 RDI: 0000000000000006\nRBP: 00007f62fcf170e0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f62fcf17170\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nv2: Dont't forget to deregister if DMA mask setup fails.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/63d8c1933ed280717f934e2bc2edd869bb66f329",
      "https://git.kernel.org/stable/c/872875c9ecf8fa2e1d82bb2f2f1963f571aa8959",
      "https://git.kernel.org/stable/c/e658538c610c6047b3c9f552e73801894d9284b1",
      "https://git.kernel.org/stable/c/f2f6ea1a8da1317430a84701fc0170449ee88315",
      "https://git.kernel.org/stable/c/9e9fa6a9198b767b00f48160800128e83a038f9f"
    ],
    "受影响版本": [
      "fbb0de795078190a9834b3409e4b009cfb18a6d4",
      "fbb0de795078190a9834b3409e4b009cfb18a6d4",
      "fbb0de795078190a9834b3409e4b009cfb18a6d4",
      "fbb0de795078190a9834b3409e4b009cfb18a6d4",
      "fbb0de795078190a9834b3409e4b009cfb18a6d4"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49979",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fix refcount bug in sk_psock_get (2)\n\nSyzkaller reports refcount bug as follows:\n------------[ cut here ]------------\nrefcount_t: saturated; leaking memory.\nWARNING: CPU: 1 PID: 3605 at lib/refcount.c:19 refcount_warn_saturate+0xf4/0x1e0 lib/refcount.c:19\nModules linked in:\nCPU: 1 PID: 3605 Comm: syz-executor208 Not tainted 5.18.0-syzkaller-03023-g7e062cda7d90 #0\n <TASK>\n __refcount_add_not_zero include/linux/refcount.h:163 [inline]\n __refcount_inc_not_zero include/linux/refcount.h:227 [inline]\n refcount_inc_not_zero include/linux/refcount.h:245 [inline]\n sk_psock_get+0x3bc/0x410 include/linux/skmsg.h:439\n tls_data_ready+0x6d/0x1b0 net/tls/tls_sw.c:2091\n tcp_data_ready+0x106/0x520 net/ipv4/tcp_input.c:4983\n tcp_data_queue+0x25f2/0x4c90 net/ipv4/tcp_input.c:5057\n tcp_rcv_state_process+0x1774/0x4e80 net/ipv4/tcp_input.c:6659\n tcp_v4_do_rcv+0x339/0x980 net/ipv4/tcp_ipv4.c:1682\n sk_backlog_rcv include/net/sock.h:1061 [inline]\n __release_sock+0x134/0x3b0 net/core/sock.c:2849\n release_sock+0x54/0x1b0 net/core/sock.c:3404\n inet_shutdown+0x1e0/0x430 net/ipv4/af_inet.c:909\n __sys_shutdown_sock net/socket.c:2331 [inline]\n __sys_shutdown_sock net/socket.c:2325 [inline]\n __sys_shutdown+0xf1/0x1b0 net/socket.c:2343\n __do_sys_shutdown net/socket.c:2351 [inline]\n __se_sys_shutdown net/socket.c:2349 [inline]\n __x64_sys_shutdown+0x50/0x70 net/socket.c:2349\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\n </TASK>\n\nDuring SMC fallback process in connect syscall, kernel will\nreplaces TCP with SMC. In order to forward wakeup\nsmc socket waitqueue after fallback, kernel will sets\nclcsk->sk_user_data to origin smc socket in\nsmc_fback_replace_callbacks().\n\nLater, in shutdown syscall, kernel will calls\nsk_psock_get(), which treats the clcsk->sk_user_data\nas psock type, triggering the refcnt warning.\n\nSo, the root cause is that smc and psock, both will use\nsk_user_data field. So they will mismatch this field\neasily.\n\nThis patch solves it by using another bit(defined as\nSK_USER_DATA_PSOCK) in PTRMASK, to mark whether\nsk_user_data points to a psock object or not.\nThis patch depends on a PTRMASK introduced in commit f1ff5ce2cd5e\n(\"net, sk_msg: Clear sk_user_data pointer on clone if tagged\").\n\nFor there will possibly be more flags in the sk_user_data field,\nthis patch also refactor sk_user_data flags code to be more generic\nto improve its maintainability.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/61cc798591a36ca27eb7d8d6c09bf20e50a59968",
      "https://git.kernel.org/stable/c/a5d1cb908131e939bd8b63b8e5e23365bbc2edaf",
      "https://git.kernel.org/stable/c/86026be8535c16fcc5e4f960286faf04d7f77815",
      "https://git.kernel.org/stable/c/2a0133723f9ebeb751cfce19f74ec07e108bef1f"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49977",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nftrace: Fix NULL pointer dereference in is_ftrace_trampoline when ftrace is dead\n\nftrace_startup does not remove ops from ftrace_ops_list when\nftrace_startup_enable fails:\n\nregister_ftrace_function\n  ftrace_startup\n    __register_ftrace_function\n      ...\n      add_ftrace_ops(&ftrace_ops_list, ops)\n      ...\n    ...\n    ftrace_startup_enable // if ftrace failed to modify, ftrace_disabled is set to 1\n    ...\n  return 0 // ops is in the ftrace_ops_list.\n\nWhen ftrace_disabled = 1, unregister_ftrace_function simply returns without doing anything:\nunregister_ftrace_function\n  ftrace_shutdown\n    if (unlikely(ftrace_disabled))\n            return -ENODEV;  // return here, __unregister_ftrace_function is not executed,\n                             // as a result, ops is still in the ftrace_ops_list\n    __unregister_ftrace_function\n    ...\n\nIf ops is dynamically allocated, it will be free later, in this case,\nis_ftrace_trampoline accesses NULL pointer:\n\nis_ftrace_trampoline\n  ftrace_ops_trampoline\n    do_for_each_ftrace_op(op, ftrace_ops_list) // OOPS! op may be NULL!\n\nSyzkaller reports as follows:\n[ 1203.506103] BUG: kernel NULL pointer dereference, address: 000000000000010b\n[ 1203.508039] #PF: supervisor read access in kernel mode\n[ 1203.508798] #PF: error_code(0x0000) - not-present page\n[ 1203.509558] PGD 800000011660b067 P4D 800000011660b067 PUD 130fb8067 PMD 0\n[ 1203.510560] Oops: 0000 [#1] SMP KASAN PTI\n[ 1203.511189] CPU: 6 PID: 29532 Comm: syz-executor.2 Tainted: G    B   W         5.10.0 #8\n[ 1203.512324] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014\n[ 1203.513895] RIP: 0010:is_ftrace_trampoline+0x26/0xb0\n[ 1203.514644] Code: ff eb d3 90 41 55 41 54 49 89 fc 55 53 e8 f2 00 fd ff 48 8b 1d 3b 35 5d 03 e8 e6 00 fd ff 48 8d bb 90 00 00 00 e8 2a 81 26 00 <48> 8b ab 90 00 00 00 48 85 ed 74 1d e8 c9 00 fd ff 48 8d bb 98 00\n[ 1203.518838] RSP: 0018:ffffc900012cf960 EFLAGS: 00010246\n[ 1203.520092] RAX: 0000000000000000 RBX: 000000000000007b RCX: ffffffff8a331866\n[ 1203.521469] RDX: 0000000000000000 RSI: 0000000000000008 RDI: 000000000000010b\n[ 1203.522583] RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffff8df18b07\n[ 1203.523550] R10: fffffbfff1be3160 R11: 0000000000000001 R12: 0000000000478399\n[ 1203.524596] R13: 0000000000000000 R14: ffff888145088000 R15: 0000000000000008\n[ 1203.525634] FS:  00007f429f5f4700(0000) GS:ffff8881daf00000(0000) knlGS:0000000000000000\n[ 1203.526801] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 1203.527626] CR2: 000000000000010b CR3: 0000000170e1e001 CR4: 00000000003706e0\n[ 1203.528611] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 1203.529605] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n\nTherefore, when ftrace_startup_enable fails, we need to rollback registration\nprocess and remove ops from ftrace_ops_list.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8569b4ada1e0b9bfaa125bd0c0967918b6560fa2",
      "https://git.kernel.org/stable/c/4c34a2a6c9927c239dd2e295a03d49b37b618d2c",
      "https://git.kernel.org/stable/c/ddffe882d74ef43a3494f0ab0c24baf076c45f96",
      "https://git.kernel.org/stable/c/934e49f7d696afdae9f979abe3f308408184e17b",
      "https://git.kernel.org/stable/c/dbd8c8fc60480e3faa3ae7e27ebe03371ecd1b77",
      "https://git.kernel.org/stable/c/e4ae97295984ff1b9b340ed18ae1b066f36b7835",
      "https://git.kernel.org/stable/c/d81bd6671f45fde4c3ac7fd7733c6e3082ae9d8e",
      "https://git.kernel.org/stable/c/c3b0f72e805f0801f05fa2aa52011c4bfc694c44"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49976",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86: x86-android-tablets: Fix broken touchscreen on Chuwi Hi8 with Windows BIOS\n\nThe x86-android-tablets handling for the Chuwi Hi8 is only necessary with\nthe Android BIOS and it is causing problems with the Windows BIOS version.\n\nSpecifically when trying to register the already present touchscreen\nx86_acpi_irq_helper_get() calls acpi_unregister_gsi(), this breaks\nthe working of the touchscreen and also leads to an oops:\n\n[   14.248946] ------------[ cut here ]------------\n[   14.248954] remove_proc_entry: removing non-empty directory 'irq/75', leaking at least 'MSSL0001:00'\n[   14.248983] WARNING: CPU: 3 PID: 440 at fs/proc/generic.c:718 remove_proc_entry\n...\n[   14.249293]  unregister_irq_proc+0xe0/0x100\n[   14.249305]  free_desc+0x29/0x70\n[   14.249312]  irq_free_descs+0x4b/0x80\n[   14.249320]  mp_unmap_irq+0x5c/0x60\n[   14.249329]  acpi_unregister_gsi_ioapic+0x2a/0x40\n[   14.249338]  x86_acpi_irq_helper_get+0x4b/0x190 [x86_android_tablets]\n[   14.249355]  x86_android_tablet_init+0x178/0xe34 [x86_android_tablets]\n\nAdd an init callback for the Chuwi Hi8, which detects when the Windows BIOS\nis in use and exits with -ENODEV in that case, fixing this.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c77b724cddfb8ac1291a60e3e68937e62cbfc5e0",
      "https://git.kernel.org/stable/c/2986c51540ed50ac654ffb5a772e546c02628c91"
    ],
    "受影响版本": [
      "84c2dcdd475f3f5d1d30c87404cafba4dd4b75ec",
      "84c2dcdd475f3f5d1d30c87404cafba4dd4b75ec"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49973",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nskmsg: Fix wrong last sg check in sk_msg_recvmsg()\n\nFix one kernel NULL pointer dereference as below:\n\n[  224.462334] Call Trace:\n[  224.462394]  __tcp_bpf_recvmsg+0xd3/0x380\n[  224.462441]  ? sock_has_perm+0x78/0xa0\n[  224.462463]  tcp_bpf_recvmsg+0x12e/0x220\n[  224.462494]  inet_recvmsg+0x5b/0xd0\n[  224.462534]  __sys_recvfrom+0xc8/0x130\n[  224.462574]  ? syscall_trace_enter+0x1df/0x2e0\n[  224.462606]  ? __do_page_fault+0x2de/0x500\n[  224.462635]  __x64_sys_recvfrom+0x24/0x30\n[  224.462660]  do_syscall_64+0x5d/0x1d0\n[  224.462709]  entry_SYSCALL_64_after_hwframe+0x65/0xca\n\nIn commit 9974d37ea75f (\"skmsg: Fix invalid last sg check in\nsk_msg_recvmsg()\"), we change last sg check to sg_is_last(),\nbut in sockmap redirection case (without stream_parser/stream_verdict/\nskb_verdict), we did not mark the end of the scatterlist. Check the\nsk_msg_alloc, sk_msg_page_add, and bpf_msg_push_data functions, they all\ndo not mark the end of sg. They are expected to use sg.end for end\njudgment. So the judgment of '(i != msg_rx->sg.end)' is added back here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/de22cba333d8699ad77e79f862fe1320cb1284de",
      "https://git.kernel.org/stable/c/10ee118a1756141f8e9c87aa7344ed12b41630a8",
      "https://git.kernel.org/stable/c/583585e48d965338e73e1eb383768d16e0922d73"
    ],
    "受影响版本": [
      "293c53b7dbf9073cbcc488f938bc053ff4caeec0",
      "1295dae30f30c3daa03005ed8958d44b17f037fd",
      "9974d37ea75f01b47d16072b5dad305bd8d23fcc",
      "4674c0da448b546e390a981b819cd4af5cb16cf9"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49970",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, cgroup: Fix kernel BUG in purge_effective_progs\n\nSyzkaller reported a triggered kernel BUG as follows:\n\n  ------------[ cut here ]------------\n  kernel BUG at kernel/bpf/cgroup.c:925!\n  invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n  CPU: 1 PID: 194 Comm: detach Not tainted 5.19.0-14184-g69dac8e431af #8\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n  rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\n  RIP: 0010:__cgroup_bpf_detach+0x1f2/0x2a0\n  Code: 00 e8 92 60 30 00 84 c0 75 d8 4c 89 e0 31 f6 85 f6 74 19 42 f6 84\n  28 48 05 00 00 02 75 0e 48 8b 80 c0 00 00 00 48 85 c0 75 e5 <0f> 0b 48\n  8b 0c5\n  RSP: 0018:ffffc9000055bdb0 EFLAGS: 00000246\n  RAX: 0000000000000000 RBX: ffff888100ec0800 RCX: ffffc900000f1000\n  RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff888100ec4578\n  RBP: 0000000000000000 R08: ffff888100ec0800 R09: 0000000000000040\n  R10: 0000000000000000 R11: 0000000000000000 R12: ffff888100ec4000\n  R13: 000000000000000d R14: ffffc90000199000 R15: ffff888100effb00\n  FS:  00007f68213d2b80(0000) GS:ffff88813bc80000(0000)\n  knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 000055f74a0e5850 CR3: 0000000102836000 CR4: 00000000000006e0\n  Call Trace:\n   <TASK>\n   cgroup_bpf_prog_detach+0xcc/0x100\n   __sys_bpf+0x2273/0x2a00\n   __x64_sys_bpf+0x17/0x20\n   do_syscall_64+0x3b/0x90\n   entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  RIP: 0033:0x7f68214dbcb9\n  Code: 08 44 89 e0 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 48 89 f8 48 89\n  f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01\n  f0 ff8\n  RSP: 002b:00007ffeb487db68 EFLAGS: 00000246 ORIG_RAX: 0000000000000141\n  RAX: ffffffffffffffda RBX: 000000000000000b RCX: 00007f68214dbcb9\n  RDX: 0000000000000090 RSI: 00007ffeb487db70 RDI: 0000000000000009\n  RBP: 0000000000000003 R08: 0000000000000012 R09: 0000000b00000003\n  R10: 00007ffeb487db70 R11: 0000000000000246 R12: 00007ffeb487dc20\n  R13: 0000000000000004 R14: 0000000000000001 R15: 000055f74a1011b0\n   </TASK>\n  Modules linked in:\n  ---[ end trace 0000000000000000 ]---\n\nRepetition steps:\n\nFor the following cgroup tree,\n\n  root\n   |\n  cg1\n   |\n  cg2\n\n  1. attach prog2 to cg2, and then attach prog1 to cg1, both bpf progs\n     attach type is NONE or OVERRIDE.\n  2. write 1 to /proc/thread-self/fail-nth for failslab.\n  3. detach prog1 for cg1, and then kernel BUG occur.\n\nFailslab injection will cause kmalloc fail and fall back to\npurge_effective_progs. The problem is that cg2 have attached another prog,\nso when go through cg2 layer, iteration will add pos to 1, and subsequent\noperations will be skipped by the following condition, and cg will meet\nNULL in the end.\n\n  `if (pos && !(cg->bpf.flags[atype] & BPF_F_ALLOW_MULTI))`\n\nThe NULL cg means no link or prog match, this is as expected, and it's not\na bug. So here just skip the no match situation.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c5f975e3ebfa57be13393c585a4b58ea707023cb",
      "https://git.kernel.org/stable/c/222bd95c89b135fde21f0bd0cb5cc1611c0c576c",
      "https://git.kernel.org/stable/c/a1a05d3ae58299b040da4d5b27e72e81c2132e0b",
      "https://git.kernel.org/stable/c/7d6620f107bae6ed687ff07668e8e8f855487aa9"
    ],
    "受影响版本": [
      "3527e3cbb84d8868c4d4e91ba55915f96d39ec3d",
      "1f8ca9c40e6222ce431e9ba5dae3cccce8ef9443",
      "be001f9da71eaa3b61e186fb88bde3279728bdca",
      "4c46091ee985ae84c60c5e95055d779fcd291d87",
      "6336388715afa419cc97d0255bda3bba1b96b7ca"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49955",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/rtas: Fix RTAS MSR[HV] handling for Cell\n\nThe semi-recent changes to MSR handling when entering RTAS (firmware)\ncause crashes on IBM Cell machines. An example trace:\n\n  kernel tried to execute user page (2fff01a8) - exploit attempt? (uid: 0)\n  BUG: Unable to handle kernel instruction fetch\n  Faulting instruction address: 0x2fff01a8\n  Oops: Kernel access of bad area, sig: 11 [#1]\n  BE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=4 NUMA Cell\n  Modules linked in:\n  CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W          6.0.0-rc2-00433-gede0a8d3307a #207\n  NIP:  000000002fff01a8 LR: 0000000000032608 CTR: 0000000000000000\n  REGS: c0000000015236b0 TRAP: 0400   Tainted: G        W           (6.0.0-rc2-00433-gede0a8d3307a)\n  MSR:  0000000008001002 <ME,RI>  CR: 00000000  XER: 20000000\n  ...\n  NIP 0x2fff01a8\n  LR  0x32608\n  Call Trace:\n    0xc00000000143c5f8 (unreliable)\n    .rtas_call+0x224/0x320\n    .rtas_get_boot_time+0x70/0x150\n    .read_persistent_clock64+0x114/0x140\n    .read_persistent_wall_and_boot_offset+0x24/0x80\n    .timekeeping_init+0x40/0x29c\n    .start_kernel+0x674/0x8f0\n    start_here_common+0x1c/0x50\n\nUnlike PAPR platforms where RTAS is only used in guests, on the IBM Cell\nmachines Linux runs with MSR[HV] set but also uses RTAS, provided by\nSLOF.\n\nFix it by copying the MSR[HV] bit from the MSR value we've just read\nusing mfmsr into the value used for RTAS.\n\nIt seems like we could also fix it using an #ifdef CELL to set MSR[HV],\nbut that doesn't work because it's possible to build a single kernel\nimage that runs on both Cell native and pseries.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8b08d4f97233d8e58fff2fd9d5f86397a49733c5",
      "https://git.kernel.org/stable/c/91926d8b7e71aaf5f84f0cf208fc5a8b7a761050"
    ],
    "受影响版本": [
      "b6b1c3ce06ca438eb24e0f45bf0e63ecad0369f5",
      "b6b1c3ce06ca438eb24e0f45bf0e63ecad0369f5",
      "5ca40fcf0da0ce2b5bc44e7d8b036535955f2e3d",
      "5f4367448f6817c8a0e94dc9736ed84fa8eee4a3",
      "c9c41f0273826a13ac93124e66a4ff45df281ba0"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49944",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nRevert \"usb: typec: ucsi: add a common function ucsi_unregister_connectors()\"\n\nThe recent commit 87d0e2f41b8c (\"usb: typec: ucsi: add a common\nfunction ucsi_unregister_connectors()\") introduced a regression that\ncaused NULL dereference at reading the power supply sysfs.  It's a\nstale sysfs entry that should have been removed but remains with NULL\nops.  The commit changed the error handling to skip the entries after\na NULL con->wq, and this leaves the power device unreleased.\n\nFor addressing the regression, the straight revert is applied here.\nFurther code improvements can be done from the scratch again.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3d4044c9e6d2e3f11f1f8b5e0ee8647d3eb1afad",
      "https://git.kernel.org/stable/c/5f73aa2cf8bef4a39baa1591c3144ede4788826e"
    ],
    "受影响版本": [
      "87d0e2f41b8cc2018499be4e8003fa8c09b6f2fb",
      "87d0e2f41b8cc2018499be4e8003fa8c09b6f2fb"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49943",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: gadget: Fix obscure lockdep violation for udc_mutex\n\nA recent commit expanding the scope of the udc_lock mutex in the\ngadget core managed to cause an obscure and slightly bizarre lockdep\nviolation.  In abbreviated form:\n\n======================================================\nWARNING: possible circular locking dependency detected\n5.19.0-rc7+ #12510 Not tainted\n------------------------------------------------------\nudevadm/312 is trying to acquire lock:\nffff80000aae1058 (udc_lock){+.+.}-{3:3}, at: usb_udc_uevent+0x54/0xe0\n\nbut task is already holding lock:\nffff000002277548 (kn->active#4){++++}-{0:0}, at: kernfs_seq_start+0x34/0xe0\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #3 (kn->active#4){++++}-{0:0}:\n        lock_acquire+0x68/0x84\n        __kernfs_remove+0x268/0x380\n        kernfs_remove_by_name_ns+0x58/0xac\n        sysfs_remove_file_ns+0x18/0x24\n        device_del+0x15c/0x440\n\n-> #2 (device_links_lock){+.+.}-{3:3}:\n        lock_acquire+0x68/0x84\n        __mutex_lock+0x9c/0x430\n        mutex_lock_nested+0x38/0x64\n        device_link_remove+0x3c/0xa0\n        _regulator_put.part.0+0x168/0x190\n        regulator_put+0x3c/0x54\n        devm_regulator_release+0x14/0x20\n\n-> #1 (regulator_list_mutex){+.+.}-{3:3}:\n        lock_acquire+0x68/0x84\n        __mutex_lock+0x9c/0x430\n        mutex_lock_nested+0x38/0x64\n        regulator_lock_dependent+0x54/0x284\n        regulator_enable+0x34/0x80\n        phy_power_on+0x24/0x130\n        __dwc2_lowlevel_hw_enable+0x100/0x130\n        dwc2_lowlevel_hw_enable+0x18/0x40\n        dwc2_hsotg_udc_start+0x6c/0x2f0\n        gadget_bind_driver+0x124/0x1f4\n\n-> #0 (udc_lock){+.+.}-{3:3}:\n        __lock_acquire+0x1298/0x20cc\n        lock_acquire.part.0+0xe0/0x230\n        lock_acquire+0x68/0x84\n        __mutex_lock+0x9c/0x430\n        mutex_lock_nested+0x38/0x64\n        usb_udc_uevent+0x54/0xe0\n\nEvidently this was caused by the scope of udc_mutex being too large.\nThe mutex is only meant to protect udc->driver along with a few other\nthings.  As far as I can tell, there's no reason for the mutex to be\nheld while the gadget core calls a gadget driver's ->bind or ->unbind\nroutine, or while a UDC is being started or stopped.  (This accounts\nfor link #1 in the chain above, where the mutex is held while the\ndwc2_hsotg_udc is started as part of driver probing.)\n\nGadget drivers' ->disconnect callbacks are problematic.  Even though\nusb_gadget_disconnect() will now acquire the udc_mutex, there's a\nwindow in usb_gadget_bind_driver() between the times when the mutex is\nreleased and the ->bind callback is invoked.  If a disconnect occurred\nduring that window, we could call the driver's ->disconnect routine\nbefore its ->bind routine.  To prevent this from happening, it will be\nnecessary to prevent a UDC from connecting while it has no gadget\ndriver.  This should be done already but it doesn't seem to be;\ncurrently usb_gadget_connect() has no check for this.  Such a check\nwill have to be added later.\n\nSome degree of mutual exclusion is required in soft_connect_store(),\nwhich can dereference udc->driver at arbitrary times since it is a\nsysfs callback.  The solution here is to acquire the gadget's device\nlock rather than the udc_mutex.  Since the driver core guarantees that\nthe device lock is always held during driver binding and unbinding,\nthis will make the accesses in soft_connect_store() mutually exclusive\nwith any changes to udc->driver.\n\nLastly, it turns out there is one place which should hold the\nudc_mutex but currently does not: The function_show() routine needs\nprotection while it dereferences udc->driver.  The missing lock and\nunlock calls are added.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1a065e4673cbdd9f222a05f85e17d78ea50c8d9c",
      "https://git.kernel.org/stable/c/1016fc0c096c92dd0e6e0541daac7a7868169903"
    ],
    "受影响版本": [
      "f44b0b95d50fffeca036e1ba36770390e0b519dd",
      "2191c00855b03aa59c20e698be713d952d51fc18"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49937",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: mceusb: Use new usb_control_msg_*() routines\n\nAutomatic kernel fuzzing led to a WARN about invalid pipe direction in\nthe mceusb driver:\n\n------------[ cut here ]------------\nusb 6-1: BOGUS control dir, pipe 80000380 doesn't match bRequestType 40\nWARNING: CPU: 0 PID: 2465 at drivers/usb/core/urb.c:410\nusb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410\nModules linked in:\nCPU: 0 PID: 2465 Comm: kworker/0:2 Not tainted 5.19.0-rc4-00208-g69cb6c6556ad #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.13.0-1ubuntu1.1 04/01/2014\nWorkqueue: usb_hub_wq hub_event\nRIP: 0010:usb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410\nCode: 7c 24 40 e8 ac 23 91 fd 48 8b 7c 24 40 e8 b2 70 1b ff 45 89 e8\n44 89 f1 4c 89 e2 48 89 c6 48 c7 c7 a0 30 a9 86 e8 48 07 11 02 <0f> 0b\ne9 1c f0 ff ff e8 7e 23 91 fd 0f b6 1d 63 22 83 05 31 ff 41\nRSP: 0018:ffffc900032becf0 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: ffff8881100f3058 RCX: 0000000000000000\nRDX: ffffc90004961000 RSI: ffff888114c6d580 RDI: fffff52000657d90\nRBP: ffff888105ad90f0 R08: ffffffff812c3638 R09: 0000000000000000\nR10: 0000000000000005 R11: ffffed1023504ef1 R12: ffff888105ad9000\nR13: 0000000000000040 R14: 0000000080000380 R15: ffff88810ba96500\nFS: 0000000000000000(0000) GS:ffff88811a800000(0000) knlGS:0000000000000000\nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffe810bda58 CR3: 000000010b720000 CR4: 0000000000350ef0\nCall Trace:\n<TASK>\nusb_start_wait_urb+0x101/0x4c0 drivers/usb/core/message.c:58\nusb_internal_control_msg drivers/usb/core/message.c:102 [inline]\nusb_control_msg+0x31c/0x4a0 drivers/usb/core/message.c:153\nmceusb_gen1_init drivers/media/rc/mceusb.c:1431 [inline]\nmceusb_dev_probe+0x258e/0x33f0 drivers/media/rc/mceusb.c:1807\n\nThe reason for the warning is clear enough; the driver sends an\nunusual read request on endpoint 0 but does not set the USB_DIR_IN bit\nin the bRequestType field.\n\nMore importantly, the whole situation can be avoided and the driver\nsimplified by converting it over to the relatively new\nusb_control_msg_recv() and usb_control_msg_send() routines.  That's\nwhat this fix does.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/587f793c64d99d92be8ef01c4c69d885a3f2edb6",
      "https://git.kernel.org/stable/c/75913c562f5ba4cf397d835c63f443879167c6f6",
      "https://git.kernel.org/stable/c/d69c738ac9310b56e84c51c8f09fc018a8291bc6",
      "https://git.kernel.org/stable/c/608e58a0f4617977178131f5f68a3fce1d3f5316"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年06月18日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49898",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix tree mod log mishandling of reallocated nodes\n\nWe have been seeing the following panic in production\n\n  kernel BUG at fs/btrfs/tree-mod-log.c:677!\n  invalid opcode: 0000 [#1] SMP\n  RIP: 0010:tree_mod_log_rewind+0x1b4/0x200\n  RSP: 0000:ffffc9002c02f890 EFLAGS: 00010293\n  RAX: 0000000000000003 RBX: ffff8882b448c700 RCX: 0000000000000000\n  RDX: 0000000000008000 RSI: 00000000000000a7 RDI: ffff88877d831c00\n  RBP: 0000000000000002 R08: 000000000000009f R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000100c40 R12: 0000000000000001\n  R13: ffff8886c26d6a00 R14: ffff88829f5424f8 R15: ffff88877d831a00\n  FS:  00007fee1d80c780(0000) GS:ffff8890400c0000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007fee1963a020 CR3: 0000000434f33002 CR4: 00000000007706e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  PKRU: 55555554\n  Call Trace:\n   btrfs_get_old_root+0x12b/0x420\n   btrfs_search_old_slot+0x64/0x2f0\n   ? tree_mod_log_oldest_root+0x3d/0xf0\n   resolve_indirect_ref+0xfd/0x660\n   ? ulist_alloc+0x31/0x60\n   ? kmem_cache_alloc_trace+0x114/0x2c0\n   find_parent_nodes+0x97a/0x17e0\n   ? ulist_alloc+0x30/0x60\n   btrfs_find_all_roots_safe+0x97/0x150\n   iterate_extent_inodes+0x154/0x370\n   ? btrfs_search_path_in_tree+0x240/0x240\n   iterate_inodes_from_logical+0x98/0xd0\n   ? btrfs_search_path_in_tree+0x240/0x240\n   btrfs_ioctl_logical_to_ino+0xd9/0x180\n   btrfs_ioctl+0xe2/0x2ec0\n   ? __mod_memcg_lruvec_state+0x3d/0x280\n   ? do_sys_openat2+0x6d/0x140\n   ? kretprobe_dispatcher+0x47/0x70\n   ? kretprobe_rethook_handler+0x38/0x50\n   ? rethook_trampoline_handler+0x82/0x140\n   ? arch_rethook_trampoline_callback+0x3b/0x50\n   ? kmem_cache_free+0xfb/0x270\n   ? do_sys_openat2+0xd5/0x140\n   __x64_sys_ioctl+0x71/0xb0\n   do_syscall_64+0x2d/0x40\n\nWhich is this code in tree_mod_log_rewind()\n\n\tswitch (tm->op) {\n        case BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING:\n\t\tBUG_ON(tm->slot < n);\n\nThis occurs because we replay the nodes in order that they happened, and\nwhen we do a REPLACE we will log a REMOVE_WHILE_FREEING for every slot,\nstarting at 0.  'n' here is the number of items in this block, which in\nthis case was 1, but we had 2 REMOVE_WHILE_FREEING operations.\n\nThe actual root cause of this was that we were replaying operations for\na block that shouldn't have been replayed.  Consider the following\nsequence of events\n\n1. We have an already modified root, and we do a btrfs_get_tree_mod_seq().\n2. We begin removing items from this root, triggering KEY_REPLACE for\n   it's child slots.\n3. We remove one of the 2 children this root node points to, thus triggering\n   the root node promotion of the remaining child, and freeing this node.\n4. We modify a new root, and re-allocate the above node to the root node of\n   this other root.\n\nThe tree mod log looks something like this\n\n\tlogical 0\top KEY_REPLACE (slot 1)\t\t\tseq 2\n\tlogical 0\top KEY_REMOVE (slot 1)\t\t\tseq 3\n\tlogical 0\top KEY_REMOVE_WHILE_FREEING (slot 0)\tseq 4\n\tlogical 4096\top LOG_ROOT_REPLACE (old logical 0)\tseq 5\n\tlogical 8192\top KEY_REMOVE_WHILE_FREEING (slot 1)\tseq 6\n\tlogical 8192\top KEY_REMOVE_WHILE_FREEING (slot 0)\tseq 7\n\tlogical 0\top LOG_ROOT_REPLACE (old logical 8192)\tseq 8\n\n>From here the bug is triggered by the following steps\n\n1.  Call btrfs_get_old_root() on the new_root.\n2.  We call tree_mod_log_oldest_root(btrfs_root_node(new_root)), which is\n    currently logical 0.\n3.  tree_mod_log_oldest_root() calls tree_mod_log_search_oldest(), which\n    gives us the KEY_REPLACE seq 2, and since that's not a\n    LOG_ROOT_REPLACE we incorrectly believe that we don't have an old\n    root, because we expect that the most recent change should be a\n    LOG_ROOT_REPLACE.\n4.  Back in tree_mod_log_oldest_root() we don't have a LOG_ROOT_REPLACE,\n    so we don't set old_root, we simply use our e\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/007058eb8292efc4c88f921752194b83269da085",
      "https://git.kernel.org/stable/c/52b2b65c9eb56fd829dda323786db828627ff7e6",
      "https://git.kernel.org/stable/c/968b71583130b6104c9f33ba60446d598e327a8b"
    ],
    "受影响版本": [
      "bd989ba359f2acb8bc5f5490e19010fc0a6f8356",
      "bd989ba359f2acb8bc5f5490e19010fc0a6f8356",
      "bd989ba359f2acb8bc5f5490e19010fc0a6f8356"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49885",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: APEI: Fix integer overflow in ghes_estatus_pool_init()\n\nChange num_ghes from int to unsigned int, preventing an overflow\nand causing subsequent vmalloc() to fail.\n\nThe overflow happens in ghes_estatus_pool_init() when calculating\nlen during execution of the statement below as both multiplication\noperands here are signed int:\n\nlen += (num_ghes * GHES_ESOURCE_PREALLOC_MAX_SIZE);\n\nThe following call trace is observed because of this bug:\n\n[    9.317108] swapper/0: vmalloc error: size 18446744071562596352, exceeds total pages, mode:0xcc0(GFP_KERNEL), nodemask=(null),cpuset=/,mems_allowed=0-1\n[    9.317131] Call Trace:\n[    9.317134]  <TASK>\n[    9.317137]  dump_stack_lvl+0x49/0x5f\n[    9.317145]  dump_stack+0x10/0x12\n[    9.317146]  warn_alloc.cold+0x7b/0xdf\n[    9.317150]  ? __device_attach+0x16a/0x1b0\n[    9.317155]  __vmalloc_node_range+0x702/0x740\n[    9.317160]  ? device_add+0x17f/0x920\n[    9.317164]  ? dev_set_name+0x53/0x70\n[    9.317166]  ? platform_device_add+0xf9/0x240\n[    9.317168]  __vmalloc_node+0x49/0x50\n[    9.317170]  ? ghes_estatus_pool_init+0x43/0xa0\n[    9.317176]  vmalloc+0x21/0x30\n[    9.317177]  ghes_estatus_pool_init+0x43/0xa0\n[    9.317179]  acpi_hest_init+0x129/0x19c\n[    9.317185]  acpi_init+0x434/0x4a4\n[    9.317188]  ? acpi_sleep_proc_init+0x2a/0x2a\n[    9.317190]  do_one_initcall+0x48/0x200\n[    9.317195]  kernel_init_freeable+0x221/0x284\n[    9.317200]  ? rest_init+0xe0/0xe0\n[    9.317204]  kernel_init+0x1a/0x130\n[    9.317205]  ret_from_fork+0x22/0x30\n[    9.317208]  </TASK>\n\n[ rjw: Subject and changelog edits ]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9edf20e5a1d805855e78f241cf221d741b50d482",
      "https://git.kernel.org/stable/c/c50ec15725e005e9fb20bce69b6c23b135a4a9b7",
      "https://git.kernel.org/stable/c/4c10c854113720cbfe75d4f51db79b700a629e73",
      "https://git.kernel.org/stable/c/43d2748394c3feb86c0c771466f5847e274fc043"
    ],
    "受影响版本": [
      "fb7be08f1a091ec243780bfdad4bf0c492057808",
      "fb7be08f1a091ec243780bfdad4bf0c492057808",
      "fb7be08f1a091ec243780bfdad4bf0c492057808",
      "fb7be08f1a091ec243780bfdad4bf0c492057808"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49880",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix warning in 'ext4_da_release_space'\n\nSyzkaller report issue as follows:\nEXT4-fs (loop0): Free/Dirty block details\nEXT4-fs (loop0): free_blocks=0\nEXT4-fs (loop0): dirty_blocks=0\nEXT4-fs (loop0): Block reservation details\nEXT4-fs (loop0): i_reserved_data_blocks=0\nEXT4-fs warning (device loop0): ext4_da_release_space:1527: ext4_da_release_space: ino 18, to_free 1 with only 0 reserved data blocks\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 92 at fs/ext4/inode.c:1528 ext4_da_release_space+0x25e/0x370 fs/ext4/inode.c:1524\nModules linked in:\nCPU: 0 PID: 92 Comm: kworker/u4:4 Not tainted 6.0.0-syzkaller-09423-g493ffd6605b2 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/22/2022\nWorkqueue: writeback wb_workfn (flush-7:0)\nRIP: 0010:ext4_da_release_space+0x25e/0x370 fs/ext4/inode.c:1528\nRSP: 0018:ffffc900015f6c90 EFLAGS: 00010296\nRAX: 42215896cd52ea00 RBX: 0000000000000000 RCX: 42215896cd52ea00\nRDX: 0000000000000000 RSI: 0000000080000001 RDI: 0000000000000000\nRBP: 1ffff1100e907d96 R08: ffffffff816aa79d R09: fffff520002bece5\nR10: fffff520002bece5 R11: 1ffff920002bece4 R12: ffff888021fd2000\nR13: ffff88807483ecb0 R14: 0000000000000001 R15: ffff88807483e740\nFS:  0000000000000000(0000) GS:ffff8880b9a00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00005555569ba628 CR3: 000000000c88e000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n ext4_es_remove_extent+0x1ab/0x260 fs/ext4/extents_status.c:1461\n mpage_release_unused_pages+0x24d/0xef0 fs/ext4/inode.c:1589\n ext4_writepages+0x12eb/0x3be0 fs/ext4/inode.c:2852\n do_writepages+0x3c3/0x680 mm/page-writeback.c:2469\n __writeback_single_inode+0xd1/0x670 fs/fs-writeback.c:1587\n writeback_sb_inodes+0xb3b/0x18f0 fs/fs-writeback.c:1870\n wb_writeback+0x41f/0x7b0 fs/fs-writeback.c:2044\n wb_do_writeback fs/fs-writeback.c:2187 [inline]\n wb_workfn+0x3cb/0xef0 fs/fs-writeback.c:2227\n process_one_work+0x877/0xdb0 kernel/workqueue.c:2289\n worker_thread+0xb14/0x1330 kernel/workqueue.c:2436\n kthread+0x266/0x300 kernel/kthread.c:376\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:306\n </TASK>\n\nAbove issue may happens as follows:\next4_da_write_begin\n  ext4_create_inline_data\n    ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);\n    ext4_set_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n__ext4_ioctl\n  ext4_ext_migrate -> will lead to eh->eh_entries not zero, and set extent flag\next4_da_write_begin\n  ext4_da_convert_inline_data_to_extent\n    ext4_da_write_inline_data_begin\n      ext4_da_map_blocks\n        ext4_insert_delayed_block\n\t  if (!ext4_es_scan_clu(inode, &ext4_es_is_delonly, lblk))\n\t    if (!ext4_es_scan_clu(inode, &ext4_es_is_mapped, lblk))\n\t      ext4_clu_mapped(inode, EXT4_B2C(sbi, lblk)); -> will return 1\n\t       allocated = true;\n          ext4_es_insert_delayed_block(inode, lblk, allocated);\next4_writepages\n  mpage_map_and_submit_extent(handle, &mpd, &give_up_on_write); -> return -ENOSPC\n  mpage_release_unused_pages(&mpd, give_up_on_write); -> give_up_on_write == 1\n    ext4_es_remove_extent\n      ext4_da_release_space(inode, reserved);\n        if (unlikely(to_free > ei->i_reserved_data_blocks))\n\t  -> to_free == 1  but ei->i_reserved_data_blocks == 0\n\t  -> then trigger warning as above\n\nTo solve above issue, forbid inode do migrate which has inline data.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0de5ee103747fd3a24f1c010c79caabe35e8f0bb",
      "https://git.kernel.org/stable/c/c3bf1e95cfa7d950dc3c064d0c2e3d06b427bc63",
      "https://git.kernel.org/stable/c/890d738f569fa9412b70ba09f15407f17a52da20",
      "https://git.kernel.org/stable/c/72743d5598b9096950bbfd6a9b7f173d156eea97",
      "https://git.kernel.org/stable/c/5370b965b7a945bb8f48b9ee23d83a76a947902e",
      "https://git.kernel.org/stable/c/0a43c015e98121c91a76154edf42280ce1a8a883",
      "https://git.kernel.org/stable/c/89bee03d2fb8c54119b38ac6c24e7d60fae036b6",
      "https://git.kernel.org/stable/c/1b8f787ef547230a3249bcf897221ef0cc78481b"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49879",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix BUG_ON() when directory entry has invalid rec_len\n\nThe rec_len field in the directory entry has to be a multiple of 4.  A\ncorrupted filesystem image can be used to hit a BUG() in\next4_rec_len_to_disk(), called from make_indexed_dir().\n\n ------------[ cut here ]------------\n kernel BUG at fs/ext4/ext4.h:2413!\n ...\n RIP: 0010:make_indexed_dir+0x53f/0x5f0\n ...\n Call Trace:\n  <TASK>\n  ? add_dirent_to_buf+0x1b2/0x200\n  ext4_add_entry+0x36e/0x480\n  ext4_add_nondir+0x2b/0xc0\n  ext4_create+0x163/0x200\n  path_openat+0x635/0xe90\n  do_filp_open+0xb4/0x160\n  ? __create_object.isra.0+0x1de/0x3b0\n  ? _raw_spin_unlock+0x12/0x30\n  do_sys_openat2+0x91/0x150\n  __x64_sys_open+0x6c/0xa0\n  do_syscall_64+0x3c/0x80\n  entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThe fix simply adds a call to ext4_check_dir_entry() to validate the\ndirectory entry, returning -EFSCORRUPTED if the entry is invalid.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2fa24d0274fbf913b56ee31f15bc01168669d909",
      "https://git.kernel.org/stable/c/156451a67b93986fb07c274ef6995ff40766c5ad",
      "https://git.kernel.org/stable/c/999cff2b6ce3b45c08abf793bf55534777421327",
      "https://git.kernel.org/stable/c/ce1ee2c8827fb6493e91acbd50f664cf2a972c3d",
      "https://git.kernel.org/stable/c/17a0bc9bd697f75cfdf9b378d5eb2d7409c91340"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49850",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix deadlock in nilfs_count_free_blocks()\n\nA semaphore deadlock can occur if nilfs_get_block() detects metadata\ncorruption while locating data blocks and a superblock writeback occurs at\nthe same time:\n\ntask 1                               task 2\n------                               ------\n* A file operation *\nnilfs_truncate()\n  nilfs_get_block()\n    down_read(rwsem A) <--\n    nilfs_bmap_lookup_contig()\n      ...                            generic_shutdown_super()\n                                       nilfs_put_super()\n                                         * Prepare to write superblock *\n                                         down_write(rwsem B) <--\n                                         nilfs_cleanup_super()\n      * Detect b-tree corruption *         nilfs_set_log_cursor()\n      nilfs_bmap_convert_error()             nilfs_count_free_blocks()\n        __nilfs_error()                        down_read(rwsem A) <--\n          nilfs_set_error()\n            down_write(rwsem B) <--\n\n                           *** DEADLOCK ***\n\nHere, nilfs_get_block() readlocks rwsem A (= NILFS_MDT(dat_inode)->mi_sem)\nand then calls nilfs_bmap_lookup_contig(), but if it fails due to metadata\ncorruption, __nilfs_error() is called from nilfs_bmap_convert_error()\ninside the lock section.\n\nSince __nilfs_error() calls nilfs_set_error() unless the filesystem is\nread-only and nilfs_set_error() attempts to writelock rwsem B (=\nnilfs->ns_sem) to write back superblock exclusively, hierarchical lock\nacquisition occurs in the order rwsem A -> rwsem B.\n\nNow, if another task starts updating the superblock, it may writelock\nrwsem B during the lock sequence above, and can deadlock trying to\nreadlock rwsem A in nilfs_count_free_blocks().\n\nHowever, there is actually no need to take rwsem A in\nnilfs_count_free_blocks() because it, within the lock section, only reads\na single integer data on a shared struct with\nnilfs_sufile_get_ncleansegs().  This has been the case after commit\naa474a220180 (\"nilfs2: add local variable to cache the number of clean\nsegments\"), that is, even before this bug was introduced.\n\nSo, this resolves the deadlock problem by just not taking the semaphore in\nnilfs_count_free_blocks().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3c89ca6d3dfa6c09c515807a7a97a521f5d5147e",
      "https://git.kernel.org/stable/c/8b4506cff6630bb474bb46a2a75c31e533a756ba",
      "https://git.kernel.org/stable/c/f0cc93080d4c09510b74ecba87fd778cca390bb1",
      "https://git.kernel.org/stable/c/36ff974b0310771417c0be64b64aa221bd70d63d",
      "https://git.kernel.org/stable/c/1d4ff73062096c21b47954d2996b4df259777bda",
      "https://git.kernel.org/stable/c/abc082aac0d9b6b926038fc3adb7008306581be2",
      "https://git.kernel.org/stable/c/cb029b54953420f7a2d65100f1c5107f14411bdc",
      "https://git.kernel.org/stable/c/8ac932a4921a96ca52f61935dbba64ea87bbd5dc"
    ],
    "受影响版本": [
      "e828949e5b42bfd234ee537cdb7c5e3a577958a3",
      "e828949e5b42bfd234ee537cdb7c5e3a577958a3",
      "e828949e5b42bfd234ee537cdb7c5e3a577958a3",
      "e828949e5b42bfd234ee537cdb7c5e3a577958a3",
      "e828949e5b42bfd234ee537cdb7c5e3a577958a3",
      "e828949e5b42bfd234ee537cdb7c5e3a577958a3",
      "e828949e5b42bfd234ee537cdb7c5e3a577958a3",
      "e828949e5b42bfd234ee537cdb7c5e3a577958a3"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49841",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nserial: imx: Add missing .thaw_noirq hook\n\nThe following warning is seen with non-console UART instance when\nsystem hibernates.\n\n[   37.371969] ------------[ cut here ]------------\n[   37.376599] uart3_root_clk already disabled\n[   37.380810] WARNING: CPU: 0 PID: 296 at drivers/clk/clk.c:952 clk_core_disable+0xa4/0xb0\n...\n[   37.506986] Call trace:\n[   37.509432]  clk_core_disable+0xa4/0xb0\n[   37.513270]  clk_disable+0x34/0x50\n[   37.516672]  imx_uart_thaw+0x38/0x5c\n[   37.520250]  platform_pm_thaw+0x30/0x6c\n[   37.524089]  dpm_run_callback.constprop.0+0x3c/0xd4\n[   37.528972]  device_resume+0x7c/0x160\n[   37.532633]  dpm_resume+0xe8/0x230\n[   37.536036]  hibernation_snapshot+0x288/0x430\n[   37.540397]  hibernate+0x10c/0x2e0\n[   37.543798]  state_store+0xc4/0xd0\n[   37.547203]  kobj_attr_store+0x1c/0x30\n[   37.550953]  sysfs_kf_write+0x48/0x60\n[   37.554619]  kernfs_fop_write_iter+0x118/0x1ac\n[   37.559063]  new_sync_write+0xe8/0x184\n[   37.562812]  vfs_write+0x230/0x290\n[   37.566214]  ksys_write+0x68/0xf4\n[   37.569529]  __arm64_sys_write+0x20/0x2c\n[   37.573452]  invoke_syscall.constprop.0+0x50/0xf0\n[   37.578156]  do_el0_svc+0x11c/0x150\n[   37.581648]  el0_svc+0x30/0x140\n[   37.584792]  el0t_64_sync_handler+0xe8/0xf0\n[   37.588976]  el0t_64_sync+0x1a0/0x1a4\n[   37.592639] ---[ end trace 56e22eec54676d75 ]---\n\nOn hibernating, pm core calls into related hooks in sequence like:\n\n    .freeze\n    .freeze_noirq\n    .thaw_noirq\n    .thaw\n\nWith .thaw_noirq hook being absent, the clock will be disabled in a\nunbalanced call which results the warning above.\n\n    imx_uart_freeze()\n        clk_prepare_enable()\n    imx_uart_suspend_noirq()\n        clk_disable()\n    imx_uart_thaw\n        clk_disable_unprepare()\n\nAdding the missing .thaw_noirq hook as imx_uart_resume_noirq() will have\nthe call sequence corrected as below and thus fix the warning.\n\n    imx_uart_freeze()\n        clk_prepare_enable()\n    imx_uart_suspend_noirq()\n        clk_disable()\n    imx_uart_resume_noirq()\n        clk_enable()\n    imx_uart_thaw\n        clk_disable_unprepare()",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e401312ca6e180ee1bd65f6a766e99dd40aa95e7",
      "https://git.kernel.org/stable/c/476b09e07bd519ec7ba5941a6a6f9a02256dbb21",
      "https://git.kernel.org/stable/c/0a3160f4ffc70ee4bfa1521f698dace06e6091fd",
      "https://git.kernel.org/stable/c/ae22294e213a402a70fa1731538367d1b758ffe7",
      "https://git.kernel.org/stable/c/e3f9d87d6f0732827c443bd1474df21c2fad704b",
      "https://git.kernel.org/stable/c/4561d8008a467cb05ac632a215391d6b787f40aa"
    ],
    "受影响版本": [
      "09df0b3464e528c6a4ca2c48d9ff6d2fd7cbd775",
      "09df0b3464e528c6a4ca2c48d9ff6d2fd7cbd775",
      "09df0b3464e528c6a4ca2c48d9ff6d2fd7cbd775",
      "09df0b3464e528c6a4ca2c48d9ff6d2fd7cbd775",
      "09df0b3464e528c6a4ca2c48d9ff6d2fd7cbd775",
      "09df0b3464e528c6a4ca2c48d9ff6d2fd7cbd775"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49837",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix memory leaks in __check_func_call\n\nkmemleak reports this issue:\n\nunreferenced object 0xffff88817139d000 (size 2048):\n  comm \"test_progs\", pid 33246, jiffies 4307381979 (age 45851.820s)\n  hex dump (first 32 bytes):\n    01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [<0000000045f075f0>] kmalloc_trace+0x27/0xa0\n    [<0000000098b7c90a>] __check_func_call+0x316/0x1230\n    [<00000000b4c3c403>] check_helper_call+0x172e/0x4700\n    [<00000000aa3875b7>] do_check+0x21d8/0x45e0\n    [<000000001147357b>] do_check_common+0x767/0xaf0\n    [<00000000b5a595b4>] bpf_check+0x43e3/0x5bc0\n    [<0000000011e391b1>] bpf_prog_load+0xf26/0x1940\n    [<0000000007f765c0>] __sys_bpf+0xd2c/0x3650\n    [<00000000839815d6>] __x64_sys_bpf+0x75/0xc0\n    [<00000000946ee250>] do_syscall_64+0x3b/0x90\n    [<0000000000506b7f>] entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe root case here is: In function prepare_func_exit(), the callee is\nnot released in the abnormal scenario after \"state->curframe--;\". To\nfix, move \"state->curframe--;\" to the very bottom of the function,\nright when we free callee and reset frame[] pointer to NULL, as Andrii\nsuggested.\n\nIn addition, function __check_func_call() has a similar problem. In\nthe abnormal scenario before \"state->curframe++;\", the callee also\nshould be released by free_func_state().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d4944497827a3d14bc5a26dbcfb7433eb5a956c0",
      "https://git.kernel.org/stable/c/83946d772e756734a900ef99dbe0aeda506adf37",
      "https://git.kernel.org/stable/c/eb86559a691cea5fa63e57a03ec3dc9c31e97955"
    ],
    "受影响版本": [
      "fd978bf7fd312581a7ca454a991f0ffb34c4204b",
      "fd978bf7fd312581a7ca454a991f0ffb34c4204b",
      "fd978bf7fd312581a7ca454a991f0ffb34c4204b"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49832",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npinctrl: devicetree: fix null pointer dereferencing in pinctrl_dt_to_map\n\nHere is the BUG report by KASAN about null pointer dereference:\n\nBUG: KASAN: null-ptr-deref in strcmp+0x2e/0x50\nRead of size 1 at addr 0000000000000000 by task python3/2640\nCall Trace:\n strcmp\n __of_find_property\n of_find_property\n pinctrl_dt_to_map\n\nkasprintf() would return NULL pointer when kmalloc() fail to allocate.\nSo directly return ENOMEM, if kasprintf() return NULL pointer.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/aaf552c5d53abe4659176e099575fe870d2e4768",
      "https://git.kernel.org/stable/c/b4d9f55cd38435358bc16d580612bc0d798d7b4c",
      "https://git.kernel.org/stable/c/a988dcd3dd9e691c5ccc3324b209688f3b5453e9",
      "https://git.kernel.org/stable/c/040f726fecd88121f3b95e70369785ad452dddf9",
      "https://git.kernel.org/stable/c/777430aa4ddccaa5accec6db90ffc1d47f00d471",
      "https://git.kernel.org/stable/c/97e5b508e96176f1a73888ed89df396d7041bfcb",
      "https://git.kernel.org/stable/c/5834a3a98cd266ad35a229923c0adbd0addc8d68",
      "https://git.kernel.org/stable/c/91d5c5060ee24fe8da88cd585bb43b843d2f0dce"
    ],
    "受影响版本": [
      "57291ce295c0aca738dd284c4a9c591c09ebee71",
      "57291ce295c0aca738dd284c4a9c591c09ebee71",
      "57291ce295c0aca738dd284c4a9c591c09ebee71",
      "57291ce295c0aca738dd284c4a9c591c09ebee71",
      "57291ce295c0aca738dd284c4a9c591c09ebee71",
      "57291ce295c0aca738dd284c4a9c591c09ebee71",
      "57291ce295c0aca738dd284c4a9c591c09ebee71",
      "57291ce295c0aca738dd284c4a9c591c09ebee71"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49808",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: don't leak tagger-owned storage on switch driver unbind\n\nIn the initial commit dc452a471dba (\"net: dsa: introduce tagger-owned\nstorage for private and shared data\"), we had a call to\ntag_ops->disconnect(dst) issued from dsa_tree_free(), which is called at\ntree teardown time.\n\nThere were problems with connecting to a switch tree as a whole, so this\ngot reworked to connecting to individual switches within the tree. In\nthis process, tag_ops->disconnect(ds) was made to be called only from\nswitch.c (cross-chip notifiers emitted as a result of dynamic tag proto\nchanges), but the normal driver teardown code path wasn't replaced with\nanything.\n\nSolve this problem by adding a function that does the opposite of\ndsa_switch_setup_tag_protocol(), which is called from the equivalent\nspot in dsa_switch_teardown(). The positioning here also ensures that we\nwon't have any use-after-free in tagging protocol (*rcv) ops, since the\nteardown sequence is as follows:\n\ndsa_tree_teardown\n-> dsa_tree_teardown_master\n   -> dsa_master_teardown\n      -> unsets master->dsa_ptr, making no further packets match the\n         ETH_P_XDSA packet type handler\n-> dsa_tree_teardown_ports\n   -> dsa_port_teardown\n      -> dsa_slave_destroy\n         -> unregisters DSA net devices, there is even a synchronize_net()\n            in unregister_netdevice_many()\n-> dsa_tree_teardown_switches\n   -> dsa_switch_teardown\n      -> dsa_switch_teardown_tag_protocol\n         -> finally frees the tagger-owned storage",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5809fb03942dbac25144db5bebea84fa003ecaca",
      "https://git.kernel.org/stable/c/4e0c19fcb8b5323716140fa82b79aa9f60e60407"
    ],
    "受影响版本": [
      "7f2973149c22e7a6fee4c0c9fa6b8e4108e9c208",
      "7f2973149c22e7a6fee4c0c9fa6b8e4108e9c208"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49806",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: microchip: sparx5: Fix potential null-ptr-deref in sparx_stats_init() and sparx5_start()\n\nsparx_stats_init() calls create_singlethread_workqueue() and not\nchecked the ret value, which may return NULL. And a null-ptr-deref may\nhappen:\n\nsparx_stats_init()\n    create_singlethread_workqueue() # failed, sparx5->stats_queue is NULL\n    queue_delayed_work()\n        queue_delayed_work_on()\n            __queue_delayed_work()  # warning here, but continue\n                __queue_work()      # access wq->flags, null-ptr-deref\n\nCheck the ret value and return -ENOMEM if it is NULL. So as\nsparx5_start().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/80e590aeb132887102c3fa79d99b338f099dc952",
      "https://git.kernel.org/stable/c/456327e565dc49d18b2f595f39f47df8a36f1057",
      "https://git.kernel.org/stable/c/639f5d006e36bb303f525d9479448c412b720c39"
    ],
    "受影响版本": [
      "b37a1bae742f92cc9b1f777d54e04ee3d86bbfc2",
      "b37a1bae742f92cc9b1f777d54e04ee3d86bbfc2",
      "b37a1bae742f92cc9b1f777d54e04ee3d86bbfc2"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49805",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: lan966x: Fix potential null-ptr-deref in lan966x_stats_init()\n\nlan966x_stats_init() calls create_singlethread_workqueue() and not\nchecked the ret value, which may return NULL. And a null-ptr-deref may\nhappen:\n\nlan966x_stats_init()\n    create_singlethread_workqueue() # failed, lan966x->stats_queue is NULL\n    queue_delayed_work()\n        queue_delayed_work_on()\n            __queue_delayed_work()  # warning here, but continue\n                __queue_work()      # access wq->flags, null-ptr-deref\n\nCheck the ret value and return -ENOMEM if it is NULL.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4a43c1c6040e848e1344c7b16ac696b68fbc439c",
      "https://git.kernel.org/stable/c/ba86af3733aece88dbcee0dfebf7e2dcfefb2be4"
    ],
    "受影响版本": [
      "12c2d0a5b8e2a1afc8c7738e19a0d1dd7f3d4007",
      "12c2d0a5b8e2a1afc8c7738e19a0d1dd7f3d4007"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49789",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: zfcp: Fix double free of FSF request when qdio send fails\n\nWe used to use the wrong type of integer in 'zfcp_fsf_req_send()' to cache\nthe FSF request ID when sending a new FSF request. This is used in case the\nsending fails and we need to remove the request from our internal hash\ntable again (so we don't keep an invalid reference and use it when we free\nthe request again).\n\nIn 'zfcp_fsf_req_send()' we used to cache the ID as 'int' (signed and 32\nbit wide), but the rest of the zfcp code (and the firmware specification)\nhandles the ID as 'unsigned long'/'u64' (unsigned and 64 bit wide [s390x\nELF ABI]).  For one this has the obvious problem that when the ID grows\npast 32 bit (this can happen reasonably fast) it is truncated to 32 bit\nwhen storing it in the cache variable and so doesn't match the original ID\nanymore.  The second less obvious problem is that even when the original ID\nhas not yet grown past 32 bit, as soon as the 32nd bit is set in the\noriginal ID (0x80000000 = 2'147'483'648) we will have a mismatch when we\ncast it back to 'unsigned long'. As the cached variable is of a signed\ntype, the compiler will choose a sign-extending instruction to load the 32\nbit variable into a 64 bit register (e.g.: 'lgf %r11,188(%r15)'). So once\nwe pass the cached variable into 'zfcp_reqlist_find_rm()' to remove the\nrequest again all the leading zeros will be flipped to ones to extend the\nsign and won't match the original ID anymore (this has been observed in\npractice).\n\nIf we can't successfully remove the request from the hash table again after\n'zfcp_qdio_send()' fails (this happens regularly when zfcp cannot notify\nthe adapter about new work because the adapter is already gone during\ne.g. a ChpID toggle) we will end up with a double free.  We unconditionally\nfree the request in the calling function when 'zfcp_fsf_req_send()' fails,\nbut because the request is still in the hash table we end up with a stale\nmemory reference, and once the zfcp adapter is either reset during recovery\nor shutdown we end up freeing the same memory twice.\n\nThe resulting stack traces vary depending on the kernel and have no direct\ncorrelation to the place where the bug occurs. Here are three examples that\nhave been seen in practice:\n\n  list_del corruption. next->prev should be 00000001b9d13800, but was 00000000dead4ead. (next=00000001bd131a00)\n  ------------[ cut here ]------------\n  kernel BUG at lib/list_debug.c:62!\n  monitor event: 0040 ilc:2 [#1] PREEMPT SMP\n  Modules linked in: ...\n  CPU: 9 PID: 1617 Comm: zfcperp0.0.1740 Kdump: loaded\n  Hardware name: ...\n  Krnl PSW : 0704d00180000000 00000003cbeea1f8 (__list_del_entry_valid+0x98/0x140)\n             R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:1 PM:0 RI:0 EA:3\n  Krnl GPRS: 00000000916d12f1 0000000080000000 000000000000006d 00000003cb665cd6\n             0000000000000001 0000000000000000 0000000000000000 00000000d28d21e8\n             00000000d3844000 00000380099efd28 00000001bd131a00 00000001b9d13800\n             00000000d3290100 0000000000000000 00000003cbeea1f4 00000380099efc70\n  Krnl Code: 00000003cbeea1e8: c020004f68a7        larl    %r2,00000003cc8d7336\n             00000003cbeea1ee: c0e50027fd65        brasl   %r14,00000003cc3e9cb8\n            #00000003cbeea1f4: af000000            mc      0,0\n            >00000003cbeea1f8: c02000920440        larl    %r2,00000003cd12aa78\n             00000003cbeea1fe: c0e500289c25        brasl   %r14,00000003cc3fda48\n             00000003cbeea204: b9040043            lgr     %r4,%r3\n             00000003cbeea208: b9040051            lgr     %r5,%r1\n             00000003cbeea20c: b9040032            lgr     %r3,%r2\n  Call Trace:\n   [<00000003cbeea1f8>] __list_del_entry_valid+0x98/0x140\n  ([<00000003cbeea1f4>] __list_del_entry_valid+0x94/0x140)\n   [<000003ff7ff502fe>] zfcp_fsf_req_dismiss_all+0xde/0x150 [zfcp]\n   [<000003ff7ff49cd0>] zfcp_erp_strategy_do_action+0x160/0x280 [zfcp]\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1bf8ed585501bb2dd0b5f67c824eab45adfbdccd",
      "https://git.kernel.org/stable/c/d2c7d8f58e9cde8ac8d1f75e9d66c2a813ffe0ab",
      "https://git.kernel.org/stable/c/11edbdee4399401f533adda9bffe94567aa08b96",
      "https://git.kernel.org/stable/c/90a49a6b015fa439cd62e45121390284c125a91f",
      "https://git.kernel.org/stable/c/0954256e970ecf371b03a6c9af2cf91b9c4085ff"
    ],
    "受影响版本": [
      "e60a6d69f1f84c2ef1cc63aefaadfe7ae9f12934",
      "e60a6d69f1f84c2ef1cc63aefaadfe7ae9f12934",
      "e60a6d69f1f84c2ef1cc63aefaadfe7ae9f12934",
      "e60a6d69f1f84c2ef1cc63aefaadfe7ae9f12934",
      "e60a6d69f1f84c2ef1cc63aefaadfe7ae9f12934"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49778",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64/mm: fix incorrect file_map_count for non-leaf pmd/pud\n\nThe page table check trigger BUG_ON() unexpectedly when collapse hugepage:\n\n ------------[ cut here ]------------\n kernel BUG at mm/page_table_check.c:82!\n Internal error: Oops - BUG: 00000000f2000800 [#1] SMP\n Dumping ftrace buffer:\n    (ftrace buffer empty)\n Modules linked in:\n CPU: 6 PID: 68 Comm: khugepaged Not tainted 6.1.0-rc3+ #750\n Hardware name: linux,dummy-virt (DT)\n pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : page_table_check_clear.isra.0+0x258/0x3f0\n lr : page_table_check_clear.isra.0+0x240/0x3f0\n[...]\n Call trace:\n  page_table_check_clear.isra.0+0x258/0x3f0\n  __page_table_check_pmd_clear+0xbc/0x108\n  pmdp_collapse_flush+0xb0/0x160\n  collapse_huge_page+0xa08/0x1080\n  hpage_collapse_scan_pmd+0xf30/0x1590\n  khugepaged_scan_mm_slot.constprop.0+0x52c/0xac8\n  khugepaged+0x338/0x518\n  kthread+0x278/0x2f8\n  ret_from_fork+0x10/0x20\n[...]\n\nSince pmd_user_accessible_page() doesn't check if a pmd is leaf, it\ndecrease file_map_count for a non-leaf pmd comes from collapse_huge_page().\nand so trigger BUG_ON() unexpectedly.\n\nFix this problem by using pmd_leaf() insteal of pmd_present() in\npmd_user_accessible_page(). Moreover, use pud_leaf() for\npud_user_accessible_page() too.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2d458046df634088611d44fd77f45465e833ef78",
      "https://git.kernel.org/stable/c/5b47348fc0b18a78c96f8474cc90b7525ad1bbfe"
    ],
    "受影响版本": [
      "42b2547137f5c974bb1bfd657c869fe96b96d86f",
      "42b2547137f5c974bb1bfd657c869fe96b96d86f"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49768",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\n9p: trans_fd/p9_conn_cancel: drop client lock earlier\n\nsyzbot reported a double-lock here and we no longer need this\nlock after requests have been moved off to local list:\njust drop the lock earlier.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/82825dbf393f7c7979d462f9609a15bde8092b3f",
      "https://git.kernel.org/stable/c/e3031280fe4eaf61a09e60823331f81f321be8e1",
      "https://git.kernel.org/stable/c/fec1406f5e7ab20b71f6d231792b0040e3300aaf",
      "https://git.kernel.org/stable/c/96760723aae1b45f733f702abb4333137143909f",
      "https://git.kernel.org/stable/c/f14858bc77c567e089965962877ee726ffad0556",
      "https://git.kernel.org/stable/c/a4f1a01b2e81378fce9ca528d4d8a049e4b58fcd",
      "https://git.kernel.org/stable/c/612c977f5d481f551d03d83d0aef588845c1300c",
      "https://git.kernel.org/stable/c/52f1c45dde9136f964d63a77d19826c8a74e2c7f"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年05月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49760",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/hugetlb: fix PTE marker handling in hugetlb_change_protection()\n\nPatch series \"mm/hugetlb: uffd-wp fixes for hugetlb_change_protection()\".\n\nPlaying with virtio-mem and background snapshots (using uffd-wp) on\nhugetlb in QEMU, I managed to trigger a VM_BUG_ON().  Looking into the\ndetails, hugetlb_change_protection() seems to not handle uffd-wp correctly\nin all cases.\n\nPatch #1 fixes my test case.  I don't have reproducers for patch #2, as it\nrequires running into migration entries.\n\nI did not yet check in detail yet if !hugetlb code requires similar care.\n\n\nThis patch (of 2):\n\nThere are two problematic cases when stumbling over a PTE marker in\nhugetlb_change_protection():\n\n(1) We protect an uffd-wp PTE marker a second time using uffd-wp: we will\n    end up in the \"!huge_pte_none(pte)\" case and mess up the PTE marker.\n\n(2) We unprotect a uffd-wp PTE marker: we will similarly end up in the\n    \"!huge_pte_none(pte)\" case even though we cleared the PTE, because\n    the \"pte\" variable is stale. We'll mess up the PTE marker.\n\nFor example, if we later stumble over such a \"wrongly modified\" PTE marker,\nwe'll treat it like a present PTE that maps some garbage page.\n\nThis can, for example, be triggered by mapping a memfd backed by huge\npages, registering uffd-wp, uffd-wp'ing an unmapped page and (a)\nuffd-wp'ing it a second time; or (b) uffd-unprotecting it; or (c)\nunregistering uffd-wp. Then, ff we trigger fallocate(FALLOC_FL_PUNCH_HOLE)\non that file range, we will run into a VM_BUG_ON:\n\n[  195.039560] page:00000000ba1f2987 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x0\n[  195.039565] flags: 0x7ffffc0001000(reserved|node=0|zone=0|lastcpupid=0x1fffff)\n[  195.039568] raw: 0007ffffc0001000 ffffe742c0000008 ffffe742c0000008 0000000000000000\n[  195.039569] raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000\n[  195.039569] page dumped because: VM_BUG_ON_PAGE(compound && !PageHead(page))\n[  195.039573] ------------[ cut here ]------------\n[  195.039574] kernel BUG at mm/rmap.c:1346!\n[  195.039579] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n[  195.039581] CPU: 7 PID: 4777 Comm: qemu-system-x86 Not tainted 6.0.12-200.fc36.x86_64 #1\n[  195.039583] Hardware name: LENOVO 20WNS1F81N/20WNS1F81N, BIOS N35ET50W (1.50 ) 09/15/2022\n[  195.039584] RIP: 0010:page_remove_rmap+0x45b/0x550\n[  195.039588] Code: [...]\n[  195.039589] RSP: 0018:ffffbc03c3633ba8 EFLAGS: 00010292\n[  195.039591] RAX: 0000000000000040 RBX: ffffe742c0000000 RCX: 0000000000000000\n[  195.039592] RDX: 0000000000000002 RSI: ffffffff8e7aac1a RDI: 00000000ffffffff\n[  195.039592] RBP: 0000000000000001 R08: 0000000000000000 R09: ffffbc03c3633a08\n[  195.039593] R10: 0000000000000003 R11: ffffffff8f146328 R12: ffff9b04c42754b0\n[  195.039594] R13: ffffffff8fcc6328 R14: ffffbc03c3633c80 R15: ffff9b0484ab9100\n[  195.039595] FS:  00007fc7aaf68640(0000) GS:ffff9b0bbf7c0000(0000) knlGS:0000000000000000\n[  195.039596] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  195.039597] CR2: 000055d402c49110 CR3: 0000000159392003 CR4: 0000000000772ee0\n[  195.039598] PKRU: 55555554\n[  195.039599] Call Trace:\n[  195.039600]  <TASK>\n[  195.039602]  __unmap_hugepage_range+0x33b/0x7d0\n[  195.039605]  unmap_hugepage_range+0x55/0x70\n[  195.039608]  hugetlb_vmdelete_list+0x77/0xa0\n[  195.039611]  hugetlbfs_fallocate+0x410/0x550\n[  195.039612]  ? _raw_spin_unlock_irqrestore+0x23/0x40\n[  195.039616]  vfs_fallocate+0x12e/0x360\n[  195.039618]  __x64_sys_fallocate+0x40/0x70\n[  195.039620]  do_syscall_64+0x58/0x80\n[  195.039623]  ? syscall_exit_to_user_mode+0x17/0x40\n[  195.039624]  ? do_syscall_64+0x67/0x80\n[  195.039626]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[  195.039628] RIP: 0033:0x7fc7b590651f\n[  195.039653] Code: [...]\n[  195.039654] RSP: 002b:00007fc7aaf66e70 EFLAGS: 00000293 ORIG_RAX: 000000000000011d\n[  195.039655] RAX: ffffffffffffffda RBX: 0000558ef4b7f370 RCX: 00007fc7b590651f\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6062c992e912df1eedad52cf64efb3d48e8d35c5",
      "https://git.kernel.org/stable/c/0e678153f5be7e6c8d28835f5a678618da4b7a9c"
    ],
    "受影响版本": [
      "60dfaad65aa97fb6755b9798a6b3c9e79bcd5930",
      "60dfaad65aa97fb6755b9798a6b3c9e79bcd5930"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49753",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: Fix double increment of client_count in dma_chan_get()\n\nThe first time dma_chan_get() is called for a channel the channel\nclient_count is incorrectly incremented twice for public channels,\nfirst in balance_ref_count(), and again prior to returning. This\nresults in an incorrect client count which will lead to the\nchannel resources not being freed when they should be. A simple\n test of repeated module load and unload of async_tx on a Dell\n Power Edge R7425 also shows this resulting in a kref underflow\n warning.\n\n[  124.329662] async_tx: api initialized (async)\n[  129.000627] async_tx: api initialized (async)\n[  130.047839] ------------[ cut here ]------------\n[  130.052472] refcount_t: underflow; use-after-free.\n[  130.057279] WARNING: CPU: 3 PID: 19364 at lib/refcount.c:28\nrefcount_warn_saturate+0xba/0x110\n[  130.065811] Modules linked in: async_tx(-) rfkill intel_rapl_msr\nintel_rapl_common amd64_edac edac_mce_amd ipmi_ssif kvm_amd dcdbas kvm\nmgag200 drm_shmem_helper acpi_ipmi irqbypass drm_kms_helper ipmi_si\nsyscopyarea sysfillrect rapl pcspkr ipmi_devintf sysimgblt fb_sys_fops\nk10temp i2c_piix4 ipmi_msghandler acpi_power_meter acpi_cpufreq vfat\nfat drm fuse xfs libcrc32c sd_mod t10_pi sg ahci crct10dif_pclmul\nlibahci crc32_pclmul crc32c_intel ghash_clmulni_intel igb megaraid_sas\ni40e libata i2c_algo_bit ccp sp5100_tco dca dm_mirror dm_region_hash\ndm_log dm_mod [last unloaded: async_tx]\n[  130.117361] CPU: 3 PID: 19364 Comm: modprobe Kdump: loaded Not\ntainted 5.14.0-185.el9.x86_64 #1\n[  130.126091] Hardware name: Dell Inc. PowerEdge R7425/02MJ3T, BIOS\n1.18.0 01/17/2022\n[  130.133806] RIP: 0010:refcount_warn_saturate+0xba/0x110\n[  130.139041] Code: 01 01 e8 6d bd 55 00 0f 0b e9 72 9d 8a 00 80 3d\n26 18 9c 01 00 75 85 48 c7 c7 f8 a3 03 9d c6 05 16 18 9c 01 01 e8 4a\nbd 55 00 <0f> 0b e9 4f 9d 8a 00 80 3d 01 18 9c 01 00 0f 85 5e ff ff ff\n48 c7\n[  130.157807] RSP: 0018:ffffbf98898afe68 EFLAGS: 00010286\n[  130.163036] RAX: 0000000000000000 RBX: ffff9da06028e598 RCX: 0000000000000000\n[  130.170172] RDX: ffff9daf9de26480 RSI: ffff9daf9de198a0 RDI: ffff9daf9de198a0\n[  130.177316] RBP: ffff9da7cddf3970 R08: 0000000000000000 R09: 00000000ffff7fff\n[  130.184459] R10: ffffbf98898afd00 R11: ffffffff9d9e8c28 R12: ffff9da7cddf1970\n[  130.191596] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n[  130.198739] FS:  00007f646435c740(0000) GS:ffff9daf9de00000(0000)\nknlGS:0000000000000000\n[  130.206832] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  130.212586] CR2: 00007f6463b214f0 CR3: 00000008ab98c000 CR4: 00000000003506e0\n[  130.219729] Call Trace:\n[  130.222192]  <TASK>\n[  130.224305]  dma_chan_put+0x10d/0x110\n[  130.227988]  dmaengine_put+0x7a/0xa0\n[  130.231575]  __do_sys_delete_module.constprop.0+0x178/0x280\n[  130.237157]  ? syscall_trace_enter.constprop.0+0x145/0x1d0\n[  130.242652]  do_syscall_64+0x5c/0x90\n[  130.246240]  ? exc_page_fault+0x62/0x150\n[  130.250178]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[  130.255243] RIP: 0033:0x7f6463a3f5ab\n[  130.258830] Code: 73 01 c3 48 8b 0d 75 a8 1b 00 f7 d8 64 89 01 48\n83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa b8 b0 00 00\n00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 45 a8 1b 00 f7 d8 64 89\n01 48\n[  130.277591] RSP: 002b:00007fff22f972c8 EFLAGS: 00000206 ORIG_RAX:\n00000000000000b0\n[  130.285164] RAX: ffffffffffffffda RBX: 000055b6786edd40 RCX: 00007f6463a3f5ab\n[  130.292303] RDX: 0000000000000000 RSI: 0000000000000800 RDI: 000055b6786edda8\n[  130.299443] RBP: 000055b6786edd40 R08: 0000000000000000 R09: 0000000000000000\n[  130.306584] R10: 00007f6463b9eac0 R11: 0000000000000206 R12: 000055b6786edda8\n[  130.313731] R13: 0000000000000000 R14: 000055b6786edda8 R15: 00007fff22f995f8\n[  130.320875]  </TASK>\n[  130.323081] ---[ end trace eff7156d56b5cf25 ]---\n\ncat /sys/class/dma/dma0chan*/in_use would get the wrong result.\n2\n2\n2\n\nTest-by: Jie Hai <haijie1@huawei.com>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1b409e14b4b7af034e0450f95c165b6c5c87dbc1",
      "https://git.kernel.org/stable/c/c6221afe573413fd2981e291f7df4a58283e0654",
      "https://git.kernel.org/stable/c/18dd3b30d4c7e8440c63118c7a7b687372b9567f",
      "https://git.kernel.org/stable/c/42ecd72f02cd657b00b559621e7ef7d2c4d3e5f1",
      "https://git.kernel.org/stable/c/71c601965532c38030133535f7cd93c1efa75af1",
      "https://git.kernel.org/stable/c/142d644fd2cc059ffa042fbfb68e766433ef3afd",
      "https://git.kernel.org/stable/c/f3dc1b3b4750851a94212dba249703dd0e50bb20"
    ],
    "受影响版本": [
      "d2f4f99db3e9ec8b063cf2e45704e2bb95428317",
      "d2f4f99db3e9ec8b063cf2e45704e2bb95428317",
      "d2f4f99db3e9ec8b063cf2e45704e2bb95428317",
      "d2f4f99db3e9ec8b063cf2e45704e2bb95428317",
      "d2f4f99db3e9ec8b063cf2e45704e2bb95428317",
      "d2f4f99db3e9ec8b063cf2e45704e2bb95428317",
      "d2f4f99db3e9ec8b063cf2e45704e2bb95428317"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49751",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nw1: fix WARNING after calling w1_process()\n\nI got the following WARNING message while removing driver(ds2482):\n\n------------[ cut here ]------------\ndo not call blocking ops when !TASK_RUNNING; state=1 set at [<000000002d50bfb6>] w1_process+0x9e/0x1d0 [wire]\nWARNING: CPU: 0 PID: 262 at kernel/sched/core.c:9817 __might_sleep+0x98/0xa0\nCPU: 0 PID: 262 Comm: w1_bus_master1 Tainted: G                 N 6.1.0-rc3+ #307\nRIP: 0010:__might_sleep+0x98/0xa0\nCall Trace:\n exit_signals+0x6c/0x550\n do_exit+0x2b4/0x17e0\n kthread_exit+0x52/0x60\n kthread+0x16d/0x1e0\n ret_from_fork+0x1f/0x30\n\nThe state of task is set to TASK_INTERRUPTIBLE in loop in w1_process(),\nset it to TASK_RUNNING when it breaks out of the loop to avoid the\nwarning.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/190b5c3bbd5df685bb1063bda048831d72b8f1d4",
      "https://git.kernel.org/stable/c/bccd6df4c177b1ad766f16565ccc298653d027d0",
      "https://git.kernel.org/stable/c/276052159ba94d4d9f5b453fb4707d6798c6b845",
      "https://git.kernel.org/stable/c/216f35db6ec6a667cd9db4838d657c1d2f4684da",
      "https://git.kernel.org/stable/c/89c62cee5d4d65ac75d99b5f986f7f94290e888f",
      "https://git.kernel.org/stable/c/cfc7462ff824ed6718ed0272ee9aae88e20d469a",
      "https://git.kernel.org/stable/c/36225a7c72e9e3e1ce4001b6ce72849f5c9a2d3b"
    ],
    "受影响版本": [
      "3c52e4e627896b42152cc6ff98216c302932227e",
      "3c52e4e627896b42152cc6ff98216c302932227e",
      "3c52e4e627896b42152cc6ff98216c302932227e",
      "3c52e4e627896b42152cc6ff98216c302932227e",
      "3c52e4e627896b42152cc6ff98216c302932227e",
      "3c52e4e627896b42152cc6ff98216c302932227e",
      "3c52e4e627896b42152cc6ff98216c302932227e"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49744",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/uffd: fix pte marker when fork() without fork event\n\nPatch series \"mm: Fixes on pte markers\".\n\nPatch 1 resolves the syzkiller report from Pengfei.\n\nPatch 2 further harden pte markers when used with the recent swapin error\nmarkers.  The major case is we should persist a swapin error marker after\nfork(), so child shouldn't read a corrupted page.\n\n\nThis patch (of 2):\n\nWhen fork(), dst_vma is not guaranteed to have VM_UFFD_WP even if src may\nhave it and has pte marker installed.  The warning is improper along with\nthe comment.  The right thing is to inherit the pte marker when needed, or\nkeep the dst pte empty.\n\nA vague guess is this happened by an accident when there's the prior patch\nto introduce src/dst vma into this helper during the uffd-wp feature got\ndeveloped and I probably messed up in the rebase, since if we replace\ndst_vma with src_vma the warning & comment it all makes sense too.\n\nHugetlb did exactly the right here (copy_hugetlb_page_range()).  Fix the\ngeneral path.\n\nReproducer:\n\nhttps://github.com/xupengfe/syzkaller_logs/blob/main/221208_115556_copy_page_range/repro.c\n\nBugzilla report: https://bugzilla.kernel.org/show_bug.cgi?id=216808",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2d11727655bf931776fb541f5862daf04bd5bf02",
      "https://git.kernel.org/stable/c/49d6d7fb631345b0f2957a7c4be24ad63903150f"
    ],
    "受影响版本": [
      "c56d1b62cce83695823c13e52f73e92eb568c0c1",
      "c56d1b62cce83695823c13e52f73e92eb568c0c1"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49729",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfc: nfcmrvl: Fix memory leak in nfcmrvl_play_deferred\n\nSimilar to the handling of play_deferred in commit 19cfe912c37b\n(\"Bluetooth: btusb: Fix memory leak in play_deferred\"), we thought\na patch might be needed here as well.\n\nCurrently usb_submit_urb is called directly to submit deferred tx\nurbs after unanchor them.\n\nSo the usb_giveback_urb_bh would failed to unref it in usb_unanchor_urb\nand cause memory leak.\n\nPut those urbs in tx_anchor to avoid the leak, and also fix the error\nhandling.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1eb0afecfb9cd0f38424b82bd9aaa542310934ee",
      "https://git.kernel.org/stable/c/f21f908347712b8288ffe83b531b5e977042b29c",
      "https://git.kernel.org/stable/c/3e7c7df6991ac349f2fa8540047757df666e610f",
      "https://git.kernel.org/stable/c/6b4d8b44e7163a77fe942f5b80e1651c1b78c537",
      "https://git.kernel.org/stable/c/0eeec1a8b0cd38c47edeb042980a6aeacecf35ed",
      "https://git.kernel.org/stable/c/6616872cfe7f0474a22dd1f12699f95bcf81a54d",
      "https://git.kernel.org/stable/c/3eadc560c1919b8193d17334145dad9a917960e4",
      "https://git.kernel.org/stable/c/8a4d480702b71184fabcf379b80bf7539716752e"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49721",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64: ftrace: consistently handle PLTs.\n\nSometimes it is necessary to use a PLT entry to call an ftrace\ntrampoline. This is handled by ftrace_make_call() and ftrace_make_nop(),\nwith each having *almost* identical logic, but this is not handled by\nftrace_modify_call() since its introduction in commit:\n\n  3b23e4991fb66f6d (\"arm64: implement ftrace with regs\")\n\nDue to this, if we ever were to call ftrace_modify_call() for a callsite\nwhich requires a PLT entry for a trampoline, then either:\n\na) If the old addr requires a trampoline, ftrace_modify_call() will use\n   an out-of-range address to generate the 'old' branch instruction.\n   This will result in warnings from aarch64_insn_gen_branch_imm() and\n   ftrace_modify_code(), and no instructions will be modified. As\n   ftrace_modify_call() will return an error, this will result in\n   subsequent internal ftrace errors.\n\nb) If the old addr does not require a trampoline, but the new addr does,\n   ftrace_modify_call() will use an out-of-range address to generate the\n   'new' branch instruction. This will result in warnings from\n   aarch64_insn_gen_branch_imm(), and ftrace_modify_code() will replace\n   the 'old' branch with a BRK. This will result in a kernel panic when\n   this BRK is later executed.\n\nPractically speaking, case (a) is vastly more likely than case (b), and\ntypically this will result in internal ftrace errors that don't\nnecessarily affect the rest of the system. This can be demonstrated with\nan out-of-tree test module which triggers ftrace_modify_call(), e.g.\n\n| # insmod test_ftrace.ko\n| test_ftrace: Function test_function raw=0xffffb3749399201c, callsite=0xffffb37493992024\n| branch_imm_common: offset out of range\n| branch_imm_common: offset out of range\n| ------------[ ftrace bug ]------------\n| ftrace failed to modify\n| [<ffffb37493992024>] test_function+0x8/0x38 [test_ftrace]\n|  actual:   1d:00:00:94\n| Updating ftrace call site to call a different ftrace function\n| ftrace record flags: e0000002\n|  (2) R\n|  expected tramp: ffffb374ae42ed54\n| ------------[ cut here ]------------\n| WARNING: CPU: 0 PID: 165 at kernel/trace/ftrace.c:2085 ftrace_bug+0x280/0x2b0\n| Modules linked in: test_ftrace(+)\n| CPU: 0 PID: 165 Comm: insmod Not tainted 5.19.0-rc2-00002-g4d9ead8b45ce #13\n| Hardware name: linux,dummy-virt (DT)\n| pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n| pc : ftrace_bug+0x280/0x2b0\n| lr : ftrace_bug+0x280/0x2b0\n| sp : ffff80000839ba00\n| x29: ffff80000839ba00 x28: 0000000000000000 x27: ffff80000839bcf0\n| x26: ffffb37493994180 x25: ffffb374b0991c28 x24: ffffb374b0d70000\n| x23: 00000000ffffffea x22: ffffb374afcc33b0 x21: ffffb374b08f9cc8\n| x20: ffff572b8462c000 x19: ffffb374b08f9000 x18: ffffffffffffffff\n| x17: 6c6c6163202c6331 x16: ffffb374ae5ad110 x15: ffffb374b0d51ee4\n| x14: 0000000000000000 x13: 3435646532346561 x12: 3437336266666666\n| x11: 203a706d61727420 x10: 6465746365707865 x9 : ffffb374ae5149e8\n| x8 : 336266666666203a x7 : 706d617274206465 x6 : 00000000fffff167\n| x5 : ffff572bffbc4a08 x4 : 00000000fffff167 x3 : 0000000000000000\n| x2 : 0000000000000000 x1 : ffff572b84461e00 x0 : 0000000000000022\n| Call trace:\n|  ftrace_bug+0x280/0x2b0\n|  ftrace_replace_code+0x98/0xa0\n|  ftrace_modify_all_code+0xe0/0x144\n|  arch_ftrace_update_code+0x14/0x20\n|  ftrace_startup+0xf8/0x1b0\n|  register_ftrace_function+0x38/0x90\n|  test_ftrace_init+0xd0/0x1000 [test_ftrace]\n|  do_one_initcall+0x50/0x2b0\n|  do_init_module+0x50/0x1f0\n|  load_module+0x17c8/0x1d64\n|  __do_sys_finit_module+0xa8/0x100\n|  __arm64_sys_finit_module+0x2c/0x3c\n|  invoke_syscall+0x50/0x120\n|  el0_svc_common.constprop.0+0xdc/0x100\n|  do_el0_svc+0x3c/0xd0\n|  el0_svc+0x34/0xb0\n|  el0t_64_sync_handler+0xbc/0x140\n|  el0t_64_sync+0x18c/0x190\n| ---[ end trace 0000000000000000 ]---\n\nWe can solve this by consistently determining whether to use a PLT entry\nfor an address.\n\nNote that since (the earlier) commit:\n\n  f1a54ae9\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/bc28fde90937a920f7714ec4408269cac744f796",
      "https://git.kernel.org/stable/c/db73aa9466338ec821ed2a0b01721fe4d06876b1",
      "https://git.kernel.org/stable/c/dcecc96ed16f73417de5550f384e348c9d56f279",
      "https://git.kernel.org/stable/c/a6253579977e4c6f7818eeb05bf2bc65678a7187"
    ],
    "受影响版本": [
      "3b23e4991fb66f6d152f9055ede271a726ef9f21",
      "3b23e4991fb66f6d152f9055ede271a726ef9f21",
      "3b23e4991fb66f6d152f9055ede271a726ef9f21",
      "3b23e4991fb66f6d152f9055ede271a726ef9f21"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49700",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slub: add missing TID updates on slab deactivation\n\nThe fastpath in slab_alloc_node() assumes that c->slab is stable as long as\nthe TID stays the same. However, two places in __slab_alloc() currently\ndon't update the TID when deactivating the CPU slab.\n\nIf multiple operations race the right way, this could lead to an object\ngetting lost; or, in an even more unlikely situation, it could even lead to\nan object being freed onto the wrong slab's freelist, messing up the\n`inuse` counter and eventually causing a page to be freed to the page\nallocator while it still contains slab objects.\n\n(I haven't actually tested these cases though, this is just based on\nlooking at the code. Writing testcases for this stuff seems like it'd be\na pain...)\n\nThe race leading to state inconsistency is (all operations on the same CPU\nand kmem_cache):\n\n - task A: begin do_slab_free():\n    - read TID\n    - read pcpu freelist (==NULL)\n    - check `slab == c->slab` (true)\n - [PREEMPT A->B]\n - task B: begin slab_alloc_node():\n    - fastpath fails (`c->freelist` is NULL)\n    - enter __slab_alloc()\n    - slub_get_cpu_ptr() (disables preemption)\n    - enter ___slab_alloc()\n    - take local_lock_irqsave()\n    - read c->freelist as NULL\n    - get_freelist() returns NULL\n    - write `c->slab = NULL`\n    - drop local_unlock_irqrestore()\n    - goto new_slab\n    - slub_percpu_partial() is NULL\n    - get_partial() returns NULL\n    - slub_put_cpu_ptr() (enables preemption)\n - [PREEMPT B->A]\n - task A: finish do_slab_free():\n    - this_cpu_cmpxchg_double() succeeds()\n    - [CORRUPT STATE: c->slab==NULL, c->freelist!=NULL]\n\nFrom there, the object on c->freelist will get lost if task B is allowed to\ncontinue from here: It will proceed to the retry_load_slab label,\nset c->slab, then jump to load_freelist, which clobbers c->freelist.\n\nBut if we instead continue as follows, we get worse corruption:\n\n - task A: run __slab_free() on object from other struct slab:\n    - CPU_PARTIAL_FREE case (slab was on no list, is now on pcpu partial)\n - task A: run slab_alloc_node() with NUMA node constraint:\n    - fastpath fails (c->slab is NULL)\n    - call __slab_alloc()\n    - slub_get_cpu_ptr() (disables preemption)\n    - enter ___slab_alloc()\n    - c->slab is NULL: goto new_slab\n    - slub_percpu_partial() is non-NULL\n    - set c->slab to slub_percpu_partial(c)\n    - [CORRUPT STATE: c->slab points to slab-1, c->freelist has objects\n      from slab-2]\n    - goto redo\n    - node_match() fails\n    - goto deactivate_slab\n    - existing c->freelist is passed into deactivate_slab()\n    - inuse count of slab-1 is decremented to account for object from\n      slab-2\n\nAt this point, the inuse count of slab-1 is 1 lower than it should be.\nThis means that if we free all allocated objects in slab-1 except for one,\nSLUB will think that slab-1 is completely unused, and may free its page,\nleading to use-after-free.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/308c6d0e1f200fd26c71270c6e6bfcf0fc6ff082",
      "https://git.kernel.org/stable/c/d6a597450e686d4c6388bd3cdcb17224b4dae7f0",
      "https://git.kernel.org/stable/c/e2b2f0e2e34d71ae6c2a1114fd3c525930e84bc7",
      "https://git.kernel.org/stable/c/e7e3e90d671078455a3a08189f89d85b3da2de9e",
      "https://git.kernel.org/stable/c/6c32496964da0dc230cea763a0e934b2e02dabd5",
      "https://git.kernel.org/stable/c/0515cc9b6b24877f59b222ade704bfaa42caa2a6",
      "https://git.kernel.org/stable/c/197e257da473c725dfe47759c3ee02f2398d8ea5",
      "https://git.kernel.org/stable/c/eeaa345e128515135ccb864c04482180c08e3259"
    ],
    "受影响版本": [
      "03e404af26dc2ea0d278d7a342de0aab394793ce",
      "03e404af26dc2ea0d278d7a342de0aab394793ce",
      "03e404af26dc2ea0d278d7a342de0aab394793ce",
      "03e404af26dc2ea0d278d7a342de0aab394793ce",
      "03e404af26dc2ea0d278d7a342de0aab394793ce",
      "03e404af26dc2ea0d278d7a342de0aab394793ce",
      "03e404af26dc2ea0d278d7a342de0aab394793ce",
      "03e404af26dc2ea0d278d7a342de0aab394793ce"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49686",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: uvc: fix list double add in uvcg_video_pump\n\nA panic can occur if the endpoint becomes disabled and the\nuvcg_video_pump adds the request back to the req_free list after it has\nalready been queued to the endpoint. The endpoint complete will add the\nrequest back to the req_free list. Invalidate the local request handle\nonce it's been queued.\n\n<6>[  246.796704][T13726] configfs-gadget gadget: uvc: uvc_function_set_alt(1, 0)\n<3>[  246.797078][   T26] list_add double add: new=ffffff878bee5c40, prev=ffffff878bee5c40, next=ffffff878b0f0a90.\n<6>[  246.797213][   T26] ------------[ cut here ]------------\n<2>[  246.797224][   T26] kernel BUG at lib/list_debug.c:31!\n<6>[  246.807073][   T26] Call trace:\n<6>[  246.807180][   T26]  uvcg_video_pump+0x364/0x38c\n<6>[  246.807366][   T26]  process_one_work+0x2a4/0x544\n<6>[  246.807394][   T26]  worker_thread+0x350/0x784\n<6>[  246.807442][   T26]  kthread+0x2ac/0x320",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d95ac8b920de1d39525fadc408ce675697626ca6",
      "https://git.kernel.org/stable/c/96163f835e65f8c9897487fac965819f0651d671"
    ],
    "受影响版本": [
      "f9897ec0f6d34e8b2bc2f4c8ab8789351090f3d2",
      "f9897ec0f6d34e8b2bc2f4c8ab8789351090f3d2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49667",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bonding: fix use-after-free after 802.3ad slave unbind\n\ncommit 0622cab0341c (\"bonding: fix 802.3ad aggregator reselection\"),\nresolve case, when there is several aggregation groups in the same bond.\nbond_3ad_unbind_slave will invalidate (clear) aggregator when\n__agg_active_ports return zero. So, ad_clear_agg can be executed even, when\nnum_of_ports!=0. Than bond_3ad_unbind_slave can be executed again for,\npreviously cleared aggregator. NOTE: at this time bond_3ad_unbind_slave\nwill not update slave ports list, because lag_ports==NULL. So, here we\ngot slave ports, pointing to freed aggregator memory.\n\nFix with checking actual number of ports in group (as was before\ncommit 0622cab0341c (\"bonding: fix 802.3ad aggregator reselection\") ),\nbefore ad_clear_agg().\n\nThe KASAN logs are as follows:\n\n[  767.617392] ==================================================================\n[  767.630776] BUG: KASAN: use-after-free in bond_3ad_state_machine_handler+0x13dc/0x1470\n[  767.638764] Read of size 2 at addr ffff00011ba9d430 by task kworker/u8:7/767\n[  767.647361] CPU: 3 PID: 767 Comm: kworker/u8:7 Tainted: G           O 5.15.11 #15\n[  767.655329] Hardware name: DNI AmazonGo1 A7040 board (DT)\n[  767.660760] Workqueue: lacp_1 bond_3ad_state_machine_handler\n[  767.666468] Call trace:\n[  767.668930]  dump_backtrace+0x0/0x2d0\n[  767.672625]  show_stack+0x24/0x30\n[  767.675965]  dump_stack_lvl+0x68/0x84\n[  767.679659]  print_address_description.constprop.0+0x74/0x2b8\n[  767.685451]  kasan_report+0x1f0/0x260\n[  767.689148]  __asan_load2+0x94/0xd0\n[  767.692667]  bond_3ad_state_machine_handler+0x13dc/0x1470",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a853b7a3a9fd1d74a4ccdd9cd73512b7dace2f1e",
      "https://git.kernel.org/stable/c/b90ac60303063a43e17dd4aec159067599d255e6",
      "https://git.kernel.org/stable/c/f162f7c348fa2a5555bafdb5cc890b89b221e69c",
      "https://git.kernel.org/stable/c/893825289ba840afd86bfffcb6f7f363c73efff8",
      "https://git.kernel.org/stable/c/63b2fe509f69b90168a75e04e14573dccf7984e6",
      "https://git.kernel.org/stable/c/ef0af7d08d26c5333ff4944a559279464edf6f15",
      "https://git.kernel.org/stable/c/2765749def4765c5052a4c66445cf4c96fcccdbc",
      "https://git.kernel.org/stable/c/050133e1aa2cb49bb17be847d48a4431598ef562"
    ],
    "受影响版本": [
      "0622cab0341cac6b30da177b0faa39fae0680e71",
      "0622cab0341cac6b30da177b0faa39fae0680e71",
      "0622cab0341cac6b30da177b0faa39fae0680e71",
      "0622cab0341cac6b30da177b0faa39fae0680e71",
      "0622cab0341cac6b30da177b0faa39fae0680e71",
      "0622cab0341cac6b30da177b0faa39fae0680e71",
      "0622cab0341cac6b30da177b0faa39fae0680e71",
      "0622cab0341cac6b30da177b0faa39fae0680e71"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49658",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix insufficient bounds propagation from adjust_scalar_min_max_vals\n\nKuee reported a corner case where the tnum becomes constant after the call\nto __reg_bound_offset(), but the register's bounds are not, that is, its\nmin bounds are still not equal to the register's max bounds.\n\nThis in turn allows to leak pointers through turning a pointer register as\nis into an unknown scalar via adjust_ptr_min_max_vals().\n\nBefore:\n\n  func#0 @0\n  0: R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))\n  0: (b7) r0 = 1                        ; R0_w=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0))\n  1: (b7) r3 = 0                        ; R3_w=scalar(imm=0,umax=0,var_off=(0x0; 0x0))\n  2: (87) r3 = -r3                      ; R3_w=scalar()\n  3: (87) r3 = -r3                      ; R3_w=scalar()\n  4: (47) r3 |= 32767                   ; R3_w=scalar(smin=-9223372036854743041,umin=32767,var_off=(0x7fff; 0xffffffffffff8000),s32_min=-2147450881)\n  5: (75) if r3 s>= 0x0 goto pc+1       ; R3_w=scalar(umin=9223372036854808575,var_off=(0x8000000000007fff; 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767)\n  6: (95) exit\n\n  from 5 to 7: R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R3=scalar(umin=32767,umax=9223372036854775807,var_off=(0x7fff; 0x7fffffffffff8000),s32_min=-2147450881) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))\n  7: (d5) if r3 s<= 0x8000 goto pc+1    ; R3=scalar(umin=32769,umax=9223372036854775807,var_off=(0x7fff; 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767)\n  8: (95) exit\n\n  from 7 to 9: R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R3=scalar(umin=32767,umax=32768,var_off=(0x7fff; 0x8000)) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))\n  9: (07) r3 += -32767                  ; R3_w=scalar(imm=0,umax=1,var_off=(0x0; 0x0))  <--- [*]\n  10: (95) exit\n\nWhat can be seen here is that R3=scalar(umin=32767,umax=32768,var_off=(0x7fff;\n0x8000)) after the operation R3 += -32767 results in a 'malformed' constant, that\nis, R3_w=scalar(imm=0,umax=1,var_off=(0x0; 0x0)). Intersecting with var_off has\nnot been done at that point via __update_reg_bounds(), which would have improved\nthe umax to be equal to umin.\n\nRefactor the tnum <> min/max bounds information flow into a reg_bounds_sync()\nhelper and use it consistently everywhere. After the fix, bounds have been\ncorrected to R3_w=scalar(imm=0,umax=0,var_off=(0x0; 0x0)) and thus the register\nis regarded as a 'proper' constant scalar of 0.\n\nAfter:\n\n  func#0 @0\n  0: R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))\n  0: (b7) r0 = 1                        ; R0_w=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0))\n  1: (b7) r3 = 0                        ; R3_w=scalar(imm=0,umax=0,var_off=(0x0; 0x0))\n  2: (87) r3 = -r3                      ; R3_w=scalar()\n  3: (87) r3 = -r3                      ; R3_w=scalar()\n  4: (47) r3 |= 32767                   ; R3_w=scalar(smin=-9223372036854743041,umin=32767,var_off=(0x7fff; 0xffffffffffff8000),s32_min=-2147450881)\n  5: (75) if r3 s>= 0x0 goto pc+1       ; R3_w=scalar(umin=9223372036854808575,var_off=(0x8000000000007fff; 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767)\n  6: (95) exit\n\n  from 5 to 7: R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R3=scalar(umin=32767,umax=9223372036854775807,var_off=(0x7fff; 0x7fffffffffff8000),s32_min=-2147450881) R10=fp(off=0,imm=0,umax=0,var_off=(0x0; 0x0))\n  7: (d5) if r3 s<= 0x8000 goto pc+1    ; R3=scalar(umin=32769,umax=9223372036854775807,var_off=(0x7fff; 0x7fffffffffff8000),s32_min=-2147450881,u32_min=32767)\n  8: (95) exit\n\n  from 7 to 9: R0=scalar(imm=1,umin=1,umax=1,var_off=(0x1; 0x0)) R1=ctx(off=0,imm=0,umax=0,var_off=(0x0; 0x0)) R3=scalar(umin=32767,umax=32768,var_off=(0x7fff; 0x8000)) R10=fp(off=0\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e917be1f83ea14a68b3cf64d3da9968eaf991dae",
      "https://git.kernel.org/stable/c/a7de8d436db92bab8b1f44624297c2554a6ac36b",
      "https://git.kernel.org/stable/c/b2a28bb36664c94375926cbbb91976242847699d",
      "https://git.kernel.org/stable/c/3844d153a41adea718202c10ae91dc96b37453b5"
    ],
    "受影响版本": [
      "b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2",
      "b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2",
      "b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2",
      "b03c9f9fdc37dab81ea04d5dacdc5995d4c224c2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49648",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/histograms: Fix memory leak problem\n\nThis reverts commit 46bbe5c671e06f070428b9be142cc4ee5cedebac.\n\nAs commit 46bbe5c671e0 (\"tracing: fix double free\") said, the\n\"double free\" problem reported by clang static analyzer is:\n  > In parse_var_defs() if there is a problem allocating\n  > var_defs.expr, the earlier var_defs.name is freed.\n  > This free is duplicated by free_var_defs() which frees\n  > the rest of the list.\n\nHowever, if there is a problem allocating N-th var_defs.expr:\n  + in parse_var_defs(), the freed 'earlier var_defs.name' is\n    actually the N-th var_defs.name;\n  + then in free_var_defs(), the names from 0th to (N-1)-th are freed;\n\n                        IF ALLOCATING PROBLEM HAPPENED HERE!!! -+\n                                                                 \\\n                                                                  |\n          0th           1th                 (N-1)-th      N-th    V\n          +-------------+-------------+-----+-------------+-----------\nvar_defs: | name | expr | name | expr | ... | name | expr | name | ///\n          +-------------+-------------+-----+-------------+-----------\n\nThese two frees don't act on same name, so there was no \"double free\"\nproblem before. Conversely, after that commit, we get a \"memory leak\"\nproblem because the above \"N-th var_defs.name\" is not freed.\n\nIf enable CONFIG_DEBUG_KMEMLEAK and inject a fault at where the N-th\nvar_defs.expr allocated, then execute on shell like:\n  $ echo 'hist:key=call_site:val=$v1,$v2:v1=bytes_req,v2=bytes_alloc' > \\\n/sys/kernel/debug/tracing/events/kmem/kmalloc/trigger\n\nThen kmemleak reports:\n  unreferenced object 0xffff8fb100ef3518 (size 8):\n    comm \"bash\", pid 196, jiffies 4295681690 (age 28.538s)\n    hex dump (first 8 bytes):\n      76 31 00 00 b1 8f ff ff                          v1......\n    backtrace:\n      [<0000000038fe4895>] kstrdup+0x2d/0x60\n      [<00000000c99c049a>] event_hist_trigger_parse+0x206f/0x20e0\n      [<00000000ae70d2cc>] trigger_process_regex+0xc0/0x110\n      [<0000000066737a4c>] event_trigger_write+0x75/0xd0\n      [<000000007341e40c>] vfs_write+0xbb/0x2a0\n      [<0000000087fde4c2>] ksys_write+0x59/0xd0\n      [<00000000581e9cdf>] do_syscall_64+0x3a/0x80\n      [<00000000cf3b065c>] entry_SYSCALL_64_after_hwframe+0x46/0xb0",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/eb622d5580b9e2ff694f62da6410618bd73853cb",
      "https://git.kernel.org/stable/c/ecc6dec12c33aa92c086cd702af9f544ddaf3c75",
      "https://git.kernel.org/stable/c/78a1400c42ee11197eb1f0f85ba51df9a4fdfff0",
      "https://git.kernel.org/stable/c/22eeff55679d9e7c0f768c79bfbd83e2f8142d89",
      "https://git.kernel.org/stable/c/4d453eb5e1eec89971aa5b3262857ee26cfdffd3",
      "https://git.kernel.org/stable/c/7edc3945bdce9c39198a10d6129377a5c53559c2"
    ],
    "受影响版本": [
      "240dd5118a9e0454f280ffeae63f22bd14735733",
      "e92c490f104993cea35e5f5d5108ac12df1850ac",
      "46bbe5c671e06f070428b9be142cc4ee5cedebac",
      "46bbe5c671e06f070428b9be142cc4ee5cedebac",
      "46bbe5c671e06f070428b9be142cc4ee5cedebac",
      "46bbe5c671e06f070428b9be142cc4ee5cedebac",
      "e3a23511638a3dcf0275c1e71a46d1ca2e2e6788"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49623",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/xive/spapr: correct bitmap allocation size\n\nkasan detects access beyond the end of the xibm->bitmap allocation:\n\nBUG: KASAN: slab-out-of-bounds in _find_first_zero_bit+0x40/0x140\nRead of size 8 at addr c00000001d1d0118 by task swapper/0/1\n\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.19.0-rc2-00001-g90df023b36dd #28\nCall Trace:\n[c00000001d98f770] [c0000000012baab8] dump_stack_lvl+0xac/0x108 (unreliable)\n[c00000001d98f7b0] [c00000000068faac] print_report+0x37c/0x710\n[c00000001d98f880] [c0000000006902c0] kasan_report+0x110/0x354\n[c00000001d98f950] [c000000000692324] __asan_load8+0xa4/0xe0\n[c00000001d98f970] [c0000000011c6ed0] _find_first_zero_bit+0x40/0x140\n[c00000001d98f9b0] [c0000000000dbfbc] xive_spapr_get_ipi+0xcc/0x260\n[c00000001d98fa70] [c0000000000d6d28] xive_setup_cpu_ipi+0x1e8/0x450\n[c00000001d98fb30] [c000000004032a20] pSeries_smp_probe+0x5c/0x118\n[c00000001d98fb60] [c000000004018b44] smp_prepare_cpus+0x944/0x9ac\n[c00000001d98fc90] [c000000004009f9c] kernel_init_freeable+0x2d4/0x640\n[c00000001d98fd90] [c0000000000131e8] kernel_init+0x28/0x1d0\n[c00000001d98fe10] [c00000000000cd54] ret_from_kernel_thread+0x5c/0x64\n\nAllocated by task 0:\n kasan_save_stack+0x34/0x70\n __kasan_kmalloc+0xb4/0xf0\n __kmalloc+0x268/0x540\n xive_spapr_init+0x4d0/0x77c\n pseries_init_irq+0x40/0x27c\n init_IRQ+0x44/0x84\n start_kernel+0x2a4/0x538\n start_here_common+0x1c/0x20\n\nThe buggy address belongs to the object at c00000001d1d0118\n which belongs to the cache kmalloc-8 of size 8\nThe buggy address is located 0 bytes inside of\n 8-byte region [c00000001d1d0118, c00000001d1d0120)\n\nThe buggy address belongs to the physical page:\npage:c00c000000074740 refcount:1 mapcount:0 mapping:0000000000000000 index:0xc00000001d1d0558 pfn:0x1d1d\nflags: 0x7ffff000000200(slab|node=0|zone=0|lastcpupid=0x7ffff)\nraw: 007ffff000000200 c00000001d0003c8 c00000001d0003c8 c00000001d010480\nraw: c00000001d1d0558 0000000001e1000a 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n c00000001d1d0000: fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n c00000001d1d0080: fc fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc\n>c00000001d1d0100: fc fc fc 02 fc fc fc fc fc fc fc fc fc fc fc fc\n                            ^\n c00000001d1d0180: fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc fc\n c00000001d1d0200: fc fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc\n\nThis happens because the allocation uses the wrong unit (bits) when it\nshould pass (BITS_TO_LONGS(count) * sizeof(long)) or equivalent. With small\nnumbers of bits, the allocated object can be smaller than sizeof(long),\nwhich results in invalid accesses.\n\nUse bitmap_zalloc() to allocate and initialize the irq bitmap, paired with\nbitmap_free() for consistency.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/10f2cd373e65bcd3be8f3cdc71c330c25763dfd8",
      "https://git.kernel.org/stable/c/99d1c36bddd93919072b5a51a89297bbb5ad6a6f",
      "https://git.kernel.org/stable/c/19fc5bb93c6bbdce8292b4d7eed04e2fa118d2fe"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49559",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Drop WARNs that assert a triple fault never \"escapes\" from L2\n\nRemove WARNs that sanity check that KVM never lets a triple fault for L2\nescape and incorrectly end up in L1.  In normal operation, the sanity\ncheck is perfectly valid, but it incorrectly assumes that it's impossible\nfor userspace to induce KVM_REQ_TRIPLE_FAULT without bouncing through\nKVM_RUN (which guarantees kvm_check_nested_state() will see and handle\nthe triple fault).\n\nThe WARN can currently be triggered if userspace injects a machine check\nwhile L2 is active and CR4.MCE=0.  And a future fix to allow save/restore\nof KVM_REQ_TRIPLE_FAULT, e.g. so that a synthesized triple fault isn't\nlost on migration, will make it trivially easy for userspace to trigger\nthe WARN.\n\nClearing KVM_REQ_TRIPLE_FAULT when forcibly leaving guest mode is\ntempting, but wrong, especially if/when the request is saved/restored,\ne.g. if userspace restores events (including a triple fault) and then\nrestores nested state (which may forcibly leave guest mode).  Ignoring\nthe fact that KVM doesn't currently provide the necessary APIs, it's\nuserspace's responsibility to manage pending events during save/restore.\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 7 PID: 1399 at arch/x86/kvm/vmx/nested.c:4522 nested_vmx_vmexit+0x7fe/0xd90 [kvm_intel]\n  Modules linked in: kvm_intel kvm irqbypass\n  CPU: 7 PID: 1399 Comm: state_test Not tainted 5.17.0-rc3+ #808\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n  RIP: 0010:nested_vmx_vmexit+0x7fe/0xd90 [kvm_intel]\n  Call Trace:\n   <TASK>\n   vmx_leave_nested+0x30/0x40 [kvm_intel]\n   vmx_set_nested_state+0xca/0x3e0 [kvm_intel]\n   kvm_arch_vcpu_ioctl+0xf49/0x13e0 [kvm]\n   kvm_vcpu_ioctl+0x4b9/0x660 [kvm]\n   __x64_sys_ioctl+0x83/0xb0\n   do_syscall_64+0x3b/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n   </TASK>\n  ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8d3a2aa0976f57320ba89baf9d57fb158dd0cd0d",
      "https://git.kernel.org/stable/c/f476a59d5c86c02a79eef893c6da86735f2977ac",
      "https://git.kernel.org/stable/c/7de373c9b48229e428ecdb8fbde269c5a8617fd2",
      "https://git.kernel.org/stable/c/45846661d10422ce9e22da21f8277540b29eca22"
    ],
    "受影响版本": [
      "cb6a32c2b8777ad31a02e585584d869251a790e3",
      "cb6a32c2b8777ad31a02e585584d869251a790e3",
      "cb6a32c2b8777ad31a02e585584d869251a790e3",
      "cb6a32c2b8777ad31a02e585584d869251a790e3"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49543",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nath11k: fix the warning of dev_wake in mhi_pm_disable_transition()\n\nWhen test device recovery with below command, it has warning in message\nas below.\necho assert > /sys/kernel/debug/ath11k/wcn6855\\ hw2.0/simulate_fw_crash\necho assert > /sys/kernel/debug/ath11k/qca6390\\ hw2.0/simulate_fw_crash\n\nwarning message:\n[ 1965.642121] ath11k_pci 0000:06:00.0: simulating firmware assert crash\n[ 1968.471364] ieee80211 phy0: Hardware restart was requested\n[ 1968.511305] ------------[ cut here ]------------\n[ 1968.511368] WARNING: CPU: 3 PID: 1546 at drivers/bus/mhi/core/pm.c:505 mhi_pm_disable_transition+0xb37/0xda0 [mhi]\n[ 1968.511443] Modules linked in: ath11k_pci ath11k mac80211 libarc4 cfg80211 qmi_helpers qrtr_mhi mhi qrtr nvme nvme_core\n[ 1968.511563] CPU: 3 PID: 1546 Comm: kworker/u17:0 Kdump: loaded Tainted: G        W         5.17.0-rc3-wt-ath+ #579\n[ 1968.511629] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021\n[ 1968.511704] Workqueue: mhi_hiprio_wq mhi_pm_st_worker [mhi]\n[ 1968.511787] RIP: 0010:mhi_pm_disable_transition+0xb37/0xda0 [mhi]\n[ 1968.511870] Code: a9 fe ff ff 4c 89 ff 44 89 04 24 e8 03 46 f6 e5 44 8b 04 24 41 83 f8 01 0f 84 21 fe ff ff e9 4c fd ff ff 0f 0b e9 af f8 ff ff <0f> 0b e9 5c f8 ff ff 48 89 df e8 da 9e ee e3 e9 12 fd ff ff 4c 89\n[ 1968.511923] RSP: 0018:ffffc900024efbf0 EFLAGS: 00010286\n[ 1968.511969] RAX: 00000000ffffffff RBX: ffff88811d241250 RCX: ffffffffc0176922\n[ 1968.512014] RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffff888118a90a24\n[ 1968.512059] RBP: ffff888118a90800 R08: 0000000000000000 R09: ffff888118a90a27\n[ 1968.512102] R10: ffffed1023152144 R11: 0000000000000001 R12: ffff888118a908ac\n[ 1968.512229] R13: ffff888118a90928 R14: dffffc0000000000 R15: ffff888118a90a24\n[ 1968.512310] FS:  0000000000000000(0000) GS:ffff888234200000(0000) knlGS:0000000000000000\n[ 1968.512405] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 1968.512493] CR2: 00007f5538f443a8 CR3: 000000016dc28001 CR4: 00000000003706e0\n[ 1968.512587] Call Trace:\n[ 1968.512672]  <TASK>\n[ 1968.512751]  ? _raw_spin_unlock_irq+0x1f/0x40\n[ 1968.512859]  mhi_pm_st_worker+0x3ac/0x790 [mhi]\n[ 1968.512959]  ? mhi_pm_mission_mode_transition.isra.0+0x7d0/0x7d0 [mhi]\n[ 1968.513063]  process_one_work+0x86a/0x1400\n[ 1968.513184]  ? pwq_dec_nr_in_flight+0x230/0x230\n[ 1968.513312]  ? move_linked_works+0x125/0x290\n[ 1968.513416]  worker_thread+0x6db/0xf60\n[ 1968.513536]  ? process_one_work+0x1400/0x1400\n[ 1968.513627]  kthread+0x241/0x2d0\n[ 1968.513733]  ? kthread_complete_and_exit+0x20/0x20\n[ 1968.513821]  ret_from_fork+0x22/0x30\n[ 1968.513924]  </TASK>\n\nReason is mhi_deassert_dev_wake() from mhi_device_put() is called\nbut mhi_assert_dev_wake() from __mhi_device_get_sync() is not called\nin progress of recovery. Commit 8e0559921f9a (\"bus: mhi: core:\nSkip device wake in error or shutdown state\") add check for the\npm_state of mhi in __mhi_device_get_sync(), and the pm_state is not\nthe normal state untill recovery is completed, so it leads the\ndev_wake is not 0 and above warning print in mhi_pm_disable_transition()\nwhile checking mhi_cntrl->dev_wake.\n\nAdd check in ath11k_pci_write32()/ath11k_pci_read32() to skip call\nmhi_device_put() if mhi_device_get_sync() does not really do wake,\nthen the warning gone.\n\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5f18206cddae033c488e4879f198699092ca0524",
      "https://git.kernel.org/stable/c/a2d9b7357469949ad02f511fc69f8fa3a1afbf89",
      "https://git.kernel.org/stable/c/0d7a8a6204ea9271f1d0a8c66a9fd2f54d2e3cbc"
    ],
    "受影响版本": [
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49540",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nrcu-tasks: Fix race in schedule and flush work\n\nWhile booting secondary CPUs, cpus_read_[lock/unlock] is not keeping\nonline cpumask stable. The transient online mask results in below\ncalltrace.\n\n[    0.324121] CPU1: Booted secondary processor 0x0000000001 [0x410fd083]\n[    0.346652] Detected PIPT I-cache on CPU2\n[    0.347212] CPU2: Booted secondary processor 0x0000000002 [0x410fd083]\n[    0.377255] Detected PIPT I-cache on CPU3\n[    0.377823] CPU3: Booted secondary processor 0x0000000003 [0x410fd083]\n[    0.379040] ------------[ cut here ]------------\n[    0.383662] WARNING: CPU: 0 PID: 10 at kernel/workqueue.c:3084 __flush_work+0x12c/0x138\n[    0.384850] Modules linked in:\n[    0.385403] CPU: 0 PID: 10 Comm: rcu_tasks_rude_ Not tainted 5.17.0-rc3-v8+ #13\n[    0.386473] Hardware name: Raspberry Pi 4 Model B Rev 1.4 (DT)\n[    0.387289] pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    0.388308] pc : __flush_work+0x12c/0x138\n[    0.388970] lr : __flush_work+0x80/0x138\n[    0.389620] sp : ffffffc00aaf3c60\n[    0.390139] x29: ffffffc00aaf3d20 x28: ffffffc009c16af0 x27: ffffff80f761df48\n[    0.391316] x26: 0000000000000004 x25: 0000000000000003 x24: 0000000000000100\n[    0.392493] x23: ffffffffffffffff x22: ffffffc009c16b10 x21: ffffffc009c16b28\n[    0.393668] x20: ffffffc009e53861 x19: ffffff80f77fbf40 x18: 00000000d744fcc9\n[    0.394842] x17: 000000000000000b x16: 00000000000001c2 x15: ffffffc009e57550\n[    0.396016] x14: 0000000000000000 x13: ffffffffffffffff x12: 0000000100000000\n[    0.397190] x11: 0000000000000462 x10: ffffff8040258008 x9 : 0000000100000000\n[    0.398364] x8 : 0000000000000000 x7 : ffffffc0093c8bf4 x6 : 0000000000000000\n[    0.399538] x5 : 0000000000000000 x4 : ffffffc00a976e40 x3 : ffffffc00810444c\n[    0.400711] x2 : 0000000000000004 x1 : 0000000000000000 x0 : 0000000000000000\n[    0.401886] Call trace:\n[    0.402309]  __flush_work+0x12c/0x138\n[    0.402941]  schedule_on_each_cpu+0x228/0x278\n[    0.403693]  rcu_tasks_rude_wait_gp+0x130/0x144\n[    0.404502]  rcu_tasks_kthread+0x220/0x254\n[    0.405264]  kthread+0x174/0x1ac\n[    0.405837]  ret_from_fork+0x10/0x20\n[    0.406456] irq event stamp: 102\n[    0.406966] hardirqs last  enabled at (101): [<ffffffc0093c8468>] _raw_spin_unlock_irq+0x78/0xb4\n[    0.408304] hardirqs last disabled at (102): [<ffffffc0093b8270>] el1_dbg+0x24/0x5c\n[    0.409410] softirqs last  enabled at (54): [<ffffffc0081b80c8>] local_bh_enable+0xc/0x2c\n[    0.410645] softirqs last disabled at (50): [<ffffffc0081b809c>] local_bh_disable+0xc/0x2c\n[    0.411890] ---[ end trace 0000000000000000 ]---\n[    0.413000] smp: Brought up 1 node, 4 CPUs\n[    0.413762] SMP: Total of 4 processors activated.\n[    0.414566] CPU features: detected: 32-bit EL0 Support\n[    0.415414] CPU features: detected: 32-bit EL1 Support\n[    0.416278] CPU features: detected: CRC32 instructions\n[    0.447021] Callback from call_rcu_tasks_rude() invoked.\n[    0.506693] Callback from call_rcu_tasks() invoked.\n\nThis commit therefore fixes this issue by applying a single-CPU\noptimization to the RCU Tasks Rude grace-period process.  The key point\nhere is that the purpose of this RCU flavor is to force a schedule on\neach online CPU since some past event.  But the rcu_tasks_rude_wait_gp()\nfunction runs in the context of the RCU Tasks Rude's grace-period kthread,\nso there must already have been a context switch on the current CPU since\nthe call to either synchronize_rcu_tasks_rude() or call_rcu_tasks_rude().\nSo if there is only a single CPU online, RCU Tasks Rude's grace-period\nkthread does not need to anything at all.\n\nIt turns out that the rcu_tasks_rude_wait_gp() function's call to\nschedule_on_each_cpu() causes problems during early boot.  During that\ntime, there is only one online CPU, namely the boot CPU.  Therefore,\napplying this single-CPU optimization fixes early-boot instances of\nthis problem.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1c6c3f2336642fb3074593911f5176565f47ec41",
      "https://git.kernel.org/stable/c/ba722d061bc4b54802d701fc63fc2fd988934603",
      "https://git.kernel.org/stable/c/230bf5878af6038dfb63d9184272a58475236580",
      "https://git.kernel.org/stable/c/8f49a8758b5cd541bd7aa9a0d0d11c7426141c0e",
      "https://git.kernel.org/stable/c/f75fd4b9221d93177c50dcfde671b2e907f53e86"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49539",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nrtw89: ser: fix CAM leaks occurring in L2 reset\n\nThe CAM, meaning address CAM and bssid CAM here, will get leaks during\nSER (system error recover) L2 reset process and ieee80211_restart_hw()\nwhich is called by L2 reset process eventually.\n\nThe normal flow would be like\n-> add interface (acquire 1)\n-> enter ips (release 1)\n-> leave ips (acquire 1)\n-> connection (occupy 1) <(A) 1 leak after L2 reset if non-sec connection>\n\nThe ieee80211_restart_hw() flow (under connection)\n-> ieee80211 reconfig\n-> add interface (acquire 1)\n-> leave ips (acquire 1)\n-> connection (occupy (A) + 2) <(B) 1 more leak>\n\nOriginally, CAM is released before HW restart only if connection is under\nsecurity. Now, release CAM whatever connection it is to fix leak in (A).\nOTOH, check if CAM is already valid to avoid acquiring multiple times to\nfix (B).\n\nBesides, if AP mode, release address CAM of all stations before HW restart.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f6aff772c9978844529618d86aafb53e5d3ae161",
      "https://git.kernel.org/stable/c/b169f877f001a474fb89939842c390518160bcc5"
    ],
    "受影响版本": [
      "e3ec7017f6a20d12ddd9fe23d345ebb7b8c104dd",
      "e3ec7017f6a20d12ddd9fe23d345ebb7b8c104dd"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49528",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: i2c: dw9714: Disable the regulator when the driver fails to probe\n\nWhen the driver fails to probe, we will get the following splat:\n\n[   59.305988] ------------[ cut here ]------------\n[   59.306417] WARNING: CPU: 2 PID: 395 at drivers/regulator/core.c:2257 _regulator_put+0x3ec/0x4e0\n[   59.310345] RIP: 0010:_regulator_put+0x3ec/0x4e0\n[   59.318362] Call Trace:\n[   59.318582]  <TASK>\n[   59.318765]  regulator_put+0x1f/0x30\n[   59.319058]  devres_release_group+0x319/0x3d0\n[   59.319420]  i2c_device_probe+0x766/0x940\n\nFix this by disabling the regulator in error handling.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fa83ea1de5b3efd87fe01408d5db1fd2ff4767fa",
      "https://git.kernel.org/stable/c/02276e18defa2fccf16413b44440277d98c2b1ea"
    ],
    "受影响版本": [
      "cc95d3423c6786d61e3c52898ed69955077f41a6",
      "cc95d3423c6786d61e3c52898ed69955077f41a6"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49522",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmmc: jz4740: Apply DMA engine limits to maximum segment size\n\nDo what is done in other DMA-enabled MMC host drivers (cf. host/mmci.c) and\nlimit the maximum segment size based on the DMA engine's capabilities. This\nis needed to avoid warnings like the following with CONFIG_DMA_API_DEBUG=y.\n\n------------[ cut here ]------------\nWARNING: CPU: 0 PID: 21 at kernel/dma/debug.c:1162 debug_dma_map_sg+0x2f4/0x39c\nDMA-API: jz4780-dma 13420000.dma-controller: mapping sg segment longer than device claims to support [len=98304] [max=65536]\nCPU: 0 PID: 21 Comm: kworker/0:1H Not tainted 5.18.0-rc1 #19\nWorkqueue: kblockd blk_mq_run_work_fn\nStack : 81575aec 00000004 80620000 80620000 80620000 805e7358 00000009 801537ac\n        814c832c 806276e3 806e34b4 80620000 81575aec 00000001 81575ab8 09291444\n        00000000 00000000 805e7358 81575958 ffffffea 8157596c 00000000 636f6c62\n        6220646b 80387a70 0000000f 6d5f6b6c 80620000 00000000 81575ba4 00000009\n        805e170c 80896640 00000001 00010000 00000000 00000000 00006098 806e0000\n        ...\nCall Trace:\n[<80107670>] show_stack+0x84/0x120\n[<80528cd8>] __warn+0xb8/0xec\n[<80528d78>] warn_slowpath_fmt+0x6c/0xb8\n[<8016f1d4>] debug_dma_map_sg+0x2f4/0x39c\n[<80169d4c>] __dma_map_sg_attrs+0xf0/0x118\n[<8016a27c>] dma_map_sg_attrs+0x14/0x28\n[<804f66b4>] jz4740_mmc_prepare_dma_data+0x74/0xa4\n[<804f6714>] jz4740_mmc_pre_request+0x30/0x54\n[<804f4ff4>] mmc_blk_mq_issue_rq+0x6e0/0x7bc\n[<804f5590>] mmc_mq_queue_rq+0x220/0x2d4\n[<8038b2c0>] blk_mq_dispatch_rq_list+0x480/0x664\n[<80391040>] blk_mq_do_dispatch_sched+0x2dc/0x370\n[<80391468>] __blk_mq_sched_dispatch_requests+0xec/0x164\n[<80391540>] blk_mq_sched_dispatch_requests+0x44/0x94\n[<80387900>] __blk_mq_run_hw_queue+0xb0/0xcc\n[<80134c14>] process_one_work+0x1b8/0x264\n[<80134ff8>] worker_thread+0x2ec/0x3b8\n[<8013b13c>] kthread+0x104/0x10c\n[<80101dcc>] ret_from_kernel_thread+0x14/0x1c\n\n---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7923f95997a79cef2ad161a2facae64c25a0bca0",
      "https://git.kernel.org/stable/c/90281cadf5077f2d2bec8b08c2ead1f8cd12660e",
      "https://git.kernel.org/stable/c/353298cadbd4c7d8e8a16d6000066414694933c3",
      "https://git.kernel.org/stable/c/807f90f1960a59dc557542b818c484a8db9ac978",
      "https://git.kernel.org/stable/c/a828920b9ec0d89d3011198d482b7fe224d2de19",
      "https://git.kernel.org/stable/c/afadb04f1d6e74b18a253403f5274cde5e3fd7bd"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49519",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nath10k: skip ath10k_halt during suspend for driver state RESTARTING\n\nDouble free crash is observed when FW recovery(caused by wmi\ntimeout/crash) is followed by immediate suspend event. The FW recovery\nis triggered by ath10k_core_restart() which calls driver clean up via\nath10k_halt(). When the suspend event occurs between the FW recovery,\nthe restart worker thread is put into frozen state until suspend completes.\nThe suspend event triggers ath10k_stop() which again triggers ath10k_halt()\nThe double invocation of ath10k_halt() causes ath10k_htt_rx_free() to be\ncalled twice(Note: ath10k_htt_rx_alloc was not called by restart worker\nthread because of its frozen state), causing the crash.\n\nTo fix this, during the suspend flow, skip call to ath10k_halt() in\nath10k_stop() when the current driver state is ATH10K_STATE_RESTARTING.\nAlso, for driver state ATH10K_STATE_RESTARTING, call\nath10k_wait_for_suspend() in ath10k_stop(). This is because call to\nath10k_wait_for_suspend() is skipped later in\n[ath10k_halt() > ath10k_core_stop()] for the driver state\nATH10K_STATE_RESTARTING.\n\nThe frozen restart worker thread will be cancelled during resume when the\ndevice comes out of suspend.\n\nBelow is the crash stack for reference:\n\n[  428.469167] ------------[ cut here ]------------\n[  428.469180] kernel BUG at mm/slub.c:4150!\n[  428.469193] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n[  428.469219] Workqueue: events_unbound async_run_entry_fn\n[  428.469230] RIP: 0010:kfree+0x319/0x31b\n[  428.469241] RSP: 0018:ffffa1fac015fc30 EFLAGS: 00010246\n[  428.469247] RAX: ffffedb10419d108 RBX: ffff8c05262b0000\n[  428.469252] RDX: ffff8c04a8c07000 RSI: 0000000000000000\n[  428.469256] RBP: ffffa1fac015fc78 R08: 0000000000000000\n[  428.469276] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  428.469285] Call Trace:\n[  428.469295]  ? dma_free_attrs+0x5f/0x7d\n[  428.469320]  ath10k_core_stop+0x5b/0x6f\n[  428.469336]  ath10k_halt+0x126/0x177\n[  428.469352]  ath10k_stop+0x41/0x7e\n[  428.469387]  drv_stop+0x88/0x10e\n[  428.469410]  __ieee80211_suspend+0x297/0x411\n[  428.469441]  rdev_suspend+0x6e/0xd0\n[  428.469462]  wiphy_suspend+0xb1/0x105\n[  428.469483]  ? name_show+0x2d/0x2d\n[  428.469490]  dpm_run_callback+0x8c/0x126\n[  428.469511]  ? name_show+0x2d/0x2d\n[  428.469517]  __device_suspend+0x2e7/0x41b\n[  428.469523]  async_suspend+0x1f/0x93\n[  428.469529]  async_run_entry_fn+0x3d/0xd1\n[  428.469535]  process_one_work+0x1b1/0x329\n[  428.469541]  worker_thread+0x213/0x372\n[  428.469547]  kthread+0x150/0x15f\n[  428.469552]  ? pr_cont_work+0x58/0x58\n[  428.469558]  ? kthread_blkcg+0x31/0x31\n\nTested-on: QCA6174 hw3.2 PCI WLAN.RM.4.4.1-00288-QCARMSWPZ-1",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8aa3750986ffcf73e0692db3b40dd3a8e8c0c575",
      "https://git.kernel.org/stable/c/c2272428090d0d215a3f017cbbbad731c07eee53",
      "https://git.kernel.org/stable/c/7eb14cb604f49e58b7cf6faa87961a865a3c8649",
      "https://git.kernel.org/stable/c/5321e5211b5dc873e2e3d0deb749e69ecf4dbfe5",
      "https://git.kernel.org/stable/c/b72a4aff947ba807177bdabb43debaf2c66bee05"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49510",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/omap: fix NULL but dereferenced coccicheck error\n\nFix the following coccicheck warning:\n./drivers/gpu/drm/omapdrm/omap_overlay.c:89:22-25: ERROR: r_ovl is NULL\nbut dereferenced.\n\nHere should be ovl->idx rather than r_ovl->idx.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d2507be660310bb9bcca918f81f49b8bba07e462",
      "https://git.kernel.org/stable/c/08d9a75eab594ca508a440db7c73064498d26687",
      "https://git.kernel.org/stable/c/8f2a3970c969d0d8d7289a4c65edcedafc16fd92"
    ],
    "受影响版本": [
      "e02b5cc9e898ad6f223a69df63397beae60390ff",
      "e02b5cc9e898ad6f223a69df63397beae60390ff",
      "e02b5cc9e898ad6f223a69df63397beae60390ff"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49492",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-pci: fix a NULL pointer dereference in nvme_alloc_admin_tags\n\nIn nvme_alloc_admin_tags, the admin_q can be set to an error (typically\n-ENOMEM) if the blk_mq_init_queue call fails to set up the queue, which\nis checked immediately after the call. However, when we return the error\nmessage up the stack, to nvme_reset_work the error takes us to\nnvme_remove_dead_ctrl()\n  nvme_dev_disable()\n   nvme_suspend_queue(&dev->queues[0]).\n\nHere, we only check that the admin_q is non-NULL, rather than not\nan error or NULL, and begin quiescing a queue that never existed, leading\nto bad / NULL pointer dereference.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8321b17789f614414206af07e17ce4751c95dc76",
      "https://git.kernel.org/stable/c/9e649471b396fa0139d53919354ce1eace9b9a24",
      "https://git.kernel.org/stable/c/8da2b7bdb47e94bbc4062a3978c708926bcb022c",
      "https://git.kernel.org/stable/c/f76729662650cd7bc8f8194e057af381370349a7",
      "https://git.kernel.org/stable/c/af98940dd33c9f9e1beb4f71c0a39260100e2a65",
      "https://git.kernel.org/stable/c/906c81dba8ee8057523859b5e1a2479e9fd34860",
      "https://git.kernel.org/stable/c/7a28556082d1fbcbc599baf1c24252dfc73efefc",
      "https://git.kernel.org/stable/c/54a4c1e47d1b2585e74920399455bd9abbfb2bd7",
      "https://git.kernel.org/stable/c/da42761181627e9bdc37d18368b827948a583929"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49474",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: fix dangling sco_conn and use-after-free in sco_sock_timeout\n\nConnecting the same socket twice consecutively in sco_sock_connect()\ncould lead to a race condition where two sco_conn objects are created\nbut only one is associated with the socket. If the socket is closed\nbefore the SCO connection is established, the timer associated with the\ndangling sco_conn object won't be canceled. As the sock object is being\nfreed, the use-after-free problem happens when the timer callback\nfunction sco_sock_timeout() accesses the socket. Here's the call trace:\n\ndump_stack+0x107/0x163\n? refcount_inc+0x1c/\nprint_address_description.constprop.0+0x1c/0x47e\n? refcount_inc+0x1c/0x7b\nkasan_report+0x13a/0x173\n? refcount_inc+0x1c/0x7b\ncheck_memory_region+0x132/0x139\nrefcount_inc+0x1c/0x7b\nsco_sock_timeout+0xb2/0x1ba\nprocess_one_work+0x739/0xbd1\n? cancel_delayed_work+0x13f/0x13f\n? __raw_spin_lock_init+0xf0/0xf0\n? to_kthread+0x59/0x85\nworker_thread+0x593/0x70e\nkthread+0x346/0x35a\n? drain_workqueue+0x31a/0x31a\n? kthread_bind+0x4b/0x4b\nret_from_fork+0x1f/0x30",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9de3dc09e56f8deacd2bdbf4cecb71e11a312405",
      "https://git.kernel.org/stable/c/7d61dbd7311ab978d8ddac1749a758de4de00374",
      "https://git.kernel.org/stable/c/390d82733a953c1fabf3de9c9618091a7a9c90a6",
      "https://git.kernel.org/stable/c/6f55fac0af3531cf60d11369454c41f5fc81ab3f",
      "https://git.kernel.org/stable/c/36c644c63bfcaee2d3a426f45e89a9cd09799318",
      "https://git.kernel.org/stable/c/65d347cb39e2e6bd0c2a745ad7c928998ebb0162",
      "https://git.kernel.org/stable/c/537f619dea4e3fa8ed1f8f938abffe3615794bcc",
      "https://git.kernel.org/stable/c/99df16007f4bbf9abfc3478cb17d10f0d7f8906e",
      "https://git.kernel.org/stable/c/7aa1e7d15f8a5b65f67bacb100d8fc033b21efa2"
    ],
    "受影响版本": [
      "22c66af08230a7030bdb88accffaec3424695631",
      "0115a66ebb44bd9127ccb58cf43ed23c795eb1f0",
      "bc4b08383046f3282b6fa58cfcef05bd13e52b93",
      "5ccb04c6e1fb7b97fa2e1785b67c3a1cb3527ef7",
      "059c2c09f4b7f97711d0d8eaa0b9877f5e7d0a75",
      "e1dee2c1de2b4dd00eb44004a4bda6326ed07b59",
      "e1dee2c1de2b4dd00eb44004a4bda6326ed07b59",
      "e1dee2c1de2b4dd00eb44004a4bda6326ed07b59",
      "e1dee2c1de2b4dd00eb44004a4bda6326ed07b59",
      "98ae477ed1540d3acbbf44d88ee237ad64275158",
      "f0c389e23e2475e5837716a629c81b7a9d90cc94",
      "0b9da4bde0d59c61b3675bdd80a05a726beb875a"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49460",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nPM / devfreq: rk3399_dmc: Disable edev on remove()\n\nOtherwise we hit an unablanced enable-count when unbinding the DFI\ndevice:\n\n[ 1279.659119] ------------[ cut here ]------------\n[ 1279.659179] WARNING: CPU: 2 PID: 5638 at drivers/devfreq/devfreq-event.c:360 devfreq_event_remove_edev+0x84/0x8c\n...\n[ 1279.659352] Hardware name: Google Kevin (DT)\n[ 1279.659363] pstate: 80400005 (Nzcv daif +PAN -UAO -TCO BTYPE=--)\n[ 1279.659371] pc : devfreq_event_remove_edev+0x84/0x8c\n[ 1279.659380] lr : devm_devfreq_event_release+0x1c/0x28\n...\n[ 1279.659571] Call trace:\n[ 1279.659582]  devfreq_event_remove_edev+0x84/0x8c\n[ 1279.659590]  devm_devfreq_event_release+0x1c/0x28\n[ 1279.659602]  release_nodes+0x1cc/0x244\n[ 1279.659611]  devres_release_all+0x44/0x60\n[ 1279.659621]  device_release_driver_internal+0x11c/0x1ac\n[ 1279.659629]  device_driver_detach+0x20/0x2c\n[ 1279.659641]  unbind_store+0x7c/0xb0\n[ 1279.659650]  drv_attr_store+0x2c/0x40\n[ 1279.659663]  sysfs_kf_write+0x44/0x58\n[ 1279.659672]  kernfs_fop_write_iter+0xf4/0x190\n[ 1279.659684]  vfs_write+0x2b0/0x2e4\n[ 1279.659693]  ksys_write+0x80/0xec\n[ 1279.659701]  __arm64_sys_write+0x24/0x30\n[ 1279.659714]  el0_svc_common+0xf0/0x1d8\n[ 1279.659724]  do_el0_svc_compat+0x28/0x3c\n[ 1279.659738]  el0_svc_compat+0x10/0x1c\n[ 1279.659746]  el0_sync_compat_handler+0xa8/0xcc\n[ 1279.659758]  el0_sync_compat+0x188/0x1c0\n[ 1279.659768] ---[ end trace cec200e5094155b4 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/664736e2cc09e504ce58ec61164d029d1f2651bb",
      "https://git.kernel.org/stable/c/a0180e324a9a63de8f770da300477b48cb4a53f1",
      "https://git.kernel.org/stable/c/86b091b6894c449d2734de7aa7d79ccb33ffd97d",
      "https://git.kernel.org/stable/c/cb1be1d4be18fe286ba5a67d928598378fd7fbe5",
      "https://git.kernel.org/stable/c/fb089b6f21de03a685dd31df3789bbb01c59f8e3",
      "https://git.kernel.org/stable/c/a9c2b23a7ac6ab19214cad8cac8af8608a4d9cef",
      "https://git.kernel.org/stable/c/2fccf9e6050e0e3b8b4cd275d41daf7f7fa22804"
    ],
    "受影响版本": [
      "5a893e31a636cca3798af2db5aee8d3d144b1e1e",
      "5a893e31a636cca3798af2db5aee8d3d144b1e1e",
      "5a893e31a636cca3798af2db5aee8d3d144b1e1e",
      "5a893e31a636cca3798af2db5aee8d3d144b1e1e",
      "5a893e31a636cca3798af2db5aee8d3d144b1e1e",
      "5a893e31a636cca3798af2db5aee8d3d144b1e1e",
      "5a893e31a636cca3798af2db5aee8d3d144b1e1e"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49458",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/msm: don't free the IRQ if it was not requested\n\nAs msm_drm_uninit() is called from the msm_drm_init() error path,\nadditional care should be necessary as not to call the free_irq() for\nthe IRQ that was not requested before (because an error occured earlier\nthan the request_irq() call).\n\nThis fixed the issue reported with the following backtrace:\n\n[    8.571329] Trying to free already-free IRQ 187\n[    8.571339] WARNING: CPU: 0 PID: 76 at kernel/irq/manage.c:1895 free_irq+0x1e0/0x35c\n[    8.588746] Modules linked in: pmic_glink pdr_interface fastrpc qrtr_smd snd_soc_hdmi_codec msm fsa4480 gpu_sched drm_dp_aux_bus qrtr i2c_qcom_geni crct10dif_ce qcom_stats qcom_q6v5_pas drm_display_helper gpi qcom_pil_info drm_kms_helper qcom_q6v5 qcom_sysmon qcom_common qcom_glink_smem qcom_rng mdt_loader qmi_helpers phy_qcom_qmp ufs_qcom typec qnoc_sm8350 socinfo rmtfs_mem fuse drm ipv6\n[    8.624154] CPU: 0 PID: 76 Comm: kworker/u16:2 Not tainted 5.18.0-rc5-next-20220506-00033-g6cee8cab6089-dirty #419\n[    8.624161] Hardware name: Qualcomm Technologies, Inc. SM8350 HDK (DT)\n[    8.641496] Workqueue: events_unbound deferred_probe_work_func\n[    8.647510] pstate: 604000c5 (nZCv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    8.654681] pc : free_irq+0x1e0/0x35c\n[    8.658454] lr : free_irq+0x1e0/0x35c\n[    8.662228] sp : ffff800008ab3950\n[    8.665642] x29: ffff800008ab3950 x28: 0000000000000000 x27: ffff16350f56a700\n[    8.672994] x26: ffff1635025df080 x25: ffff16350251badc x24: ffff16350251bb90\n[    8.680343] x23: 0000000000000000 x22: 00000000000000bb x21: ffff16350e8f9800\n[    8.687690] x20: ffff16350251ba00 x19: ffff16350cbd5880 x18: ffffffffffffffff\n[    8.695039] x17: 0000000000000000 x16: ffffa2dd12179434 x15: ffffa2dd1431d02d\n[    8.702391] x14: 0000000000000000 x13: ffffa2dd1431d028 x12: 662d79646165726c\n[    8.709740] x11: ffffa2dd13fd2438 x10: 000000000000000a x9 : 00000000000000bb\n[    8.717111] x8 : ffffa2dd13fd23f0 x7 : ffff800008ab3750 x6 : 00000000fffff202\n[    8.724487] x5 : ffff16377e870a18 x4 : 00000000fffff202 x3 : ffff735a6ae1b000\n[    8.731851] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff1635015f8000\n[    8.739217] Call trace:\n[    8.741755]  free_irq+0x1e0/0x35c\n[    8.745198]  msm_drm_uninit.isra.0+0x14c/0x294 [msm]\n[    8.750548]  msm_drm_bind+0x28c/0x5d0 [msm]\n[    8.755081]  try_to_bring_up_aggregate_device+0x164/0x1d0\n[    8.760657]  __component_add+0xa0/0x170\n[    8.764626]  component_add+0x14/0x20\n[    8.768337]  dp_display_probe+0x2a4/0x464 [msm]\n[    8.773242]  platform_probe+0x68/0xe0\n[    8.777043]  really_probe.part.0+0x9c/0x28c\n[    8.781368]  __driver_probe_device+0x98/0x144\n[    8.785871]  driver_probe_device+0x40/0x140\n[    8.790191]  __device_attach_driver+0xb4/0x120\n[    8.794788]  bus_for_each_drv+0x78/0xd0\n[    8.798751]  __device_attach+0xdc/0x184\n[    8.802713]  device_initial_probe+0x14/0x20\n[    8.807031]  bus_probe_device+0x9c/0xa4\n[    8.810991]  deferred_probe_work_func+0x88/0xc0\n[    8.815667]  process_one_work+0x1d0/0x320\n[    8.819809]  worker_thread+0x14c/0x444\n[    8.823688]  kthread+0x10c/0x110\n[    8.827036]  ret_from_fork+0x10/0x20\n\nPatchwork: https://patchwork.freedesktop.org/patch/485422/",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/beb81c13d020ceb7f8693e65464162e5f249218e",
      "https://git.kernel.org/stable/c/b288ec4439c1dad304c1862bf6b0be78d9b1b2b2",
      "https://git.kernel.org/stable/c/59023c4fb1ab3de0fa001681650f662c253c7fd7",
      "https://git.kernel.org/stable/c/577e2a9dfc8fba7938aaf75db63fae7e328cc3cb"
    ],
    "受影响版本": [
      "f026e431cf861197dc03217d1920b38b80b31dd9",
      "f026e431cf861197dc03217d1920b38b80b31dd9",
      "f026e431cf861197dc03217d1920b38b80b31dd9",
      "f026e431cf861197dc03217d1920b38b80b31dd9"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49440",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/rtas: Keep MSR[RI] set when calling RTAS\n\nRTAS runs in real mode (MSR[DR] and MSR[IR] unset) and in 32-bit big\nendian mode (MSR[SF,LE] unset).\n\nThe change in MSR is done in enter_rtas() in a relatively complex way,\nsince the MSR value could be hardcoded.\n\nFurthermore, a panic has been reported when hitting the watchdog interrupt\nwhile running in RTAS, this leads to the following stack trace:\n\n  watchdog: CPU 24 Hard LOCKUP\n  watchdog: CPU 24 TB:997512652051031, last heartbeat TB:997504470175378 (15980ms ago)\n  ...\n  Supported: No, Unreleased kernel\n  CPU: 24 PID: 87504 Comm: drmgr Kdump: loaded Tainted: G            E  X    5.14.21-150400.71.1.bz196362_2-default #1 SLE15-SP4 (unreleased) 0d821077ef4faa8dfaf370efb5fdca1fa35f4e2c\n  NIP:  000000001fb41050 LR: 000000001fb4104c CTR: 0000000000000000\n  REGS: c00000000fc33d60 TRAP: 0100   Tainted: G            E  X     (5.14.21-150400.71.1.bz196362_2-default)\n  MSR:  8000000002981000 <SF,VEC,VSX,ME>  CR: 48800002  XER: 20040020\n  CFAR: 000000000000011c IRQMASK: 1\n  GPR00: 0000000000000003 ffffffffffffffff 0000000000000001 00000000000050dc\n  GPR04: 000000001ffb6100 0000000000000020 0000000000000001 000000001fb09010\n  GPR08: 0000000020000000 0000000000000000 0000000000000000 0000000000000000\n  GPR12: 80040000072a40a8 c00000000ff8b680 0000000000000007 0000000000000034\n  GPR16: 000000001fbf6e94 000000001fbf6d84 000000001fbd1db0 000000001fb3f008\n  GPR20: 000000001fb41018 ffffffffffffffff 000000000000017f fffffffffffff68f\n  GPR24: 000000001fb18fe8 000000001fb3e000 000000001fb1adc0 000000001fb1cf40\n  GPR28: 000000001fb26000 000000001fb460f0 000000001fb17f18 000000001fb17000\n  NIP [000000001fb41050] 0x1fb41050\n  LR [000000001fb4104c] 0x1fb4104c\n  Call Trace:\n  Instruction dump:\n  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n  Oops: Unrecoverable System Reset, sig: 6 [#1]\n  LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries\n  ...\n  Supported: No, Unreleased kernel\n  CPU: 24 PID: 87504 Comm: drmgr Kdump: loaded Tainted: G            E  X    5.14.21-150400.71.1.bz196362_2-default #1 SLE15-SP4 (unreleased) 0d821077ef4faa8dfaf370efb5fdca1fa35f4e2c\n  NIP:  000000001fb41050 LR: 000000001fb4104c CTR: 0000000000000000\n  REGS: c00000000fc33d60 TRAP: 0100   Tainted: G            E  X     (5.14.21-150400.71.1.bz196362_2-default)\n  MSR:  8000000002981000 <SF,VEC,VSX,ME>  CR: 48800002  XER: 20040020\n  CFAR: 000000000000011c IRQMASK: 1\n  GPR00: 0000000000000003 ffffffffffffffff 0000000000000001 00000000000050dc\n  GPR04: 000000001ffb6100 0000000000000020 0000000000000001 000000001fb09010\n  GPR08: 0000000020000000 0000000000000000 0000000000000000 0000000000000000\n  GPR12: 80040000072a40a8 c00000000ff8b680 0000000000000007 0000000000000034\n  GPR16: 000000001fbf6e94 000000001fbf6d84 000000001fbd1db0 000000001fb3f008\n  GPR20: 000000001fb41018 ffffffffffffffff 000000000000017f fffffffffffff68f\n  GPR24: 000000001fb18fe8 000000001fb3e000 000000001fb1adc0 000000001fb1cf40\n  GPR28: 000000001fb26000 000000001fb460f0 000000001fb17f18 000000001fb17000\n  NIP [000000001fb41050] 0x1fb41050\n  LR [000000001fb4104c] 0x1fb4104c\n  Call Trace:\n  Instruction dump:\n  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n  ---[ end trace 3ddec07f638c34a2 ]---\n\nThis happens because MSR[RI] is unset when entering RTAS but there is no\nvalid reason to not set it here.\n\nRTAS is expected to be called with MSR[RI] as specified in PAPR+ section\n\"7.2.1 Machine State\":\n\n  R1–7.2.1–9. If called with MSR[RI] equal to 1, then RTAS must protect\n  its own critical regions from recursion by setting the MSR[RI] bit to\n  0 when in the critical regions.\n\nFixing this by reviewing the way MSR is compute before calling RTAS. Now a\nhardcoded value meaning real \n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5ca40fcf0da0ce2b5bc44e7d8b036535955f2e3d",
      "https://git.kernel.org/stable/c/5f4367448f6817c8a0e94dc9736ed84fa8eee4a3",
      "https://git.kernel.org/stable/c/c9c41f0273826a13ac93124e66a4ff45df281ba0",
      "https://git.kernel.org/stable/c/b6b1c3ce06ca438eb24e0f45bf0e63ecad0369f5"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49430",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nInput: gpio-keys - cancel delayed work only in case of GPIO\n\ngpio_keys module can either accept gpios or interrupts. The module\ninitializes delayed work in case of gpios only and is only used if\ndebounce timer is not used, so make sure cancel_delayed_work_sync()\nis called only when its gpio-backed and debounce_use_hrtimer is false.\n\nThis fixes the issue seen below when the gpio_keys module is unloaded and\nan interrupt pin is used instead of GPIO:\n\n[  360.297569] ------------[ cut here ]------------\n[  360.302303] WARNING: CPU: 0 PID: 237 at kernel/workqueue.c:3066 __flush_work+0x414/0x470\n[  360.310531] Modules linked in: gpio_keys(-)\n[  360.314797] CPU: 0 PID: 237 Comm: rmmod Not tainted 5.18.0-rc5-arm64-renesas-00116-g73636105874d-dirty #166\n[  360.324662] Hardware name: Renesas SMARC EVK based on r9a07g054l2 (DT)\n[  360.331270] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  360.338318] pc : __flush_work+0x414/0x470\n[  360.342385] lr : __cancel_work_timer+0x140/0x1b0\n[  360.347065] sp : ffff80000a7fba00\n[  360.350423] x29: ffff80000a7fba00 x28: ffff000012b9c5c0 x27: 0000000000000000\n[  360.357664] x26: ffff80000a7fbb80 x25: ffff80000954d0a8 x24: 0000000000000001\n[  360.364904] x23: ffff800009757000 x22: 0000000000000000 x21: ffff80000919b000\n[  360.372143] x20: ffff00000f5974e0 x19: ffff00000f5974e0 x18: ffff8000097fcf48\n[  360.379382] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000053f40\n[  360.386622] x14: ffff800009850e88 x13: 0000000000000002 x12: 000000000000a60c\n[  360.393861] x11: 000000000000a610 x10: 0000000000000000 x9 : 0000000000000008\n[  360.401100] x8 : 0101010101010101 x7 : 00000000a473c394 x6 : 0080808080808080\n[  360.408339] x5 : 0000000000000001 x4 : 0000000000000000 x3 : ffff80000919b458\n[  360.415578] x2 : ffff8000097577f0 x1 : 0000000000000001 x0 : 0000000000000000\n[  360.422818] Call trace:\n[  360.425299]  __flush_work+0x414/0x470\n[  360.429012]  __cancel_work_timer+0x140/0x1b0\n[  360.433340]  cancel_delayed_work_sync+0x10/0x18\n[  360.437931]  gpio_keys_quiesce_key+0x28/0x58 [gpio_keys]\n[  360.443327]  devm_action_release+0x10/0x18\n[  360.447481]  release_nodes+0x8c/0x1a0\n[  360.451194]  devres_release_all+0x90/0x100\n[  360.455346]  device_unbind_cleanup+0x14/0x60\n[  360.459677]  device_release_driver_internal+0xe8/0x168\n[  360.464883]  driver_detach+0x4c/0x90\n[  360.468509]  bus_remove_driver+0x54/0xb0\n[  360.472485]  driver_unregister+0x2c/0x58\n[  360.476462]  platform_driver_unregister+0x10/0x18\n[  360.481230]  gpio_keys_exit+0x14/0x828 [gpio_keys]\n[  360.486088]  __arm64_sys_delete_module+0x1e0/0x270\n[  360.490945]  invoke_syscall+0x40/0xf8\n[  360.494661]  el0_svc_common.constprop.3+0xf0/0x110\n[  360.499515]  do_el0_svc+0x20/0x78\n[  360.502877]  el0_svc+0x48/0xf8\n[  360.505977]  el0t_64_sync_handler+0x88/0xb0\n[  360.510216]  el0t_64_sync+0x148/0x14c\n[  360.513930] irq event stamp: 4306\n[  360.517288] hardirqs last  enabled at (4305): [<ffff8000080b0300>] __cancel_work_timer+0x130/0x1b0\n[  360.526359] hardirqs last disabled at (4306): [<ffff800008d194fc>] el1_dbg+0x24/0x88\n[  360.534204] softirqs last  enabled at (4278): [<ffff8000080104a0>] _stext+0x4a0/0x5e0\n[  360.542133] softirqs last disabled at (4267): [<ffff8000080932ac>] irq_exit_rcu+0x18c/0x1b0\n[  360.550591] ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/96c460687813915dedca9dd7d04ae0e90607fd79",
      "https://git.kernel.org/stable/c/4160e09619086fc155b51ccdb3462a3f233a5f4b",
      "https://git.kernel.org/stable/c/8b1ae300c2953257c146b5f0757537935c0b6027",
      "https://git.kernel.org/stable/c/cee409bbba0d1bd3fb73064fb480ff365f453b5d"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49427",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/mediatek: Remove clk_disable in mtk_iommu_remove\n\nAfter the commit b34ea31fe013 (\"iommu/mediatek: Always enable the clk on\nresume\"), the iommu clock is controlled by the runtime callback.\nthus remove the clk control in the mtk_iommu_remove.\n\nOtherwise, it will warning like:\n\necho 14018000.iommu > /sys/bus/platform/drivers/mtk-iommu/unbind\n\n[   51.413044] ------------[ cut here ]------------\n[   51.413648] vpp0_smi_iommu already disabled\n[   51.414233] WARNING: CPU: 2 PID: 157 at */v5.15-rc1/kernel/mediatek/\n                          drivers/clk/clk.c:952 clk_core_disable+0xb0/0xb8\n[   51.417174] Hardware name: MT8195V/C(ENG) (DT)\n[   51.418635] pc : clk_core_disable+0xb0/0xb8\n[   51.419177] lr : clk_core_disable+0xb0/0xb8\n...\n[   51.429375] Call trace:\n[   51.429694]  clk_core_disable+0xb0/0xb8\n[   51.430193]  clk_core_disable_lock+0x24/0x40\n[   51.430745]  clk_disable+0x20/0x30\n[   51.431189]  mtk_iommu_remove+0x58/0x118\n[   51.431705]  platform_remove+0x28/0x60\n[   51.432197]  device_release_driver_internal+0x110/0x1f0\n[   51.432873]  device_driver_detach+0x18/0x28\n[   51.433418]  unbind_store+0xd4/0x108\n[   51.433886]  drv_attr_store+0x24/0x38\n[   51.434363]  sysfs_kf_write+0x40/0x58\n[   51.434843]  kernfs_fop_write_iter+0x164/0x1e0",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/053465ab20dcd324a43a1811ee98e5721e6a3e65",
      "https://git.kernel.org/stable/c/9b3bd97acb4f8954b8a43a5d63ed9050d463b4e1",
      "https://git.kernel.org/stable/c/6eaa046c696c83542c56765cdde564d9818ff1fb",
      "https://git.kernel.org/stable/c/98df772bdd1c4ce717a26289efea15cbbe4b64ed"
    ],
    "受影响版本": [
      "b34ea31fe013569d42b7e8681ef3f717f77c5b72",
      "b34ea31fe013569d42b7e8681ef3f717f77c5b72",
      "b34ea31fe013569d42b7e8681ef3f717f77c5b72",
      "b34ea31fe013569d42b7e8681ef3f717f77c5b72",
      "5cad9e2caa9613fdcd246bd4ebf0ffbec1cba2ca"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49401",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/page_owner: use strscpy() instead of strlcpy()\n\ncurrent->comm[] is not a string (no guarantee for a zero byte in it).\n\nstrlcpy(s1, s2, l) is calling strlen(s2), potentially\ncausing out-of-bound access, as reported by syzbot:\n\ndetected buffer overflow in __fortify_strlen\n------------[ cut here ]------------\nkernel BUG at lib/string_helpers.c:980!\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN\nCPU: 0 PID: 4087 Comm: dhcpcd-run-hooks Not tainted 5.18.0-rc3-syzkaller-01537-g20b87e7c29df #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:fortify_panic+0x18/0x1a lib/string_helpers.c:980\nCode: 8c e8 c5 ba e1 fa e9 23 0f bf fa e8 0b 5d 8c f8 eb db 55 48 89 fd e8 e0 49 40 f8 48 89 ee 48 c7 c7 80 f5 26 8a e8 99 09 f1 ff <0f> 0b e8 ca 49 40 f8 48 8b 54 24 18 4c 89 f1 48 c7 c7 00 00 27 8a\nRSP: 0018:ffffc900000074a8 EFLAGS: 00010286\n\nRAX: 000000000000002c RBX: ffff88801226b728 RCX: 0000000000000000\nRDX: ffff8880198e0000 RSI: ffffffff81600458 RDI: fffff52000000e87\nRBP: ffffffff89da2aa0 R08: 000000000000002c R09: 0000000000000000\nR10: ffffffff815fae2e R11: 0000000000000000 R12: ffff88801226b700\nR13: ffff8880198e0830 R14: 0000000000000000 R15: 0000000000000000\nFS:  0000000000000000(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f5876ad6ff8 CR3: 000000001a48c000 CR4: 00000000003506f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nCall Trace:\n <IRQ>\n __fortify_strlen include/linux/fortify-string.h:128 [inline]\n strlcpy include/linux/fortify-string.h:143 [inline]\n __set_page_owner_handle+0x2b1/0x3e0 mm/page_owner.c:171\n __set_page_owner+0x3e/0x50 mm/page_owner.c:190\n prep_new_page mm/page_alloc.c:2441 [inline]\n get_page_from_freelist+0xba2/0x3e00 mm/page_alloc.c:4182\n __alloc_pages+0x1b2/0x500 mm/page_alloc.c:5408\n alloc_pages+0x1aa/0x310 mm/mempolicy.c:2272\n alloc_slab_page mm/slub.c:1799 [inline]\n allocate_slab+0x26c/0x3c0 mm/slub.c:1944\n new_slab mm/slub.c:2004 [inline]\n ___slab_alloc+0x8df/0xf20 mm/slub.c:3005\n __slab_alloc.constprop.0+0x4d/0xa0 mm/slub.c:3092\n slab_alloc_node mm/slub.c:3183 [inline]\n slab_alloc mm/slub.c:3225 [inline]\n __kmem_cache_alloc_lru mm/slub.c:3232 [inline]\n kmem_cache_alloc+0x360/0x3b0 mm/slub.c:3242\n dst_alloc+0x146/0x1f0 net/core/dst.c:92",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5cd9900a1ac8b0a4ff3cd97d4d77b7711be435bf",
      "https://git.kernel.org/stable/c/cd8c1fd8cdd14158f2d8bea2d1bfe8015dccfa3a"
    ],
    "受影响版本": [
      "865ed6a3278654ce4a55eb74c5283eeb82ad4699",
      "865ed6a3278654ce4a55eb74c5283eeb82ad4699"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49378",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsfc: fix considering that all channels have TX queues\n\nNormally, all channels have RX and TX queues, but this is not true if\nmodparam efx_separate_tx_channels=1 is used. In that cases, some\nchannels only have RX queues and others only TX queues (or more\npreciselly, they have them allocated, but not initialized).\n\nFix efx_channel_has_tx_queues to return the correct value for this case\ntoo.\n\nMessages shown at probe time before the fix:\n sfc 0000:03:00.0 ens6f0np0: MC command 0x82 inlen 544 failed rc=-22 (raw=0) arg=0\n ------------[ cut here ]------------\n netdevice: ens6f0np0: failed to initialise TXQ -1\n WARNING: CPU: 1 PID: 626 at drivers/net/ethernet/sfc/ef10.c:2393 efx_ef10_tx_init+0x201/0x300 [sfc]\n [...] stripped\n RIP: 0010:efx_ef10_tx_init+0x201/0x300 [sfc]\n [...] stripped\n Call Trace:\n  efx_init_tx_queue+0xaa/0xf0 [sfc]\n  efx_start_channels+0x49/0x120 [sfc]\n  efx_start_all+0x1f8/0x430 [sfc]\n  efx_net_open+0x5a/0xe0 [sfc]\n  __dev_open+0xd0/0x190\n  __dev_change_flags+0x1b3/0x220\n  dev_change_flags+0x21/0x60\n [...] stripped\n\nMessages shown at remove time before the fix:\n sfc 0000:03:00.0 ens6f0np0: failed to flush 10 queues\n sfc 0000:03:00.0 ens6f0np0: failed to flush queues",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8f81a4113e1e574d2cbde4f2cd599380a9189c0f",
      "https://git.kernel.org/stable/c/5567d69b95b9c07e1c56f15cf0301251d12e5f97",
      "https://git.kernel.org/stable/c/e7e8d5e25dc762b70f9c88ec6b7d451d0816eead",
      "https://git.kernel.org/stable/c/913d45f02d346ce41c4aad057eaf53a8ed449dc3",
      "https://git.kernel.org/stable/c/2e102b53f8a778f872dc137f4c7ac548705817aa"
    ],
    "受影响版本": [
      "8700aff089843399f95bc7701ae87b642b35a716",
      "8700aff089843399f95bc7701ae87b642b35a716",
      "8700aff089843399f95bc7701ae87b642b35a716",
      "8700aff089843399f95bc7701ae87b642b35a716",
      "8700aff089843399f95bc7701ae87b642b35a716"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49357",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nefi: Do not import certificates from UEFI Secure Boot for T2 Macs\n\nOn Apple T2 Macs, when Linux attempts to read the db and dbx efi variables\nat early boot to load UEFI Secure Boot certificates, a page fault occurs\nin Apple firmware code and EFI runtime services are disabled with the\nfollowing logs:\n\n[Firmware Bug]: Page fault caused by firmware at PA: 0xffffb1edc0068000\nWARNING: CPU: 3 PID: 104 at arch/x86/platform/efi/quirks.c:735 efi_crash_gracefully_on_page_fault+0x50/0xf0\n(Removed some logs from here)\nCall Trace:\n <TASK>\n page_fault_oops+0x4f/0x2c0\n ? search_bpf_extables+0x6b/0x80\n ? search_module_extables+0x50/0x80\n ? search_exception_tables+0x5b/0x60\n kernelmode_fixup_or_oops+0x9e/0x110\n __bad_area_nosemaphore+0x155/0x190\n bad_area_nosemaphore+0x16/0x20\n do_kern_addr_fault+0x8c/0xa0\n exc_page_fault+0xd8/0x180\n asm_exc_page_fault+0x1e/0x30\n(Removed some logs from here)\n ? __efi_call+0x28/0x30\n ? switch_mm+0x20/0x30\n ? efi_call_rts+0x19a/0x8e0\n ? process_one_work+0x222/0x3f0\n ? worker_thread+0x4a/0x3d0\n ? kthread+0x17a/0x1a0\n ? process_one_work+0x3f0/0x3f0\n ? set_kthread_struct+0x40/0x40\n ? ret_from_fork+0x22/0x30\n </TASK>\n---[ end trace 1f82023595a5927f ]---\nefi: Froze efi_rts_wq and disabled EFI Runtime Services\nintegrity: Couldn't get size: 0x8000000000000015\nintegrity: MODSIGN: Couldn't get UEFI db list\nefi: EFI Runtime Services are disabled!\nintegrity: Couldn't get size: 0x8000000000000015\nintegrity: Couldn't get UEFI dbx list\nintegrity: Couldn't get size: 0x8000000000000015\nintegrity: Couldn't get mokx list\nintegrity: Couldn't get size: 0x80000000\n\nSo we avoid reading these UEFI variables and thus prevent the crash.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b1cda6dd2c44771f042d65f0d17bec322ef99a0a",
      "https://git.kernel.org/stable/c/c072cab98bac11f6ef9db640fb51834d9552e2e6",
      "https://git.kernel.org/stable/c/65237307f88f5200782ae7f243bdd385e37cde5d",
      "https://git.kernel.org/stable/c/b34786b25d75f9c119696e6bdf3827f54ae3601b",
      "https://git.kernel.org/stable/c/1f7264f0510f519b4e4f575a8f0579ea65e7592e",
      "https://git.kernel.org/stable/c/155ca952c7ca19aa32ecfb7373a32bbc2e1ec6eb"
    ],
    "受影响版本": [
      "15ea0e1e3e185040bed6119f815096f2e4326242",
      "15ea0e1e3e185040bed6119f815096f2e4326242",
      "15ea0e1e3e185040bed6119f815096f2e4326242",
      "15ea0e1e3e185040bed6119f815096f2e4326242",
      "15ea0e1e3e185040bed6119f815096f2e4326242",
      "15ea0e1e3e185040bed6119f815096f2e4326242"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49352",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix warning in ext4_handle_inode_extension\n\nWe got issue as follows:\nEXT4-fs error (device loop0) in ext4_reserve_inode_write:5741: Out of memory\nEXT4-fs error (device loop0): ext4_setattr:5462: inode #13: comm syz-executor.0: mark_inode_dirty error\nEXT4-fs error (device loop0) in ext4_setattr:5519: Out of memory\nEXT4-fs error (device loop0): ext4_ind_map_blocks:595: inode #13: comm syz-executor.0: Can't allocate blocks for non-extent mapped inodes with bigalloc\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 4361 at fs/ext4/file.c:301 ext4_file_write_iter+0x11c9/0x1220\nModules linked in:\nCPU: 1 PID: 4361 Comm: syz-executor.0 Not tainted 5.10.0+ #1\nRIP: 0010:ext4_file_write_iter+0x11c9/0x1220\nRSP: 0018:ffff924d80b27c00 EFLAGS: 00010282\nRAX: ffffffff815a3379 RBX: 0000000000000000 RCX: 000000003b000000\nRDX: ffff924d81601000 RSI: 00000000000009cc RDI: 00000000000009cd\nRBP: 000000000000000d R08: ffffffffbc5a2c6b R09: 0000902e0e52a96f\nR10: ffff902e2b7c1b40 R11: ffff902e2b7c1b40 R12: 000000000000000a\nR13: 0000000000000001 R14: ffff902e0e52aa10 R15: ffffffffffffff8b\nFS:  00007f81a7f65700(0000) GS:ffff902e3bc80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffffffff600400 CR3: 000000012db88001 CR4: 00000000003706e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n do_iter_readv_writev+0x2e5/0x360\n do_iter_write+0x112/0x4c0\n do_pwritev+0x1e5/0x390\n __x64_sys_pwritev2+0x7e/0xa0\n do_syscall_64+0x37/0x50\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nAbove issue may happen as follows:\nAssume\ninode.i_size=4096\nEXT4_I(inode)->i_disksize=4096\n\nstep 1: set inode->i_isize = 8192\next4_setattr\n  if (attr->ia_size != inode->i_size)\n    EXT4_I(inode)->i_disksize = attr->ia_size;\n    rc = ext4_mark_inode_dirty\n       ext4_reserve_inode_write\n          ext4_get_inode_loc\n            __ext4_get_inode_loc\n              sb_getblk --> return -ENOMEM\n   ...\n   if (!error)  ->will not update i_size\n     i_size_write(inode, attr->ia_size);\nNow:\ninode.i_size=4096\nEXT4_I(inode)->i_disksize=8192\n\nstep 2: Direct write 4096 bytes\next4_file_write_iter\n ext4_dio_write_iter\n   iomap_dio_rw ->return error\n if (extend)\n   ext4_handle_inode_extension\n     WARN_ON_ONCE(i_size_read(inode) < EXT4_I(inode)->i_disksize);\n->Then trigger warning.\n\nTo solve above issue, if mark inode dirty failed in ext4_setattr just\nset 'EXT4_I(inode)->i_disksize' with old value.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/adf490083ca52ebfb0b2fe64ff1ead00c0452dd7",
      "https://git.kernel.org/stable/c/b81d2ff6885e38fc745eeaf9565775055778fc0b",
      "https://git.kernel.org/stable/c/e383c2aa5f02ab571530dc5c5696479672478c25",
      "https://git.kernel.org/stable/c/1bcce88da60eccc946c0f4ed942b0f08cd565778",
      "https://git.kernel.org/stable/c/f4534c9fc94d22383f187b9409abb3f9df2e3db3"
    ],
    "受影响版本": [
      "b1b4705d54abedfd69dcdf42779c521aa1e0fbd3",
      "b1b4705d54abedfd69dcdf42779c521aa1e0fbd3",
      "b1b4705d54abedfd69dcdf42779c521aa1e0fbd3",
      "b1b4705d54abedfd69dcdf42779c521aa1e0fbd3",
      "b1b4705d54abedfd69dcdf42779c521aa1e0fbd3"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49347",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix bug_on in ext4_writepages\n\nwe got issue as follows:\nEXT4-fs error (device loop0): ext4_mb_generate_buddy:1141: group 0, block bitmap and bg descriptor inconsistent: 25 vs 31513 free cls\n------------[ cut here ]------------\nkernel BUG at fs/ext4/inode.c:2708!\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN PTI\nCPU: 2 PID: 2147 Comm: rep Not tainted 5.18.0-rc2-next-20220413+ #155\nRIP: 0010:ext4_writepages+0x1977/0x1c10\nRSP: 0018:ffff88811d3e7880 EFLAGS: 00010246\nRAX: 0000000000000000 RBX: 0000000000000001 RCX: ffff88811c098000\nRDX: 0000000000000000 RSI: ffff88811c098000 RDI: 0000000000000002\nRBP: ffff888128140f50 R08: ffffffffb1ff6387 R09: 0000000000000000\nR10: 0000000000000007 R11: ffffed10250281ea R12: 0000000000000001\nR13: 00000000000000a4 R14: ffff88811d3e7bb8 R15: ffff888128141028\nFS:  00007f443aed9740(0000) GS:ffff8883aef00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020007200 CR3: 000000011c2a4000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <TASK>\n do_writepages+0x130/0x3a0\n filemap_fdatawrite_wbc+0x83/0xa0\n filemap_flush+0xab/0xe0\n ext4_alloc_da_blocks+0x51/0x120\n __ext4_ioctl+0x1534/0x3210\n __x64_sys_ioctl+0x12c/0x170\n do_syscall_64+0x3b/0x90\n\nIt may happen as follows:\n1. write inline_data inode\nvfs_write\n  new_sync_write\n    ext4_file_write_iter\n      ext4_buffered_write_iter\n        generic_perform_write\n          ext4_da_write_begin\n            ext4_da_write_inline_data_begin -> If inline data size too\n            small will allocate block to write, then mapping will has\n            dirty page\n                ext4_da_convert_inline_data_to_extent ->clear EXT4_STATE_MAY_INLINE_DATA\n2. fallocate\ndo_vfs_ioctl\n  ioctl_preallocate\n    vfs_fallocate\n      ext4_fallocate\n        ext4_convert_inline_data\n          ext4_convert_inline_data_nolock\n            ext4_map_blocks -> fail will goto restore data\n            ext4_restore_inline_data\n              ext4_create_inline_data\n              ext4_write_inline_data\n              ext4_set_inode_state -> set inode EXT4_STATE_MAY_INLINE_DATA\n3. writepages\n__ext4_ioctl\n  ext4_alloc_da_blocks\n    filemap_flush\n      filemap_fdatawrite_wbc\n        do_writepages\n          ext4_writepages\n            if (ext4_has_inline_data(inode))\n              BUG_ON(ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))\n\nThe root cause of this issue is we destory inline data until call\next4_writepages under delay allocation mode.  But there maybe already\nconvert from inline to extent.  To solve this issue, we call\nfilemap_flush first..",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/19918ec7717d87d5ab825884a46b26b21375d7ce",
      "https://git.kernel.org/stable/c/b2b78f5bf2d453dda3903955efee059260787a42",
      "https://git.kernel.org/stable/c/de1732b5c1693ad489c5d254f124f67cb775f37d",
      "https://git.kernel.org/stable/c/73fd5b19285197078ee8a2e651d75d5b094a4de9",
      "https://git.kernel.org/stable/c/1b061af037646c9cdb0afd8a8d2f1e1c06285866",
      "https://git.kernel.org/stable/c/18a759f7f99f0b65a08ff5b7e745fc405a42bde4",
      "https://git.kernel.org/stable/c/1cde35417edc0370fb0179a4e38b78a15350a8d0",
      "https://git.kernel.org/stable/c/013f12bdedb96816aaa27ee04349f4433d361f52",
      "https://git.kernel.org/stable/c/ef09ed5d37b84d18562b30cf7253e57062d0db05"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49344",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Fix a data-race in unix_dgram_peer_wake_me().\n\nunix_dgram_poll() calls unix_dgram_peer_wake_me() without `other`'s\nlock held and check if its receive queue is full.  Here we need to\nuse unix_recvq_full_lockless() instead of unix_recvq_full(), otherwise\nKCSAN will report a data-race.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/95f0ba806277733bf6024e23e27e1be773701cca",
      "https://git.kernel.org/stable/c/556720013c36c193d9cbfb06e7b33e51f0c39fbf",
      "https://git.kernel.org/stable/c/c61848500a3fd6867dfa4834b8c7f97133eceb9f",
      "https://git.kernel.org/stable/c/c926ae58f24f7bd55aa2ea4add9f952032507913",
      "https://git.kernel.org/stable/c/71e8bfc7f838cabc60cba24e09ca84c4f8321ab2",
      "https://git.kernel.org/stable/c/8801eb3ccd2e4e3b1a01449383e3321ae6dbd9d6",
      "https://git.kernel.org/stable/c/662a80946ce13633ae90a55379f1346c10f0c432"
    ],
    "受影响版本": [
      "7d267278a9ece963d77eefec61630223fce08c6c",
      "7d267278a9ece963d77eefec61630223fce08c6c",
      "7d267278a9ece963d77eefec61630223fce08c6c",
      "7d267278a9ece963d77eefec61630223fce08c6c",
      "7d267278a9ece963d77eefec61630223fce08c6c",
      "7d267278a9ece963d77eefec61630223fce08c6c",
      "7d267278a9ece963d77eefec61630223fce08c6c",
      "60bc010667ef06e0fb08d5ec599c0977adc2ac72",
      "a3b0f6e8a21ef02f69a15abac440572d8cde8c2a",
      "ec54d5ae9d298abf01c273233de9f2bc25d80475",
      "da8db0830a2ce63f628150307a01a315f5081202",
      "9964b4c4ee925b2910723e509abd7241cff1ef84",
      "9d054f57adc981a5f503d5eb9b259aa450b90dc5",
      "72032798034d921ed565e3bf8dfdc3098f6473e2",
      "5c77e26862ce604edea05b3442ed765e9756fe0f",
      "bad967fdd8ecbdd171f5f243657be033d2d081a7",
      "58a6a46a036ce81a2a8ecaa6fc1537c894349e3f"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49337",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: dlmfs: fix error handling of user_dlm_destroy_lock\n\nWhen user_dlm_destroy_lock failed, it didn't clean up the flags it set\nbefore exit.  For USER_LOCK_IN_TEARDOWN, if this function fails because of\nlock is still in used, next time when unlink invokes this function, it\nwill return succeed, and then unlink will remove inode and dentry if lock\nis not in used(file closed), but the dlm lock is still linked in dlm lock\nresource, then when bast come in, it will trigger a panic due to\nuser-after-free.  See the following panic call trace.  To fix this,\nUSER_LOCK_IN_TEARDOWN should be reverted if fail.  And also error should\nbe returned if USER_LOCK_IN_TEARDOWN is set to let user know that unlink\nfail.\n\nFor the case of ocfs2_dlm_unlock failure, besides USER_LOCK_IN_TEARDOWN,\nUSER_LOCK_BUSY is also required to be cleared.  Even though spin lock is\nreleased in between, but USER_LOCK_IN_TEARDOWN is still set, for\nUSER_LOCK_BUSY, if before every place that waits on this flag,\nUSER_LOCK_IN_TEARDOWN is checked to bail out, that will make sure no flow\nwaits on the busy flag set by user_dlm_destroy_lock(), then we can\nsimplely revert USER_LOCK_BUSY when ocfs2_dlm_unlock fails.  Fix\nuser_dlm_cluster_lock() which is the only function not following this.\n\n[  941.336392] (python,26174,16):dlmfs_unlink:562 ERROR: unlink\n004fb0000060000b5a90b8c847b72e1, error -16 from destroy\n[  989.757536] ------------[ cut here ]------------\n[  989.757709] kernel BUG at fs/ocfs2/dlmfs/userdlm.c:173!\n[  989.757876] invalid opcode: 0000 [#1] SMP\n[  989.758027] Modules linked in: ksplice_2zhuk2jr_ib_ipoib_new(O)\nksplice_2zhuk2jr(O) mptctl mptbase xen_netback xen_blkback xen_gntalloc\nxen_gntdev xen_evtchn cdc_ether usbnet mii ocfs2 jbd2 rpcsec_gss_krb5\nauth_rpcgss nfsv4 nfsv3 nfs_acl nfs fscache lockd grace ocfs2_dlmfs\nocfs2_stack_o2cb ocfs2_dlm ocfs2_nodemanager ocfs2_stackglue configfs bnx2fc\nfcoe libfcoe libfc scsi_transport_fc sunrpc ipmi_devintf bridge stp llc\nrds_rdma rds bonding ib_sdp ib_ipoib rdma_ucm ib_ucm ib_uverbs ib_umad\nrdma_cm ib_cm iw_cm falcon_lsm_serviceable(PE) falcon_nf_netcontain(PE)\nmlx4_vnic falcon_kal(E) falcon_lsm_pinned_13402(E) mlx4_ib ib_sa ib_mad\nib_core ib_addr xenfs xen_privcmd dm_multipath iTCO_wdt iTCO_vendor_support\npcspkr sb_edac edac_core i2c_i801 lpc_ich mfd_core ipmi_ssif i2c_core ipmi_si\nipmi_msghandler\n[  989.760686]  ioatdma sg ext3 jbd mbcache sd_mod ahci libahci ixgbe dca ptp\npps_core vxlan udp_tunnel ip6_udp_tunnel megaraid_sas mlx4_core crc32c_intel\nbe2iscsi bnx2i cnic uio cxgb4i cxgb4 cxgb3i libcxgbi ipv6 cxgb3 mdio\nlibiscsi_tcp qla4xxx iscsi_boot_sysfs libiscsi scsi_transport_iscsi wmi\ndm_mirror dm_region_hash dm_log dm_mod [last unloaded:\nksplice_2zhuk2jr_ib_ipoib_old]\n[  989.761987] CPU: 10 PID: 19102 Comm: dlm_thread Tainted: P           OE\n4.1.12-124.57.1.el6uek.x86_64 #2\n[  989.762290] Hardware name: Oracle Corporation ORACLE SERVER\nX5-2/ASM,MOTHERBOARD,1U, BIOS 30350100 06/17/2021\n[  989.762599] task: ffff880178af6200 ti: ffff88017f7c8000 task.ti:\nffff88017f7c8000\n[  989.762848] RIP: e030:[<ffffffffc07d4316>]  [<ffffffffc07d4316>]\n__user_dlm_queue_lockres.part.4+0x76/0x80 [ocfs2_dlmfs]\n[  989.763185] RSP: e02b:ffff88017f7cbcb8  EFLAGS: 00010246\n[  989.763353] RAX: 0000000000000000 RBX: ffff880174d48008 RCX:\n0000000000000003\n[  989.763565] RDX: 0000000000120012 RSI: 0000000000000003 RDI:\nffff880174d48170\n[  989.763778] RBP: ffff88017f7cbcc8 R08: ffff88021f4293b0 R09:\n0000000000000000\n[  989.763991] R10: ffff880179c8c000 R11: 0000000000000003 R12:\nffff880174d48008\n[  989.764204] R13: 0000000000000003 R14: ffff880179c8c000 R15:\nffff88021db7a000\n[  989.764422] FS:  0000000000000000(0000) GS:ffff880247480000(0000)\nknlGS:ffff880247480000\n[  989.764685] CS:  e033 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  989.764865] CR2: ffff8000007f6800 CR3: 0000000001ae0000 CR4:\n0000000000042660\n[  989.765081] Stack:\n[  989.765167]  00000000000\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1434cd71ad9f3a6beda3036972983b6c4869207c",
      "https://git.kernel.org/stable/c/02480e2e82ae0e5588374bbbcf4fa6e4959fa174",
      "https://git.kernel.org/stable/c/733a35c00ef363a1c774d7ea486e0735b7c13a15",
      "https://git.kernel.org/stable/c/82bf8e7271fade40184177cb406203addc34c4a0",
      "https://git.kernel.org/stable/c/337e36550788dbe03254f0593a231c1c4873b20d",
      "https://git.kernel.org/stable/c/9c96238fac045b289993d7bc5aae7b2d72b25c76",
      "https://git.kernel.org/stable/c/efb54ec548829e1d3605f0434526f86e345b1b28",
      "https://git.kernel.org/stable/c/2c5e26a626fe46675bceba853e12aaf13c712e10",
      "https://git.kernel.org/stable/c/863e0d81b6683c4cbc588ad831f560c90e494bef"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49306",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3: host: Stop setting the ACPI companion\n\nIt is no longer needed. The sysdev pointer is now used when\nassigning the ACPI companions to the xHCI ports and USB\ndevices.\n\nAssigning the ACPI companion here resulted in the\nfwnode->secondary pointer to be replaced also for the parent\ndwc3 device since the primary fwnode (the ACPI companion)\nwas shared. That was unintentional and it created potential\nside effects like resource leaks.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d7f35934f7ab67bfd9adabc84207e59da9c19108",
      "https://git.kernel.org/stable/c/9c185fde906a48368bd2d2a8c17d4b6fb3d670af",
      "https://git.kernel.org/stable/c/7fd069d65da2e20b1caec3b7bcf9dfbe28c04bb2"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49296",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nceph: fix possible deadlock when holding Fwb to get inline_data\n\n1, mount with wsync.\n2, create a file with O_RDWR, and the request was sent to mds.0:\n\n   ceph_atomic_open()-->\n     ceph_mdsc_do_request(openc)\n     finish_open(file, dentry, ceph_open)-->\n       ceph_open()-->\n         ceph_init_file()-->\n           ceph_init_file_info()-->\n             ceph_uninline_data()-->\n             {\n               ...\n               if (inline_version == 1 || /* initial version, no data */\n                   inline_version == CEPH_INLINE_NONE)\n                     goto out_unlock;\n               ...\n             }\n\nThe inline_version will be 1, which is the initial version for the\nnew create file. And here the ci->i_inline_version will keep with 1,\nit's buggy.\n\n3, buffer write to the file immediately:\n\n   ceph_write_iter()-->\n     ceph_get_caps(file, need=Fw, want=Fb, ...);\n     generic_perform_write()-->\n       a_ops->write_begin()-->\n         ceph_write_begin()-->\n           netfs_write_begin()-->\n             netfs_begin_read()-->\n               netfs_rreq_submit_slice()-->\n                 netfs_read_from_server()-->\n                   rreq->netfs_ops->issue_read()-->\n                     ceph_netfs_issue_read()-->\n                     {\n                       ...\n                       if (ci->i_inline_version != CEPH_INLINE_NONE &&\n                           ceph_netfs_issue_op_inline(subreq))\n                         return;\n                       ...\n                     }\n     ceph_put_cap_refs(ci, Fwb);\n\nThe ceph_netfs_issue_op_inline() will send a getattr(Fsr) request to\nmds.1.\n\n4, then the mds.1 will request the rd lock for CInode::filelock from\nthe auth mds.0, the mds.0 will do the CInode::filelock state transation\nfrom excl --> sync, but it need to revoke the Fxwb caps back from the\nclients.\n\nWhile the kernel client has aleady held the Fwb caps and waiting for\nthe getattr(Fsr).\n\nIt's deadlock!\n\nURL: https://tracker.ceph.com/issues/55377",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/292b7a7275ce535a1abfa4dd0b2e586162aaae1e",
      "https://git.kernel.org/stable/c/825978fd6a0defc3c29d8a38b6cea76a0938d21e"
    ],
    "受影响版本": [
      "9030aaf9bf0a1eee47a154c316c789e959638b0f",
      "9030aaf9bf0a1eee47a154c316c789e959638b0f"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49289",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nuaccess: fix integer overflow on access_ok()\n\nThree architectures check the end of a user access against the\naddress limit without taking a possible overflow into account.\nPassing a negative length or another overflow in here returns\nsuccess when it should not.\n\nUse the most common correct implementation here, which optimizes\nfor a constant 'size' argument, and turns the common case into a\nsingle comparison.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e65d28d4e9bf90a35ba79c06661a572a38391dec",
      "https://git.kernel.org/stable/c/99801e2f457824955da4aadaa035913a6dede03a",
      "https://git.kernel.org/stable/c/a1ad747fc1a0e06d1bf26b996ee8a56b5c8d02d8",
      "https://git.kernel.org/stable/c/222ca305c9fd39e5ed8104da25c09b2b79a516a8"
    ],
    "受影响版本": [
      "7567746e1c0d66ac0ef8a9d8816ca694462c7370",
      "7567746e1c0d66ac0ef8a9d8816ca694462c7370",
      "7567746e1c0d66ac0ef8a9d8816ca694462c7370",
      "7567746e1c0d66ac0ef8a9d8816ca694462c7370"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49287",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntpm: fix reference counting for struct tpm_chip\n\nThe following sequence of operations results in a refcount warning:\n\n1. Open device /dev/tpmrm.\n2. Remove module tpm_tis_spi.\n3. Write a TPM command to the file descriptor opened at step 1.\n\n------------[ cut here ]------------\nWARNING: CPU: 3 PID: 1161 at lib/refcount.c:25 kobject_get+0xa0/0xa4\nrefcount_t: addition on 0; use-after-free.\nModules linked in: tpm_tis_spi tpm_tis_core tpm mdio_bcm_unimac brcmfmac\nsha256_generic libsha256 sha256_arm hci_uart btbcm bluetooth cfg80211 vc4\nbrcmutil ecdh_generic ecc snd_soc_core crc32_arm_ce libaes\nraspberrypi_hwmon ac97_bus snd_pcm_dmaengine bcm2711_thermal snd_pcm\nsnd_timer genet snd phy_generic soundcore [last unloaded: spi_bcm2835]\nCPU: 3 PID: 1161 Comm: hold_open Not tainted 5.10.0ls-main-dirty #2\nHardware name: BCM2711\n[<c0410c3c>] (unwind_backtrace) from [<c040b580>] (show_stack+0x10/0x14)\n[<c040b580>] (show_stack) from [<c1092174>] (dump_stack+0xc4/0xd8)\n[<c1092174>] (dump_stack) from [<c0445a30>] (__warn+0x104/0x108)\n[<c0445a30>] (__warn) from [<c0445aa8>] (warn_slowpath_fmt+0x74/0xb8)\n[<c0445aa8>] (warn_slowpath_fmt) from [<c08435d0>] (kobject_get+0xa0/0xa4)\n[<c08435d0>] (kobject_get) from [<bf0a715c>] (tpm_try_get_ops+0x14/0x54 [tpm])\n[<bf0a715c>] (tpm_try_get_ops [tpm]) from [<bf0a7d6c>] (tpm_common_write+0x38/0x60 [tpm])\n[<bf0a7d6c>] (tpm_common_write [tpm]) from [<c05a7ac0>] (vfs_write+0xc4/0x3c0)\n[<c05a7ac0>] (vfs_write) from [<c05a7ee4>] (ksys_write+0x58/0xcc)\n[<c05a7ee4>] (ksys_write) from [<c04001a0>] (ret_fast_syscall+0x0/0x4c)\nException stack(0xc226bfa8 to 0xc226bff0)\nbfa0:                   00000000 000105b4 00000003 beafe664 00000014 00000000\nbfc0: 00000000 000105b4 000103f8 00000004 00000000 00000000 b6f9c000 beafe684\nbfe0: 0000006c beafe648 0001056c b6eb6944\n---[ end trace d4b8409def9b8b1f ]---\n\nThe reason for this warning is the attempt to get the chip->dev reference\nin tpm_common_write() although the reference counter is already zero.\n\nSince commit 8979b02aaf1d (\"tpm: Fix reference count to main device\") the\nextra reference used to prevent a premature zero counter is never taken,\nbecause the required TPM_CHIP_FLAG_TPM2 flag is never set.\n\nFix this by moving the TPM 2 character device handling from\ntpm_chip_alloc() to tpm_add_char_device() which is called at a later point\nin time when the flag has been set in case of TPM2.\n\nCommit fdc915f7f719 (\"tpm: expose spaces via a device link /dev/tpmrm<n>\")\nalready introduced function tpm_devs_release() to release the extra\nreference but did not implement the required put on chip->devs that results\nin the call of this function.\n\nFix this by putting chip->devs in tpm_chip_unregister().\n\nFinally move the new implementation for the TPM 2 handling into a new\nfunction to avoid multiple checks for the TPM_CHIP_FLAG_TPM2 flag in the\ngood case and error cases.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/473a66f99cb8173c14138c5a5c69bfad04e8f9ac",
      "https://git.kernel.org/stable/c/cb64bd038beacb4331fe464a36c8b5481e8f51e2",
      "https://git.kernel.org/stable/c/a27ed2f3695baf15f9b34d2d7a1f9fc105539a81",
      "https://git.kernel.org/stable/c/290e05f346d1829e849662c97e42d5ad984f5258",
      "https://git.kernel.org/stable/c/662893b4f6bd466ff9e1cd454c44c26d32d554fe",
      "https://git.kernel.org/stable/c/2f928c0d5c02dbab49e8c19d98725c822f6fc409",
      "https://git.kernel.org/stable/c/6e7baf84149fb43950631415de231b3a41915aa3",
      "https://git.kernel.org/stable/c/7e0438f83dc769465ee663bb5dcf8cc154940712"
    ],
    "受影响版本": [
      "fdc915f7f71939ad5a3dda3389b8d2d7a7c5ee66",
      "fdc915f7f71939ad5a3dda3389b8d2d7a7c5ee66",
      "fdc915f7f71939ad5a3dda3389b8d2d7a7c5ee66",
      "fdc915f7f71939ad5a3dda3389b8d2d7a7c5ee66",
      "fdc915f7f71939ad5a3dda3389b8d2d7a7c5ee66",
      "fdc915f7f71939ad5a3dda3389b8d2d7a7c5ee66",
      "fdc915f7f71939ad5a3dda3389b8d2d7a7c5ee66",
      "fdc915f7f71939ad5a3dda3389b8d2d7a7c5ee66"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49285",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: accel: mma8452: use the correct logic to get mma8452_data\n\nThe original logic to get mma8452_data is wrong, the *dev point to\nthe device belong to iio_dev. we can't use this dev to find the\ncorrect i2c_client. The original logic happen to work because it\nfinally use dev->driver_data to get iio_dev. Here use the API\nto_i2c_client() is wrong and make reader confuse. To correct the\nlogic, it should be like this\n\n  struct mma8452_data *data = iio_priv(dev_get_drvdata(dev));\n\nBut after commit 8b7651f25962 (\"iio: iio_device_alloc(): Remove\nunnecessary self drvdata\"), the upper logic also can't work.\nWhen try to show the avialable scale in userspace, will meet kernel\ndump, kernel handle NULL pointer dereference.\n\nSo use dev_to_iio_dev() to correct the logic.\n\nDual fixes tags as the second reflects when the bug was exposed, whilst\nthe first reflects when the original bug was introduced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4c0bb583a4444cce224e8661090cbffc98e2fe07",
      "https://git.kernel.org/stable/c/d2d9ebdbff79d87d27652578e6d1638ad3b5f3bf",
      "https://git.kernel.org/stable/c/c87b7b12f48db86ac9909894f4dc0107d7df6375"
    ],
    "受影响版本": [
      "c3cdd6e48e35b7a02f28e301ef30a87ff3cd6527",
      "c3cdd6e48e35b7a02f28e301ef30a87ff3cd6527",
      "c3cdd6e48e35b7a02f28e301ef30a87ff3cd6527"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49282",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: quota: fix loop condition at f2fs_quota_sync()\n\ncnt should be passed to sb_has_quota_active() instead of type to check\nactive quota properly.\n\nMoreover, when the type is -1, the compiler with enough inline knowledge\ncan discard sb_has_quota_active() check altogether, causing a NULL pointer\ndereference at the following inode_lock(dqopt->files[cnt]):\n\n[    2.796010] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000a0\n[    2.796024] Mem abort info:\n[    2.796025]   ESR = 0x96000005\n[    2.796028]   EC = 0x25: DABT (current EL), IL = 32 bits\n[    2.796029]   SET = 0, FnV = 0\n[    2.796031]   EA = 0, S1PTW = 0\n[    2.796032] Data abort info:\n[    2.796034]   ISV = 0, ISS = 0x00000005\n[    2.796035]   CM = 0, WnR = 0\n[    2.796046] user pgtable: 4k pages, 39-bit VAs, pgdp=00000003370d1000\n[    2.796048] [00000000000000a0] pgd=0000000000000000, pud=0000000000000000\n[    2.796051] Internal error: Oops: 96000005 [#1] PREEMPT SMP\n[    2.796056] CPU: 7 PID: 640 Comm: f2fs_ckpt-259:7 Tainted: G S                5.4.179-arter97-r8-64666-g2f16e087f9d8 #1\n[    2.796057] Hardware name: Qualcomm Technologies, Inc. Lahaina MTP lemonadep (DT)\n[    2.796059] pstate: 80c00005 (Nzcv daif +PAN +UAO)\n[    2.796065] pc : down_write+0x28/0x70\n[    2.796070] lr : f2fs_quota_sync+0x100/0x294\n[    2.796071] sp : ffffffa3f48ffc30\n[    2.796073] x29: ffffffa3f48ffc30 x28: 0000000000000000\n[    2.796075] x27: ffffffa3f6d718b8 x26: ffffffa415fe9d80\n[    2.796077] x25: ffffffa3f7290048 x24: 0000000000000001\n[    2.796078] x23: 0000000000000000 x22: ffffffa3f7290000\n[    2.796080] x21: ffffffa3f72904a0 x20: ffffffa3f7290110\n[    2.796081] x19: ffffffa3f77a9800 x18: ffffffc020aae038\n[    2.796083] x17: ffffffa40e38e040 x16: ffffffa40e38e6d0\n[    2.796085] x15: ffffffa40e38e6cc x14: ffffffa40e38e6d0\n[    2.796086] x13: 00000000000004f6 x12: 00162c44ff493000\n[    2.796088] x11: 0000000000000400 x10: ffffffa40e38c948\n[    2.796090] x9 : 0000000000000000 x8 : 00000000000000a0\n[    2.796091] x7 : 0000000000000000 x6 : 0000d1060f00002a\n[    2.796093] x5 : ffffffa3f48ff718 x4 : 000000000000000d\n[    2.796094] x3 : 00000000060c0000 x2 : 0000000000000001\n[    2.796096] x1 : 0000000000000000 x0 : 00000000000000a0\n[    2.796098] Call trace:\n[    2.796100]  down_write+0x28/0x70\n[    2.796102]  f2fs_quota_sync+0x100/0x294\n[    2.796104]  block_operations+0x120/0x204\n[    2.796106]  f2fs_write_checkpoint+0x11c/0x520\n[    2.796107]  __checkpoint_and_complete_reqs+0x7c/0xd34\n[    2.796109]  issue_checkpoint_thread+0x6c/0xb8\n[    2.796112]  kthread+0x138/0x414\n[    2.796114]  ret_from_fork+0x10/0x18\n[    2.796117] Code: aa0803e0 aa1f03e1 52800022 aa0103e9 (c8e97d02)\n[    2.796120] ---[ end trace 96e942e8eb6a0b53 ]---\n[    2.800116] Kernel panic - not syncing: Fatal exception\n[    2.800120] SMP: stopping secondary CPUs",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f1d5946d47c0827bae39e1537959ce8d6f0224c5",
      "https://git.kernel.org/stable/c/e58ee6bd939b773675240f5d0f5b88a367c037c4",
      "https://git.kernel.org/stable/c/f9156db0987f1b426015d56505e2c58dee70c90d",
      "https://git.kernel.org/stable/c/e9ebf1e8fc50b6a9336f9aea1082d7845e568d0e",
      "https://git.kernel.org/stable/c/724469814d805820cd37ea789769dba94123ff1a",
      "https://git.kernel.org/stable/c/680af5b824a52faa819167628665804a14f0e0df"
    ],
    "受影响版本": [
      "a02982545e61020c23f411b073ba5171381138e4",
      "2d586a3f5b7ec2f5a939db4abc9aa053c237545c",
      "9de71ede81e6d1a111fdd868b2d78d459fa77f80",
      "9de71ede81e6d1a111fdd868b2d78d459fa77f80",
      "9de71ede81e6d1a111fdd868b2d78d459fa77f80",
      "9de71ede81e6d1a111fdd868b2d78d459fa77f80",
      "9dd5052a8a8be252990c1bb451b51f32529411ef",
      "699a077aa087c17cf29c7170db71a34141e2effe"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49271",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: prevent bad output lengths in smb2_ioctl_query_info()\n\nWhen calling smb2_ioctl_query_info() with\nsmb_query_info::flags=PASSTHRU_FSCTL and\nsmb_query_info::output_buffer_length=0, the following would return\n0x10\n\n\tbuffer = memdup_user(arg + sizeof(struct smb_query_info),\n\t\t\t     qi.output_buffer_length);\n\tif (IS_ERR(buffer)) {\n\t\tkfree(vars);\n\t\treturn PTR_ERR(buffer);\n\t}\n\nrather than a valid pointer thus making IS_ERR() check fail.  This\nwould then cause a NULL ptr deference in @buffer when accessing it\nlater in smb2_ioctl_query_ioctl().  While at it, prevent having a\n@buffer smaller than 8 bytes to correctly handle SMB2_SET_INFO\nFileEndOfFileInformation requests when\nsmb_query_info::flags=PASSTHRU_SET_INFO.\n\nHere is a small C reproducer which triggers a NULL ptr in @buffer when\npassing an invalid smb_query_info::flags\n\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <stdint.h>\n\t#include <unistd.h>\n\t#include <fcntl.h>\n\t#include <sys/ioctl.h>\n\n\t#define die(s) perror(s), exit(1)\n\t#define QUERY_INFO 0xc018cf07\n\n\tint main(int argc, char *argv[])\n\t{\n\t\tint fd;\n\n\t\tif (argc < 2)\n\t\t\texit(1);\n\t\tfd = open(argv[1], O_RDONLY);\n\t\tif (fd == -1)\n\t\t\tdie(\"open\");\n\t\tif (ioctl(fd, QUERY_INFO, (uint32_t[]) { 0, 0, 0, 4, 0, 0}) == -1)\n\t\t\tdie(\"ioctl\");\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n\tmount.cifs //srv/share /mnt -o ...\n\tgcc repro.c && ./a.out /mnt/f0\n\n\t[  114.138620] general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN NOPTI\n\t[  114.139310] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n\t[  114.139775] CPU: 2 PID: 995 Comm: a.out Not tainted 5.17.0-rc8 #1\n\t[  114.140148] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.15.0-0-g2dd4b9b-rebuilt.opensuse.org 04/01/2014\n\t[  114.140818] RIP: 0010:smb2_ioctl_query_info+0x206/0x410 [cifs]\n\t[  114.141221] Code: 00 00 00 00 fc ff df 48 c1 ea 03 80 3c 02 00 0f 85 c8 01 00 00 48 b8 00 00 00 00 00 fc ff df 4c 8b 7b 28 4c 89 fa 48 c1 ea 03 <80> 3c 02 00 0f 85 9c 01 00 00 49 8b 3f e8 58 02 fb ff 48 8b 14 24\n\t[  114.142348] RSP: 0018:ffffc90000b47b00 EFLAGS: 00010256\n\t[  114.142692] RAX: dffffc0000000000 RBX: ffff888115503200 RCX: ffffffffa020580d\n\t[  114.143119] RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffffffffa043a380\n\t[  114.143544] RBP: ffff888115503278 R08: 0000000000000001 R09: 0000000000000003\n\t[  114.143983] R10: fffffbfff4087470 R11: 0000000000000001 R12: ffff888115503288\n\t[  114.144424] R13: 00000000ffffffea R14: ffff888115503228 R15: 0000000000000000\n\t[  114.144852] FS:  00007f7aeabdf740(0000) GS:ffff888151600000(0000) knlGS:0000000000000000\n\t[  114.145338] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n\t[  114.145692] CR2: 00007f7aeacfdf5e CR3: 000000012000e000 CR4: 0000000000350ee0\n\t[  114.146131] Call Trace:\n\t[  114.146291]  <TASK>\n\t[  114.146432]  ? smb2_query_reparse_tag+0x890/0x890 [cifs]\n\t[  114.146800]  ? cifs_mapchar+0x460/0x460 [cifs]\n\t[  114.147121]  ? rcu_read_lock_sched_held+0x3f/0x70\n\t[  114.147412]  ? cifs_strndup_to_utf16+0x15b/0x250 [cifs]\n\t[  114.147775]  ? dentry_path_raw+0xa6/0xf0\n\t[  114.148024]  ? cifs_convert_path_to_utf16+0x198/0x220 [cifs]\n\t[  114.148413]  ? smb2_check_message+0x1080/0x1080 [cifs]\n\t[  114.148766]  ? rcu_read_lock_sched_held+0x3f/0x70\n\t[  114.149065]  cifs_ioctl+0x1577/0x3320 [cifs]\n\t[  114.149371]  ? lock_downgrade+0x6f0/0x6f0\n\t[  114.149631]  ? cifs_readdir+0x2e60/0x2e60 [cifs]\n\t[  114.149956]  ? rcu_read_lock_sched_held+0x3f/0x70\n\t[  114.150250]  ? __rseq_handle_notify_resume+0x80b/0xbe0\n\t[  114.150562]  ? __up_read+0x192/0x710\n\t[  114.150791]  ? __ia32_sys_rseq+0xf0/0xf0\n\t[  114.151025]  ? __x64_sys_openat+0x11f/0x1d0\n\t[  114.151296]  __x64_sys_ioctl+0x127/0x190\n\t[  114.151549]  do_syscall_64+0x3b/0x90\n\t[  114.151768]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\t[  114.152079] RIP: 0033:0x7f7aead043df\n\t[  114.152306] Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9963ccea6087268e1275b992dca5d0dd4b938765",
      "https://git.kernel.org/stable/c/f143f8334fb9eb2f6c7c15b9da1472d9c965fd84",
      "https://git.kernel.org/stable/c/fadddfc1dc3c6f79b21cff4a7e9a6c40b84fbc53",
      "https://git.kernel.org/stable/c/7529fbee10d82493c5cb109e51788bf74816d1c0",
      "https://git.kernel.org/stable/c/b92e358757b91c2827af112cae9af513f26a3f34"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49260",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: hisilicon/sec - fix the aead software fallback for engine\n\nDue to the subreq pointer misuse the private context memory. The aead\nsoft crypto occasionally casues the OS panic as setting the 64K page.\nHere is fix it.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/40dba7c26e897c637e91312b35f664f1d4d0073c",
      "https://git.kernel.org/stable/c/ef7b10f3cac7810ddcfd976304fd125aca33d144",
      "https://git.kernel.org/stable/c/5c1149e2abe0b7489300736b8277b45b113de67f",
      "https://git.kernel.org/stable/c/0a2a464f863187f97e96ebc6384c052cafd4a54c"
    ],
    "受影响版本": [
      "6c46a3297beae4ae2d22b26da5e091f058381c7c",
      "6c46a3297beae4ae2d22b26da5e091f058381c7c",
      "6c46a3297beae4ae2d22b26da5e091f058381c7c",
      "6c46a3297beae4ae2d22b26da5e091f058381c7c"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49255",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix missing free nid in f2fs_handle_failed_inode\n\nThis patch fixes xfstests/generic/475 failure.\n\n[  293.680694] F2FS-fs (dm-1): May loss orphan inode, run fsck to fix.\n[  293.685358] Buffer I/O error on dev dm-1, logical block 8388592, async page read\n[  293.691527] Buffer I/O error on dev dm-1, logical block 8388592, async page read\n[  293.691764] sh (7615): drop_caches: 3\n[  293.691819] sh (7616): drop_caches: 3\n[  293.694017] Buffer I/O error on dev dm-1, logical block 1, async page read\n[  293.695659] sh (7618): drop_caches: 3\n[  293.696979] sh (7617): drop_caches: 3\n[  293.700290] sh (7623): drop_caches: 3\n[  293.708621] sh (7626): drop_caches: 3\n[  293.711386] sh (7628): drop_caches: 3\n[  293.711825] sh (7627): drop_caches: 3\n[  293.716738] sh (7630): drop_caches: 3\n[  293.719613] sh (7632): drop_caches: 3\n[  293.720971] sh (7633): drop_caches: 3\n[  293.727741] sh (7634): drop_caches: 3\n[  293.730783] sh (7636): drop_caches: 3\n[  293.732681] sh (7635): drop_caches: 3\n[  293.732988] sh (7637): drop_caches: 3\n[  293.738836] sh (7639): drop_caches: 3\n[  293.740568] sh (7641): drop_caches: 3\n[  293.743053] sh (7640): drop_caches: 3\n[  293.821889] ------------[ cut here ]------------\n[  293.824654] kernel BUG at fs/f2fs/node.c:3334!\n[  293.826226] invalid opcode: 0000 [#1] PREEMPT SMP PTI\n[  293.828713] CPU: 0 PID: 7653 Comm: umount Tainted: G           OE     5.17.0-rc1-custom #1\n[  293.830946] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n[  293.832526] RIP: 0010:f2fs_destroy_node_manager+0x33f/0x350 [f2fs]\n[  293.833905] Code: e8 d6 3d f9 f9 48 8b 45 d0 65 48 2b 04 25 28 00 00 00 75 1a 48 81 c4 28 03 00 00 5b 41 5c 41 5d 41 5e 41 5f 5d c3 0f 0b\n[  293.837783] RSP: 0018:ffffb04ec31e7a20 EFLAGS: 00010202\n[  293.839062] RAX: 0000000000000001 RBX: ffff9df947db2eb8 RCX: 0000000080aa0072\n[  293.840666] RDX: 0000000000000000 RSI: ffffe86c0432a140 RDI: ffffffffc0b72a21\n[  293.842261] RBP: ffffb04ec31e7d70 R08: ffff9df94ca85780 R09: 0000000080aa0072\n[  293.843909] R10: ffff9df94ca85700 R11: ffff9df94e1ccf58 R12: ffff9df947db2e00\n[  293.845594] R13: ffff9df947db2ed0 R14: ffff9df947db2eb8 R15: ffff9df947db2eb8\n[  293.847855] FS:  00007f5a97379800(0000) GS:ffff9dfa77c00000(0000) knlGS:0000000000000000\n[  293.850647] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  293.852940] CR2: 00007f5a97528730 CR3: 000000010bc76005 CR4: 0000000000370ef0\n[  293.854680] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  293.856423] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  293.858380] Call Trace:\n[  293.859302]  <TASK>\n[  293.860311]  ? ttwu_do_wakeup+0x1c/0x170\n[  293.861800]  ? ttwu_do_activate+0x6d/0xb0\n[  293.863057]  ? _raw_spin_unlock_irqrestore+0x29/0x40\n[  293.864411]  ? try_to_wake_up+0x9d/0x5e0\n[  293.865618]  ? debug_smp_processor_id+0x17/0x20\n[  293.866934]  ? debug_smp_processor_id+0x17/0x20\n[  293.868223]  ? free_unref_page+0xbf/0x120\n[  293.869470]  ? __free_slab+0xcb/0x1c0\n[  293.870614]  ? preempt_count_add+0x7a/0xc0\n[  293.871811]  ? __slab_free+0xa0/0x2d0\n[  293.872918]  ? __wake_up_common_lock+0x8a/0xc0\n[  293.874186]  ? __slab_free+0xa0/0x2d0\n[  293.875305]  ? free_inode_nonrcu+0x20/0x20\n[  293.876466]  ? free_inode_nonrcu+0x20/0x20\n[  293.877650]  ? debug_smp_processor_id+0x17/0x20\n[  293.878949]  ? call_rcu+0x11a/0x240\n[  293.880060]  ? f2fs_destroy_stats+0x59/0x60 [f2fs]\n[  293.881437]  ? kfree+0x1fe/0x230\n[  293.882674]  f2fs_put_super+0x160/0x390 [f2fs]\n[  293.883978]  generic_shutdown_super+0x7a/0x120\n[  293.885274]  kill_block_super+0x27/0x50\n[  293.886496]  kill_f2fs_super+0x7f/0x100 [f2fs]\n[  293.887806]  deactivate_locked_super+0x35/0xa0\n[  293.889271]  deactivate_super+0x40/0x50\n[  293.890513]  cleanup_mnt+0x139/0x190\n[  293.891689]  __cleanup_mnt+0x12/0x20\n[  293.892850]  task_work_run+0x64/0xa0\n[  293.894035]  exit_to_user_mode_prepare+0x1b7/\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/005f9cdab70c915702254c5eb67a8efced80e821",
      "https://git.kernel.org/stable/c/1a11a873749c6375bb668953fa1a196d8538d26b",
      "https://git.kernel.org/stable/c/d1eaaf6cadedf638e17017b0a04d56308405ac10",
      "https://git.kernel.org/stable/c/aa80bf73e3b3fb7026d343c77b3ddc849e26a095",
      "https://git.kernel.org/stable/c/8579b413af100ec5f3592bd6cf11559312b380c0",
      "https://git.kernel.org/stable/c/2fef99b8372c1ae3d8445ab570e888b5a358dbe9"
    ],
    "受影响版本": [
      "7735730d39d75e70476c1b01435b9b1f41637f0e",
      "7735730d39d75e70476c1b01435b9b1f41637f0e",
      "7735730d39d75e70476c1b01435b9b1f41637f0e",
      "7735730d39d75e70476c1b01435b9b1f41637f0e",
      "7735730d39d75e70476c1b01435b9b1f41637f0e",
      "7735730d39d75e70476c1b01435b9b1f41637f0e"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49245",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: rockchip: Fix PM usage reference of rockchip_i2s_tdm_resume\n\npm_runtime_get_sync will increment pm usage counter\neven it failed. Forgetting to putting operation will\nresult in reference leak here. We fix it by replacing\nit with pm_runtime_resume_and_get to keep usage counter\nbalanced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4e5510219111607b1f1875ab3c3f0485ba3c381c",
      "https://git.kernel.org/stable/c/5c1834aac759ddfd0f17c9f38db1b30adc8eb4e8",
      "https://git.kernel.org/stable/c/cc5d8ac95663a5813c696008bc524b794d471215"
    ],
    "受影响版本": [
      "081068fd641403994f0505e6b91e021d3925f348",
      "081068fd641403994f0505e6b91e021d3925f348",
      "081068fd641403994f0505e6b91e021d3925f348"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49227",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nigc: avoid kernel warning when changing RX ring parameters\n\nCalling ethtool changing the RX ring parameters like this:\n\n  $ ethtool -G eth0 rx 1024\n\non igc triggers kernel warnings like this:\n\n[  225.198467] ------------[ cut here ]------------\n[  225.198473] Missing unregister, handled but fix driver\n[  225.198485] WARNING: CPU: 7 PID: 959 at net/core/xdp.c:168\nxdp_rxq_info_reg+0x79/0xd0\n[...]\n[  225.198601] Call Trace:\n[  225.198604]  <TASK>\n[  225.198609]  igc_setup_rx_resources+0x3f/0xe0 [igc]\n[  225.198617]  igc_ethtool_set_ringparam+0x30e/0x450 [igc]\n[  225.198626]  ethnl_set_rings+0x18a/0x250\n[  225.198631]  genl_family_rcv_msg_doit+0xca/0x110\n[  225.198637]  genl_rcv_msg+0xce/0x1c0\n[  225.198640]  ? rings_prepare_data+0x60/0x60\n[  225.198644]  ? genl_get_cmd+0xd0/0xd0\n[  225.198647]  netlink_rcv_skb+0x4e/0xf0\n[  225.198652]  genl_rcv+0x24/0x40\n[  225.198655]  netlink_unicast+0x20e/0x330\n[  225.198659]  netlink_sendmsg+0x23f/0x480\n[  225.198663]  sock_sendmsg+0x5b/0x60\n[  225.198667]  __sys_sendto+0xf0/0x160\n[  225.198671]  ? handle_mm_fault+0xb2/0x280\n[  225.198676]  ? do_user_addr_fault+0x1eb/0x690\n[  225.198680]  __x64_sys_sendto+0x20/0x30\n[  225.198683]  do_syscall_64+0x38/0x90\n[  225.198687]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[  225.198693] RIP: 0033:0x7f7ae38ac3aa\n\nigc_ethtool_set_ringparam() copies the igc_ring structure but neglects to\nreset the xdp_rxq_info member before calling igc_setup_rx_resources().\nThis in turn calls xdp_rxq_info_reg() with an already registered xdp_rxq_info.\n\nMake sure to unregister the xdp_rxq_info structure first in\nigc_setup_rx_resources.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ab8c107470d12e7ef99030bf0911a10cdef62d16",
      "https://git.kernel.org/stable/c/3ddb49af08094ebee250b461172ee7b8e27a35d3",
      "https://git.kernel.org/stable/c/65aebcf1e05bd97d2e7ffcdff36efea1757c9450",
      "https://git.kernel.org/stable/c/453307b569a0d41bddd07f26bf41b784cd82a4c9"
    ],
    "受影响版本": [
      "73f1071c1d2952b8c93cd6cd99744768c59ec840",
      "73f1071c1d2952b8c93cd6cd99744768c59ec840",
      "73f1071c1d2952b8c93cd6cd99744768c59ec840",
      "73f1071c1d2952b8c93cd6cd99744768c59ec840"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49215",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nxsk: Fix race at socket teardown\n\nFix a race in the xsk socket teardown code that can lead to a NULL pointer\ndereference splat. The current xsk unbind code in xsk_unbind_dev() starts by\nsetting xs->state to XSK_UNBOUND, sets xs->dev to NULL and then waits for any\nNAPI processing to terminate using synchronize_net(). After that, the release\ncode starts to tear down the socket state and free allocated memory.\n\n  BUG: kernel NULL pointer dereference, address: 00000000000000c0\n  PGD 8000000932469067 P4D 8000000932469067 PUD 0\n  Oops: 0000 [#1] PREEMPT SMP PTI\n  CPU: 25 PID: 69132 Comm: grpcpp_sync_ser Tainted: G          I       5.16.0+ #2\n  Hardware name: Dell Inc. PowerEdge R730/0599V5, BIOS 1.2.10 03/09/2015\n  RIP: 0010:__xsk_sendmsg+0x2c/0x690\n  [...]\n  RSP: 0018:ffffa2348bd13d50 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: 0000000000000040 RCX: ffff8d5fc632d258\n  RDX: 0000000000400000 RSI: ffffa2348bd13e10 RDI: ffff8d5fc5489800\n  RBP: ffffa2348bd13db0 R08: 0000000000000000 R09: 00007ffffffff000\n  R10: 0000000000000000 R11: 0000000000000000 R12: ffff8d5fc5489800\n  R13: ffff8d5fcb0f5140 R14: ffff8d5fcb0f5140 R15: 0000000000000000\n  FS:  00007f991cff9400(0000) GS:ffff8d6f1f700000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00000000000000c0 CR3: 0000000114888005 CR4: 00000000001706e0\n  Call Trace:\n  <TASK>\n  ? aa_sk_perm+0x43/0x1b0\n  xsk_sendmsg+0xf0/0x110\n  sock_sendmsg+0x65/0x70\n  __sys_sendto+0x113/0x190\n  ? debug_smp_processor_id+0x17/0x20\n  ? fpregs_assert_state_consistent+0x23/0x50\n  ? exit_to_user_mode_prepare+0xa5/0x1d0\n  __x64_sys_sendto+0x29/0x30\n  do_syscall_64+0x3b/0xc0\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThere are two problems with the current code. First, setting xs->dev to NULL\nbefore waiting for all users to stop using the socket is not correct. The\nentry to the data plane functions xsk_poll(), xsk_sendmsg(), and xsk_recvmsg()\nare all guarded by a test that xs->state is in the state XSK_BOUND and if not,\nit returns right away. But one process might have passed this test but still\nhave not gotten to the point in which it uses xs->dev in the code. In this\ninterim, a second process executing xsk_unbind_dev() might have set xs->dev to\nNULL which will lead to a crash for the first process. The solution here is\njust to get rid of this NULL assignment since it is not used anymore. Before\ncommit 42fddcc7c64b (\"xsk: use state member for socket synchronization\"),\nxs->dev was the gatekeeper to admit processes into the data plane functions,\nbut it was replaced with the state variable xs->state in the aforementioned\ncommit.\n\nThe second problem is that synchronize_net() does not wait for any process in\nxsk_poll(), xsk_sendmsg(), or xsk_recvmsg() to complete, which means that the\nstate they rely on might be cleaned up prematurely. This can happen when the\nnotifier gets called (at driver unload for example) as it uses xsk_unbind_dev().\nSolve this by extending the RCU critical region from just the ndo_xsk_wakeup\nto the whole functions mentioned above, so that both the test of xs->state ==\nXSK_BOUND and the last use of any member of xs is covered by the RCU critical\nsection. This will guarantee that when synchronize_net() completes, there will\nbe no processes left executing xsk_poll(), xsk_sendmsg(), or xsk_recvmsg() and\nstate can be cleaned up safely. Note that we need to drop the RCU lock for the\nskb xmit path as it uses functions that might sleep. Due to this, we have to\nretest the xs->state after we grab the mutex that protects the skb xmit code\nfrom, among a number of things, an xsk_unbind_dev() being executed from the\nnotifier at the same time.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ad7219cd8751bd258b9d1e69ae0654ec00f71875",
      "https://git.kernel.org/stable/c/d1579253ffce39986e7a6ab757ac93b2680a665f",
      "https://git.kernel.org/stable/c/8a2dea162b92c322f3e42eae0c4a74b8d20aa7a9",
      "https://git.kernel.org/stable/c/18b1ab7aa76bde181bdb1ab19a87fa9523c32f21"
    ],
    "受影响版本": [
      "42fddcc7c64b723a867c7b2f5f7505e244212f13",
      "42fddcc7c64b723a867c7b2f5f7505e244212f13",
      "42fddcc7c64b723a867c7b2f5f7505e244212f13",
      "42fddcc7c64b723a867c7b2f5f7505e244212f13"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49194",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bcmgenet: Use stronger register read/writes to assure ordering\n\nGCC12 appears to be much smarter about its dependency tracking and is\naware that the relaxed variants are just normal loads and stores and\nthis is causing problems like:\n\n[  210.074549] ------------[ cut here ]------------\n[  210.079223] NETDEV WATCHDOG: enabcm6e4ei0 (bcmgenet): transmit queue 1 timed out\n[  210.086717] WARNING: CPU: 1 PID: 0 at net/sched/sch_generic.c:529 dev_watchdog+0x234/0x240\n[  210.095044] Modules linked in: genet(E) nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat]\n[  210.146561] ACPI CPPC: PCC check channel failed for ss: 0. ret=-110\n[  210.146927] CPU: 1 PID: 0 Comm: swapper/1 Tainted: G            E     5.17.0-rc7G12+ #58\n[  210.153226] CPPC Cpufreq:cppc_scale_freq_workfn: failed to read perf counters\n[  210.161349] Hardware name: Raspberry Pi Foundation Raspberry Pi 4 Model B/Raspberry Pi 4 Model B, BIOS EDK2-DEV 02/08/2022\n[  210.161353] pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  210.161358] pc : dev_watchdog+0x234/0x240\n[  210.161364] lr : dev_watchdog+0x234/0x240\n[  210.161368] sp : ffff8000080a3a40\n[  210.161370] x29: ffff8000080a3a40 x28: ffffcd425af87000 x27: ffff8000080a3b20\n[  210.205150] x26: ffffcd425aa00000 x25: 0000000000000001 x24: ffffcd425af8ec08\n[  210.212321] x23: 0000000000000100 x22: ffffcd425af87000 x21: ffff55b142688000\n[  210.219491] x20: 0000000000000001 x19: ffff55b1426884c8 x18: ffffffffffffffff\n[  210.226661] x17: 64656d6974203120 x16: 0000000000000001 x15: 6d736e617274203a\n[  210.233831] x14: 2974656e65676d63 x13: ffffcd4259c300d8 x12: ffffcd425b07d5f0\n[  210.241001] x11: 00000000ffffffff x10: ffffcd425b07d5f0 x9 : ffffcd4258bdad9c\n[  210.248171] x8 : 00000000ffffdfff x7 : 000000000000003f x6 : 0000000000000000\n[  210.255341] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000001000\n[  210.262511] x2 : 0000000000001000 x1 : 0000000000000005 x0 : 0000000000000044\n[  210.269682] Call trace:\n[  210.272133]  dev_watchdog+0x234/0x240\n[  210.275811]  call_timer_fn+0x3c/0x15c\n[  210.279489]  __run_timers.part.0+0x288/0x310\n[  210.283777]  run_timer_softirq+0x48/0x80\n[  210.287716]  __do_softirq+0x128/0x360\n[  210.291392]  __irq_exit_rcu+0x138/0x140\n[  210.295243]  irq_exit_rcu+0x1c/0x30\n[  210.298745]  el1_interrupt+0x38/0x54\n[  210.302334]  el1h_64_irq_handler+0x18/0x24\n[  210.306445]  el1h_64_irq+0x7c/0x80\n[  210.309857]  arch_cpu_idle+0x18/0x2c\n[  210.313445]  default_idle_call+0x4c/0x140\n[  210.317470]  cpuidle_idle_call+0x14c/0x1a0\n[  210.321584]  do_idle+0xb0/0x100\n[  210.324737]  cpu_startup_entry+0x30/0x8c\n[  210.328675]  secondary_start_kernel+0xe4/0x110\n[  210.333138]  __secondary_switched+0x94/0x98\n\nThe assumption when these were relaxed seems to be that device memory\nwould be mapped non reordering, and that other constructs\n(spinlocks/etc) would provide the barriers to assure that packet data\nand in memory rings/queues were ordered with respect to device\nregister reads/writes. This itself seems a bit sketchy, but the real\nproblem with GCC12 is that it is moving the actual reads/writes around\nat will as though they were independent operations when in truth they\nare not, but the compiler can't know that. When looking at the\nassembly dumps for many of these routines its possible to see very\nclean, but not strictly in program order operations occurring as the\ncompiler would be free to do if these weren't actually register\nreads/write operations.\n\nIts possible to suppress the timeout with a liberal bit of dma_mb()'s\nsprinkled around but the device still seems unable to reliably\nsend/receive data. A better plan is to use the safer readl/writel\neverywhere.\n\nSince this partially reverts an older commit, which notes the use of\nthe relaxed variants for performance reasons. I would suggest that\nany performance problems \n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b26091a02093104259ca64aeca73601e56160d62",
      "https://git.kernel.org/stable/c/06d836801cd82ded282aaf9e888ff9e7e4a88b91",
      "https://git.kernel.org/stable/c/1d717816189fd68f9e089cf89ed1f7327d2c2e71",
      "https://git.kernel.org/stable/c/f49769b462f282477ca801cf648f875b1c5b59db",
      "https://git.kernel.org/stable/c/8d3ea3d402db94b61075617e71b67459a714a502"
    ],
    "受影响版本": [
      "69d2ea9c798983c4a7157278ec84ff969d1cd8e8",
      "69d2ea9c798983c4a7157278ec84ff969d1cd8e8",
      "69d2ea9c798983c4a7157278ec84ff969d1cd8e8",
      "69d2ea9c798983c4a7157278ec84ff969d1cd8e8",
      "69d2ea9c798983c4a7157278ec84ff969d1cd8e8"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49175",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nPM: core: keep irq flags in device_pm_check_callbacks()\n\nThe function device_pm_check_callbacks() can be called under the spin\nlock (in the reported case it happens from genpd_add_device() ->\ndev_pm_domain_set(), when the genpd uses spinlocks rather than mutexes.\n\nHowever this function uncoditionally uses spin_lock_irq() /\nspin_unlock_irq(), thus not preserving the CPU flags. Use the\nirqsave/irqrestore instead.\n\nThe backtrace for the reference:\n[    2.752010] ------------[ cut here ]------------\n[    2.756769] raw_local_irq_restore() called with IRQs enabled\n[    2.762596] WARNING: CPU: 4 PID: 1 at kernel/locking/irqflag-debug.c:10 warn_bogus_irq_restore+0x34/0x50\n[    2.772338] Modules linked in:\n[    2.775487] CPU: 4 PID: 1 Comm: swapper/0 Tainted: G S                5.17.0-rc6-00384-ge330d0d82eff-dirty #684\n[    2.781384] Freeing initrd memory: 46024K\n[    2.785839] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[    2.785841] pc : warn_bogus_irq_restore+0x34/0x50\n[    2.785844] lr : warn_bogus_irq_restore+0x34/0x50\n[    2.785846] sp : ffff80000805b7d0\n[    2.785847] x29: ffff80000805b7d0 x28: 0000000000000000 x27: 0000000000000002\n[    2.785850] x26: ffffd40e80930b18 x25: ffff7ee2329192b8 x24: ffff7edfc9f60800\n[    2.785853] x23: ffffd40e80930b18 x22: ffffd40e80930d30 x21: ffff7edfc0dffa00\n[    2.785856] x20: ffff7edfc09e3768 x19: 0000000000000000 x18: ffffffffffffffff\n[    2.845775] x17: 6572206f74206465 x16: 6c696166203a3030 x15: ffff80008805b4f7\n[    2.853108] x14: 0000000000000000 x13: ffffd40e809550b0 x12: 00000000000003d8\n[    2.860441] x11: 0000000000000148 x10: ffffd40e809550b0 x9 : ffffd40e809550b0\n[    2.867774] x8 : 00000000ffffefff x7 : ffffd40e809ad0b0 x6 : ffffd40e809ad0b0\n[    2.875107] x5 : 000000000000bff4 x4 : 0000000000000000 x3 : 0000000000000000\n[    2.882440] x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff7edfc03a8000\n[    2.889774] Call trace:\n[    2.892290]  warn_bogus_irq_restore+0x34/0x50\n[    2.896770]  _raw_spin_unlock_irqrestore+0x94/0xa0\n[    2.901690]  genpd_unlock_spin+0x20/0x30\n[    2.905724]  genpd_add_device+0x100/0x2d0\n[    2.909850]  __genpd_dev_pm_attach+0xa8/0x23c\n[    2.914329]  genpd_dev_pm_attach_by_id+0xc4/0x190\n[    2.919167]  genpd_dev_pm_attach_by_name+0x3c/0xd0\n[    2.924086]  dev_pm_domain_attach_by_name+0x24/0x30\n[    2.929102]  psci_dt_attach_cpu+0x24/0x90\n[    2.933230]  psci_cpuidle_probe+0x2d4/0x46c\n[    2.937534]  platform_probe+0x68/0xe0\n[    2.941304]  really_probe.part.0+0x9c/0x2fc\n[    2.945605]  __driver_probe_device+0x98/0x144\n[    2.950085]  driver_probe_device+0x44/0x15c\n[    2.954385]  __device_attach_driver+0xb8/0x120\n[    2.958950]  bus_for_each_drv+0x78/0xd0\n[    2.962896]  __device_attach+0xd8/0x180\n[    2.966843]  device_initial_probe+0x14/0x20\n[    2.971144]  bus_probe_device+0x9c/0xa4\n[    2.975092]  device_add+0x380/0x88c\n[    2.978679]  platform_device_add+0x114/0x234\n[    2.983067]  platform_device_register_full+0x100/0x190\n[    2.988344]  psci_idle_init+0x6c/0xb0\n[    2.992113]  do_one_initcall+0x74/0x3a0\n[    2.996060]  kernel_init_freeable+0x2fc/0x384\n[    3.000543]  kernel_init+0x28/0x130\n[    3.004132]  ret_from_fork+0x10/0x20\n[    3.007817] irq event stamp: 319826\n[    3.011404] hardirqs last  enabled at (319825): [<ffffd40e7eda0268>] __up_console_sem+0x78/0x84\n[    3.020332] hardirqs last disabled at (319826): [<ffffd40e7fd6d9d8>] el1_dbg+0x24/0x8c\n[    3.028458] softirqs last  enabled at (318312): [<ffffd40e7ec90410>] _stext+0x410/0x588\n[    3.036678] softirqs last disabled at (318299): [<ffffd40e7ed1bf68>] __irq_exit_rcu+0x158/0x174\n[    3.045607] ---[ end trace 0000000000000000 ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3ec80d52b9b74b9e691997632a543c73eddfeba0",
      "https://git.kernel.org/stable/c/78c4d68b952f5f537788dbd454031ea9bf50f642",
      "https://git.kernel.org/stable/c/be8bc05f38d667eda1e820bc6f69234795be7809",
      "https://git.kernel.org/stable/c/0cccf9d4fb45f1acbc0bbf6d7e4d8d0fb7a10416",
      "https://git.kernel.org/stable/c/ede1ef1a7de973321699736ef96d01a4b9a6fe9e",
      "https://git.kernel.org/stable/c/c29642ba72f87c0a3d7449f7db5d6d76a7ed53c3",
      "https://git.kernel.org/stable/c/2add538e57a2825c61d639260386f385c75e4166",
      "https://git.kernel.org/stable/c/c7c0ec5a1dcc3eaa1e85c804c2ccf46e457788a3",
      "https://git.kernel.org/stable/c/524bb1da785a7ae43dd413cd392b5071c6c367f8"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49132",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nath11k: pci: fix crash on suspend if board file is not found\n\nMario reported that the kernel was crashing on suspend if ath11k was not able\nto find a board file:\n\n[  473.693286] PM: Suspending system (s2idle)\n[  473.693291] printk: Suspending console(s) (use no_console_suspend to debug)\n[  474.407787] BUG: unable to handle page fault for address: 0000000000002070\n[  474.407791] #PF: supervisor read access in kernel mode\n[  474.407794] #PF: error_code(0x0000) - not-present page\n[  474.407798] PGD 0 P4D 0\n[  474.407801] Oops: 0000 [#1] PREEMPT SMP NOPTI\n[  474.407805] CPU: 2 PID: 2350 Comm: kworker/u32:14 Tainted: G        W         5.16.0 #248\n[...]\n[  474.407868] Call Trace:\n[  474.407870]  <TASK>\n[  474.407874]  ? _raw_spin_lock_irqsave+0x2a/0x60\n[  474.407882]  ? lock_timer_base+0x72/0xa0\n[  474.407889]  ? _raw_spin_unlock_irqrestore+0x29/0x3d\n[  474.407892]  ? try_to_del_timer_sync+0x54/0x80\n[  474.407896]  ath11k_dp_rx_pktlog_stop+0x49/0xc0 [ath11k]\n[  474.407912]  ath11k_core_suspend+0x34/0x130 [ath11k]\n[  474.407923]  ath11k_pci_pm_suspend+0x1b/0x50 [ath11k_pci]\n[  474.407928]  pci_pm_suspend+0x7e/0x170\n[  474.407935]  ? pci_pm_freeze+0xc0/0xc0\n[  474.407939]  dpm_run_callback+0x4e/0x150\n[  474.407947]  __device_suspend+0x148/0x4c0\n[  474.407951]  async_suspend+0x20/0x90\ndmesg-efi-164255130401001:\nOops#1 Part1\n[  474.407955]  async_run_entry_fn+0x33/0x120\n[  474.407959]  process_one_work+0x220/0x3f0\n[  474.407966]  worker_thread+0x4a/0x3d0\n[  474.407971]  kthread+0x17a/0x1a0\n[  474.407975]  ? process_one_work+0x3f0/0x3f0\n[  474.407979]  ? set_kthread_struct+0x40/0x40\n[  474.407983]  ret_from_fork+0x22/0x30\n[  474.407991]  </TASK>\n\nThe issue here is that board file loading happens after ath11k_pci_probe()\nsuccesfully returns (ath11k initialisation happends asynchronously) and the\nsuspend handler is still enabled, of course failing as ath11k is not properly\ninitialised. Fix this by checking ATH11K_FLAG_QMI_FAIL during both suspend and\nresume.\n\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fed4cef115ab21a18faf499b3fa9b9a4b544f941",
      "https://git.kernel.org/stable/c/f3c5ef433da82d257337424b3647ce9dcb37d4b5",
      "https://git.kernel.org/stable/c/aeed776c00e804a0f7896db39c7c661cea34ee1f",
      "https://git.kernel.org/stable/c/b4f4c56459a5c744f7f066b9fc2b54ea995030c5"
    ],
    "受影响版本": [
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49130",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nath11k: mhi: use mhi_sync_power_up()\n\nIf amss.bin was missing ath11k would crash during 'rmmod ath11k_pci'. The\nreason for that was that we were using mhi_async_power_up() which does not\ncheck any errors. But mhi_sync_power_up() on the other hand does check for\nerrors so let's use that to fix the crash.\n\nI was not able to find a reason why an async version was used.\nath11k_mhi_start() (which enables state ATH11K_MHI_POWER_ON) is called from\nath11k_hif_power_up(), which can sleep. So sync version should be safe to use\nhere.\n\n[  145.569731] general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC KASAN PTI\n[  145.569789] KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n[  145.569843] CPU: 2 PID: 1628 Comm: rmmod Kdump: loaded Tainted: G        W         5.16.0-wt-ath+ #567\n[  145.569898] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB, BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021\n[  145.569956] RIP: 0010:ath11k_hal_srng_access_begin+0xb5/0x2b0 [ath11k]\n[  145.570028] Code: df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 ec 01 00 00 48 8b ab a8 00 00 00 48 b8 00 00 00 00 00 fc ff df 48 89 ea 48 c1 ea 03 <0f> b6 14 02 48 89 e8 83 e0 07 83 c0 03 45 85 ed 75 48 38 d0 7c 08\n[  145.570089] RSP: 0018:ffffc900025d7ac0 EFLAGS: 00010246\n[  145.570144] RAX: dffffc0000000000 RBX: ffff88814fca2dd8 RCX: 1ffffffff50cb455\n[  145.570196] RDX: 0000000000000000 RSI: ffff88814fca2dd8 RDI: ffff88814fca2e80\n[  145.570252] RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffffa8659497\n[  145.570329] R10: fffffbfff50cb292 R11: 0000000000000001 R12: ffff88814fca0000\n[  145.570410] R13: 0000000000000000 R14: ffff88814fca2798 R15: ffff88814fca2dd8\n[  145.570465] FS:  00007fa399988540(0000) GS:ffff888233e00000(0000) knlGS:0000000000000000\n[  145.570519] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  145.570571] CR2: 00007fa399b51421 CR3: 0000000137898002 CR4: 00000000003706e0\n[  145.570623] Call Trace:\n[  145.570675]  <TASK>\n[  145.570727]  ? ath11k_ce_tx_process_cb+0x34b/0x860 [ath11k]\n[  145.570797]  ath11k_ce_tx_process_cb+0x356/0x860 [ath11k]\n[  145.570864]  ? tasklet_init+0x150/0x150\n[  145.570919]  ? ath11k_ce_alloc_pipes+0x280/0x280 [ath11k]\n[  145.570986]  ? tasklet_clear_sched+0x42/0xe0\n[  145.571042]  ? tasklet_kill+0xe9/0x1b0\n[  145.571095]  ? tasklet_clear_sched+0xe0/0xe0\n[  145.571148]  ? irq_has_action+0x120/0x120\n[  145.571202]  ath11k_ce_cleanup_pipes+0x45a/0x580 [ath11k]\n[  145.571270]  ? ath11k_pci_stop+0x10e/0x170 [ath11k_pci]\n[  145.571345]  ath11k_core_stop+0x8a/0xc0 [ath11k]\n[  145.571434]  ath11k_core_deinit+0x9e/0x150 [ath11k]\n[  145.571499]  ath11k_pci_remove+0xd2/0x260 [ath11k_pci]\n[  145.571553]  pci_device_remove+0x9a/0x1c0\n[  145.571605]  __device_release_driver+0x332/0x660\n[  145.571659]  driver_detach+0x1e7/0x2c0\n[  145.571712]  bus_remove_driver+0xe2/0x2d0\n[  145.571772]  pci_unregister_driver+0x21/0x250\n[  145.571826]  __do_sys_delete_module+0x30a/0x4b0\n[  145.571879]  ? free_module+0xac0/0xac0\n[  145.571933]  ? lockdep_hardirqs_on_prepare.part.0+0x18c/0x370\n[  145.571986]  ? syscall_enter_from_user_mode+0x1d/0x50\n[  145.572039]  ? lockdep_hardirqs_on+0x79/0x100\n[  145.572097]  do_syscall_64+0x3b/0x90\n[  145.572153]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/339bd0b55ecdd0f7f341e9357c4cfde799de9418",
      "https://git.kernel.org/stable/c/20d01a11efde2e05e47d5c66101f5c26eaca68e2",
      "https://git.kernel.org/stable/c/3fd7d50384c3808b7f7fa135aa9bb5feb1cb9849",
      "https://git.kernel.org/stable/c/646d533af2911be1184eaee8c900b7eb8ecc4396",
      "https://git.kernel.org/stable/c/3df6d74aedfdca919cca475d15dfdbc8b05c9e5d"
    ],
    "受影响版本": [
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d",
      "d5c65159f2895379e11ca13f62feabe93278985d"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49118",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: hisi_sas: Free irq vectors in order for v3 HW\n\nIf the driver probe fails to request the channel IRQ or fatal IRQ, the\ndriver will free the IRQ vectors before freeing the IRQs in free_irq(),\nand this will cause a kernel BUG like this:\n\n------------[ cut here ]------------\nkernel BUG at drivers/pci/msi.c:369!\nInternal error: Oops - BUG: 0 [#1] PREEMPT SMP\nCall trace:\n   free_msi_irqs+0x118/0x13c\n   pci_disable_msi+0xfc/0x120\n   pci_free_irq_vectors+0x24/0x3c\n   hisi_sas_v3_probe+0x360/0x9d0 [hisi_sas_v3_hw]\n   local_pci_probe+0x44/0xb0\n   work_for_cpu_fn+0x20/0x34\n   process_one_work+0x1d0/0x340\n   worker_thread+0x2e0/0x460\n   kthread+0x180/0x190\n   ret_from_fork+0x10/0x20\n---[ end trace b88990335b610c11 ]---\n\nSo we use devm_add_action() to control the order in which we free the\nvectors.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/224903cc60d045576393c3b16907742f23e6c740",
      "https://git.kernel.org/stable/c/f05a0d8de2ea49af36821a20b0b501e20ced937e",
      "https://git.kernel.org/stable/c/8b6eab9d683bae7f88dc894b8c851f866032301c",
      "https://git.kernel.org/stable/c/b4cc04fa8f1fc3816c8494d77abab3f72b9d2292",
      "https://git.kernel.org/stable/c/554fb72ee34f4732c7f694f56c3c6e67790352a0"
    ],
    "受影响版本": [
      "47caad1577cd7a39e2048c5e4edbce4b863dc12b",
      "47caad1577cd7a39e2048c5e4edbce4b863dc12b",
      "47caad1577cd7a39e2048c5e4edbce4b863dc12b",
      "47caad1577cd7a39e2048c5e4edbce4b863dc12b",
      "47caad1577cd7a39e2048c5e4edbce4b863dc12b"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49092",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ipv4: fix route with nexthop object delete warning\n\nFRR folks have hit a kernel warning[1] while deleting routes[2] which is\ncaused by trying to delete a route pointing to a nexthop id without\nspecifying nhid but matching on an interface. That is, a route is found\nbut we hit a warning while matching it. The warning is from\nfib_info_nh() in include/net/nexthop.h because we run it on a fib_info\nwith nexthop object. The call chain is:\n inet_rtm_delroute -> fib_table_delete -> fib_nh_match (called with a\nnexthop fib_info and also with fc_oif set thus calling fib_info_nh on\nthe fib_info and triggering the warning). The fix is to not do any\nmatching in that branch if the fi has a nexthop object because those are\nmanaged separately. I.e. we should match when deleting without nh spec and\nshould fail when deleting a nexthop route with old-style nh spec because\nnexthop objects are managed separately, e.g.:\n $ ip r show 1.2.3.4/32\n 1.2.3.4 nhid 12 via 192.168.11.2 dev dummy0\n\n $ ip r del 1.2.3.4/32\n $ ip r del 1.2.3.4/32 nhid 12\n <both should work>\n\n $ ip r del 1.2.3.4/32 dev dummy0\n <should fail with ESRCH>\n\n[1]\n [  523.462226] ------------[ cut here ]------------\n [  523.462230] WARNING: CPU: 14 PID: 22893 at include/net/nexthop.h:468 fib_nh_match+0x210/0x460\n [  523.462236] Modules linked in: dummy rpcsec_gss_krb5 xt_socket nf_socket_ipv4 nf_socket_ipv6 ip6table_raw iptable_raw bpf_preload xt_statistic ip_set ip_vs_sh ip_vs_wrr ip_vs_rr ip_vs xt_mark nf_tables xt_nat veth nf_conntrack_netlink nfnetlink xt_addrtype br_netfilter overlay dm_crypt nfsv3 nfs fscache netfs vhost_net vhost vhost_iotlb tap tun xt_CHECKSUM xt_MASQUERADE xt_conntrack 8021q garp mrp ipt_REJECT nf_reject_ipv4 ip6table_mangle ip6table_nat iptable_mangle iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 iptable_filter bridge stp llc rfcomm snd_seq_dummy snd_hrtimer rpcrdma rdma_cm iw_cm ib_cm ib_core ip6table_filter xt_comment ip6_tables vboxnetadp(OE) vboxnetflt(OE) vboxdrv(OE) qrtr bnep binfmt_misc xfs vfat fat squashfs loop nvidia_drm(POE) nvidia_modeset(POE) nvidia_uvm(POE) nvidia(POE) intel_rapl_msr intel_rapl_common snd_hda_codec_realtek snd_hda_codec_generic ledtrig_audio snd_hda_codec_hdmi btusb btrtl iwlmvm uvcvideo btbcm snd_hda_intel edac_mce_amd\n [  523.462274]  videobuf2_vmalloc videobuf2_memops btintel snd_intel_dspcfg videobuf2_v4l2 snd_intel_sdw_acpi bluetooth snd_usb_audio snd_hda_codec mac80211 snd_usbmidi_lib joydev snd_hda_core videobuf2_common kvm_amd snd_rawmidi snd_hwdep snd_seq videodev ccp snd_seq_device libarc4 ecdh_generic mc snd_pcm kvm iwlwifi snd_timer drm_kms_helper snd cfg80211 cec soundcore irqbypass rapl wmi_bmof i2c_piix4 rfkill k10temp pcspkr acpi_cpufreq nfsd auth_rpcgss nfs_acl lockd grace sunrpc drm zram ip_tables crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel nvme sp5100_tco r8169 nvme_core wmi ipmi_devintf ipmi_msghandler fuse\n [  523.462300] CPU: 14 PID: 22893 Comm: ip Tainted: P           OE     5.16.18-200.fc35.x86_64 #1\n [  523.462302] Hardware name: Micro-Star International Co., Ltd. MS-7C37/MPG X570 GAMING EDGE WIFI (MS-7C37), BIOS 1.C0 10/29/2020\n [  523.462303] RIP: 0010:fib_nh_match+0x210/0x460\n [  523.462304] Code: 7c 24 20 48 8b b5 90 00 00 00 e8 bb ee f4 ff 48 8b 7c 24 20 41 89 c4 e8 ee eb f4 ff 45 85 e4 0f 85 2e fe ff ff e9 4c ff ff ff <0f> 0b e9 17 ff ff ff 3c 0a 0f 85 61 fe ff ff 48 8b b5 98 00 00 00\n [  523.462306] RSP: 0018:ffffaa53d4d87928 EFLAGS: 00010286\n [  523.462307] RAX: 0000000000000000 RBX: ffffaa53d4d87a90 RCX: ffffaa53d4d87bb0\n [  523.462308] RDX: ffff9e3d2ee6be80 RSI: ffffaa53d4d87a90 RDI: ffffffff920ed380\n [  523.462309] RBP: ffff9e3d2ee6be80 R08: 0000000000000064 R09: 0000000000000000\n [  523.462310] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000031\n [  523.462310] R13: 0000000000000020 R14: 0000000000000000 R15: ffff9e3d331054e0\n [  523.462311] FS:  00007f2455\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f5064531c23ad646da7be8b938292b00a7e61438",
      "https://git.kernel.org/stable/c/63ea57478aaa3e06a597081a0f537318fc04e49f",
      "https://git.kernel.org/stable/c/907c97986d6fa77318d17659dd76c94b65dd27c5",
      "https://git.kernel.org/stable/c/dcd689f9e2640c992f94eae9955b106f71c6825d",
      "https://git.kernel.org/stable/c/f8db5743d09523c0bb35f16e13691e3b7eb5dba0",
      "https://git.kernel.org/stable/c/6bf92d70e690b7ff12b24f4bfff5e5434d019b82"
    ],
    "受影响版本": [
      "4c7e8084fd467ddb2b0e6c6011f9c1064afb7e56",
      "4c7e8084fd467ddb2b0e6c6011f9c1064afb7e56",
      "4c7e8084fd467ddb2b0e6c6011f9c1064afb7e56",
      "4c7e8084fd467ddb2b0e6c6011f9c1064afb7e56",
      "4c7e8084fd467ddb2b0e6c6011f9c1064afb7e56",
      "4c7e8084fd467ddb2b0e6c6011f9c1064afb7e56"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49090",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\narch/arm64: Fix topology initialization for core scheduling\n\nArm64 systems rely on store_cpu_topology() to call update_siblings_masks()\nto transfer the toplogy to the various cpu masks. This needs to be done\nbefore the call to notify_cpu_starting() which tells the scheduler about\neach cpu found, otherwise the core scheduling data structures are setup\nin a way that does not match the actual topology.\n\nWith smt_mask not setup correctly we bail on `cpumask_weight(smt_mask) == 1`\nfor !leaders in:\n\n notify_cpu_starting()\n   cpuhp_invoke_callback_range()\n     sched_cpu_starting()\n       sched_core_cpu_starting()\n\nwhich leads to rq->core not being correctly set for !leader-rq's.\n\nWithout this change stress-ng (which enables core scheduling in its prctl\ntests in newer versions -- i.e. with PR_SCHED_CORE support) causes a warning\nand then a crash (trimmed for legibility):\n\n[ 1853.805168] ------------[ cut here ]------------\n[ 1853.809784] task_rq(b)->core != rq->core\n[ 1853.809792] WARNING: CPU: 117 PID: 0 at kernel/sched/fair.c:11102 cfs_prio_less+0x1b4/0x1c4\n...\n[ 1854.015210] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000010\n...\n[ 1854.231256] Call trace:\n[ 1854.233689]  pick_next_task+0x3dc/0x81c\n[ 1854.237512]  __schedule+0x10c/0x4cc\n[ 1854.240988]  schedule_idle+0x34/0x54",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/87f5d66daa5f457449bb95d6b8d18bb7596aa627",
      "https://git.kernel.org/stable/c/790c1567582bda8f1153015436e3330a7c6eb278",
      "https://git.kernel.org/stable/c/c78a1b2d0bff678570c8dc9f14035606f5e5257d",
      "https://git.kernel.org/stable/c/5524cbb1bfcdff0cad0aaa9f94e6092002a07259"
    ],
    "受影响版本": [
      "9edeaea1bc452372718837ed2ba775811baf1ba1",
      "9edeaea1bc452372718837ed2ba775811baf1ba1",
      "9edeaea1bc452372718837ed2ba775811baf1ba1",
      "9edeaea1bc452372718837ed2ba775811baf1ba1"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49078",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nlz4: fix LZ4_decompress_safe_partial read out of bound\n\nWhen partialDecoding, it is EOF if we've either filled the output buffer\nor can't proceed with reading an offset for following match.\n\nIn some extreme corner cases when compressed data is suitably corrupted,\nUAF will occur.  As reported by KASAN [1], LZ4_decompress_safe_partial\nmay lead to read out of bound problem during decoding.  lz4 upstream has\nfixed it [2] and this issue has been disscussed here [3] before.\n\ncurrent decompression routine was ported from lz4 v1.8.3, bumping\nlib/lz4 to v1.9.+ is certainly a huge work to be done later, so, we'd\nbetter fix it first.\n\n[1] https://lore.kernel.org/all/000000000000830d1205cf7f0477@google.com/\n[2] https://github.com/lz4/lz4/commit/c5d6f8a8be3927c0bec91bcc58667a6cfad244ad#\n[3] https://lore.kernel.org/all/CC666AE8-4CA4-4951-B6FB-A2EFDE3AC03B@fb.com/",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/73953dfa9d50e5c9fe98ee13fd1d3427aa12a0a3",
      "https://git.kernel.org/stable/c/6adc01a7aa37445dafe8846faa0610a86029b253",
      "https://git.kernel.org/stable/c/9fb8bc6cfc58773ce95414e11c9ccc8fc6ac4927",
      "https://git.kernel.org/stable/c/e64dbe97c05c769525cbca099ddbd22485630235",
      "https://git.kernel.org/stable/c/467d5e200ab4486b744fe1776154a43d1aa22d4b",
      "https://git.kernel.org/stable/c/eafc0a02391b7b36617b36c97c4b5d6832cf5e24"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49073",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nata: sata_dwc_460ex: Fix crash due to OOB write\n\nthe driver uses libata's \"tag\" values from in various arrays.\nSince the mentioned patch bumped the ATA_TAG_INTERNAL to 32,\nthe value of the SATA_DWC_QCMD_MAX needs to account for that.\n\nOtherwise ATA_TAG_INTERNAL usage cause similar crashes like\nthis as reported by Tice Rex on the OpenWrt Forum and\nreproduced (with symbols) here:\n\n| BUG: Kernel NULL pointer dereference at 0x00000000\n| Faulting instruction address: 0xc03ed4b8\n| Oops: Kernel access of bad area, sig: 11 [#1]\n| BE PAGE_SIZE=4K PowerPC 44x Platform\n| CPU: 0 PID: 362 Comm: scsi_eh_1 Not tainted 5.4.163 #0\n| NIP:  c03ed4b8 LR: c03d27e8 CTR: c03ed36c\n| REGS: cfa59950 TRAP: 0300   Not tainted  (5.4.163)\n| MSR:  00021000 <CE,ME>  CR: 42000222  XER: 00000000\n| DEAR: 00000000 ESR: 00000000\n| GPR00: c03d27e8 cfa59a08 cfa55fe0 00000000 0fa46bc0 [...]\n| [..]\n| NIP [c03ed4b8] sata_dwc_qc_issue+0x14c/0x254\n| LR [c03d27e8] ata_qc_issue+0x1c8/0x2dc\n| Call Trace:\n| [cfa59a08] [c003f4e0] __cancel_work_timer+0x124/0x194 (unreliable)\n| [cfa59a78] [c03d27e8] ata_qc_issue+0x1c8/0x2dc\n| [cfa59a98] [c03d2b3c] ata_exec_internal_sg+0x240/0x524\n| [cfa59b08] [c03d2e98] ata_exec_internal+0x78/0xe0\n| [cfa59b58] [c03d30fc] ata_read_log_page.part.38+0x1dc/0x204\n| [cfa59bc8] [c03d324c] ata_identify_page_supported+0x68/0x130\n| [...]\n\nThis is because sata_dwc_dma_xfer_complete() NULLs the\ndma_pending's next neighbour \"chan\" (a *dma_chan struct) in\nthis '32' case right here (line ~735):\n> hsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_NONE;\n\nThen the next time, a dma gets issued; dma_dwc_xfer_setup() passes\nthe NULL'd hsdevp->chan to the dmaengine_slave_config() which then\ncauses the crash.\n\nWith this patch, SATA_DWC_QCMD_MAX is now set to ATA_MAX_QUEUE + 1.\nThis avoids the OOB. But please note, there was a worthwhile discussion\non what ATA_TAG_INTERNAL and ATA_MAX_QUEUE is. And why there should not\nbe a \"fake\" 33 command-long queue size.\n\nIdeally, the dw driver should account for the ATA_TAG_INTERNAL.\nIn Damien Le Moal's words: \"... having looked at the driver, it\nis a bigger change than just faking a 33rd \"tag\" that is in fact\nnot a command tag at all.\"\n\nBugLink: https://github.com/openwrt/openwrt/issues/9505",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/596c7efd69aae94f4b0e91172b075eb197958b99",
      "https://git.kernel.org/stable/c/55e1465ba79562a191708a40eeae3f8082a209e3",
      "https://git.kernel.org/stable/c/fc629224aa62f23849cae83717932985ac51232d",
      "https://git.kernel.org/stable/c/8a05a6952ecd59aaa62cbdcdaf523ae2c8f436e8",
      "https://git.kernel.org/stable/c/234c0132f76f0676d175757f61b0025191a3d935",
      "https://git.kernel.org/stable/c/3a8751c0d4e24129e72dcec0139e99833b13904a",
      "https://git.kernel.org/stable/c/7aa8104a554713b685db729e66511b93d989dd6a"
    ],
    "受影响版本": [
      "28361c403683c2b00d4f5e76045f3ccd299bf99d",
      "28361c403683c2b00d4f5e76045f3ccd299bf99d",
      "28361c403683c2b00d4f5e76045f3ccd299bf99d",
      "28361c403683c2b00d4f5e76045f3ccd299bf99d",
      "28361c403683c2b00d4f5e76045f3ccd299bf99d",
      "28361c403683c2b00d4f5e76045f3ccd299bf99d",
      "28361c403683c2b00d4f5e76045f3ccd299bf99d"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49034",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsh: cpuinfo: Fix a warning for CONFIG_CPUMASK_OFFSTACK\n\nWhen CONFIG_CPUMASK_OFFSTACK and CONFIG_DEBUG_PER_CPU_MAPS are selected,\ncpu_max_bits_warn() generates a runtime warning similar as below when\nshowing /proc/cpuinfo. Fix this by using nr_cpu_ids (the runtime limit)\ninstead of NR_CPUS to iterate CPUs.\n\n[    3.052463] ------------[ cut here ]------------\n[    3.059679] WARNING: CPU: 3 PID: 1 at include/linux/cpumask.h:108 show_cpuinfo+0x5e8/0x5f0\n[    3.070072] Modules linked in: efivarfs autofs4\n[    3.076257] CPU: 0 PID: 1 Comm: systemd Not tainted 5.19-rc5+ #1052\n[    3.099465] Stack : 9000000100157b08 9000000000f18530 9000000000cf846c 9000000100154000\n[    3.109127]         9000000100157a50 0000000000000000 9000000100157a58 9000000000ef7430\n[    3.118774]         90000001001578e8 0000000000000040 0000000000000020 ffffffffffffffff\n[    3.128412]         0000000000aaaaaa 1ab25f00eec96a37 900000010021de80 900000000101c890\n[    3.138056]         0000000000000000 0000000000000000 0000000000000000 0000000000aaaaaa\n[    3.147711]         ffff8000339dc220 0000000000000001 0000000006ab4000 0000000000000000\n[    3.157364]         900000000101c998 0000000000000004 9000000000ef7430 0000000000000000\n[    3.167012]         0000000000000009 000000000000006c 0000000000000000 0000000000000000\n[    3.176641]         9000000000d3de08 9000000001639390 90000000002086d8 00007ffff0080286\n[    3.186260]         00000000000000b0 0000000000000004 0000000000000000 0000000000071c1c\n[    3.195868]         ...\n[    3.199917] Call Trace:\n[    3.203941] [<90000000002086d8>] show_stack+0x38/0x14c\n[    3.210666] [<9000000000cf846c>] dump_stack_lvl+0x60/0x88\n[    3.217625] [<900000000023d268>] __warn+0xd0/0x100\n[    3.223958] [<9000000000cf3c90>] warn_slowpath_fmt+0x7c/0xcc\n[    3.231150] [<9000000000210220>] show_cpuinfo+0x5e8/0x5f0\n[    3.238080] [<90000000004f578c>] seq_read_iter+0x354/0x4b4\n[    3.245098] [<90000000004c2e90>] new_sync_read+0x17c/0x1c4\n[    3.252114] [<90000000004c5174>] vfs_read+0x138/0x1d0\n[    3.258694] [<90000000004c55f8>] ksys_read+0x70/0x100\n[    3.265265] [<9000000000cfde9c>] do_syscall+0x7c/0x94\n[    3.271820] [<9000000000202fe4>] handle_syscall+0xc4/0x160\n[    3.281824] ---[ end trace 8b484262b4b8c24c ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8fbb57eabfc8ae67115cb47f904614c99d626a89",
      "https://git.kernel.org/stable/c/f8f26cf69003a37ffa947631fc0e6fe6daee624a",
      "https://git.kernel.org/stable/c/77755dc95ff2f9a3e473acc1e039f498629949ea",
      "https://git.kernel.org/stable/c/e2b91997db286a5dd3cca6d5d9c20004851f22eb",
      "https://git.kernel.org/stable/c/2b6b8e011fab680a223b5e07a3c64774156ec6fe",
      "https://git.kernel.org/stable/c/09faf32c682ea4a547200b8b9e04d8b3c8e84b55",
      "https://git.kernel.org/stable/c/39373f6f89f52770a5405d30dddd08a27d097872",
      "https://git.kernel.org/stable/c/701e32900683378d93693fec15d133e2c5f7ada2",
      "https://git.kernel.org/stable/c/3c891f7c6a4e90bb1199497552f24b26e46383bc"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年12月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49023",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: cfg80211: fix buffer overflow in elem comparison\n\nFor vendor elements, the code here assumes that 5 octets\nare present without checking. Since the element itself is\nalready checked to fit, we only need to check the length.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f5c2ec288a865dbe3706b09bed12302e9f6d696b",
      "https://git.kernel.org/stable/c/9e6b79a3cd17620d467311b30d56f2648f6880aa",
      "https://git.kernel.org/stable/c/88a6fe3707888bd1893e9741157a7035c4159ab6",
      "https://git.kernel.org/stable/c/391cb872553627bdcf236c03ee7d5adb275e37e1",
      "https://git.kernel.org/stable/c/9f16b5c82a025cd4c864737409234ddc44fb166a"
    ],
    "受影响版本": [
      "0b8fb8235be8be99a197e8d948fc0a2df8dc261a",
      "0b8fb8235be8be99a197e8d948fc0a2df8dc261a",
      "0b8fb8235be8be99a197e8d948fc0a2df8dc261a",
      "0b8fb8235be8be99a197e8d948fc0a2df8dc261a",
      "0b8fb8235be8be99a197e8d948fc0a2df8dc261a"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-49001",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: fix race when vmap stack overflow\n\nCurrently, when detecting vmap stack overflow, riscv firstly switches\nto the so called shadow stack, then use this shadow stack to call the\nget_overflow_stack() to get the overflow stack. However, there's\na race here if two or more harts use the same shadow stack at the same\ntime.\n\nTo solve this race, we introduce spin_shadow_stack atomic var, which\nwill be swap between its own address and 0 in atomic way, when the\nvar is set, it means the shadow_stack is being used; when the var\nis cleared, it means the shadow_stack isn't being used.\n\n[Palmer: Add AQ to the swap, and also some comments.]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ac00301adb19df54f2eae1efc4bad7447c0156ce",
      "https://git.kernel.org/stable/c/879fabc5a95401d9bce357e4b1d24ae4a360a81f",
      "https://git.kernel.org/stable/c/7e1864332fbc1b993659eab7974da9fe8bf8c128"
    ],
    "受影响版本": [
      "31da94c25aea835ceac00575a9fd206c5a833fed",
      "31da94c25aea835ceac00575a9fd206c5a833fed",
      "31da94c25aea835ceac00575a9fd206c5a833fed"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48998",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/bpf/32: Fix Oops on tail call tests\n\ntest_bpf tail call tests end up as:\n\n  test_bpf: #0 Tail call leaf jited:1 85 PASS\n  test_bpf: #1 Tail call 2 jited:1 111 PASS\n  test_bpf: #2 Tail call 3 jited:1 145 PASS\n  test_bpf: #3 Tail call 4 jited:1 170 PASS\n  test_bpf: #4 Tail call load/store leaf jited:1 190 PASS\n  test_bpf: #5 Tail call load/store jited:1\n  BUG: Unable to handle kernel data access on write at 0xf1b4e000\n  Faulting instruction address: 0xbe86b710\n  Oops: Kernel access of bad area, sig: 11 [#1]\n  BE PAGE_SIZE=4K MMU=Hash PowerMac\n  Modules linked in: test_bpf(+)\n  CPU: 0 PID: 97 Comm: insmod Not tainted 6.1.0-rc4+ #195\n  Hardware name: PowerMac3,1 750CL 0x87210 PowerMac\n  NIP:  be86b710 LR: be857e88 CTR: be86b704\n  REGS: f1b4df20 TRAP: 0300   Not tainted  (6.1.0-rc4+)\n  MSR:  00009032 <EE,ME,IR,DR,RI>  CR: 28008242  XER: 00000000\n  DAR: f1b4e000 DSISR: 42000000\n  GPR00: 00000001 f1b4dfe0 c11d2280 00000000 00000000 00000000 00000002 00000000\n  GPR08: f1b4e000 be86b704 f1b4e000 00000000 00000000 100d816a f2440000 fe73baa8\n  GPR16: f2458000 00000000 c1941ae4 f1fe2248 00000045 c0de0000 f2458030 00000000\n  GPR24: 000003e8 0000000f f2458000 f1b4dc90 3e584b46 00000000 f24466a0 c1941a00\n  NIP [be86b710] 0xbe86b710\n  LR [be857e88] __run_one+0xec/0x264 [test_bpf]\n  Call Trace:\n  [f1b4dfe0] [00000002] 0x2 (unreliable)\n  Instruction dump:\n  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n  ---[ end trace 0000000000000000 ]---\n\nThis is a tentative to write above the stack. The problem is encoutered\nwith tests added by commit 38608ee7b690 (\"bpf, tests: Add load store\ntest case for tail call\")\n\nThis happens because tail call is done to a BPF prog with a different\nstack_depth. At the time being, the stack is kept as is when the caller\ntail calls its callee. But at exit, the callee restores the stack based\non its own properties. Therefore here, at each run, r1 is erroneously\nincreased by 32 - 16 = 16 bytes.\n\nThis was done that way in order to pass the tail call count from caller\nto callee through the stack. As powerpc32 doesn't have a red zone in\nthe stack, it was necessary the maintain the stack as is for the tail\ncall. But it was not anticipated that the BPF frame size could be\ndifferent.\n\nLet's take a new approach. Use register r4 to carry the tail call count\nduring the tail call, and save it into the stack at function entry if\nrequired. This means the input parameter must be in r3, which is more\ncorrect as it is a 32 bits parameter, then tail call better match with\nnormal BPF function entry, the down side being that we move that input\nparameter back and forth between r3 and r4. That can be optimised later.\n\nDoing that also has the advantage of maximising the common parts between\ntail calls and a normal function exit.\n\nWith the fix, tail call tests are now successfull:\n\n  test_bpf: #0 Tail call leaf jited:1 53 PASS\n  test_bpf: #1 Tail call 2 jited:1 115 PASS\n  test_bpf: #2 Tail call 3 jited:1 154 PASS\n  test_bpf: #3 Tail call 4 jited:1 165 PASS\n  test_bpf: #4 Tail call load/store leaf jited:1 101 PASS\n  test_bpf: #5 Tail call load/store jited:1 141 PASS\n  test_bpf: #6 Tail call error path, max count reached jited:1 994 PASS\n  test_bpf: #7 Tail call count preserved across function calls jited:1 140975 PASS\n  test_bpf: #8 Tail call error path, NULL target jited:1 110 PASS\n  test_bpf: #9 Tail call error path, index out of range jited:1 69 PASS\n  test_bpf: test_tail_calls: Summary: 10 PASSED, 0 FAILED, [10/10 JIT'ed]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/747a6e547240baaaf41874d27333b87b87cfd24c",
      "https://git.kernel.org/stable/c/89d21e259a94f7d5582ec675aa445f5a79f347e4"
    ],
    "受影响版本": [
      "51c66ad849a703d9bbfd7704c941827aed0fd9fd",
      "51c66ad849a703d9bbfd7704c941827aed0fd9fd"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48983",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring: Fix a null-ptr-deref in io_tctx_exit_cb()\n\nSyzkaller reports a NULL deref bug as follows:\n\n BUG: KASAN: null-ptr-deref in io_tctx_exit_cb+0x53/0xd3\n Read of size 4 at addr 0000000000000138 by task file1/1955\n\n CPU: 1 PID: 1955 Comm: file1 Not tainted 6.1.0-rc7-00103-gef4d3ea40565 #75\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.0-2.el7 04/01/2014\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0xcd/0x134\n  ? io_tctx_exit_cb+0x53/0xd3\n  kasan_report+0xbb/0x1f0\n  ? io_tctx_exit_cb+0x53/0xd3\n  kasan_check_range+0x140/0x190\n  io_tctx_exit_cb+0x53/0xd3\n  task_work_run+0x164/0x250\n  ? task_work_cancel+0x30/0x30\n  get_signal+0x1c3/0x2440\n  ? lock_downgrade+0x6e0/0x6e0\n  ? lock_downgrade+0x6e0/0x6e0\n  ? exit_signals+0x8b0/0x8b0\n  ? do_raw_read_unlock+0x3b/0x70\n  ? do_raw_spin_unlock+0x50/0x230\n  arch_do_signal_or_restart+0x82/0x2470\n  ? kmem_cache_free+0x260/0x4b0\n  ? putname+0xfe/0x140\n  ? get_sigframe_size+0x10/0x10\n  ? do_execveat_common.isra.0+0x226/0x710\n  ? lockdep_hardirqs_on+0x79/0x100\n  ? putname+0xfe/0x140\n  ? do_execveat_common.isra.0+0x238/0x710\n  exit_to_user_mode_prepare+0x15f/0x250\n  syscall_exit_to_user_mode+0x19/0x50\n  do_syscall_64+0x42/0xb0\n  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n RIP: 0023:0x0\n Code: Unable to access opcode bytes at 0xffffffffffffffd6.\n RSP: 002b:00000000fffb7790 EFLAGS: 00000200 ORIG_RAX: 000000000000000b\n RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000\n RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\n R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n  </TASK>\n Kernel panic - not syncing: panic_on_warn set ...\n\nThis happens because the adding of task_work from io_ring_exit_work()\nisn't synchronized with canceling all work items from eg exec. The\nexecution of the two are ordered in that they are both run by the task\nitself, but if io_tctx_exit_cb() is queued while we're canceling all\nwork items off exec AND gets executed when the task exits to userspace\nrather than in the main loop in io_uring_cancel_generic(), then we can\nfind current->io_uring == NULL and hit the above crash.\n\nIt's safe to add this NULL check here, because the execution of the two\npaths are done by the task itself.\n\n[axboe: add code comment and also put an explanation in the commit msg]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f895511de9d27fff71dad2c234ad53b4afd2b06c",
      "https://git.kernel.org/stable/c/d91edca1943453aaaba4f380f6f364346222e5cf",
      "https://git.kernel.org/stable/c/998b30c3948e4d0b1097e639918c5cff332acac5"
    ],
    "受影响版本": [
      "d56d938b4bef3e1421a42023cdcd6e13c1f50831",
      "d56d938b4bef3e1421a42023cdcd6e13c1f50831",
      "d56d938b4bef3e1421a42023cdcd6e13c1f50831"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48975",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpiolib: fix memory leak in gpiochip_setup_dev()\n\nHere is a backtrace report about memory leak detected in\ngpiochip_setup_dev():\n\nunreferenced object 0xffff88810b406400 (size 512):\n  comm \"python3\", pid 1682, jiffies 4295346908 (age 24.090s)\n  backtrace:\n    kmalloc_trace\n    device_add\t\tdevice_private_init at drivers/base/core.c:3361\n\t\t\t(inlined by) device_add at drivers/base/core.c:3411\n    cdev_device_add\n    gpiolib_cdev_register\n    gpiochip_setup_dev\n    gpiochip_add_data_with_key\n\ngcdev_register() & gcdev_unregister() would call device_add() &\ndevice_del() (no matter CONFIG_GPIO_CDEV is enabled or not) to\nregister/unregister device.\n\nHowever, if device_add() succeeds, some resource (like\nstruct device_private allocated by device_private_init())\nis not released by device_del().\n\nTherefore, after device_add() succeeds by gcdev_register(), it\nneeds to call put_device() to release resource in the error handle\npath.\n\nHere we move forward the register of release function, and let it\nrelease every piece of resource by put_device() instead of kfree().\n\nWhile at it, fix another subtle issue, i.e. when gc->ngpio is equal\nto 0, we still call kcalloc() and, in case of further error, kfree()\non the ZERO_PTR pointer, which is not NULL. It's not a bug per se,\nbut rather waste of the resources and potentially wrong expectation\nabout contents of the gdev->descs variable.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6daaa84b621485fe28c401be18debf92ae8ef04a",
      "https://git.kernel.org/stable/c/371363716398ed718e389bea8c5e9843a79dde4e",
      "https://git.kernel.org/stable/c/ec851b23084b3a0af8bf0f5e51d33a8d678bdc49"
    ],
    "受影响版本": [
      "159f3cd92f17c61a4e2a47456de5865b114ef88e",
      "159f3cd92f17c61a4e2a47456de5865b114ef88e",
      "159f3cd92f17c61a4e2a47456de5865b114ef88e"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48922",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: fix oops caused by irqsoff latency tracer\n\nThe trace_hardirqs_{on,off}() require the caller to setup frame pointer\nproperly. This because these two functions use macro 'CALLER_ADDR1' (aka.\n__builtin_return_address(1)) to acquire caller info. If the $fp is used\nfor other purpose, the code generated this macro (as below) could trigger\nmemory access fault.\n\n   0xffffffff8011510e <+80>:    ld      a1,-16(s0)\n   0xffffffff80115112 <+84>:    ld      s2,-8(a1)  # <-- paging fault here\n\nThe oops message during booting if compiled with 'irqoff' tracer enabled:\n[    0.039615][    T0] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000f8\n[    0.041925][    T0] Oops [#1]\n[    0.042063][    T0] Modules linked in:\n[    0.042864][    T0] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.17.0-rc1-00233-g9a20c48d1ed2 #29\n[    0.043568][    T0] Hardware name: riscv-virtio,qemu (DT)\n[    0.044343][    T0] epc : trace_hardirqs_on+0x56/0xe2\n[    0.044601][    T0]  ra : restore_all+0x12/0x6e\n[    0.044721][    T0] epc : ffffffff80126a5c ra : ffffffff80003b94 sp : ffffffff81403db0\n[    0.044801][    T0]  gp : ffffffff8163acd8 tp : ffffffff81414880 t0 : 0000000000000020\n[    0.044882][    T0]  t1 : 0098968000000000 t2 : 0000000000000000 s0 : ffffffff81403de0\n[    0.044967][    T0]  s1 : 0000000000000000 a0 : 0000000000000001 a1 : 0000000000000100\n[    0.045046][    T0]  a2 : 0000000000000000 a3 : 0000000000000000 a4 : 0000000000000000\n[    0.045124][    T0]  a5 : 0000000000000000 a6 : 0000000000000000 a7 : 0000000054494d45\n[    0.045210][    T0]  s2 : ffffffff80003b94 s3 : ffffffff81a8f1b0 s4 : ffffffff80e27b50\n[    0.045289][    T0]  s5 : ffffffff81414880 s6 : ffffffff8160fa00 s7 : 00000000800120e8\n[    0.045389][    T0]  s8 : 0000000080013100 s9 : 000000000000007f s10: 0000000000000000\n[    0.045474][    T0]  s11: 0000000000000000 t3 : 7fffffffffffffff t4 : 0000000000000000\n[    0.045548][    T0]  t5 : 0000000000000000 t6 : ffffffff814aa368\n[    0.045620][    T0] status: 0000000200000100 badaddr: 00000000000000f8 cause: 000000000000000d\n[    0.046402][    T0] [<ffffffff80003b94>] restore_all+0x12/0x6e\n\nThis because the $fp(aka. $s0) register is not used as frame pointer in the\nassembly entry code.\n\n\tresume_kernel:\n\t\tREG_L s0, TASK_TI_PREEMPT_COUNT(tp)\n\t\tbnez s0, restore_all\n\t\tREG_L s0, TASK_TI_FLAGS(tp)\n                andi s0, s0, _TIF_NEED_RESCHED\n                beqz s0, restore_all\n                call preempt_schedule_irq\n                j restore_all\n\nTo fix above issue, here we add one extra level wrapper for function\ntrace_hardirqs_{on,off}() so they can be safely called by low level entry\ncode.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9e2dbc31e367d08ee299a0d8aeb498cb2e12a1c3",
      "https://git.kernel.org/stable/c/1851b9a467065b18ec2cba156eea345206df1c8f",
      "https://git.kernel.org/stable/c/b5e180490db4af8c0f80c4b65ee482d333d0e8ee",
      "https://git.kernel.org/stable/c/22e2100b1b07d6f5acc71cc1acb53f680c677d77"
    ],
    "受影响版本": [
      "3c46979829824da5af8766d89fa877976bdae884",
      "3c46979829824da5af8766d89fa877976bdae884",
      "3c46979829824da5af8766d89fa877976bdae884",
      "3c46979829824da5af8766d89fa877976bdae884"
    ],
    "公开日期": "2024年08月22日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48916",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/vt-d: Fix double list_add when enabling VMD in scalable mode\n\nWhen enabling VMD and IOMMU scalable mode, the following kernel panic\ncall trace/kernel log is shown in Eagle Stream platform (Sapphire Rapids\nCPU) during booting:\n\npci 0000:59:00.5: Adding to iommu group 42\n...\nvmd 0000:59:00.5: PCI host bridge to bus 10000:80\npci 10000:80:01.0: [8086:352a] type 01 class 0x060400\npci 10000:80:01.0: reg 0x10: [mem 0x00000000-0x0001ffff 64bit]\npci 10000:80:01.0: enabling Extended Tags\npci 10000:80:01.0: PME# supported from D0 D3hot D3cold\npci 10000:80:01.0: DMAR: Setup RID2PASID failed\npci 10000:80:01.0: Failed to add to iommu group 42: -16\npci 10000:80:03.0: [8086:352b] type 01 class 0x060400\npci 10000:80:03.0: reg 0x10: [mem 0x00000000-0x0001ffff 64bit]\npci 10000:80:03.0: enabling Extended Tags\npci 10000:80:03.0: PME# supported from D0 D3hot D3cold\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:29!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 0 PID: 7 Comm: kworker/0:1 Not tainted 5.17.0-rc3+ #7\nHardware name: Lenovo ThinkSystem SR650V3/SB27A86647, BIOS ESE101Y-1.00 01/13/2022\nWorkqueue: events work_for_cpu_fn\nRIP: 0010:__list_add_valid.cold+0x26/0x3f\nCode: 9a 4a ab ff 4c 89 c1 48 c7 c7 40 0c d9 9e e8 b9 b1 fe ff 0f\n      0b 48 89 f2 4c 89 c1 48 89 fe 48 c7 c7 f0 0c d9 9e e8 a2 b1\n      fe ff <0f> 0b 48 89 d1 4c 89 c6 4c 89 ca 48 c7 c7 98 0c d9\n      9e e8 8b b1 fe\nRSP: 0000:ff5ad434865b3a40 EFLAGS: 00010246\nRAX: 0000000000000058 RBX: ff4d61160b74b880 RCX: ff4d61255e1fffa8\nRDX: 0000000000000000 RSI: 00000000fffeffff RDI: ffffffff9fd34f20\nRBP: ff4d611d8e245c00 R08: 0000000000000000 R09: ff5ad434865b3888\nR10: ff5ad434865b3880 R11: ff4d61257fdc6fe8 R12: ff4d61160b74b8a0\nR13: ff4d61160b74b8a0 R14: ff4d611d8e245c10 R15: ff4d611d8001ba70\nFS:  0000000000000000(0000) GS:ff4d611d5ea00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ff4d611fa1401000 CR3: 0000000aa0210001 CR4: 0000000000771ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n <TASK>\n intel_pasid_alloc_table+0x9c/0x1d0\n dmar_insert_one_dev_info+0x423/0x540\n ? device_to_iommu+0x12d/0x2f0\n intel_iommu_attach_device+0x116/0x290\n __iommu_attach_device+0x1a/0x90\n iommu_group_add_device+0x190/0x2c0\n __iommu_probe_device+0x13e/0x250\n iommu_probe_device+0x24/0x150\n iommu_bus_notifier+0x69/0x90\n blocking_notifier_call_chain+0x5a/0x80\n device_add+0x3db/0x7b0\n ? arch_memremap_can_ram_remap+0x19/0x50\n ? memremap+0x75/0x140\n pci_device_add+0x193/0x1d0\n pci_scan_single_device+0xb9/0xf0\n pci_scan_slot+0x4c/0x110\n pci_scan_child_bus_extend+0x3a/0x290\n vmd_enable_domain.constprop.0+0x63e/0x820\n vmd_probe+0x163/0x190\n local_pci_probe+0x42/0x80\n work_for_cpu_fn+0x13/0x20\n process_one_work+0x1e2/0x3b0\n worker_thread+0x1c4/0x3a0\n ? rescuer_thread+0x370/0x370\n kthread+0xc7/0xf0\n ? kthread_complete_and_exit+0x20/0x20\n ret_from_fork+0x1f/0x30\n </TASK>\nModules linked in:\n---[ end trace 0000000000000000 ]---\n...\nKernel panic - not syncing: Fatal exception\nKernel Offset: 0x1ca00000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n---[ end Kernel panic - not syncing: Fatal exception ]---\n\nThe following 'lspci' output shows devices '10000:80:*' are subdevices of\nthe VMD device 0000:59:00.5:\n\n  $ lspci\n  ...\n  0000:59:00.5 RAID bus controller: Intel Corporation Volume Management Device NVMe RAID Controller (rev 20)\n  ...\n  10000:80:01.0 PCI bridge: Intel Corporation Device 352a (rev 03)\n  10000:80:03.0 PCI bridge: Intel Corporation Device 352b (rev 03)\n  10000:80:05.0 PCI bridge: Intel Corporation Device 352c (rev 03)\n  10000:80:07.0 PCI bridge: Intel Corporation Device 352d (rev 03)\n  10000:81:00.0 Non-Volatile memory controller: Intel Corporation NVMe Datacenter SSD [3DNAND, Beta Rock Controller]\n  10000:82:00\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2aaa085bd012a83be7104356301828585a2253ed",
      "https://git.kernel.org/stable/c/d5ad4214d9c6c6e465c192789020a091282dfee7",
      "https://git.kernel.org/stable/c/b00833768e170a31af09268f7ab96aecfcca9623"
    ],
    "受影响版本": [
      "474dd1c6506411752a9b2f2233eec11f1733a099",
      "474dd1c6506411752a9b2f2233eec11f1733a099",
      "474dd1c6506411752a9b2f2233eec11f1733a099",
      "77c6a77a068c2304e3f19abee67b0c76dde4c0ea",
      "7e6a4c304debd9be7cacecbe99b3481985e0c885"
    ],
    "公开日期": "2024年08月22日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48903",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix relocation crash due to premature return from btrfs_commit_transaction()\n\nWe are seeing crashes similar to the following trace:\n\n[38.969182] WARNING: CPU: 20 PID: 2105 at fs/btrfs/relocation.c:4070 btrfs_relocate_block_group+0x2dc/0x340 [btrfs]\n[38.973556] CPU: 20 PID: 2105 Comm: btrfs Not tainted 5.17.0-rc4 #54\n[38.974580] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014\n[38.976539] RIP: 0010:btrfs_relocate_block_group+0x2dc/0x340 [btrfs]\n[38.980336] RSP: 0000:ffffb0dd42e03c20 EFLAGS: 00010206\n[38.981218] RAX: ffff96cfc4ede800 RBX: ffff96cfc3ce0000 RCX: 000000000002ca14\n[38.982560] RDX: 0000000000000000 RSI: 4cfd109a0bcb5d7f RDI: ffff96cfc3ce0360\n[38.983619] RBP: ffff96cfc309c000 R08: 0000000000000000 R09: 0000000000000000\n[38.984678] R10: ffff96cec0000001 R11: ffffe84c80000000 R12: ffff96cfc4ede800\n[38.985735] R13: 0000000000000000 R14: 0000000000000000 R15: ffff96cfc3ce0360\n[38.987146] FS:  00007f11c15218c0(0000) GS:ffff96d6dfb00000(0000) knlGS:0000000000000000\n[38.988662] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[38.989398] CR2: 00007ffc922c8e60 CR3: 00000001147a6001 CR4: 0000000000370ee0\n[38.990279] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[38.991219] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[38.992528] Call Trace:\n[38.992854]  <TASK>\n[38.993148]  btrfs_relocate_chunk+0x27/0xe0 [btrfs]\n[38.993941]  btrfs_balance+0x78e/0xea0 [btrfs]\n[38.994801]  ? vsnprintf+0x33c/0x520\n[38.995368]  ? __kmalloc_track_caller+0x351/0x440\n[38.996198]  btrfs_ioctl_balance+0x2b9/0x3a0 [btrfs]\n[38.997084]  btrfs_ioctl+0x11b0/0x2da0 [btrfs]\n[38.997867]  ? mod_objcg_state+0xee/0x340\n[38.998552]  ? seq_release+0x24/0x30\n[38.999184]  ? proc_nr_files+0x30/0x30\n[38.999654]  ? call_rcu+0xc8/0x2f0\n[39.000228]  ? __x64_sys_ioctl+0x84/0xc0\n[39.000872]  ? btrfs_ioctl_get_supported_features+0x30/0x30 [btrfs]\n[39.001973]  __x64_sys_ioctl+0x84/0xc0\n[39.002566]  do_syscall_64+0x3a/0x80\n[39.003011]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[39.003735] RIP: 0033:0x7f11c166959b\n[39.007324] RSP: 002b:00007fff2543e998 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n[39.008521] RAX: ffffffffffffffda RBX: 00007f11c1521698 RCX: 00007f11c166959b\n[39.009833] RDX: 00007fff2543ea40 RSI: 00000000c4009420 RDI: 0000000000000003\n[39.011270] RBP: 0000000000000003 R08: 0000000000000013 R09: 00007f11c16f94e0\n[39.012581] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fff25440df3\n[39.014046] R13: 0000000000000000 R14: 00007fff2543ea40 R15: 0000000000000001\n[39.015040]  </TASK>\n[39.015418] ---[ end trace 0000000000000000 ]---\n[43.131559] ------------[ cut here ]------------\n[43.132234] kernel BUG at fs/btrfs/extent-tree.c:2717!\n[43.133031] invalid opcode: 0000 [#1] PREEMPT SMP PTI\n[43.133702] CPU: 1 PID: 1839 Comm: btrfs Tainted: G        W         5.17.0-rc4 #54\n[43.134863] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 04/01/2014\n[43.136426] RIP: 0010:unpin_extent_range+0x37a/0x4f0 [btrfs]\n[43.139913] RSP: 0000:ffffb0dd4216bc70 EFLAGS: 00010246\n[43.140629] RAX: 0000000000000000 RBX: ffff96cfc34490f8 RCX: 0000000000000001\n[43.141604] RDX: 0000000080000001 RSI: 0000000051d00000 RDI: 00000000ffffffff\n[43.142645] RBP: 0000000000000000 R08: 0000000000000000 R09: ffff96cfd07dca50\n[43.143669] R10: ffff96cfc46e8a00 R11: fffffffffffec000 R12: 0000000041d00000\n[43.144657] R13: ffff96cfc3ce0000 R14: ffffb0dd4216bd08 R15: 0000000000000000\n[43.145686] FS:  00007f7657dd68c0(0000) GS:ffff96d6df640000(0000) knlGS:0000000000000000\n[43.146808] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[43.147584] CR2: 00007f7fe81bf5b0 CR3: 00000001093ee004 CR4: 0000000000370ee0\n[43.148589] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[43.149581] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 00000000000\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/725a6ac389b182261af174176e561a36b0f39ffc",
      "https://git.kernel.org/stable/c/a4378947ae39f08c6ae4c6a87ccdebc981a7bbcb",
      "https://git.kernel.org/stable/c/5fd76bf31ccfecc06e2e6b29f8c809e934085b99"
    ],
    "受影响版本": [
      "d0c2f4fa555e70324ec2a129b822ab58f172cc62",
      "d0c2f4fa555e70324ec2a129b822ab58f172cc62",
      "d0c2f4fa555e70324ec2a129b822ab58f172cc62"
    ],
    "公开日期": "2024年08月22日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48902",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: do not WARN_ON() if we have PageError set\n\nWhenever we do any extent buffer operations we call\nassert_eb_page_uptodate() to complain loudly if we're operating on an\nnon-uptodate page.  Our overnight tests caught this warning earlier this\nweek\n\n  WARNING: CPU: 1 PID: 553508 at fs/btrfs/extent_io.c:6849 assert_eb_page_uptodate+0x3f/0x50\n  CPU: 1 PID: 553508 Comm: kworker/u4:13 Tainted: G        W         5.17.0-rc3+ #564\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014\n  Workqueue: btrfs-cache btrfs_work_helper\n  RIP: 0010:assert_eb_page_uptodate+0x3f/0x50\n  RSP: 0018:ffffa961440a7c68 EFLAGS: 00010246\n  RAX: 0017ffffc0002112 RBX: ffffe6e74453f9c0 RCX: 0000000000001000\n  RDX: ffffe6e74467c887 RSI: ffffe6e74453f9c0 RDI: ffff8d4c5efc2fc0\n  RBP: 0000000000000d56 R08: ffff8d4d4a224000 R09: 0000000000000000\n  R10: 00015817fa9d1ef0 R11: 000000000000000c R12: 00000000000007b1\n  R13: ffff8d4c5efc2fc0 R14: 0000000001500000 R15: 0000000001cb1000\n  FS:  0000000000000000(0000) GS:ffff8d4dbbd00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007ff31d3448d8 CR3: 0000000118be8004 CR4: 0000000000370ee0\n  Call Trace:\n\n   extent_buffer_test_bit+0x3f/0x70\n   free_space_test_bit+0xa6/0xc0\n   load_free_space_tree+0x1f6/0x470\n   caching_thread+0x454/0x630\n   ? rcu_read_lock_sched_held+0x12/0x60\n   ? rcu_read_lock_sched_held+0x12/0x60\n   ? rcu_read_lock_sched_held+0x12/0x60\n   ? lock_release+0x1f0/0x2d0\n   btrfs_work_helper+0xf2/0x3e0\n   ? lock_release+0x1f0/0x2d0\n   ? finish_task_switch.isra.0+0xf9/0x3a0\n   process_one_work+0x26d/0x580\n   ? process_one_work+0x580/0x580\n   worker_thread+0x55/0x3b0\n   ? process_one_work+0x580/0x580\n   kthread+0xf0/0x120\n   ? kthread_complete_and_exit+0x20/0x20\n   ret_from_fork+0x1f/0x30\n\nThis was partially fixed by c2e39305299f01 (\"btrfs: clear extent buffer\nuptodate when we fail to write it\"), however all that fix did was keep\nus from finding extent buffers after a failed writeout.  It didn't keep\nus from continuing to use a buffer that we already had found.\n\nIn this case we're searching the commit root to cache the block group,\nso we can start committing the transaction and switch the commit root\nand then start writing.  After the switch we can look up an extent\nbuffer that hasn't been written yet and start processing that block\ngroup.  Then we fail to write that block out and clear Uptodate on the\npage, and then we start spewing these errors.\n\nNormally we're protected by the tree lock to a certain degree here.  If\nwe read a block we have that block read locked, and we block the writer\nfrom locking the block before we submit it for the write.  However this\nisn't necessarily fool proof because the read could happen before we do\nthe submit_bio and after we locked and unlocked the extent buffer.\n\nAlso in this particular case we have path->skip_locking set, so that\nwon't save us here.  We'll simply get a block that was valid when we\nread it, but became invalid while we were using it.\n\nWhat we really want is to catch the case where we've \"read\" a block but\nit's not marked Uptodate.  On read we ClearPageError(), so if we're\n!Uptodate and !Error we know we didn't do the right thing for reading\nthe page.\n\nFix this by checking !Uptodate && !Error, this way we will not complain\nif our buffer gets invalidated while we're using it, and we'll maintain\nthe spirit of the check which is to make sure we have a fully in-cache\nblock while we're messing with it.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e00077aa439f0e8f416699fa4e9600db6583db70",
      "https://git.kernel.org/stable/c/9efcc83b33b576302147634eca9bece8e3737e34",
      "https://git.kernel.org/stable/c/a50e1fcbc9b85fd4e95b89a75c0884cb032a3e06"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年08月22日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48897",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\narm64/mm: fix incorrect file_map_count for invalid pmd\n\nThe page table check trigger BUG_ON() unexpectedly when split hugepage:\n\n ------------[ cut here ]------------\n kernel BUG at mm/page_table_check.c:119!\n Internal error: Oops - BUG: 00000000f2000800 [#1] SMP\n Dumping ftrace buffer:\n    (ftrace buffer empty)\n Modules linked in:\n CPU: 7 PID: 210 Comm: transhuge-stres Not tainted 6.1.0-rc3+ #748\n Hardware name: linux,dummy-virt (DT)\n pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n pc : page_table_check_set.isra.0+0x398/0x468\n lr : page_table_check_set.isra.0+0x1c0/0x468\n[...]\n Call trace:\n  page_table_check_set.isra.0+0x398/0x468\n  __page_table_check_pte_set+0x160/0x1c0\n  __split_huge_pmd_locked+0x900/0x1648\n  __split_huge_pmd+0x28c/0x3b8\n  unmap_page_range+0x428/0x858\n  unmap_single_vma+0xf4/0x1c8\n  zap_page_range+0x2b0/0x410\n  madvise_vma_behavior+0xc44/0xe78\n  do_madvise+0x280/0x698\n  __arm64_sys_madvise+0x90/0xe8\n  invoke_syscall.constprop.0+0xdc/0x1d8\n  do_el0_svc+0xf4/0x3f8\n  el0_svc+0x58/0x120\n  el0t_64_sync_handler+0xb8/0xc0\n  el0t_64_sync+0x19c/0x1a0\n[...]\n\nOn arm64, pmd_leaf() will return true even if the pmd is invalid due to\npmd_present_invalid() check. So in pmdp_invalidate() the file_map_count\nwill not only decrease once but also increase once. Then in set_pte_at(),\nthe file_map_count increase again, and so trigger BUG_ON() unexpectedly.\n\nAdd !pmd_present_invalid() check in pmd_user_accessible_page() to fix the\nproblem.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/21e5eca0ac9046da9918a919bc92b7b5a78d27e7",
      "https://git.kernel.org/stable/c/74c2f81054510d45b813548cb0a1c4ebf87cdd5f"
    ],
    "受影响版本": [
      "42b2547137f5c974bb1bfd657c869fe96b96d86f",
      "42b2547137f5c974bb1bfd657c869fe96b96d86f"
    ],
    "公开日期": "2024年08月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48878",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_qca: Fix driver shutdown on closed serdev\n\nThe driver shutdown callback (which sends EDL_SOC_RESET to the device\nover serdev) should not be invoked when HCI device is not open (e.g. if\nhci_dev_open_sync() failed), because the serdev and its TTY are not open\neither.  Also skip this step if device is powered off\n(qca_power_shutdown()).\n\nThe shutdown callback causes use-after-free during system reboot with\nQualcomm Atheros Bluetooth:\n\n  Unable to handle kernel paging request at virtual address\n  0072662f67726fd7\n  ...\n  CPU: 6 PID: 1 Comm: systemd-shutdow Tainted: G        W\n  6.1.0-rt5-00325-g8a5f56bcfcca #8\n  Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT)\n  Call trace:\n   tty_driver_flush_buffer+0x4/0x30\n   serdev_device_write_flush+0x24/0x34\n   qca_serdev_shutdown+0x80/0x130 [hci_uart]\n   device_shutdown+0x15c/0x260\n   kernel_restart+0x48/0xac\n\nKASAN report:\n\n  BUG: KASAN: use-after-free in tty_driver_flush_buffer+0x1c/0x50\n  Read of size 8 at addr ffff16270c2e0018 by task systemd-shutdow/1\n\n  CPU: 7 PID: 1 Comm: systemd-shutdow Not tainted\n  6.1.0-next-20221220-00014-gb85aaf97fb01-dirty #28\n  Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT)\n  Call trace:\n   dump_backtrace.part.0+0xdc/0xf0\n   show_stack+0x18/0x30\n   dump_stack_lvl+0x68/0x84\n   print_report+0x188/0x488\n   kasan_report+0xa4/0xf0\n   __asan_load8+0x80/0xac\n   tty_driver_flush_buffer+0x1c/0x50\n   ttyport_write_flush+0x34/0x44\n   serdev_device_write_flush+0x48/0x60\n   qca_serdev_shutdown+0x124/0x274\n   device_shutdown+0x1e8/0x350\n   kernel_restart+0x48/0xb0\n   __do_sys_reboot+0x244/0x2d0\n   __arm64_sys_reboot+0x54/0x70\n   invoke_syscall+0x60/0x190\n   el0_svc_common.constprop.0+0x7c/0x160\n   do_el0_svc+0x44/0xf0\n   el0_svc+0x2c/0x6c\n   el0t_64_sync_handler+0xbc/0x140\n   el0t_64_sync+0x190/0x194",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e84ec6e25df9bb0968599e92eacedaf3a0a5b587",
      "https://git.kernel.org/stable/c/908d1742b6e694e84ead5c62e4b7c1bfbb8b46a3",
      "https://git.kernel.org/stable/c/ea3ebda47dd56f6e1c62f2e0e1b6e1b0a973e447",
      "https://git.kernel.org/stable/c/272970be3dabd24cbe50e393ffee8f04aec3b9a8"
    ],
    "受影响版本": [
      "7e7bbddd029b644f00f0ffbfbc485ed71977d0d5",
      "7e7bbddd029b644f00f0ffbfbc485ed71977d0d5",
      "7e7bbddd029b644f00f0ffbfbc485ed71977d0d5",
      "7e7bbddd029b644f00f0ffbfbc485ed71977d0d5"
    ],
    "公开日期": "2024年08月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48875",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: sdata can be NULL during AMPDU start\n\nieee80211_tx_ba_session_handle_start() may get NULL for sdata when a\ndeauthentication is ongoing.\n\nHere a trace triggering the race with the hostapd test\nmulti_ap_fronthaul_on_ap:\n\n(gdb) list *drv_ampdu_action+0x46\n0x8b16 is in drv_ampdu_action (net/mac80211/driver-ops.c:396).\n391             int ret = -EOPNOTSUPP;\n392\n393             might_sleep();\n394\n395             sdata = get_bss_sdata(sdata);\n396             if (!check_sdata_in_driver(sdata))\n397                     return -EIO;\n398\n399             trace_drv_ampdu_action(local, sdata, params);\n400\n\nwlan0: moving STA 02:00:00:00:03:00 to state 3\nwlan0: associated\nwlan0: deauthenticating from 02:00:00:00:03:00 by local choice (Reason: 3=DEAUTH_LEAVING)\nwlan3.sta1: Open BA session requested for 02:00:00:00:00:00 tid 0\nwlan3.sta1: dropped frame to 02:00:00:00:00:00 (unauthorized port)\nwlan0: moving STA 02:00:00:00:03:00 to state 2\nwlan0: moving STA 02:00:00:00:03:00 to state 1\nwlan0: Removed STA 02:00:00:00:03:00\nwlan0: Destroyed STA 02:00:00:00:03:00\nBUG: unable to handle page fault for address: fffffffffffffb48\nPGD 11814067 P4D 11814067 PUD 11816067 PMD 0\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 2 PID: 133397 Comm: kworker/u16:1 Tainted: G        W          6.1.0-rc8-wt+ #59\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-20220807_005459-localhost 04/01/2014\nWorkqueue: phy3 ieee80211_ba_session_work [mac80211]\nRIP: 0010:drv_ampdu_action+0x46/0x280 [mac80211]\nCode: 53 48 89 f3 be 89 01 00 00 e8 d6 43 bf ef e8 21 46 81 f0 83 bb a0 1b 00 00 04 75 0e 48 8b 9b 28 0d 00 00 48 81 eb 10 0e 00 00 <8b> 93 58 09 00 00 f6 c2 20 0f 84 3b 01 00 00 8b 05 dd 1c 0f 00 85\nRSP: 0018:ffffc900025ebd20 EFLAGS: 00010287\nRAX: 0000000000000000 RBX: fffffffffffff1f0 RCX: ffff888102228240\nRDX: 0000000080000000 RSI: ffffffff918c5de0 RDI: ffff888102228b40\nRBP: ffffc900025ebd40 R08: 0000000000000001 R09: 0000000000000001\nR10: 0000000000000001 R11: 0000000000000000 R12: ffff888118c18ec0\nR13: 0000000000000000 R14: ffffc900025ebd60 R15: ffff888018b7efb8\nFS:  0000000000000000(0000) GS:ffff88817a600000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: fffffffffffffb48 CR3: 0000000105228006 CR4: 0000000000170ee0\nCall Trace:\n <TASK>\n ieee80211_tx_ba_session_handle_start+0xd0/0x190 [mac80211]\n ieee80211_ba_session_work+0xff/0x2e0 [mac80211]\n process_one_work+0x29f/0x620\n worker_thread+0x4d/0x3d0\n ? process_one_work+0x620/0x620\n kthread+0xfb/0x120\n ? kthread_complete_and_exit+0x20/0x20\n ret_from_fork+0x22/0x30\n </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/187523fa7c2d4c780f775cb869216865c4a909ef",
      "https://git.kernel.org/stable/c/a12fd43bd175fa52c82f9740179d38c34ca1b62e",
      "https://git.kernel.org/stable/c/c838df8461a601b20dc1b9fb1834d2aad8e2f949",
      "https://git.kernel.org/stable/c/69403bad97aa0162e3d7911b27e25abe774093df"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年08月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48871",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: serial: qcom-geni-serial: fix slab-out-of-bounds on RX FIFO buffer\n\nDriver's probe allocates memory for RX FIFO (port->rx_fifo) based on\ndefault RX FIFO depth, e.g. 16.  Later during serial startup the\nqcom_geni_serial_port_setup() updates the RX FIFO depth\n(port->rx_fifo_depth) to match real device capabilities, e.g. to 32.\n\nThe RX UART handle code will read \"port->rx_fifo_depth\" number of words\ninto \"port->rx_fifo\" buffer, thus exceeding the bounds.  This can be\nobserved in certain configurations with Qualcomm Bluetooth HCI UART\ndevice and KASAN:\n\n  Bluetooth: hci0: QCA Product ID   :0x00000010\n  Bluetooth: hci0: QCA SOC Version  :0x400a0200\n  Bluetooth: hci0: QCA ROM Version  :0x00000200\n  Bluetooth: hci0: QCA Patch Version:0x00000d2b\n  Bluetooth: hci0: QCA controller version 0x02000200\n  Bluetooth: hci0: QCA Downloading qca/htbtfw20.tlv\n  bluetooth hci0: Direct firmware load for qca/htbtfw20.tlv failed with error -2\n  Bluetooth: hci0: QCA Failed to request file: qca/htbtfw20.tlv (-2)\n  Bluetooth: hci0: QCA Failed to download patch (-2)\n  ==================================================================\n  BUG: KASAN: slab-out-of-bounds in handle_rx_uart+0xa8/0x18c\n  Write of size 4 at addr ffff279347d578c0 by task swapper/0/0\n\n  CPU: 0 PID: 0 Comm: swapper/0 Not tainted 6.1.0-rt5-00350-gb2450b7e00be-dirty #26\n  Hardware name: Qualcomm Technologies, Inc. Robotics RB5 (DT)\n  Call trace:\n   dump_backtrace.part.0+0xe0/0xf0\n   show_stack+0x18/0x40\n   dump_stack_lvl+0x8c/0xb8\n   print_report+0x188/0x488\n   kasan_report+0xb4/0x100\n   __asan_store4+0x80/0xa4\n   handle_rx_uart+0xa8/0x18c\n   qcom_geni_serial_handle_rx+0x84/0x9c\n   qcom_geni_serial_isr+0x24c/0x760\n   __handle_irq_event_percpu+0x108/0x500\n   handle_irq_event+0x6c/0x110\n   handle_fasteoi_irq+0x138/0x2cc\n   generic_handle_domain_irq+0x48/0x64\n\nIf the RX FIFO depth changes after probe, be sure to resize the buffer.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/894681682dbefdad917b88f86cde1069140a047a",
      "https://git.kernel.org/stable/c/cb53a3366eb28fed67850c80afa52075bb71a38a",
      "https://git.kernel.org/stable/c/fd524ca7fe45b8a06dca2dd546d62684a9768f95",
      "https://git.kernel.org/stable/c/b8caf69a6946e18ffebad49847e258f5b6d52ac2"
    ],
    "受影响版本": [
      "f9d690b6ece7ec9a6ff6b588df95a010ab2d66f9",
      "f9d690b6ece7ec9a6ff6b588df95a010ab2d66f9",
      "f9d690b6ece7ec9a6ff6b588df95a010ab2d66f9",
      "f9d690b6ece7ec9a6ff6b588df95a010ab2d66f9"
    ],
    "公开日期": "2024年08月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48853",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nswiotlb: fix info leak with DMA_FROM_DEVICE\n\nThe problem I'm addressing was discovered by the LTP test covering\ncve-2018-1000204.\n\nA short description of what happens follows:\n1) The test case issues a command code 00 (TEST UNIT READY) via the SG_IO\n   interface with: dxfer_len == 524288, dxdfer_dir == SG_DXFER_FROM_DEV\n   and a corresponding dxferp. The peculiar thing about this is that TUR\n   is not reading from the device.\n2) In sg_start_req() the invocation of blk_rq_map_user() effectively\n   bounces the user-space buffer. As if the device was to transfer into\n   it. Since commit a45b599ad808 (\"scsi: sg: allocate with __GFP_ZERO in\n   sg_build_indirect()\") we make sure this first bounce buffer is\n   allocated with GFP_ZERO.\n3) For the rest of the story we keep ignoring that we have a TUR, so the\n   device won't touch the buffer we prepare as if the we had a\n   DMA_FROM_DEVICE type of situation. My setup uses a virtio-scsi device\n   and the  buffer allocated by SG is mapped by the function\n   virtqueue_add_split() which uses DMA_FROM_DEVICE for the \"in\" sgs (here\n   scatter-gather and not scsi generics). This mapping involves bouncing\n   via the swiotlb (we need swiotlb to do virtio in protected guest like\n   s390 Secure Execution, or AMD SEV).\n4) When the SCSI TUR is done, we first copy back the content of the second\n   (that is swiotlb) bounce buffer (which most likely contains some\n   previous IO data), to the first bounce buffer, which contains all\n   zeros.  Then we copy back the content of the first bounce buffer to\n   the user-space buffer.\n5) The test case detects that the buffer, which it zero-initialized,\n  ain't all zeros and fails.\n\nOne can argue that this is an swiotlb problem, because without swiotlb\nwe leak all zeros, and the swiotlb should be transparent in a sense that\nit does not affect the outcome (if all other participants are well\nbehaved).\n\nCopying the content of the original buffer into the swiotlb buffer is\nthe only way I can think of to make swiotlb transparent in such\nscenarios. So let's do just that if in doubt, but allow the driver\nto tell us that the whole mapped buffer is going to be overwritten,\nin which case we can preserve the old behavior and avoid the performance\nimpact of the extra bounce.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c132f2ba716b5ee6b35f82226a6e5417d013d753",
      "https://git.kernel.org/stable/c/971e5dadffd02beba1063e7dd9c3a82de17cf534",
      "https://git.kernel.org/stable/c/8d9ac1b6665c73f23e963775f85d99679fd8e192",
      "https://git.kernel.org/stable/c/6bfc5377a210dbda2a237f16d94d1bd4f1335026",
      "https://git.kernel.org/stable/c/7403f4118ab94be837ab9d770507537a8057bc63",
      "https://git.kernel.org/stable/c/270475d6d2410ec66e971bf181afe1958dad565e",
      "https://git.kernel.org/stable/c/ddbd89deb7d32b1fbb879f48d68fda1a8ac58e8e"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48848",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/osnoise: Do not unregister events twice\n\nNicolas reported that using:\n\n # trace-cmd record -e all -M 10 -p osnoise --poll\n\nResulted in the following kernel warning:\n\n ------------[ cut here ]------------\n WARNING: CPU: 0 PID: 1217 at kernel/tracepoint.c:404 tracepoint_probe_unregister+0x280/0x370\n [...]\n CPU: 0 PID: 1217 Comm: trace-cmd Not tainted 5.17.0-rc6-next-20220307-nico+ #19\n RIP: 0010:tracepoint_probe_unregister+0x280/0x370\n [...]\n CR2: 00007ff919b29497 CR3: 0000000109da4005 CR4: 0000000000170ef0\n Call Trace:\n  <TASK>\n  osnoise_workload_stop+0x36/0x90\n  tracing_set_tracer+0x108/0x260\n  tracing_set_trace_write+0x94/0xd0\n  ? __check_object_size.part.0+0x10a/0x150\n  ? selinux_file_permission+0x104/0x150\n  vfs_write+0xb5/0x290\n  ksys_write+0x5f/0xe0\n  do_syscall_64+0x3b/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n RIP: 0033:0x7ff919a18127\n [...]\n ---[ end trace 0000000000000000 ]---\n\nThe warning complains about an attempt to unregister an\nunregistered tracepoint.\n\nThis happens on trace-cmd because it first stops tracing, and\nthen switches the tracer to nop. Which is equivalent to:\n\n  # cd /sys/kernel/tracing/\n  # echo osnoise > current_tracer\n  # echo 0 > tracing_on\n  # echo nop > current_tracer\n\nThe osnoise tracer stops the workload when no trace instance\nis actually collecting data. This can be caused both by\ndisabling tracing or disabling the tracer itself.\n\nTo avoid unregistering events twice, use the existing\ntrace_osnoise_callback_enabled variable to check if the events\n(and the workload) are actually active before trying to\ndeactivate them.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4e10787d18379d9b296290c2288097feddef16d4",
      "https://git.kernel.org/stable/c/f0cfe17bcc1dd2f0872966b554a148e888833ee9"
    ],
    "受影响版本": [
      "2fac8d6486d5c34e2ec7028580142b8209da3f92",
      "2fac8d6486d5c34e2ec7028580142b8209da3f92"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48845",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nMIPS: smp: fill in sibling and core maps earlier\n\nAfter enabling CONFIG_SCHED_CORE (landed during 5.14 cycle),\n2-core 2-thread-per-core interAptiv (CPS-driven) started emitting\nthe following:\n\n[    0.025698] CPU1 revision is: 0001a120 (MIPS interAptiv (multi))\n[    0.048183] ------------[ cut here ]------------\n[    0.048187] WARNING: CPU: 1 PID: 0 at kernel/sched/core.c:6025 sched_core_cpu_starting+0x198/0x240\n[    0.048220] Modules linked in:\n[    0.048233] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 5.17.0-rc3+ #35 b7b319f24073fd9a3c2aa7ad15fb7993eec0b26f\n[    0.048247] Stack : 817f0000 00000004 327804c8 810eb050 00000000 00000004 00000000 c314fdd1\n[    0.048278]         830cbd64 819c0000 81800000 817f0000 83070bf4 00000001 830cbd08 00000000\n[    0.048307]         00000000 00000000 815fcbc4 00000000 00000000 00000000 00000000 00000000\n[    0.048334]         00000000 00000000 00000000 00000000 817f0000 00000000 00000000 817f6f34\n[    0.048361]         817f0000 818a3c00 817f0000 00000004 00000000 00000000 4dc33260 0018c933\n[    0.048389]         ...\n[    0.048396] Call Trace:\n[    0.048399] [<8105a7bc>] show_stack+0x3c/0x140\n[    0.048424] [<8131c2a0>] dump_stack_lvl+0x60/0x80\n[    0.048440] [<8108b5c0>] __warn+0xc0/0xf4\n[    0.048454] [<8108b658>] warn_slowpath_fmt+0x64/0x10c\n[    0.048467] [<810bd418>] sched_core_cpu_starting+0x198/0x240\n[    0.048483] [<810c6514>] sched_cpu_starting+0x14/0x80\n[    0.048497] [<8108c0f8>] cpuhp_invoke_callback_range+0x78/0x140\n[    0.048510] [<8108d914>] notify_cpu_starting+0x94/0x140\n[    0.048523] [<8106593c>] start_secondary+0xbc/0x280\n[    0.048539]\n[    0.048543] ---[ end trace 0000000000000000 ]---\n[    0.048636] Synchronize counters for CPU 1: done.\n\n...for each but CPU 0/boot.\nBasic debug printks right before the mentioned line say:\n\n[    0.048170] CPU: 1, smt_mask:\n\nSo smt_mask, which is sibling mask obviously, is empty when entering\nthe function.\nThis is critical, as sched_core_cpu_starting() calculates\ncore-scheduling parameters only once per CPU start, and it's crucial\nto have all the parameters filled in at that moment (at least it\nuses cpu_smt_mask() which in fact is `&cpu_sibling_map[cpu]` on\nMIPS).\n\nA bit of debugging led me to that set_cpu_sibling_map() performing\nthe actual map calculation, was being invocated after\nnotify_cpu_start(), and exactly the latter function starts CPU HP\ncallback round (sched_core_cpu_starting() is basically a CPU HP\ncallback).\nWhile the flow is same on ARM64 (maps after the notifier, although\nbefore calling set_cpu_online()), x86 started calculating sibling\nmaps earlier than starting the CPU HP callbacks in Linux 4.14 (see\n[0] for the reference). Neither me nor my brief tests couldn't find\nany potential caveats in calculating the maps right after performing\ndelay calibration, but the WARN splat is now gone.\nThe very same debug prints now yield exactly what I expected from\nthem:\n\n[    0.048433] CPU: 1, smt_mask: 0-1\n\n[0] https://git.kernel.org/pub/scm/linux/kernel/git/mips/linux.git/commit/?id=76ce7cfe35ef",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7315f8538db009605ffba00370678142ef00ac98",
      "https://git.kernel.org/stable/c/32813321f18d5432cec1b1a6ecc964f9ea26d565",
      "https://git.kernel.org/stable/c/56eaacb8137ba2071ce48d4e3d91979270e139a7",
      "https://git.kernel.org/stable/c/c2420bc3333111184cdcb112282d13afe1338dd7",
      "https://git.kernel.org/stable/c/e8ad9ecc406974deb5e7c070f51cc1d09d21dc4b",
      "https://git.kernel.org/stable/c/be538b764a46be1d0700fd3b6e82fb76bd17f13a",
      "https://git.kernel.org/stable/c/94647aec80d03d6914aa664b7b8e103cd9d63239",
      "https://git.kernel.org/stable/c/f2703def339c793674010cc9f01bfe4980231808"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48833",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: skip reserved bytes warning on unmount after log cleanup failure\n\nAfter the recent changes made by commit c2e39305299f01 (\"btrfs: clear\nextent buffer uptodate when we fail to write it\") and its followup fix,\ncommit 651740a5024117 (\"btrfs: check WRITE_ERR when trying to read an\nextent buffer\"), we can now end up not cleaning up space reservations of\nlog tree extent buffers after a transaction abort happens, as well as not\ncleaning up still dirty extent buffers.\n\nThis happens because if writeback for a log tree extent buffer failed,\nthen we have cleared the bit EXTENT_BUFFER_UPTODATE from the extent buffer\nand we have also set the bit EXTENT_BUFFER_WRITE_ERR on it. Later on,\nwhen trying to free the log tree with free_log_tree(), which iterates\nover the tree, we can end up getting an -EIO error when trying to read\na node or a leaf, since read_extent_buffer_pages() returns -EIO if an\nextent buffer does not have EXTENT_BUFFER_UPTODATE set and has the\nEXTENT_BUFFER_WRITE_ERR bit set. Getting that -EIO means that we return\nimmediately as we can not iterate over the entire tree.\n\nIn that case we never update the reserved space for an extent buffer in\nthe respective block group and space_info object.\n\nWhen this happens we get the following traces when unmounting the fs:\n\n[174957.284509] BTRFS: error (device dm-0) in cleanup_transaction:1913: errno=-5 IO failure\n[174957.286497] BTRFS: error (device dm-0) in free_log_tree:3420: errno=-5 IO failure\n[174957.399379] ------------[ cut here ]------------\n[174957.402497] WARNING: CPU: 2 PID: 3206883 at fs/btrfs/block-group.c:127 btrfs_put_block_group+0x77/0xb0 [btrfs]\n[174957.407523] Modules linked in: btrfs overlay dm_zero (...)\n[174957.424917] CPU: 2 PID: 3206883 Comm: umount Tainted: G        W         5.16.0-rc5-btrfs-next-109 #1\n[174957.426689] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014\n[174957.428716] RIP: 0010:btrfs_put_block_group+0x77/0xb0 [btrfs]\n[174957.429717] Code: 21 48 8b bd (...)\n[174957.432867] RSP: 0018:ffffb70d41cffdd0 EFLAGS: 00010206\n[174957.433632] RAX: 0000000000000001 RBX: ffff8b09c3848000 RCX: ffff8b0758edd1c8\n[174957.434689] RDX: 0000000000000001 RSI: ffffffffc0b467e7 RDI: ffff8b0758edd000\n[174957.436068] RBP: ffff8b0758edd000 R08: 0000000000000000 R09: 0000000000000000\n[174957.437114] R10: 0000000000000246 R11: 0000000000000000 R12: ffff8b09c3848148\n[174957.438140] R13: ffff8b09c3848198 R14: ffff8b0758edd188 R15: dead000000000100\n[174957.439317] FS:  00007f328fb82800(0000) GS:ffff8b0a2d200000(0000) knlGS:0000000000000000\n[174957.440402] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[174957.441164] CR2: 00007fff13563e98 CR3: 0000000404f4e005 CR4: 0000000000370ee0\n[174957.442117] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[174957.443076] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[174957.443948] Call Trace:\n[174957.444264]  <TASK>\n[174957.444538]  btrfs_free_block_groups+0x255/0x3c0 [btrfs]\n[174957.445238]  close_ctree+0x301/0x357 [btrfs]\n[174957.445803]  ? call_rcu+0x16c/0x290\n[174957.446250]  generic_shutdown_super+0x74/0x120\n[174957.446832]  kill_anon_super+0x14/0x30\n[174957.447305]  btrfs_kill_super+0x12/0x20 [btrfs]\n[174957.447890]  deactivate_locked_super+0x31/0xa0\n[174957.448440]  cleanup_mnt+0x147/0x1c0\n[174957.448888]  task_work_run+0x5c/0xa0\n[174957.449336]  exit_to_user_mode_prepare+0x1e5/0x1f0\n[174957.449934]  syscall_exit_to_user_mode+0x16/0x40\n[174957.450512]  do_syscall_64+0x48/0xc0\n[174957.450980]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[174957.451605] RIP: 0033:0x7f328fdc4a97\n[174957.452059] Code: 03 0c 00 f7 (...)\n[174957.454320] RSP: 002b:00007fff13564ec8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6\n[174957.455262] RAX: 0000000000000000 RBX: 00007f328feea264 RCX: 00007f328fdc4a97\n[174957.456131] RDX: 0000000000000000 RSI: 00000000000000\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4c5d94990fa2fd609360ecd0f7e183212a7d115c",
      "https://git.kernel.org/stable/c/44557a8f539a822c91238c1f95a95f98a5093d82",
      "https://git.kernel.org/stable/c/40cdc509877bacb438213b83c7541c5e24a1d9ec"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48818",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: mv88e6xxx: don't use devres for mdiobus\n\nAs explained in commits:\n74b6d7d13307 (\"net: dsa: realtek: register the MDIO bus under devres\")\n5135e96a3dd2 (\"net: dsa: don't allocate the slave_mii_bus using devres\")\n\nmdiobus_free() will panic when called from devm_mdiobus_free() <-\ndevres_release_all() <- __device_release_driver(), and that mdiobus was\nnot previously unregistered.\n\nThe mv88e6xxx is an MDIO device, so the initial set of constraints that\nI thought would cause this (I2C or SPI buses which call ->remove on\n->shutdown) do not apply. But there is one more which applies here.\n\nIf the DSA master itself is on a bus that calls ->remove from ->shutdown\n(like dpaa2-eth, which is on the fsl-mc bus), there is a device link\nbetween the switch and the DSA master, and device_links_unbind_consumers()\nwill unbind the Marvell switch driver on shutdown.\n\nsystemd-shutdown[1]: Powering off.\nmv88e6085 0x0000000008b96000:00 sw_gl0: Link is Down\nfsl-mc dpbp.9: Removing from iommu group 7\nfsl-mc dpbp.8: Removing from iommu group 7\n------------[ cut here ]------------\nkernel BUG at drivers/net/phy/mdio_bus.c:677!\nInternal error: Oops - BUG: 0 [#1] PREEMPT SMP\nModules linked in:\nCPU: 0 PID: 1 Comm: systemd-shutdow Not tainted 5.16.5-00040-gdc05f73788e5 #15\npc : mdiobus_free+0x44/0x50\nlr : devm_mdiobus_free+0x10/0x20\nCall trace:\n mdiobus_free+0x44/0x50\n devm_mdiobus_free+0x10/0x20\n devres_release_all+0xa0/0x100\n __device_release_driver+0x190/0x220\n device_release_driver_internal+0xac/0xb0\n device_links_unbind_consumers+0xd4/0x100\n __device_release_driver+0x4c/0x220\n device_release_driver_internal+0xac/0xb0\n device_links_unbind_consumers+0xd4/0x100\n __device_release_driver+0x94/0x220\n device_release_driver+0x28/0x40\n bus_remove_device+0x118/0x124\n device_del+0x174/0x420\n fsl_mc_device_remove+0x24/0x40\n __fsl_mc_device_remove+0xc/0x20\n device_for_each_child+0x58/0xa0\n dprc_remove+0x90/0xb0\n fsl_mc_driver_remove+0x20/0x5c\n __device_release_driver+0x21c/0x220\n device_release_driver+0x28/0x40\n bus_remove_device+0x118/0x124\n device_del+0x174/0x420\n fsl_mc_bus_remove+0x80/0x100\n fsl_mc_bus_shutdown+0xc/0x1c\n platform_shutdown+0x20/0x30\n device_shutdown+0x154/0x330\n kernel_power_off+0x34/0x6c\n __do_sys_reboot+0x15c/0x250\n __arm64_sys_reboot+0x20/0x30\n invoke_syscall.constprop.0+0x4c/0xe0\n do_el0_svc+0x4c/0x150\n el0_svc+0x24/0xb0\n el0t_64_sync_handler+0xa8/0xb0\n el0t_64_sync+0x178/0x17c\n\nSo the same treatment must be applied to all DSA switch drivers, which\nis: either use devres for both the mdiobus allocation and registration,\nor don't use devres at all.\n\nThe Marvell driver already has a good structure for mdiobus removal, so\njust plug in mdiobus_free and get rid of devres.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8ccebe77df6e0d88c72ba5e69cf1835927e53b6c",
      "https://git.kernel.org/stable/c/8b626d45127d6f5ada7d815b83cfdc09e8cb1394",
      "https://git.kernel.org/stable/c/1b451c3994a2d322f8e55032c62c8b47b7d95900",
      "https://git.kernel.org/stable/c/f53a2ce893b2c7884ef94471f170839170a4eba0"
    ],
    "受影响版本": [
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48817",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: ar9331: register the mdiobus under devres\n\nAs explained in commits:\n74b6d7d13307 (\"net: dsa: realtek: register the MDIO bus under devres\")\n5135e96a3dd2 (\"net: dsa: don't allocate the slave_mii_bus using devres\")\n\nmdiobus_free() will panic when called from devm_mdiobus_free() <-\ndevres_release_all() <- __device_release_driver(), and that mdiobus was\nnot previously unregistered.\n\nThe ar9331 is an MDIO device, so the initial set of constraints that I\nthought would cause this (I2C or SPI buses which call ->remove on\n->shutdown) do not apply. But there is one more which applies here.\n\nIf the DSA master itself is on a bus that calls ->remove from ->shutdown\n(like dpaa2-eth, which is on the fsl-mc bus), there is a device link\nbetween the switch and the DSA master, and device_links_unbind_consumers()\nwill unbind the ar9331 switch driver on shutdown.\n\nSo the same treatment must be applied to all DSA switch drivers, which\nis: either use devres for both the mdiobus allocation and registration,\nor don't use devres at all.\n\nThe ar9331 driver doesn't have a complex code structure for mdiobus\nremoval, so just replace of_mdiobus_register with the devres variant in\norder to be all-devres and ensure that we don't free a still-registered\nbus.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/475ce5dcf2d88fd4f3c213a0ac944e3e40702970",
      "https://git.kernel.org/stable/c/aae1c6a1d3d696fc33b609fb12fe744a556d1dc5",
      "https://git.kernel.org/stable/c/f1842a8cb71de4d7eb75a86f76e88c7ee739218c",
      "https://git.kernel.org/stable/c/50facd86e9fbc4b93fe02e5fe05776047f45dbfb"
    ],
    "受影响版本": [
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48815",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: bcm_sf2: don't use devres for mdiobus\n\nAs explained in commits:\n74b6d7d13307 (\"net: dsa: realtek: register the MDIO bus under devres\")\n5135e96a3dd2 (\"net: dsa: don't allocate the slave_mii_bus using devres\")\n\nmdiobus_free() will panic when called from devm_mdiobus_free() <-\ndevres_release_all() <- __device_release_driver(), and that mdiobus was\nnot previously unregistered.\n\nThe Starfighter 2 is a platform device, so the initial set of\nconstraints that I thought would cause this (I2C or SPI buses which call\n->remove on ->shutdown) do not apply. But there is one more which\napplies here.\n\nIf the DSA master itself is on a bus that calls ->remove from ->shutdown\n(like dpaa2-eth, which is on the fsl-mc bus), there is a device link\nbetween the switch and the DSA master, and device_links_unbind_consumers()\nwill unbind the bcm_sf2 switch driver on shutdown.\n\nSo the same treatment must be applied to all DSA switch drivers, which\nis: either use devres for both the mdiobus allocation and registration,\nor don't use devres at all.\n\nThe bcm_sf2 driver has the code structure in place for orderly mdiobus\nremoval, so just replace devm_mdiobus_alloc() with the non-devres\nvariant, and add manual free where necessary, to ensure that we don't\nlet devres free a still-registered bus.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2770b795294ed312375c11ef1d0b810499c66b83",
      "https://git.kernel.org/stable/c/caabb5f64f5c32fceed93356bb688ef1ec6c5783",
      "https://git.kernel.org/stable/c/08e1a3554e99a1a5bd2835907381e2383ee85cae",
      "https://git.kernel.org/stable/c/08f1a20822349004bb9cc1b153ecb516e9f2889d"
    ],
    "受影响版本": [
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48814",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: seville: register the mdiobus under devres\n\nAs explained in commits:\n74b6d7d13307 (\"net: dsa: realtek: register the MDIO bus under devres\")\n5135e96a3dd2 (\"net: dsa: don't allocate the slave_mii_bus using devres\")\n\nmdiobus_free() will panic when called from devm_mdiobus_free() <-\ndevres_release_all() <- __device_release_driver(), and that mdiobus was\nnot previously unregistered.\n\nThe Seville VSC9959 switch is a platform device, so the initial set of\nconstraints that I thought would cause this (I2C or SPI buses which call\n->remove on ->shutdown) do not apply. But there is one more which\napplies here.\n\nIf the DSA master itself is on a bus that calls ->remove from ->shutdown\n(like dpaa2-eth, which is on the fsl-mc bus), there is a device link\nbetween the switch and the DSA master, and device_links_unbind_consumers()\nwill unbind the seville switch driver on shutdown.\n\nSo the same treatment must be applied to all DSA switch drivers, which\nis: either use devres for both the mdiobus allocation and registration,\nor don't use devres at all.\n\nThe seville driver has a code structure that could accommodate both the\nmdiobus_unregister and mdiobus_free calls, but it has an external\ndependency upon mscc_miim_setup() from mdio-mscc-miim.c, which calls\ndevm_mdiobus_alloc_size() on its behalf. So rather than restructuring\nthat, and exporting yet one more symbol mscc_miim_teardown(), let's work\nwith devres and replace of_mdiobus_register with the devres variant.\nWhen we use all-devres, we can ensure that devres doesn't free a\nstill-registered bus (it either runs both callbacks, or none).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1d13e7221035947c62800c9d3d99b4ed570e27e7",
      "https://git.kernel.org/stable/c/0e816362d823cd46c666e64d8bffe329ee22f4cc",
      "https://git.kernel.org/stable/c/bd488afc3b39e045ba71aab472233f2a78726e7b"
    ],
    "受影响版本": [
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48813",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: felix: don't use devres for mdiobus\n\nAs explained in commits:\n74b6d7d13307 (\"net: dsa: realtek: register the MDIO bus under devres\")\n5135e96a3dd2 (\"net: dsa: don't allocate the slave_mii_bus using devres\")\n\nmdiobus_free() will panic when called from devm_mdiobus_free() <-\ndevres_release_all() <- __device_release_driver(), and that mdiobus was\nnot previously unregistered.\n\nThe Felix VSC9959 switch is a PCI device, so the initial set of\nconstraints that I thought would cause this (I2C or SPI buses which call\n->remove on ->shutdown) do not apply. But there is one more which\napplies here.\n\nIf the DSA master itself is on a bus that calls ->remove from ->shutdown\n(like dpaa2-eth, which is on the fsl-mc bus), there is a device link\nbetween the switch and the DSA master, and device_links_unbind_consumers()\nwill unbind the felix switch driver on shutdown.\n\nSo the same treatment must be applied to all DSA switch drivers, which\nis: either use devres for both the mdiobus allocation and registration,\nor don't use devres at all.\n\nThe felix driver has the code structure in place for orderly mdiobus\nremoval, so just replace devm_mdiobus_alloc_size() with the non-devres\nvariant, and add manual free where necessary, to ensure that we don't\nlet devres free a still-registered bus.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/95e5402f9430b3c7d885dd3ec4c8c02c17936923",
      "https://git.kernel.org/stable/c/8cda7577a0b4018572f31e0caadfabd305ea2786",
      "https://git.kernel.org/stable/c/9db6f056efd089e80d81c774c01b639adf30c097",
      "https://git.kernel.org/stable/c/209bdb7ec6a28c7cdf580a0a98afbc9fc3b98932"
    ],
    "受影响版本": [
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48812",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: lantiq_gswip: don't use devres for mdiobus\n\nAs explained in commits:\n74b6d7d13307 (\"net: dsa: realtek: register the MDIO bus under devres\")\n5135e96a3dd2 (\"net: dsa: don't allocate the slave_mii_bus using devres\")\n\nmdiobus_free() will panic when called from devm_mdiobus_free() <-\ndevres_release_all() <- __device_release_driver(), and that mdiobus was\nnot previously unregistered.\n\nThe GSWIP switch is a platform device, so the initial set of constraints\nthat I thought would cause this (I2C or SPI buses which call ->remove on\n->shutdown) do not apply. But there is one more which applies here.\n\nIf the DSA master itself is on a bus that calls ->remove from ->shutdown\n(like dpaa2-eth, which is on the fsl-mc bus), there is a device link\nbetween the switch and the DSA master, and device_links_unbind_consumers()\nwill unbind the GSWIP switch driver on shutdown.\n\nSo the same treatment must be applied to all DSA switch drivers, which\nis: either use devres for both the mdiobus allocation and registration,\nor don't use devres at all.\n\nThe gswip driver has the code structure in place for orderly mdiobus\nremoval, so just replace devm_mdiobus_alloc() with the non-devres\nvariant, and add manual free where necessary, to ensure that we don't\nlet devres free a still-registered bus.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e177d2e85ebcd3008c4b2abc293f4118e04eedef",
      "https://git.kernel.org/stable/c/b5652bc50dde7b84e93dfb25479b64b817e377c1",
      "https://git.kernel.org/stable/c/2443ba2fe396bdde187a2fdfa6a57375643ae93c",
      "https://git.kernel.org/stable/c/0d120dfb5d67edc5bcd1804e167dba2b30809afd"
    ],
    "受影响版本": [
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44",
      "ac3a68d56651c3dad2c12c7afce065fe15267f44"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48794",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ieee802154: at86rf230: Stop leaking skb's\n\nUpon error the ieee802154_xmit_complete() helper is not called. Only\nieee802154_wake_queue() is called manually. In the Tx case we then leak\nthe skb structure.\n\nFree the skb structure upon error before returning when appropriate.\n\nAs the 'is_tx = 0' cannot be moved in the complete handler because of a\npossible race between the delay in switching to STATE_RX_AACK_ON and a\nnew interrupt, we introduce an intermediate 'was_tx' boolean just for\nthis purpose.\n\nThere is no Fixes tag applying here, many changes have been made on this\narea and the issue kind of always existed.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d2a1eaf51b7d4412319adb6acef114ba472d1692",
      "https://git.kernel.org/stable/c/af649e5c95f56df64363bc46f6746b87819f9c0d",
      "https://git.kernel.org/stable/c/6312f6a53fd3ea38125dcaca5e3c9aa7d8a60cf7",
      "https://git.kernel.org/stable/c/455ef08d6e5473526fa6763f75a93f7198206966",
      "https://git.kernel.org/stable/c/0fd484644c68897c490a3307bfcc8bf767df5a43",
      "https://git.kernel.org/stable/c/23b2a25382400168427ea278f3d8bf4ecfd333bf",
      "https://git.kernel.org/stable/c/1c72f04d52b7200bb83426a9bed378668271ea4a",
      "https://git.kernel.org/stable/c/e5ce576d45bf72fd0e3dc37eff897bfcc488f6a9"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48784",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncfg80211: fix race in netlink owner interface destruction\n\nMy previous fix here to fix the deadlock left a race where\nthe exact same deadlock (see the original commit referenced\nbelow) can still happen if cfg80211_destroy_ifaces() already\nruns while nl80211_netlink_notify() is still marking some\ninterfaces as nl_owner_dead.\n\nThe race happens because we have two loops here - first we\ndev_close() all the netdevs, and then we destroy them. If we\nalso have two netdevs (first one need only be a wdev though)\nthen we can find one during the first iteration, close it,\nand go to the second iteration -- but then find two, and try\nto destroy also the one we didn't close yet.\n\nFix this by only iterating once.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/241e633cb379c4f332fc1baf2abec95ec840cbeb",
      "https://git.kernel.org/stable/c/c979f792a2baf6d0f3419587668a1a6eba46a3d2",
      "https://git.kernel.org/stable/c/f0a6fd1527067da537e9c48390237488719948ed"
    ],
    "受影响版本": [
      "ea6b2098dd02789f68770fd3d5a373732207be2f",
      "ea6b2098dd02789f68770fd3d5a373732207be2f",
      "ea6b2098dd02789f68770fd3d5a373732207be2f",
      "2e4f97122f3a9df870dfe9671994136448890768"
    ],
    "公开日期": "2024年07月16日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48765",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: LAPIC: Also cancel preemption timer during SET_LAPIC\n\nThe below warning is splatting during guest reboot.\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 1931 at arch/x86/kvm/x86.c:10322 kvm_arch_vcpu_ioctl_run+0x874/0x880 [kvm]\n  CPU: 0 PID: 1931 Comm: qemu-system-x86 Tainted: G          I       5.17.0-rc1+ #5\n  RIP: 0010:kvm_arch_vcpu_ioctl_run+0x874/0x880 [kvm]\n  Call Trace:\n   <TASK>\n   kvm_vcpu_ioctl+0x279/0x710 [kvm]\n   __x64_sys_ioctl+0x83/0xb0\n   do_syscall_64+0x3b/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n  RIP: 0033:0x7fd39797350b\n\nThis can be triggered by not exposing tsc-deadline mode and doing a reboot in\nthe guest. The lapic_shutdown() function which is called in sys_reboot path\nwill not disarm the flying timer, it just masks LVTT. lapic_shutdown() clears\nAPIC state w/ LVT_MASKED and timer-mode bit is 0, this can trigger timer-mode\nswitch between tsc-deadline and oneshot/periodic, which can result in preemption\ntimer be cancelled in apic_update_lvtt(). However, We can't depend on this when\nnot exposing tsc-deadline mode and oneshot/periodic modes emulated by preemption\ntimer. Qemu will synchronise states around reset, let's cancel preemption timer\nunder KVM_SET_LAPIC.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/54b3439c8e70e0bcfea59aeef9dd98908cbbf655",
      "https://git.kernel.org/stable/c/ce55f63f6cea4cab8ae9212f73285648a5baa30d",
      "https://git.kernel.org/stable/c/35fe7cfbab2e81f1afb23fc4212210b1de6d9633"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年06月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48758",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: bnx2fc: Flush destroy_work queue before calling bnx2fc_interface_put()\n\nThe bnx2fc_destroy() functions are removing the interface before calling\ndestroy_work. This results multiple WARNings from sysfs_remove_group() as\nthe controller rport device attributes are removed too early.\n\nReplace the fcoe_port's destroy_work queue. It's not needed.\n\nThe problem is easily reproducible with the following steps.\n\nExample:\n\n  $ dmesg -w &\n  $ systemctl enable --now fcoe\n  $ fipvlan -s -c ens2f1\n  $ fcoeadm -d ens2f1.802\n  [  583.464488] host2: libfc: Link down on port (7500a1)\n  [  583.472651] bnx2fc: 7500a1 - rport not created Yet!!\n  [  583.490468] ------------[ cut here ]------------\n  [  583.538725] sysfs group 'power' not found for kobject 'rport-2:0-0'\n  [  583.568814] WARNING: CPU: 3 PID: 192 at fs/sysfs/group.c:279 sysfs_remove_group+0x6f/0x80\n  [  583.607130] Modules linked in: dm_service_time 8021q garp mrp stp llc bnx2fc cnic uio rpcsec_gss_krb5 auth_rpcgss nfsv4 ...\n  [  583.942994] CPU: 3 PID: 192 Comm: kworker/3:2 Kdump: loaded Not tainted 5.14.0-39.el9.x86_64 #1\n  [  583.984105] Hardware name: HP ProLiant DL120 G7, BIOS J01 07/01/2013\n  [  584.016535] Workqueue: fc_wq_2 fc_rport_final_delete [scsi_transport_fc]\n  [  584.050691] RIP: 0010:sysfs_remove_group+0x6f/0x80\n  [  584.074725] Code: ff 5b 48 89 ef 5d 41 5c e9 ee c0 ff ff 48 89 ef e8 f6 b8 ff ff eb d1 49 8b 14 24 48 8b 33 48 c7 c7 ...\n  [  584.162586] RSP: 0018:ffffb567c15afdc0 EFLAGS: 00010282\n  [  584.188225] RAX: 0000000000000000 RBX: ffffffff8eec4220 RCX: 0000000000000000\n  [  584.221053] RDX: ffff8c1586ce84c0 RSI: ffff8c1586cd7cc0 RDI: ffff8c1586cd7cc0\n  [  584.255089] RBP: 0000000000000000 R08: 0000000000000000 R09: ffffb567c15afc00\n  [  584.287954] R10: ffffb567c15afbf8 R11: ffffffff8fbe7f28 R12: ffff8c1486326400\n  [  584.322356] R13: ffff8c1486326480 R14: ffff8c1483a4a000 R15: 0000000000000004\n  [  584.355379] FS:  0000000000000000(0000) GS:ffff8c1586cc0000(0000) knlGS:0000000000000000\n  [  584.394419] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [  584.421123] CR2: 00007fe95a6f7840 CR3: 0000000107674002 CR4: 00000000000606e0\n  [  584.454888] Call Trace:\n  [  584.466108]  device_del+0xb2/0x3e0\n  [  584.481701]  device_unregister+0x13/0x60\n  [  584.501306]  bsg_unregister_queue+0x5b/0x80\n  [  584.522029]  bsg_remove_queue+0x1c/0x40\n  [  584.541884]  fc_rport_final_delete+0xf3/0x1d0 [scsi_transport_fc]\n  [  584.573823]  process_one_work+0x1e3/0x3b0\n  [  584.592396]  worker_thread+0x50/0x3b0\n  [  584.609256]  ? rescuer_thread+0x370/0x370\n  [  584.628877]  kthread+0x149/0x170\n  [  584.643673]  ? set_kthread_struct+0x40/0x40\n  [  584.662909]  ret_from_fork+0x22/0x30\n  [  584.680002] ---[ end trace 53575ecefa942ece ]---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2a12fe8248a38437b95b942bbe85aced72e6e2eb",
      "https://git.kernel.org/stable/c/262550f29c750f7876b6ed1244281e72b64ebffb",
      "https://git.kernel.org/stable/c/c93a290c862ccfa404e42d7420565730d67cbff9",
      "https://git.kernel.org/stable/c/de6336b17a1376db1c0f7a528cce8783db0881c0",
      "https://git.kernel.org/stable/c/bf2bd892a0cb14dd2d21f2c658f4b747813be311",
      "https://git.kernel.org/stable/c/00849de10f798a9538242824a51b1756e7110754",
      "https://git.kernel.org/stable/c/b11e34f7bab21df36f02a5e54fb69e858c09a65d",
      "https://git.kernel.org/stable/c/ace7b6ef41251c5fe47f629a9a922382fb7b0a6b",
      "https://git.kernel.org/stable/c/847f9ea4c5186fdb7b84297e3eeed9e340e83fce"
    ],
    "受影响版本": [
      "0cbf32e1681d870632a1772601cbaadd996dc978",
      "0cbf32e1681d870632a1772601cbaadd996dc978",
      "0cbf32e1681d870632a1772601cbaadd996dc978",
      "0cbf32e1681d870632a1772601cbaadd996dc978",
      "0cbf32e1681d870632a1772601cbaadd996dc978",
      "0cbf32e1681d870632a1772601cbaadd996dc978",
      "0cbf32e1681d870632a1772601cbaadd996dc978",
      "0cbf32e1681d870632a1772601cbaadd996dc978",
      "0cbf32e1681d870632a1772601cbaadd996dc978"
    ],
    "公开日期": "2024年06月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48752",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/perf: Fix power_pmu_disable to call clear_pmi_irq_pending only if PMI is pending\n\nRunning selftest with CONFIG_PPC_IRQ_SOFT_MASK_DEBUG enabled in kernel\ntriggered below warning:\n\n[  172.851380] ------------[ cut here ]------------\n[  172.851391] WARNING: CPU: 8 PID: 2901 at arch/powerpc/include/asm/hw_irq.h:246 power_pmu_disable+0x270/0x280\n[  172.851402] Modules linked in: dm_mod bonding nft_ct nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables rfkill nfnetlink sunrpc xfs libcrc32c pseries_rng xts vmx_crypto uio_pdrv_genirq uio sch_fq_codel ip_tables ext4 mbcache jbd2 sd_mod t10_pi sg ibmvscsi ibmveth scsi_transport_srp fuse\n[  172.851442] CPU: 8 PID: 2901 Comm: lost_exception_ Not tainted 5.16.0-rc5-03218-g798527287598 #2\n[  172.851451] NIP:  c00000000013d600 LR: c00000000013d5a4 CTR: c00000000013b180\n[  172.851458] REGS: c000000017687860 TRAP: 0700   Not tainted  (5.16.0-rc5-03218-g798527287598)\n[  172.851465] MSR:  8000000000029033 <SF,EE,ME,IR,DR,RI,LE>  CR: 48004884  XER: 20040000\n[  172.851482] CFAR: c00000000013d5b4 IRQMASK: 1\n[  172.851482] GPR00: c00000000013d5a4 c000000017687b00 c000000002a10600 0000000000000004\n[  172.851482] GPR04: 0000000082004000 c0000008ba08f0a8 0000000000000000 00000008b7ed0000\n[  172.851482] GPR08: 00000000446194f6 0000000000008000 c00000000013b118 c000000000d58e68\n[  172.851482] GPR12: c00000000013d390 c00000001ec54a80 0000000000000000 0000000000000000\n[  172.851482] GPR16: 0000000000000000 0000000000000000 c000000015d5c708 c0000000025396d0\n[  172.851482] GPR20: 0000000000000000 0000000000000000 c00000000a3bbf40 0000000000000003\n[  172.851482] GPR24: 0000000000000000 c0000008ba097400 c0000000161e0d00 c00000000a3bb600\n[  172.851482] GPR28: c000000015d5c700 0000000000000001 0000000082384090 c0000008ba0020d8\n[  172.851549] NIP [c00000000013d600] power_pmu_disable+0x270/0x280\n[  172.851557] LR [c00000000013d5a4] power_pmu_disable+0x214/0x280\n[  172.851565] Call Trace:\n[  172.851568] [c000000017687b00] [c00000000013d5a4] power_pmu_disable+0x214/0x280 (unreliable)\n[  172.851579] [c000000017687b40] [c0000000003403ac] perf_pmu_disable+0x4c/0x60\n[  172.851588] [c000000017687b60] [c0000000003445e4] __perf_event_task_sched_out+0x1d4/0x660\n[  172.851596] [c000000017687c50] [c000000000d1175c] __schedule+0xbcc/0x12a0\n[  172.851602] [c000000017687d60] [c000000000d11ea8] schedule+0x78/0x140\n[  172.851608] [c000000017687d90] [c0000000001a8080] sys_sched_yield+0x20/0x40\n[  172.851615] [c000000017687db0] [c0000000000334dc] system_call_exception+0x18c/0x380\n[  172.851622] [c000000017687e10] [c00000000000c74c] system_call_common+0xec/0x268\n\nThe warning indicates that MSR_EE being set(interrupt enabled) when\nthere was an overflown PMC detected. This could happen in\npower_pmu_disable since it runs under interrupt soft disable\ncondition ( local_irq_save ) and not with interrupts hard disabled.\ncommit 2c9ac51b850d (\"powerpc/perf: Fix PMU callbacks to clear\npending PMI before resetting an overflown PMC\") intended to clear\nPMI pending bit in Paca when disabling the PMU. It could happen\nthat PMC gets overflown while code is in power_pmu_disable\ncallback function. Hence add a check to see if PMI pending bit\nis set in Paca before clearing it via clear_pmi_pending.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/55402a4618721f350a9ab660bb42717d8aa18e7c",
      "https://git.kernel.org/stable/c/28aaed966e76807a71de79dd40a8eee9042374dd",
      "https://git.kernel.org/stable/c/fa4ad064a6bd49208221df5e62adf27b426d1720",
      "https://git.kernel.org/stable/c/fb6433b48a178d4672cb26632454ee0b21056eaa"
    ],
    "受影响版本": [
      "ef798cd035f316a537fee8ed170c127f12407085",
      "fadcafa3959281ce2d96feedece8c75c3f95f8a5",
      "215a90ce3754fe509efbce6b73a4bb643c7e7528",
      "2c9ac51b850d84ee496b0a5d832ce66d411ae552"
    ],
    "公开日期": "2024年06月20日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48706",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvdpa: ifcvf: Do proper cleanup if IFCVF init fails\n\nifcvf_mgmt_dev leaks memory if it is not freed before\nreturning. Call is made to correct return statement\nso memory does not leak. ifcvf_init_hw does not take\ncare of this so it is needed to do it here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5d2cc32c1c10bd889125d2adc16a6bc3338dcd3e",
      "https://git.kernel.org/stable/c/6b04456e248761cf68f562f2fd7c04e591fcac94"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48705",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mt76: mt7921e: fix crash in chip reset fail\n\nIn case of drv own fail in reset, we may need to run mac_reset several\ntimes. The sequence would trigger system crash as the log below.\n\nBecause we do not re-enable/schedule \"tx_napi\" before disable it again,\nthe process would keep waiting for state change in napi_diable(). To\navoid the problem and keep status synchronize for each run, goto final\nresource handling if drv own failed.\n\n[ 5857.353423] mt7921e 0000:3b:00.0: driver own failed\n[ 5858.433427] mt7921e 0000:3b:00.0: Timeout for driver own\n[ 5859.633430] mt7921e 0000:3b:00.0: driver own failed\n[ 5859.633444] ------------[ cut here ]------------\n[ 5859.633446] WARNING: CPU: 6 at kernel/kthread.c:659 kthread_park+0x11d\n[ 5859.633717] Workqueue: mt76 mt7921_mac_reset_work [mt7921_common]\n[ 5859.633728] RIP: 0010:kthread_park+0x11d/0x150\n[ 5859.633736] RSP: 0018:ffff8881b676fc68 EFLAGS: 00010202\n......\n[ 5859.633766] Call Trace:\n[ 5859.633768]  <TASK>\n[ 5859.633771]  mt7921e_mac_reset+0x176/0x6f0 [mt7921e]\n[ 5859.633778]  mt7921_mac_reset_work+0x184/0x3a0 [mt7921_common]\n[ 5859.633785]  ? mt7921_mac_set_timing+0x520/0x520 [mt7921_common]\n[ 5859.633794]  ? __kasan_check_read+0x11/0x20\n[ 5859.633802]  process_one_work+0x7ee/0x1320\n[ 5859.633810]  worker_thread+0x53c/0x1240\n[ 5859.633818]  kthread+0x2b8/0x370\n[ 5859.633824]  ? process_one_work+0x1320/0x1320\n[ 5859.633828]  ? kthread_complete_and_exit+0x30/0x30\n[ 5859.633834]  ret_from_fork+0x1f/0x30\n[ 5859.633842]  </TASK>",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f7f3001723e337568017e8617974f29bc8b2f595",
      "https://git.kernel.org/stable/c/fa3fbe64037839f448dc569212bafc5a495d8219"
    ],
    "受影响版本": [
      "0efaf31dec572d3aac4316c6d952e06d1c33adc4",
      "0efaf31dec572d3aac4316c6d952e06d1c33adc4",
      "cdb39e251f864910b2fb6c099b1ef9d12c6e22c7"
    ],
    "公开日期": "2024年05月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48673",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: Fix possible access to freed memory in link clear\n\nAfter modifying the QP to the Error state, all RX WR would be completed\nwith WC in IB_WC_WR_FLUSH_ERR status. Current implementation does not\nwait for it is done, but destroy the QP and free the link group directly.\nSo there is a risk that accessing the freed memory in tasklet context.\n\nHere is a crash example:\n\n BUG: unable to handle page fault for address: ffffffff8f220860\n #PF: supervisor write access in kernel mode\n #PF: error_code(0x0002) - not-present page\n PGD f7300e067 P4D f7300e067 PUD f7300f063 PMD 8c4e45063 PTE 800ffff08c9df060\n Oops: 0002 [#1] SMP PTI\n CPU: 1 PID: 0 Comm: swapper/1 Kdump: loaded Tainted: G S         OE     5.10.0-0607+ #23\n Hardware name: Inspur NF5280M4/YZMB-00689-101, BIOS 4.1.20 07/09/2018\n RIP: 0010:native_queued_spin_lock_slowpath+0x176/0x1b0\n Code: f3 90 48 8b 32 48 85 f6 74 f6 eb d5 c1 ee 12 83 e0 03 83 ee 01 48 c1 e0 05 48 63 f6 48 05 00 c8 02 00 48 03 04 f5 00 09 98 8e <48> 89 10 8b 42 08 85 c0 75 09 f3 90 8b 42 08 85 c0 74 f7 48 8b 32\n RSP: 0018:ffffb3b6c001ebd8 EFLAGS: 00010086\n RAX: ffffffff8f220860 RBX: 0000000000000246 RCX: 0000000000080000\n RDX: ffff91db1f86c800 RSI: 000000000000173c RDI: ffff91db62bace00\n RBP: ffff91db62bacc00 R08: 0000000000000000 R09: c00000010000028b\n R10: 0000000000055198 R11: ffffb3b6c001ea58 R12: ffff91db80e05010\n R13: 000000000000000a R14: 0000000000000006 R15: 0000000000000040\n FS:  0000000000000000(0000) GS:ffff91db1f840000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: ffffffff8f220860 CR3: 00000001f9580004 CR4: 00000000003706e0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  <IRQ>\n  _raw_spin_lock_irqsave+0x30/0x40\n  mlx5_ib_poll_cq+0x4c/0xc50 [mlx5_ib]\n  smc_wr_rx_tasklet_fn+0x56/0xa0 [smc]\n  tasklet_action_common.isra.21+0x66/0x100\n  __do_softirq+0xd5/0x29c\n  asm_call_irq_on_stack+0x12/0x20\n  </IRQ>\n  do_softirq_own_stack+0x37/0x40\n  irq_exit_rcu+0x9d/0xa0\n  sysvec_call_function_single+0x34/0x80\n  asm_sysvec_call_function_single+0x12/0x20",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/89fcb70f1acd6b0bbf2f7bfbf45d7aa75a9bdcde",
      "https://git.kernel.org/stable/c/e9b1a4f867ae9c1dbd1d71cd09cbdb3239fb4968"
    ],
    "受影响版本": [
      "bd4ad57718cc86d2972a20f9791cd079996a4dd6",
      "bd4ad57718cc86d2972a20f9791cd079996a4dd6"
    ],
    "公开日期": "2024年05月03日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48656",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: ti: k3-udma-private: Fix refcount leak bug in of_xudma_dev_get()\n\nWe should call of_node_put() for the reference returned by\nof_parse_phandle() in fail path or when it is not used anymore.\nHere we only need to move the of_node_put() before the check.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/aa11dae059a439af82bae541b134f8f53ac177b5",
      "https://git.kernel.org/stable/c/dd5a6c5a08752b613e83ad2cb5133e72a64b876d",
      "https://git.kernel.org/stable/c/a17df55bf6d536712da6902a83db82b82e67d5a2",
      "https://git.kernel.org/stable/c/f9fdb0b86f087c2b7f6c6168dd0985a3c1eda87e"
    ],
    "受影响版本": [
      "d702419134133db1eab2067dc6ea5723467fd917",
      "d702419134133db1eab2067dc6ea5723467fd917",
      "d702419134133db1eab2067dc6ea5723467fd917",
      "d702419134133db1eab2067dc6ea5723467fd917"
    ],
    "公开日期": "2024年04月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48648",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsfc: fix null pointer dereference in efx_hard_start_xmit\n\nTrying to get the channel from the tx_queue variable here is wrong\nbecause we can only be here if tx_queue is NULL, so we shouldn't\ndereference it. As the above comment in the code says, this is very\nunlikely to happen, but it's wrong anyway so let's fix it.\n\nI hit this issue because of a different bug that caused tx_queue to be\nNULL. If that happens, this is the error message that we get here:\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000020\n  [...]\n  RIP: 0010:efx_hard_start_xmit+0x153/0x170 [sfc]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b3b41d4d95d3822b2e459ecbc80d030ea6aec5e7",
      "https://git.kernel.org/stable/c/8547c7bfc0617e7184e4da65b9b96681fcfe9998",
      "https://git.kernel.org/stable/c/b3b952168ee1f220ba729fa100fd9d5aa752eb03",
      "https://git.kernel.org/stable/c/0a242eb2913a4aa3d6fbdb86559f27628e9466f3"
    ],
    "受影响版本": [
      "12804793b17c0e19115a90d98f2f3df0cb79e233",
      "12804793b17c0e19115a90d98f2f3df0cb79e233",
      "12804793b17c0e19115a90d98f2f3df0cb79e233",
      "12804793b17c0e19115a90d98f2f3df0cb79e233"
    ],
    "公开日期": "2024年04月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48644",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: taprio: avoid disabling offload when it was never enabled\n\nIn an incredibly strange API design decision, qdisc->destroy() gets\ncalled even if qdisc->init() never succeeded, not exclusively since\ncommit 87b60cfacf9f (\"net_sched: fix error recovery at qdisc creation\"),\nbut apparently also earlier (in the case of qdisc_create_dflt()).\n\nThe taprio qdisc does not fully acknowledge this when it attempts full\noffload, because it starts off with q->flags = TAPRIO_FLAGS_INVALID in\ntaprio_init(), then it replaces q->flags with TCA_TAPRIO_ATTR_FLAGS\nparsed from netlink (in taprio_change(), tail called from taprio_init()).\n\nBut in taprio_destroy(), we call taprio_disable_offload(), and this\ndetermines what to do based on FULL_OFFLOAD_IS_ENABLED(q->flags).\n\nBut looking at the implementation of FULL_OFFLOAD_IS_ENABLED()\n(a bitwise check of bit 1 in q->flags), it is invalid to call this macro\non q->flags when it contains TAPRIO_FLAGS_INVALID, because that is set\nto U32_MAX, and therefore FULL_OFFLOAD_IS_ENABLED() will return true on\nan invalid set of flags.\n\nAs a result, it is possible to crash the kernel if user space forces an\nerror between setting q->flags = TAPRIO_FLAGS_INVALID, and the calling\nof taprio_enable_offload(). This is because drivers do not expect the\noffload to be disabled when it was never enabled.\n\nThe error that we force here is to attach taprio as a non-root qdisc,\nbut instead as child of an mqprio root qdisc:\n\n$ tc qdisc add dev swp0 root handle 1: \\\n\tmqprio num_tc 8 map 0 1 2 3 4 5 6 7 \\\n\tqueues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 hw 0\n$ tc qdisc replace dev swp0 parent 1:1 \\\n\ttaprio num_tc 8 map 0 1 2 3 4 5 6 7 \\\n\tqueues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 base-time 0 \\\n\tsched-entry S 0x7f 990000 sched-entry S 0x80 100000 \\\n\tflags 0x0 clockid CLOCK_TAI\nUnable to handle kernel paging request at virtual address fffffffffffffff8\n[fffffffffffffff8] pgd=0000000000000000, p4d=0000000000000000\nInternal error: Oops: 96000004 [#1] PREEMPT SMP\nCall trace:\n taprio_dump+0x27c/0x310\n vsc9959_port_setup_tc+0x1f4/0x460\n felix_port_setup_tc+0x24/0x3c\n dsa_slave_setup_tc+0x54/0x27c\n taprio_disable_offload.isra.0+0x58/0xe0\n taprio_destroy+0x80/0x104\n qdisc_create+0x240/0x470\n tc_modify_qdisc+0x1fc/0x6b0\n rtnetlink_rcv_msg+0x12c/0x390\n netlink_rcv_skb+0x5c/0x130\n rtnetlink_rcv+0x1c/0x2c\n\nFix this by keeping track of the operations we made, and undo the\noffload only if we actually did it.\n\nI've added \"bool offloaded\" inside a 4 byte hole between \"int clockid\"\nand \"atomic64_t picos_per_byte\". Now the first cache line looks like\nbelow:\n\n$ pahole -C taprio_sched net/sched/sch_taprio.o\nstruct taprio_sched {\n        struct Qdisc * *           qdiscs;               /*     0     8 */\n        struct Qdisc *             root;                 /*     8     8 */\n        u32                        flags;                /*    16     4 */\n        enum tk_offsets            tk_offset;            /*    20     4 */\n        int                        clockid;              /*    24     4 */\n        bool                       offloaded;            /*    28     1 */\n\n        /* XXX 3 bytes hole, try to pack */\n\n        atomic64_t                 picos_per_byte;       /*    32     0 */\n\n        /* XXX 8 bytes hole, try to pack */\n\n        spinlock_t                 current_entry_lock;   /*    40     0 */\n\n        /* XXX 8 bytes hole, try to pack */\n\n        struct sched_entry *       current_entry;        /*    48     8 */\n        struct sched_gate_list *   oper_sched;           /*    56     8 */\n        /* --- cacheline 1 boundary (64 bytes) --- */",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d12a1eb07003e597077329767c6aa86a7e972c76",
      "https://git.kernel.org/stable/c/586def6ebed195f3594a4884f7c5334d0e1ad1bb",
      "https://git.kernel.org/stable/c/f58e43184226e5e9662088ccf1389e424a3a4cbd",
      "https://git.kernel.org/stable/c/c7c9c7eb305ab8b4e93e4e4e1b78d8cfcbc26323",
      "https://git.kernel.org/stable/c/db46e3a88a09c5cf7e505664d01da7238cd56c92"
    ],
    "受影响版本": [
      "9c66d15646760eb8982242b4531c4d4fd36118fd",
      "9c66d15646760eb8982242b4531c4d4fd36118fd",
      "9c66d15646760eb8982242b4531c4d4fd36118fd",
      "9c66d15646760eb8982242b4531c4d4fd36118fd",
      "9c66d15646760eb8982242b4531c4d4fd36118fd"
    ],
    "公开日期": "2024年04月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48633",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/gma500: Fix WARN_ON(lock->magic != lock) error\n\npsb_gem_unpin() calls dma_resv_lock() but the underlying ww_mutex\ngets destroyed by drm_gem_object_release() move the\ndrm_gem_object_release() call in psb_gem_free_object() to after\nthe unpin to fix the below warning:\n\n[   79.693962] ------------[ cut here ]------------\n[   79.693992] DEBUG_LOCKS_WARN_ON(lock->magic != lock)\n[   79.694015] WARNING: CPU: 0 PID: 240 at kernel/locking/mutex.c:582 __ww_mutex_lock.constprop.0+0x569/0xfb0\n[   79.694052] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer qrtr bnep ath9k ath9k_common ath9k_hw snd_hda_codec_realtek snd_hda_codec_generic ledtrig_audio snd_hda_codec_hdmi snd_hda_intel ath3k snd_intel_dspcfg mac80211 snd_intel_sdw_acpi btusb snd_hda_codec btrtl btbcm btintel btmtk bluetooth at24 snd_hda_core snd_hwdep uvcvideo snd_seq libarc4 videobuf2_vmalloc ath videobuf2_memops videobuf2_v4l2 videobuf2_common snd_seq_device videodev acer_wmi intel_powerclamp coretemp mc snd_pcm joydev sparse_keymap ecdh_generic pcspkr wmi_bmof cfg80211 i2c_i801 i2c_smbus snd_timer snd r8169 rfkill lpc_ich soundcore acpi_cpufreq zram rtsx_pci_sdmmc mmc_core serio_raw rtsx_pci gma500_gfx(E) video wmi ip6_tables ip_tables i2c_dev fuse\n[   79.694436] CPU: 0 PID: 240 Comm: plymouthd Tainted: G        W   E      6.0.0-rc3+ #490\n[   79.694457] Hardware name: Packard Bell dot s/SJE01_CT, BIOS V1.10 07/23/2013\n[   79.694469] RIP: 0010:__ww_mutex_lock.constprop.0+0x569/0xfb0\n[   79.694496] Code: ff 85 c0 0f 84 15 fb ff ff 8b 05 ca 3c 11 01 85 c0 0f 85 07 fb ff ff 48 c7 c6 30 cb 84 aa 48 c7 c7 a3 e1 82 aa e8 ac 29 f8 ff <0f> 0b e9 ed fa ff ff e8 5b 83 8a ff 85 c0 74 10 44 8b 0d 98 3c 11\n[   79.694513] RSP: 0018:ffffad1dc048bbe0 EFLAGS: 00010282\n[   79.694623] RAX: 0000000000000028 RBX: 0000000000000000 RCX: 0000000000000000\n[   79.694636] RDX: 0000000000000001 RSI: ffffffffaa8b0ffc RDI: 00000000ffffffff\n[   79.694650] RBP: ffffad1dc048bc80 R08: 0000000000000000 R09: ffffad1dc048ba90\n[   79.694662] R10: 0000000000000003 R11: ffffffffaad62fe8 R12: ffff9ff302103138\n[   79.694675] R13: ffff9ff306ec8000 R14: ffff9ff307779078 R15: ffff9ff3014c0270\n[   79.694690] FS:  00007ff1cccf1740(0000) GS:ffff9ff3bc200000(0000) knlGS:0000000000000000\n[   79.694705] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[   79.694719] CR2: 0000559ecbcb4420 CR3: 0000000013210000 CR4: 00000000000006f0\n[   79.694734] Call Trace:\n[   79.694749]  <TASK>\n[   79.694761]  ? __schedule+0x47f/0x1670\n[   79.694796]  ? psb_gem_unpin+0x27/0x1a0 [gma500_gfx]\n[   79.694830]  ? lock_is_held_type+0xe3/0x140\n[   79.694864]  ? ww_mutex_lock+0x38/0xa0\n[   79.694885]  ? __cond_resched+0x1c/0x30\n[   79.694902]  ww_mutex_lock+0x38/0xa0\n[   79.694925]  psb_gem_unpin+0x27/0x1a0 [gma500_gfx]\n[   79.694964]  psb_gem_unpin+0x199/0x1a0 [gma500_gfx]\n[   79.694996]  drm_gem_object_release_handle+0x50/0x60\n[   79.695020]  ? drm_gem_object_handle_put_unlocked+0xf0/0xf0\n[   79.695042]  idr_for_each+0x4b/0xb0\n[   79.695066]  ? _raw_spin_unlock_irqrestore+0x30/0x60\n[   79.695095]  drm_gem_release+0x1c/0x30\n[   79.695118]  drm_file_free.part.0+0x1ea/0x260\n[   79.695150]  drm_release+0x6a/0x120\n[   79.695175]  __fput+0x9f/0x260\n[   79.695203]  task_work_run+0x59/0xa0\n[   79.695227]  do_exit+0x387/0xbe0\n[   79.695250]  ? seqcount_lockdep_reader_access.constprop.0+0x82/0x90\n[   79.695275]  ? lockdep_hardirqs_on+0x7d/0x100\n[   79.695304]  do_group_exit+0x33/0xb0\n[   79.695331]  __x64_sys_exit_group+0x14/0x20\n[   79.695353]  do_syscall_64+0x58/0x80\n[   79.695376]  ? up_read+0x17/0x20\n[   79.695401]  ? lock_is_held_type+0xe3/0x140\n[   79.695429]  ? asm_exc_page_fault+0x22/0x30\n[   79.695450]  ? lockdep_hardirqs_on+0x7d/0x100\n[   79.695473]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[   79.695493] RIP: 0033:0x7ff1ccefe3f1\n[   79.695516] Code: Unable to access opcode bytes at RIP 0x7ff1ccefe3c7.\n[   79.695607] RSP: 002b:00007ffed4413378 EFLAGS: \n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/55c077d97fa67e9f19952bb24122a8316b089474",
      "https://git.kernel.org/stable/c/b6f25c3b94f2aadbf5cbef954db4073614943d74"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年04月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48631",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix bug in extents parsing when eh_entries == 0 and eh_depth > 0\n\nWhen walking through an inode extents, the ext4_ext_binsearch_idx() function\nassumes that the extent header has been previously validated.  However, there\nare no checks that verify that the number of entries (eh->eh_entries) is\nnon-zero when depth is > 0.  And this will lead to problems because the\nEXT_FIRST_INDEX() and EXT_LAST_INDEX() will return garbage and result in this:\n\n[  135.245946] ------------[ cut here ]------------\n[  135.247579] kernel BUG at fs/ext4/extents.c:2258!\n[  135.249045] invalid opcode: 0000 [#1] PREEMPT SMP\n[  135.250320] CPU: 2 PID: 238 Comm: tmp118 Not tainted 5.19.0-rc8+ #4\n[  135.252067] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.15.0-0-g2dd4b9b-rebuilt.opensuse.org 04/01/2014\n[  135.255065] RIP: 0010:ext4_ext_map_blocks+0xc20/0xcb0\n[  135.256475] Code:\n[  135.261433] RSP: 0018:ffffc900005939f8 EFLAGS: 00010246\n[  135.262847] RAX: 0000000000000024 RBX: ffffc90000593b70 RCX: 0000000000000023\n[  135.264765] RDX: ffff8880038e5f10 RSI: 0000000000000003 RDI: ffff8880046e922c\n[  135.266670] RBP: ffff8880046e9348 R08: 0000000000000001 R09: ffff888002ca580c\n[  135.268576] R10: 0000000000002602 R11: 0000000000000000 R12: 0000000000000024\n[  135.270477] R13: 0000000000000000 R14: 0000000000000024 R15: 0000000000000000\n[  135.272394] FS:  00007fdabdc56740(0000) GS:ffff88807dd00000(0000) knlGS:0000000000000000\n[  135.274510] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  135.276075] CR2: 00007ffc26bd4f00 CR3: 0000000006261004 CR4: 0000000000170ea0\n[  135.277952] Call Trace:\n[  135.278635]  <TASK>\n[  135.279247]  ? preempt_count_add+0x6d/0xa0\n[  135.280358]  ? percpu_counter_add_batch+0x55/0xb0\n[  135.281612]  ? _raw_read_unlock+0x18/0x30\n[  135.282704]  ext4_map_blocks+0x294/0x5a0\n[  135.283745]  ? xa_load+0x6f/0xa0\n[  135.284562]  ext4_mpage_readpages+0x3d6/0x770\n[  135.285646]  read_pages+0x67/0x1d0\n[  135.286492]  ? folio_add_lru+0x51/0x80\n[  135.287441]  page_cache_ra_unbounded+0x124/0x170\n[  135.288510]  filemap_get_pages+0x23d/0x5a0\n[  135.289457]  ? path_openat+0xa72/0xdd0\n[  135.290332]  filemap_read+0xbf/0x300\n[  135.291158]  ? _raw_spin_lock_irqsave+0x17/0x40\n[  135.292192]  new_sync_read+0x103/0x170\n[  135.293014]  vfs_read+0x15d/0x180\n[  135.293745]  ksys_read+0xa1/0xe0\n[  135.294461]  do_syscall_64+0x3c/0x80\n[  135.295284]  entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThis patch simply adds an extra check in __ext4_ext_check(), verifying that\neh_entries is not 0 when eh_depth is > 0.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/bb7eb3ca4b3b0d2c7872cf1a41c30f5e5bd65df0",
      "https://git.kernel.org/stable/c/958b0ee23f5ac106e7cc11472b71aa2ea9a033bc",
      "https://git.kernel.org/stable/c/be4df018c0be5ebecf1ca510feacc23be415cefc",
      "https://git.kernel.org/stable/c/2f5e9de15e4f55fbf56f22d4a2ce406246cc462d",
      "https://git.kernel.org/stable/c/29a5b8a137ac8eb410cc823653a29ac0e7b7e1b0"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年04月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2022-48629",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: qcom-rng - ensure buffer for generate is completely filled\n\nThe generate function in struct rng_alg expects that the destination\nbuffer is completely filled if the function returns 0. qcom_rng_read()\ncan run into a situation where the buffer is partially filled with\nrandomness and the remaining part of the buffer is zeroed since\nqcom_rng_generate() doesn't check the return value. This issue can\nbe reproduced by running the following from libkcapi:\n\n    kcapi-rng -b 9000000 > OUTFILE\n\nThe generated OUTFILE will have three huge sections that contain all\nzeros, and this is caused by the code where the test\n'val & PRNG_STATUS_DATA_AVAIL' fails.\n\nLet's fix this issue by ensuring that qcom_rng_read() always returns\nwith a full buffer if the function returns success. Let's also have\nqcom_rng_generate() return the correct value.\n\nHere's some statistics from the ent project\n(https://www.fourmilab.ch/random/) that shows information about the\nquality of the generated numbers:\n\n    $ ent -c qcom-random-before\n    Value Char Occurrences Fraction\n      0           606748   0.067416\n      1            33104   0.003678\n      2            33001   0.003667\n    ...\n    253   �        32883   0.003654\n    254   �        33035   0.003671\n    255   �        33239   0.003693\n\n    Total:       9000000   1.000000\n\n    Entropy = 7.811590 bits per byte.\n\n    Optimum compression would reduce the size\n    of this 9000000 byte file by 2 percent.\n\n    Chi square distribution for 9000000 samples is 9329962.81, and\n    randomly would exceed this value less than 0.01 percent of the\n    times.\n\n    Arithmetic mean value of data bytes is 119.3731 (127.5 = random).\n    Monte Carlo value for Pi is 3.197293333 (error 1.77 percent).\n    Serial correlation coefficient is 0.159130 (totally uncorrelated =\n    0.0).\n\nWithout this patch, the results of the chi-square test is 0.01%, and\nthe numbers are certainly not random according to ent's project page.\nThe results improve with this patch:\n\n    $ ent -c qcom-random-after\n    Value Char Occurrences Fraction\n      0            35432   0.003937\n      1            35127   0.003903\n      2            35424   0.003936\n    ...\n    253   �        35201   0.003911\n    254   �        34835   0.003871\n    255   �        35368   0.003930\n\n    Total:       9000000   1.000000\n\n    Entropy = 7.999979 bits per byte.\n\n    Optimum compression would reduce the size\n    of this 9000000 byte file by 0 percent.\n\n    Chi square distribution for 9000000 samples is 258.77, and randomly\n    would exceed this value 42.24 percent of the times.\n\n    Arithmetic mean value of data bytes is 127.5006 (127.5 = random).\n    Monte Carlo value for Pi is 3.141277333 (error 0.01 percent).\n    Serial correlation coefficient is 0.000468 (totally uncorrelated =\n    0.0).\n\nThis change was tested on a Nexus 5 phone (msm8974 SoC).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a8e32bbb96c25b7ab29b1894dcd45e0b3b08fd9d",
      "https://git.kernel.org/stable/c/184f7bd08ce56f003530fc19f160d54e75bf5c9d",
      "https://git.kernel.org/stable/c/0f9b7b8df17525e464294c916acc8194ce38446b",
      "https://git.kernel.org/stable/c/ab9337c7cb6f875b6286440b1adfbeeef2b2b2bd",
      "https://git.kernel.org/stable/c/485995cbc98a4f77cfd4f8ed4dd7ff8ab262964d",
      "https://git.kernel.org/stable/c/a680b1832ced3b5fa7c93484248fd221ea0d614b"
    ],
    "受影响版本": [
      "ceec5f5b59882b871a722ca4d49b767a09a4bde9",
      "ceec5f5b59882b871a722ca4d49b767a09a4bde9",
      "ceec5f5b59882b871a722ca4d49b767a09a4bde9",
      "ceec5f5b59882b871a722ca4d49b767a09a4bde9",
      "ceec5f5b59882b871a722ca4d49b767a09a4bde9",
      "ceec5f5b59882b871a722ca4d49b767a09a4bde9"
    ],
    "公开日期": "2024年03月05日"
  },
  {
    "设备品牌": "Kesz1 Technologies",
    "设备类型": "OTA",
    "产品型号": "ipBlockList",
    "CVE编号": "CVE-2022-47147",
    "漏洞描述": "Cross-Site Request Forgery (CSRF) vulnerability in Kesz1 Technologies ipBlockList plugin <= 1.0 versions.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/ipblocklist/wordpress-ipblocklist-plugin-1-0-cross-site-request-forgery-csrf?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年03月14日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "LiteSpeed Cache",
    "CVE编号": "CVE-2022-46800",
    "漏洞描述": "Cross-Site Request Forgery (CSRF) vulnerability in LiteSpeed Technologies LiteSpeed Cache plugin <= 5.3 versions.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/litespeed-cache/wordpress-litespeed-cache-plugin-5-3-cross-site-request-forgery-csrf-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年05月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-45966",
    "漏洞描述": "here is an arbitrary file upload vulnerability in the file management function module of Classcms3.5.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/yinfei6/classcms"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年12月22日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-45938",
    "漏洞描述": "An issue was discovered in Comcast Defined Technologies microeisbss through 2021. An attacker can inject a stored XSS payload in the Device ID field under Inventory Management to achieve Remote Code Execution and privilege escalation..",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://my.xfinity.com/vulnerabilityreport",
      "https://pensecure.medium.com/cve-2022-45938-f4c0d441da6f"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年06月02日"
  },
  {
    "设备品牌": "1app Technologies, Inc",
    "设备类型": "OTA",
    "产品型号": "1app Business Forms",
    "CVE编号": "CVE-2022-44631",
    "漏洞描述": "Auth. (author+) Stored Cross-Site Scripting (XSS) vulnerability in 1app Technologies, Inc 1app Business Forms plugin <= 1.0.0 versions.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://patchstack.com/database/vulnerability/1app-business-forms/wordpress-1app-business-forms-plugin-1-0-0-auth-stored-cross-site-scripting-xss-vulnerability?_s_id=cve"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年04月23日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-44236",
    "漏洞描述": "Beijing Zed-3 Technologies Co.,Ltd VoIP simpliclty ASG 8.5.0.17807 (20181130-16:12) has a Weak password vulnerability.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/liong007/Zed-3/issues/2"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年12月15日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-44235",
    "漏洞描述": "Beijing Zed-3 Technologies Co.,Ltd VoIP simpliclty ASG 8.5.0.17807 (20181130-16:12) is vulnerable to Cross Site Scripting (XSS).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/liong007/Zed-3/issues/1"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年12月15日"
  },
  {
    "设备品牌": "Bulutses Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Bulutdesk Callcenter",
    "CVE编号": "CVE-2022-4422",
    "漏洞描述": "Call Center System developed by Bulutses Information Technologies before version 3.0 has an unauthenticated Sql Injection vulnerability. This has been fixed in the version 3.0 \n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-22-0747"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年01月10日"
  },
  {
    "设备品牌": "Callback technologies",
    "设备类型": "OTA",
    "产品型号": "CBFS Filter",
    "CVE编号": "CVE-2022-43590",
    "漏洞描述": "A null pointer dereference vulnerability exists in the handle_ioctl_0x830a0_systembuffer functionality of Callback technologies CBFS Filter 20.0.8317. A specially crafted I/O request packet (IRP) can lead to denial of service. An attacker can issue an ioctl to trigger this vulnerability.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://talosintelligence.com/vulnerability_reports/TALOS-2022-1649"
    ],
    "受影响版本": [
      "20.0.8317"
    ],
    "公开日期": "2022年11月28日"
  },
  {
    "设备品牌": "Callback technologies",
    "设备类型": "OTA",
    "产品型号": "CBFS Filter",
    "CVE编号": "CVE-2022-43589",
    "漏洞描述": "A null pointer dereference vulnerability exists in the handle_ioctl_8314C functionality of Callback technologies CBFS Filter 20.0.8317. A specially crafted I/O request packet (IRP) can lead to denial of service. An attacker can issue an ioctl to trigger this vulnerability.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://talosintelligence.com/vulnerability_reports/TALOS-2022-1648"
    ],
    "受影响版本": [
      "20.0.8317"
    ],
    "公开日期": "2022年11月28日"
  },
  {
    "设备品牌": "Callback technologies",
    "设备类型": "OTA",
    "产品型号": "CBFS Filter",
    "CVE编号": "CVE-2022-43588",
    "漏洞描述": "A null pointer dereference vulnerability exists in the handle_ioctl_83150 functionality of Callback technologies CBFS Filter 20.0.8317. A specially crafted I/O request packet (IRP) can lead to denial of service. An attacker can issue an ioctl to trigger this vulnerability.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://talosintelligence.com/vulnerability_reports/TALOS-2022-1647"
    ],
    "受影响版本": [
      "20.0.8317"
    ],
    "公开日期": "2022年11月28日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-40021",
    "漏洞描述": "QVidium Technologies Amino A140 (prior to firmware version 1.0.0-283) was discovered to contain a command injection vulnerability.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.securifera.com/advisories/CVE-2022-40021/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年02月17日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-37245",
    "漏洞描述": "MDaemon Technologies SecurityGateway for Email Servers 8.5.2 is vulnerable to Cross Site Scripting (XSS) via the Blacklist endpoint.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://files.mdaemon.com/securitygateway/release/relnotes_en.htm",
      "https://gtn.com.np/wp-content/uploads/2022/07/Stored-Cross-Site-Scripting-XSS-at-Blacklist-endpoint.pdf"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年08月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-37244",
    "漏洞描述": "MDaemon Technologies SecurityGateway for Email Servers 8.5.2 is vulnerable to IFRAME Injectionvia the currentRequest parameter. after login leads to inject malicious tag leads to IFRAME injection.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://files.mdaemon.com/securitygateway/release/relnotes_en.htm",
      "https://gtn.com.np/wp-content/uploads/2022/07/IFRAME-Injection-at-currentRequest-Parameter.pdf"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年08月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-37243",
    "漏洞描述": "MDaemon Technologies SecurityGateway for Email Servers 8.5.2 is vulnerable to Cross Site Scripting (XSS) via the whitelist endpoint.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://files.mdaemon.com/securitygateway/release/relnotes_en.htm",
      "https://gtn.com.np/wp-content/uploads/2022/07/Stored-Cross-Site-Scripting-XSS-at-whitelist-endpoint.pdf"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年08月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-37242",
    "漏洞描述": "MDaemon Technologies SecurityGateway for Email Servers 8.5.2, is vulnerable to HTTP Response splitting via the data parameter.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://files.mdaemon.com/securitygateway/release/relnotes_en.htm",
      "https://gtn.com.np/wp-content/uploads/2022/07/HTTP-Response-splitting-through-DATA-parameter.pdf"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年08月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-37241",
    "漏洞描述": "MDaemon Technologies SecurityGateway for Email Servers 8.5.2 is vulnerable to Cross Site Scripting (XSS) via the data_leak_list_ajax endpoint.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://files.mdaemon.com/securitygateway/release/relnotes_en.htm",
      "https://gtn.com.np/wp-content/uploads/2022/07/Stored-Cross-Site-Scripting-XSS-at-data_leak_list_ajax-endpoint.pdf"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年08月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-37240",
    "漏洞描述": "MDaemon Technologies SecurityGateway for Email Servers 8.5.2 is vulnerable to HTTP Response splitting via the format parameter.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://files.mdaemon.com/securitygateway/release/relnotes_en.htm",
      "https://gtn.com.np/wp-content/uploads/2022/07/HTTP-Response-splitting-through-format-parameter.pdf"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年08月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-37239",
    "漏洞描述": "MDaemon Technologies SecurityGateway for Email Servers 8.5.2 is vulnerable to Cross Site Scripting (XSS) via the rulles_list_ajax endpoint.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://files.mdaemon.com/securitygateway/release/relnotes_en.htm",
      "https://gtn.com.np/wp-content/uploads/2022/07/Stored-Cross-Site-Scripting-XSS.pdf"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年08月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-37238",
    "漏洞描述": "MDaemon Technologies SecurityGateway for Email Servers 8.5.2 is vulnerable to Cross Site Scripting (XSS) via the currentRequest parameter.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://gtn.com.np/wp-content/uploads/2022/07/Authenticated-Reflected-Cross-Site-Scripting-XSS-at-currentRequest-Parameter.pdf",
      "https://files.mdaemon.com/securitygateway/release/relnotes_en.htm"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年08月25日"
  },
  {
    "设备品牌": "webvendome",
    "设备类型": "OTA",
    "产品型号": "webvendome",
    "CVE编号": "CVE-2022-36787",
    "漏洞描述": "\nwebvendome - webvendome SQL Injection.\nSQL Injection in the Parameter \" DocNumber\"\nRequest :\nGet Request :\n/webvendome/showfiles.aspx?jobnumber=nullDoc Number=HERE.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.gov.il/en/Departments/faq/cve_advisories"
    ],
    "受影响版本": [
      "All versions"
    ],
    "公开日期": "2022年11月17日"
  },
  {
    "设备品牌": "rust-lang",
    "设备类型": "OTA",
    "产品型号": "cargo",
    "CVE编号": "CVE-2022-36114",
    "漏洞描述": "Cargo is a package manager for the rust programming language. It was discovered that Cargo did not limit the amount of data extracted from compressed archives. An attacker could upload to an alternate registry a specially crafted package that extracts way more data than its size (also known as a \"zip bomb\"), exhausting the disk space on the machine using Cargo to download the package. Note that by design Cargo allows code execution at build time, due to build scripts and procedural macros. The vulnerabilities in this advisory allow performing a subset of the possible damage in a harder to track down way. Your dependencies must still be trusted if you want to be protected from attacks, as it's possible to perform the same attacks with build scripts and procedural macros. The vulnerability is present in all versions of Cargo. Rust 1.64, to be released on September 22nd, will include a fix for it. Since the vulnerability is just a more limited way to accomplish what a malicious build scripts or procedural macros can do, we decided not to publish Rust point releases backporting the security fix. Patch files are available for Rust 1.63.0 are available in the wg-security-response repository for people building their own toolchain. We recommend users of alternate registries to excercise care in which package they download, by only including trusted dependencies in their projects. Please note that even with these vulnerabilities fixed, by design Cargo allows arbitrary code execution at build time thanks to build scripts and procedural macros: a malicious dependency will be able to cause damage regardless of these vulnerabilities. crates.io implemented server-side checks to reject these kinds of packages years ago, and there are no packages on crates.io exploiting these vulnerabilities. crates.io users still need to excercise care in choosing their dependencies though, as the same concerns about build scripts and procedural macros apply here.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/rust-lang/cargo/security/advisories/GHSA-2hvr-h6gw-qrxp",
      "https://github.com/rust-lang/cargo/commit/d1f9553c825f6d7481453be8d58d0e7f117988a7"
    ],
    "受影响版本": [
      "< 0.65.0",
      "= 0.66.0"
    ],
    "公开日期": "2022年09月14日"
  },
  {
    "设备品牌": "eclipse",
    "设备类型": "OTA",
    "产品型号": "deeplearning4j",
    "CVE编号": "CVE-2022-36022",
    "漏洞描述": "Deeplearning4J is a suite of tools for deploying and training deep learning models using the JVM. Packages org.deeplearning4j:dl4j-examples and org.deeplearning4j:platform-tests through version 1.0.0-M2.1 may use some unclaimed S3 buckets in tests in examples. This is likely affect people who use some older NLP examples that reference an old S3 bucket. The problem has been patched. Users should upgrade to snapshots as Deeplearning4J plan to publish a release with the fix at a later date. As a workaround, download a word2vec google news vector from a new source using git lfs from here.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/eclipse/deeplearning4j/security/advisories/GHSA-rc39-g977-687w",
      "https://github.com/mmihaltz/word2vec-GoogleNews-vectors"
    ],
    "受影响版本": [
      "<= 1.0.0-M2.1"
    ],
    "公开日期": "2022年11月10日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-35414",
    "漏洞描述": "softmmu/physmem.c in QEMU through 7.0.0 can perform an uninitialized read on the translate_fail path, leading to an io_readx or io_writex crash. NOTE: a third party states that the Non-virtualization Use Case in the qemu.org reference applies here, i.e., \"Bugs affecting the non-virtualization use case are not considered security bugs at this time.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/qemu/qemu/blob/f200ff158d5abcb974a6b597a962b6b2fbea2b06/softmmu/physmem.c",
      "https://github.com/qemu/qemu/commit/418ade7849ce7641c0f7333718caf5091a02fd4c",
      "https://github.com/qemu/qemu/commit/3517fb726741c109cae7995f9ea46f0cab6187d6#diff-83c563ed6330dc5d49876f1116e7518b5c16654bbc6e9b4ea8e28f5833d576fcR482",
      "https://github.com/qemu/qemu/blob/v7.0.0/include/exec/cpu-all.h#L145-L148",
      "https://github.com/qemu/qemu/commit/3517fb726741c109cae7995f9ea46f0cab6187d6#diff-83c563ed6330dc5d49876f1116e7518b5c16654bbc6e9b4ea8e28f5833d576fcR482.aa",
      "https://gitlab.com/qemu-project/qemu/-/issues/1065",
      "https://www.mail-archive.com/qemu-devel%40nongnu.org/msg895266.html",
      "https://sick.codes/sick-2022-113",
      "https://lists.debian.org/debian-lts-announce/2022/09/msg00008.html",
      "https://www.qemu.org/docs/master/system/security.html#non-virtualization-use-case"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年07月11日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-32429",
    "漏洞描述": "An authentication-bypass issue in the component http://MYDEVICEIP/cgi-bin-sdb/ExportSettings.sh of Mega System Technologies Inc MSNSwitch MNT.2408 allows unauthenticated attackers to arbitrarily configure settings within the application, leading to remote code execution.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://elifulkerson.com/CVE-2022-32429/",
      "http://packetstormsecurity.com/files/169819/MSNSwitch-Firmware-MNT.2408-Remote-Code-Execution.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年08月09日"
  },
  {
    "设备品牌": "nextcloud",
    "设备类型": "OTA",
    "产品型号": "security-advisories",
    "CVE编号": "CVE-2022-31014",
    "漏洞描述": "Nextcloud server is an open source personal cloud server. Affected versions were found to be vulnerable to SMTP command injection. The impact varies based on which commands are supported by the backend SMTP server. However, the main risk here is that the attacker can then hijack an already-authenticated SMTP session and run arbitrary SMTP commands as the email user, such as sending emails to other users, changing the FROM user, and so on. As before, this depends on the configuration of the server itself, but newlines should be sanitized to mitigate such arbitrary SMTP command injection. It is recommended that the Nextcloud Server is upgraded to 22.2.8 , 23.0.5 or 24.0.1. There are no known workarounds for this issue.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/nextcloud/security-advisories/security/advisories/GHSA-264h-3v4w-6xh2",
      "https://github.com/nextcloud/server/pull/32428",
      "https://hackerone.com/reports/1516377"
    ],
    "受影响版本": [
      "< 22.2.8",
      ">= 23.0.0, < 23.0.5",
      ">= 24.0.0, < 24.0.1"
    ],
    "公开日期": "2022年07月05日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-29351",
    "漏洞描述": "An arbitrary file upload vulnerability in the file upload module of Tiddlywiki5 v5.2.2 allows attackers to execute arbitrary code via a crafted SVG file. Note: The vendor argues that this is not a legitimate issue and there is no vulnerability here.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/jimcola99/corruptsvgfile",
      "http://tiddlywiki5.com",
      "https://github.com/Jermolene/TiddlyWiki5",
      "https://www.youtube.com/watch?v=F_DBx4psWns"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年05月16日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-28867",
    "漏洞描述": "An issue was discovered in Nokia NetAct 22 through the Administration of Measurements website section. A malicious user can edit or add the templateName parameter in order to include JavaScript code, which is then stored and executed by a victim's web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. Here, the /aom/html/EditTemplate.jsf and /aom/html/ViewAllTemplatesPage.jsf templateName parameter is used.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.telecomitalia.com/tit/it/innovazione/cybersecurity/red-team.html",
      "https://www.gruppotim.it/it/footer/red-team.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年07月24日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-28865",
    "漏洞描述": "An issue was discovered in Nokia NetAct 22 through the Site Configuration Tool website section. A malicious user can change a filename of an uploaded file to include JavaScript code, which is then stored and executed by a victim's web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. Here, the /netact/sct filename parameter is used.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.telecomitalia.com/tit/it/innovazione/cybersecurity/red-team.html",
      "https://www.gruppotim.it/it/footer/red-team.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年07月24日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-28864",
    "漏洞描述": "An issue was discovered in Nokia NetAct 22 through the Administration of Measurements website section. A malicious user can edit or add the templateName parameter in order to include malicious code, which is then downloaded as a .csv or .xlsx file and executed on a victim machine. Here, the /aom/html/EditTemplate.jsf and /aom/html/ViewAllTemplatesPage.jsf templateName parameter is used.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.telecomitalia.com/tit/it/innovazione/cybersecurity/red-team.html",
      "https://www.gruppotim.it/it/footer/red-team.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2023年07月24日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-28507",
    "漏洞描述": "Dragon Path Technologies Bharti Airtel Routers Hardware BDT-121 version 1.0 is vulnerable to Cross Site Scripting (XSS) via Dragon path router admin page.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://youtu.be/Ra7tWMs5dkk",
      "https://drive.google.com/file/d/1gAssizx8A6450rIfkfeI9_7o4t5NV0MH/view?usp=sharing"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年05月06日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "Kaspersky Anti-Virus products for home and Kaspersky Endpoint Security",
    "CVE编号": "CVE-2022-27534",
    "漏洞描述": "Kaspersky Anti-Virus products for home and Kaspersky Endpoint Security with antivirus databases released before 12 March 2022 had a bug in a data parsing module that potentially allowed an attacker to execute arbitrary code. The fix was delivered automatically. Credits: Georgy Zaytsev (Positive Technologies).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://support.kaspersky.com/general/vulnerability.aspx?el=12430#310322_2"
    ],
    "受影响版本": [
      "with antivirus databases released before 12.03.2022"
    ],
    "公开日期": "2022年04月01日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2022-25571",
    "漏洞描述": "Bluedon Information Security Technologies Co.,Ltd Internet Access Detector v1.0 was discovered to contain an information leak which allows attackers to access the contents of the password file via unspecified vectors.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.yuque.com/docs/share/a3a6f248-364b-459a-b572-52e7584192ba"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年03月24日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "Phicomm Routers",
    "CVE编号": "CVE-2022-25217",
    "漏洞描述": "Use of a hard-coded cryptographic key pair by the telnetd_startup service allows an attacker on the local area network to obtain a root shell on the device over telnet. The builds of telnetd_startup included in the version 22.5.9.163 of the K2 firmware, and version 32.1.15.93 of the K3C firmware (possibly amongst many other releases) included both the private and public RSA keys. The remaining versions cited here redacted the private key, but left the public key unchanged. An attacker in possession of the leaked private key may, through a scripted exchange of UDP packets, instruct telnetd_startup to spawn an unauthenticated telnet shell as root, by means of which they can then obtain complete control of the device. A consequence of the limited availablility of firmware images for testing is that models and versions not listed here may share this vulnerability.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.tenable.com/security/research/tra-2022-01"
    ],
    "受影响版本": [
      "K2 22.5.9.163, K3 21.5.37.246, K3C 32.1.15.93 -- 32.1.26.175, K3C 33.1.25.177, K2P 20.4.1.7, K2 A7 22.6.506.28"
    ],
    "公开日期": "2022年03月07日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "Red Hat Process Automation Manager 7",
    "CVE编号": "CVE-2022-2458",
    "漏洞描述": "XML external entity injection(XXE) is a vulnerability that allows an attacker to interfere with an application's processing of XML data. This attack occurs when XML input containing a reference to an external entity is processed by a weakly configured XML parser. The software processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output. Here, XML external entity injection lead to External Service interaction & Internal file read in Business Central and also Kie-Server APIs.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://bugzilla.redhat.com/show_bug.cgi?id=2107994#c0"
    ],
    "受影响版本": [
      "Fixed in 7.13.1"
    ],
    "公开日期": "2022年08月09日"
  },
  {
    "设备品牌": "tensorflow",
    "设备类型": "OTA",
    "产品型号": "tensorflow",
    "CVE编号": "CVE-2022-23578",
    "漏洞描述": "Tensorflow is an Open Source Machine Learning Framework. If a graph node is invalid, TensorFlow can leak memory in the implementation of `ImmutableExecutorState::Initialize`. Here, we set `item->kernel` to `nullptr` but it is a simple `OpKernel*` pointer so the memory that was previously allocated to it would leak. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-8r7c-3cm2-3h8f",
      "https://github.com/tensorflow/tensorflow/commit/c79ccba517dbb1a0ccb9b01ee3bd2a63748b60dd",
      "https://github.com/tensorflow/tensorflow/blob/a1320ec1eac186da1d03f033109191f715b2b130/tensorflow/core/common_runtime/immutable_executor_state.cc#L84-L262"
    ],
    "受影响版本": [
      ">= 2.7.0, < 2.7.1",
      "< 2.5.3",
      ">= 2.6.0, < 2.6.3"
    ],
    "公开日期": "2022年02月04日"
  },
  {
    "设备品牌": "SysAid",
    "设备类型": "OTA",
    "产品型号": "Sysaid",
    "CVE编号": "CVE-2022-23166",
    "漏洞描述": "Sysaid – Sysaid Local File Inclusion (LFI) – An unauthenticated attacker can access to the system by accessing to \"/lib/tinymce/examples/index.html\" path. in the \"Insert/Edit Embedded Media\" window Choose Type : iFrame and File/URL : [here is the LFI] Solution: Update to 22.2.20 cloud version, or to 22.1.64 on premise version.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://www.gov.il/en/departments/faq/cve_advisories"
    ],
    "受影响版本": [
      "22.2.19 cloud version"
    ],
    "公开日期": "2022年05月12日"
  },
  {
    "设备品牌": "Juniper Networks",
    "设备类型": "OTA",
    "产品型号": "Junos OS",
    "CVE编号": "CVE-2022-22223",
    "漏洞描述": "On QFX10000 Series devices using Juniper Networks Junos OS when configured as transit IP/MPLS penultimate hop popping (PHP) nodes with link aggregation group (LAG) interfaces, an Improper Validation of Specified Index, Position, or Offset in Input weakness allows an attacker sending certain IP packets to cause multiple interfaces in the LAG to detach causing a Denial of Service (DoS) condition. Continued receipt and processing of these packets will sustain the Denial of Service. This issue affects IPv4 and IPv6 packets. Packets of either type can cause and sustain the DoS event. These packets can be destined to the device or be transit packets. On devices such as the QFX10008 with line cards, line cards can be restarted to restore service. On devices such as the QFX10002 you can restart the PFE service, or reboot device to restore service. This issue affects: Juniper Networks Junos OS on QFX10000 Series: All versions prior to 15.1R7-S11; 18.4 versions prior to 18.4R2-S10, 18.4R3-S10; 19.1 versions prior to 19.1R3-S8; 19.2 versions prior to 19.2R3-S4; 19.3 versions prior to 19.3R3-S5; 19.4 versions prior to 19.4R2-S6, 19.4R3-S7; 20.1 versions prior to 20.1R3-S3; 20.2 versions prior to 20.2R3-S3; 20.3 versions prior to 20.3R3-S2; 20.4 versions prior to 20.4R3-S4; 21.1 versions prior to 21.1R3; 21.2 versions prior to 21.2R3-S3; 21.3 versions prior to 21.3R3-S1. An indicator of compromise may be seen by issuing the command: request pfe execute target fpc0 command \"show jspec pechip[3] registers ps l2_node 10\" timeout 0 | refresh 1 | no-more and reviewing for backpressured output; for example: GOT: 0x220702a8 pe.ps.l2_node[10].pkt_cnt 00000076 GOT: 0x220702b4 pe.ps.l2_node[10].backpressured 00000002 <<<< STICKS HERE and requesting detail on the pepic wanio: request pfe execute target fpc0 command \"show pepic 0 wanio-info\" timeout 0 | no-more | match xe-0/0/0:2 GOT: 3 xe-0/0/0:2 10 6 3 0 1 10 189 10 0x6321b088 <<< LOOK HERE as well as looking for tail drops looking at the interface queue, for example: show interfaces queue xe-0/0/0:2 resulting in: Transmitted: Total-dropped packets: 1094137 0 pps << LOOK HERE",
    "攻击向量": "ADJACENT_NETWORK",
    "厂商补丁链接": [
      "https://kb.juniper.net/JSA69873"
    ],
    "受影响版本": [
      "unspecified",
      "18.4",
      "19.1",
      "19.2",
      "19.3",
      "19.4",
      "20.1",
      "20.2",
      "20.3",
      "20.4",
      "21.1",
      "21.2",
      "21.3"
    ],
    "公开日期": "2022年10月18日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "Android",
    "CVE编号": "CVE-2022-20239",
    "漏洞描述": "remap_pfn_range' here may map out of size kernel memory (for example, may map the kernel area), and because the 'vma->vm_page_prot' can also be controlled by userspace, so userspace may map the kernel area to be writable, which is easy to be exploitedProduct: AndroidVersions: Android SoCAndroid ID: A-233972091",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://source.android.com/security/bulletin/2022-08-01"
    ],
    "受影响版本": [
      "Android SoC"
    ],
    "公开日期": "2022年08月09日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "Android",
    "CVE编号": "CVE-2022-20238",
    "漏洞描述": "'remap_pfn_range' here may map out of size kernel memory (for example, may map the kernel area), and because the 'vma->vm_page_prot' can also be controlled by userspace, so userspace may map the kernel area to be writable, which is easy to be exploitedProduct: AndroidVersions: Android SoCAndroid ID: A-233154555",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://source.android.com/security/bulletin/2022-07-01"
    ],
    "受影响版本": [
      "Android SoC"
    ],
    "公开日期": "2022年07月13日"
  },
  {
    "设备品牌": "microweber",
    "设备类型": "OTA",
    "产品型号": "microweber/microweber",
    "CVE编号": "CVE-2022-1504",
    "漏洞描述": "XSS in /demo/module/?module=HERE in GitHub repository microweber/microweber prior to 1.2.15. Typical impact of XSS attacks.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://huntr.dev/bounties/b8e5c324-3dfe-46b4-8095-1697c6b0a6d6",
      "https://github.com/microweber/microweber/commit/1f6a4de416a85e626dc643bb5ceb916e4802223e"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2022年04月27日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "OpenLiteSpeed Web Server",
    "CVE编号": "CVE-2022-0074",
    "漏洞描述": "Untrusted Search Path vulnerability in LiteSpeed Technologies OpenLiteSpeed Web Server and LiteSpeed Web Server Container allows Privilege Escalation. This affects versions from 1.6.15 before 1.7.16.1.\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/litespeedtech/ols-dockerfiles/blob/master/template/Dockerfile#L29"
    ],
    "受影响版本": [
      "1.6.15"
    ],
    "公开日期": "2022年10月27日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "OpenLiteSpeed Web Server",
    "CVE编号": "CVE-2022-0073",
    "漏洞描述": "Improper Input Validation vulnerability in LiteSpeed Technologies OpenLiteSpeed Web Server and LiteSpeed Web Server dashboards allows Command Injection. This affects 1.7.0  versions before 1.7.16.1.\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/litespeedtech/openlitespeed/blob/v1.7.16/dist/admin/html.open/lib/CValidation.php#L565",
      "https://github.com/litespeedtech/openlitespeed/blob/v1.7.16.1/dist/admin/html.open/lib/CValidation.php#L565"
    ],
    "受影响版本": [
      "1.7.0"
    ],
    "公开日期": "2022年10月27日"
  },
  {
    "设备品牌": "LiteSpeed Technologies",
    "设备类型": "OTA",
    "产品型号": "OpenLiteSpeed Web Server",
    "CVE编号": "CVE-2022-0072",
    "漏洞描述": "Directory Traversal vulnerability in LiteSpeed Technologies OpenLiteSpeed Web Server and LiteSpeed Web Server dashboards allows Path Traversal. This affects versions from 1.5.11 through 1.5.12, from 1.6.5 through 1.6.20.1, from 1.7.0 before 1.7.16.1",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/litespeedtech/openlitespeed/blob/v1.7.16/src/main/httpserver.cpp#L2060-L2061",
      "https://github.com/litespeedtech/openlitespeed/blob/v1.7.16.1/src/main/httpserver.cpp#L2060-L2061"
    ],
    "受影响版本": [
      "1.5.11",
      "1.6.5",
      "1.7.0"
    ],
    "公开日期": "2022年10月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47660",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/ntfs3: Fix some memory leaks in an error handling path of 'log_replay()'\n\nAll error handling paths lead to 'out' where many resources are freed.\n\nDo it as well here instead of a direct return, otherwise 'log', 'ra' and\n'log->one_page_buf' (at least) will leak.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d8be98ab88250dc12a98efdb703792a537b0eac3",
      "https://git.kernel.org/stable/c/bc4a1d384a04c6dba9312e1421a9f9f7c03339a4",
      "https://git.kernel.org/stable/c/2c97519ed6b4239594c58ddacf3d0d576cf070cc",
      "https://git.kernel.org/stable/c/e589f9b7078e1c0191613cd736f598e81d2390de"
    ],
    "受影响版本": [
      "b46acd6a6a627d876898e1c84d3f84902264b445",
      "b46acd6a6a627d876898e1c84d3f84902264b445",
      "b46acd6a6a627d876898e1c84d3f84902264b445",
      "b46acd6a6a627d876898e1c84d3f84902264b445"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47640",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/kasan: Fix early region not updated correctly\n\nThe shadow's page table is not updated when PTE_RPN_SHIFT is 24\nand PAGE_SHIFT is 12. It not only causes false positives but\nalso false negative as shown the following text.\n\nFix it by bringing the logic of kasan_early_shadow_page_entry here.\n\n1. False Positive:\n==================================================================\nBUG: KASAN: vmalloc-out-of-bounds in pcpu_alloc+0x508/0xa50\nWrite of size 16 at addr f57f3be0 by task swapper/0/1\n\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.15.0-12267-gdebe436e77c7 #1\nCall Trace:\n[c80d1c20] [c07fe7b8] dump_stack_lvl+0x4c/0x6c (unreliable)\n[c80d1c40] [c02ff668] print_address_description.constprop.0+0x88/0x300\n[c80d1c70] [c02ff45c] kasan_report+0x1ec/0x200\n[c80d1cb0] [c0300b20] kasan_check_range+0x160/0x2f0\n[c80d1cc0] [c03018a4] memset+0x34/0x90\n[c80d1ce0] [c0280108] pcpu_alloc+0x508/0xa50\n[c80d1d40] [c02fd7bc] __kmem_cache_create+0xfc/0x570\n[c80d1d70] [c0283d64] kmem_cache_create_usercopy+0x274/0x3e0\n[c80d1db0] [c2036580] init_sd+0xc4/0x1d0\n[c80d1de0] [c00044a0] do_one_initcall+0xc0/0x33c\n[c80d1eb0] [c2001624] kernel_init_freeable+0x2c8/0x384\n[c80d1ef0] [c0004b14] kernel_init+0x24/0x170\n[c80d1f10] [c001b26c] ret_from_kernel_thread+0x5c/0x64\n\nMemory state around the buggy address:\n f57f3a80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n f57f3b00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n>f57f3b80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n                                               ^\n f57f3c00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n f57f3c80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8\n==================================================================\n\n2. False Negative (with KASAN tests):\n==================================================================\nBefore fix:\n    ok 45 - kmalloc_double_kzfree\n    # vmalloc_oob: EXPECTATION FAILED at lib/test_kasan.c:1039\n    KASAN failure expected in \"((volatile char *)area)[3100]\", but none occurred\n    not ok 46 - vmalloc_oob\n    not ok 1 - kasan\n\n==================================================================\nAfter fix:\n    ok 1 - kasan",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7f19245c3647afea8c7c41f795506ef70f64b9f2",
      "https://git.kernel.org/stable/c/f39a3309393a4a484532f6ba745c6acbcfe06115",
      "https://git.kernel.org/stable/c/5a3d8f3192a409893c57808cc935e16484df1068",
      "https://git.kernel.org/stable/c/de56beace6648065d404cd9835aa7d30e3df519d",
      "https://git.kernel.org/stable/c/e3d157a4b4f4e0268c98be5b7013bf4b31234bb6",
      "https://git.kernel.org/stable/c/dd75080aa8409ce10d50fb58981c6b59bf8707d3"
    ],
    "受影响版本": [
      "cbd18991e24fea2c31da3bb117c83e4a3538cd11",
      "cbd18991e24fea2c31da3bb117c83e4a3538cd11",
      "cbd18991e24fea2c31da3bb117c83e4a3538cd11",
      "cbd18991e24fea2c31da3bb117c83e4a3538cd11",
      "cbd18991e24fea2c31da3bb117c83e4a3538cd11",
      "cbd18991e24fea2c31da3bb117c83e4a3538cd11",
      "3822dd8c102d11ada9d9ed8e04cad0b347a04689"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47635",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nubifs: Fix to add refcount once page is set private\n\nMM defined the rule [1] very clearly that once page was set with PG_private\nflag, we should increment the refcount in that page, also main flows like\npageout(), migrate_page() will assume there is one additional page\nreference count if page_has_private() returns true. Otherwise, we may\nget a BUG in page migration:\n\n  page:0000000080d05b9d refcount:-1 mapcount:0 mapping:000000005f4d82a8\n  index:0xe2 pfn:0x14c12\n  aops:ubifs_file_address_operations [ubifs] ino:8f1 dentry name:\"f30e\"\n  flags: 0x1fffff80002405(locked|uptodate|owner_priv_1|private|node=0|\n  zone=1|lastcpupid=0x1fffff)\n  page dumped because: VM_BUG_ON_PAGE(page_count(page) != 0)\n  ------------[ cut here ]------------\n  kernel BUG at include/linux/page_ref.h:184!\n  invalid opcode: 0000 [#1] SMP\n  CPU: 3 PID: 38 Comm: kcompactd0 Not tainted 5.15.0-rc5\n  RIP: 0010:migrate_page_move_mapping+0xac3/0xe70\n  Call Trace:\n    ubifs_migrate_page+0x22/0xc0 [ubifs]\n    move_to_new_page+0xb4/0x600\n    migrate_pages+0x1523/0x1cc0\n    compact_zone+0x8c5/0x14b0\n    kcompactd+0x2bc/0x560\n    kthread+0x18c/0x1e0\n    ret_from_fork+0x1f/0x30\n\nBefore the time, we should make clean a concept, what does refcount means\nin page gotten from grab_cache_page_write_begin(). There are 2 situations:\nSituation 1: refcount is 3, page is created by __page_cache_alloc.\n  TYPE_A - the write process is using this page\n  TYPE_B - page is assigned to one certain mapping by calling\n\t   __add_to_page_cache_locked()\n  TYPE_C - page is added into pagevec list corresponding current cpu by\n\t   calling lru_cache_add()\nSituation 2: refcount is 2, page is gotten from the mapping's tree\n  TYPE_B - page has been assigned to one certain mapping\n  TYPE_A - the write process is using this page (by calling\n\t   page_cache_get_speculative())\nFilesystem releases one refcount by calling put_page() in xxx_write_end(),\nthe released refcount corresponds to TYPE_A (write task is using it). If\nthere are any processes using a page, page migration process will skip the\npage by judging whether expected_page_refs() equals to page refcount.\n\nThe BUG is caused by following process:\n    PA(cpu 0)                           kcompactd(cpu 1)\n\t\t\t\tcompact_zone\nubifs_write_begin\n  page_a = grab_cache_page_write_begin\n    add_to_page_cache_lru\n      lru_cache_add\n        pagevec_add // put page into cpu 0's pagevec\n  (refcnf = 3, for page creation process)\nubifs_write_end\n  SetPagePrivate(page_a) // doesn't increase page count !\n  unlock_page(page_a)\n  put_page(page_a)  // refcnt = 2\n\t\t\t\t[...]\n\n    PB(cpu 0)\nfilemap_read\n  filemap_get_pages\n    add_to_page_cache_lru\n      lru_cache_add\n        __pagevec_lru_add // traverse all pages in cpu 0's pagevec\n\t  __pagevec_lru_add_fn\n\t    SetPageLRU(page_a)\n\t\t\t\tisolate_migratepages\n                                  isolate_migratepages_block\n\t\t\t\t    get_page_unless_zero(page_a)\n\t\t\t\t    // refcnt = 3\n                                      list_add(page_a, from_list)\n\t\t\t\tmigrate_pages(from_list)\n\t\t\t\t  __unmap_and_move\n\t\t\t\t    move_to_new_page\n\t\t\t\t      ubifs_migrate_page(page_a)\n\t\t\t\t        migrate_page_move_mapping\n\t\t\t\t\t  expected_page_refs get 3\n                                  (migration[1] + mapping[1] + private[1])\n\t release_pages\n\t   put_page_testzero(page_a) // refcnt = 3\n                                          page_ref_freeze  // refcnt = 0\n\t     page_ref_dec_and_test(0 - 1 = -1)\n                                          page_ref_unfreeze\n                                            VM_BUG_ON_PAGE(-1 != 0, page)\n\nUBIFS doesn't increase the page refcount after setting private flag, which\nleads to page migration task believes the page is not used by any other\nprocesses, so the page is migrated. This causes concurrent accessing on\npage refcount between put_page() called by other process(eg. read process\ncalls lru_cache_add) and page_ref_unfreeze() called by mi\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c34ae24a2590fee96a3a7735ba2fa6cc52306221",
      "https://git.kernel.org/stable/c/4f75bab98565afd4f905059c56ec4caba88a7eec",
      "https://git.kernel.org/stable/c/5aaa2c0f0052b02c4a982993d4c5bb68fb7cbe22",
      "https://git.kernel.org/stable/c/fbeb2139eed65e929ce806c6468e6601ade01b1b",
      "https://git.kernel.org/stable/c/3b67db8a6ca83e6ff90b756d3da0c966f61cd37b"
    ],
    "受影响版本": [
      "1e51764a3c2ac05a23a22b2a95ddee4d9bffb16d",
      "1e51764a3c2ac05a23a22b2a95ddee4d9bffb16d",
      "1e51764a3c2ac05a23a22b2a95ddee4d9bffb16d",
      "1e51764a3c2ac05a23a22b2a95ddee4d9bffb16d",
      "1e51764a3c2ac05a23a22b2a95ddee4d9bffb16d"
    ],
    "公开日期": "2025年02月26日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47602",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: track only QoS data frames for admission control\n\nFor admission control, obviously all of that only works for\nQoS data frames, otherwise we cannot even access the QoS\nfield in the header.\n\nSyzbot reported (see below) an uninitialized value here due\nto a status of a non-QoS nullfunc packet, which isn't even\nlong enough to contain the QoS header.\n\nFix this to only do anything for QoS data packets.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/69f054d6642c8f6173724ce17e7ee3ff66b8f682",
      "https://git.kernel.org/stable/c/46b9e29db2012a4d2a40a26101862e002ccf387b",
      "https://git.kernel.org/stable/c/eed897a22230e3231a740eddd7d6d95ba476625f",
      "https://git.kernel.org/stable/c/42d08e97b196479f593499e887a9ab81446a34b9",
      "https://git.kernel.org/stable/c/d5e568c3a4ec2ddd23e7dc5ad5b0c64e4f22981a"
    ],
    "受影响版本": [
      "02219b3abca59fca81711bfe7ee78df7abad97ce",
      "02219b3abca59fca81711bfe7ee78df7abad97ce",
      "02219b3abca59fca81711bfe7ee78df7abad97ce",
      "02219b3abca59fca81711bfe7ee78df7abad97ce",
      "02219b3abca59fca81711bfe7ee78df7abad97ce"
    ],
    "公开日期": "2024年06月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47595",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: sch_ets: don't remove idle classes from the round-robin list\n\nShuang reported that the following script:\n\n 1) tc qdisc add dev ddd0 handle 10: parent 1: ets bands 8 strict 4 priomap 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7\n 2) mausezahn ddd0  -A 10.10.10.1 -B 10.10.10.2 -c 0 -a own -b 00:c1:a0:c1:a0:00 -t udp &\n 3) tc qdisc change dev ddd0 handle 10: ets bands 4 strict 2 quanta 2500 2500 priomap 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n\ncrashes systematically when line 2) is commented:\n\n list_del corruption, ffff8e028404bd30->next is LIST_POISON1 (dead000000000100)\n ------------[ cut here ]------------\n kernel BUG at lib/list_debug.c:47!\n invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 0 PID: 954 Comm: tc Not tainted 5.16.0-rc4+ #478\n Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014\n RIP: 0010:__list_del_entry_valid.cold.1+0x12/0x47\n Code: fe ff 0f 0b 48 89 c1 4c 89 c6 48 c7 c7 08 42 1b 87 e8 1d c5 fe ff 0f 0b 48 89 fe 48 89 c2 48 c7 c7 98 42 1b 87 e8 09 c5 fe ff <0f> 0b 48 c7 c7 48 43 1b 87 e8 fb c4 fe ff 0f 0b 48 89 f2 48 89 fe\n RSP: 0018:ffffae46807a3888 EFLAGS: 00010246\n RAX: 000000000000004e RBX: 0000000000000007 RCX: 0000000000000202\n RDX: 0000000000000000 RSI: ffffffff871ac536 RDI: 00000000ffffffff\n RBP: ffffae46807a3a10 R08: 0000000000000000 R09: c0000000ffff7fff\n R10: 0000000000000001 R11: ffffae46807a36a8 R12: ffff8e028404b800\n R13: ffff8e028404bd30 R14: dead000000000100 R15: ffff8e02fafa2400\n FS:  00007efdc92e4480(0000) GS:ffff8e02fb600000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000682f48 CR3: 00000001058be000 CR4: 0000000000350ef0\n Call Trace:\n  <TASK>\n  ets_qdisc_change+0x58b/0xa70 [sch_ets]\n  tc_modify_qdisc+0x323/0x880\n  rtnetlink_rcv_msg+0x169/0x4a0\n  netlink_rcv_skb+0x50/0x100\n  netlink_unicast+0x1a5/0x280\n  netlink_sendmsg+0x257/0x4d0\n  sock_sendmsg+0x5b/0x60\n  ____sys_sendmsg+0x1f2/0x260\n  ___sys_sendmsg+0x7c/0xc0\n  __sys_sendmsg+0x57/0xa0\n  do_syscall_64+0x3a/0x80\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n RIP: 0033:0x7efdc8031338\n Code: 89 02 48 c7 c0 ff ff ff ff eb b5 0f 1f 80 00 00 00 00 f3 0f 1e fa 48 8d 05 25 43 2c 00 8b 00 85 c0 75 17 b8 2e 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 58 c3 0f 1f 80 00 00 00 00 41 54 41 89 d4 55\n RSP: 002b:00007ffdf1ce9828 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\n RAX: ffffffffffffffda RBX: 0000000061b37a97 RCX: 00007efdc8031338\n RDX: 0000000000000000 RSI: 00007ffdf1ce9890 RDI: 0000000000000003\n RBP: 0000000000000000 R08: 0000000000000001 R09: 000000000078a940\n R10: 000000000000000c R11: 0000000000000246 R12: 0000000000000001\n R13: 0000000000688880 R14: 0000000000000000 R15: 0000000000000000\n  </TASK>\n Modules linked in: sch_ets sch_tbf dummy rfkill iTCO_wdt iTCO_vendor_support intel_rapl_msr intel_rapl_common joydev pcspkr i2c_i801 virtio_balloon i2c_smbus lpc_ich ip_tables xfs libcrc32c crct10dif_pclmul crc32_pclmul crc32c_intel serio_raw ghash_clmulni_intel ahci libahci libata virtio_blk virtio_console virtio_net net_failover failover sunrpc dm_mirror dm_region_hash dm_log dm_mod [last unloaded: sch_ets]\n ---[ end trace f35878d1912655c2 ]---\n RIP: 0010:__list_del_entry_valid.cold.1+0x12/0x47\n Code: fe ff 0f 0b 48 89 c1 4c 89 c6 48 c7 c7 08 42 1b 87 e8 1d c5 fe ff 0f 0b 48 89 fe 48 89 c2 48 c7 c7 98 42 1b 87 e8 09 c5 fe ff <0f> 0b 48 c7 c7 48 43 1b 87 e8 fb c4 fe ff 0f 0b 48 89 f2 48 89 fe\n RSP: 0018:ffffae46807a3888 EFLAGS: 00010246\n RAX: 000000000000004e RBX: 0000000000000007 RCX: 0000000000000202\n RDX: 0000000000000000 RSI: ffffffff871ac536 RDI: 00000000ffffffff\n RBP: ffffae46807a3a10 R08: 0000000000000000 R09: c0000000ffff7fff\n R10: 0000000000000001 R11: ffffae46807a36a8 R12: ffff8e028404b800\n R13: ffff8e028404bd30 R14: dead000000000100 R15: ffff8e02fafa2400\n FS:  00007efdc92e4480(0000) GS:ffff8e02fb600000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000000000\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/81fbdd45652d8605a029e78ef14a6aaa529c4e72",
      "https://git.kernel.org/stable/c/491c1253441e2fdc8f6a6f4976e3f13440419b7a",
      "https://git.kernel.org/stable/c/c062f2a0b04d86c5b8c9d973bea43493eaca3d32"
    ],
    "受影响版本": [
      "ae2659d2c670252759ee9c823c4e039c0e05a6f2",
      "e25bdbc7e951ae5728fee1f4c09485df113d013c",
      "de6d25924c2a8c2988c6a385990cafbe742061bf"
    ],
    "公开日期": "2024年06月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47586",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: stmmac: dwmac-rk: fix oob read in rk_gmac_setup\n\nKASAN reports an out-of-bounds read in rk_gmac_setup on the line:\n\n\twhile (ops->regs[i]) {\n\nThis happens for most platforms since the regs flexible array member is\nempty, so the memory after the ops structure is being read here.  It\nseems that mostly this happens to contain zero anyway, so we get lucky\nand everything still works.\n\nTo avoid adding redundant data to nearly all the ops structures, add a\nnew flag to indicate whether the regs field is valid and avoid this loop\nwhen it is not.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/0b4a5d1e15ce72f69be48f38dc0401dab890ae0f",
      "https://git.kernel.org/stable/c/0546b224cc7717cc8a2db076b0bb069a9c430794"
    ],
    "受影响版本": [
      "3bb3d6b1c1957e88bfc5e77a4557f7e6ba761fe3",
      "3bb3d6b1c1957e88bfc5e77a4557f7e6ba761fe3"
    ],
    "公开日期": "2024年06月19日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47561",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: virtio: disable timeout handling\n\nIf a timeout is hit, it can result is incorrect data on the I2C bus\nand/or memory corruptions in the guest since the device can still be\noperating on the buffers it was given while the guest has freed them.\n\nHere is, for example, the start of a slub_debug splat which was\ntriggered on the next transfer after one transfer was forced to timeout\nby setting a breakpoint in the backend (rust-vmm/vhost-device):\n\n BUG kmalloc-1k (Not tainted): Poison overwritten\n First byte 0x1 instead of 0x6b\n Allocated in virtio_i2c_xfer+0x65/0x35c age=350 cpu=0 pid=29\n \t__kmalloc+0xc2/0x1c9\n \tvirtio_i2c_xfer+0x65/0x35c\n \t__i2c_transfer+0x429/0x57d\n \ti2c_transfer+0x115/0x134\n \ti2cdev_ioctl_rdwr+0x16a/0x1de\n \ti2cdev_ioctl+0x247/0x2ed\n \tvfs_ioctl+0x21/0x30\n \tsys_ioctl+0xb18/0xb41\n Freed in virtio_i2c_xfer+0x32e/0x35c age=244 cpu=0 pid=29\n \tkfree+0x1bd/0x1cc\n \tvirtio_i2c_xfer+0x32e/0x35c\n \t__i2c_transfer+0x429/0x57d\n \ti2c_transfer+0x115/0x134\n \ti2cdev_ioctl_rdwr+0x16a/0x1de\n \ti2cdev_ioctl+0x247/0x2ed\n \tvfs_ioctl+0x21/0x30\n \tsys_ioctl+0xb18/0xb41\n\nThere is no simple fix for this (the driver would have to always create\nbounce buffers and hold on to them until the device eventually returns\nthe buffers), so just disable the timeout support for now.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/cc432b0727ce404cc13e8f6b5ce29f412c3f9f1f",
      "https://git.kernel.org/stable/c/84e1d0bf1d7121759622dabf8fbef4c99ad597c5"
    ],
    "受影响版本": [
      "3cfc88380413d20f777dc6648a38f683962e52bf",
      "3cfc88380413d20f777dc6648a38f683962e52bf"
    ],
    "公开日期": "2024年05月24日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47556",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nethtool: ioctl: fix potential NULL deref in ethtool_set_coalesce()\n\nethtool_set_coalesce() now uses both the .get_coalesce() and\n.set_coalesce() callbacks. But the check for their availability is\nbuggy, so changing the coalesce settings on a device where the driver\nprovides only _one_ of the callbacks results in a NULL pointer\ndereference instead of an -EOPNOTSUPP.\n\nFix the condition so that the availability of both callbacks is\nensured. This also matches the netlink code.\n\nNote that reproducing this requires some effort - it only affects the\nlegacy ioctl path, and needs a specific combination of driver options:\n- have .get_coalesce() and .coalesce_supported but no\n .set_coalesce(), or\n- have .set_coalesce() but no .get_coalesce(). Here eg. ethtool doesn't\n  cause the crash as it first attempts to call ethtool_get_coalesce()\n  and bails out on error.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/abfdd9e2f0f9699015d72317f74154d3e53664e6",
      "https://git.kernel.org/stable/c/0276af2176c78771da7f311621a25d7608045827"
    ],
    "受影响版本": [
      "f3ccfda1931977b80267ba54070a1aeafa18f6ca",
      "f3ccfda1931977b80267ba54070a1aeafa18f6ca"
    ],
    "公开日期": "2024年05月24日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47544",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: fix page frag corruption on page fault\n\nSteffen reported a TCP stream corruption for HTTP requests\nserved by the apache web-server using a cifs mount-point\nand memory mapping the relevant file.\n\nThe root cause is quite similar to the one addressed by\ncommit 20eb4f29b602 (\"net: fix sk_page_frag() recursion from\nmemory reclaim\"). Here the nested access to the task page frag\nis caused by a page fault on the (mmapped) user-space memory\nbuffer coming from the cifs file.\n\nThe page fault handler performs an smb transaction on a different\nsocket, inside the same process context. Since sk->sk_allaction\nfor such socket does not prevent the usage for the task_frag,\nthe nested allocation modify \"under the hood\" the page frag\nin use by the outer sendmsg call, corrupting the stream.\n\nThe overall relevant stack trace looks like the following:\n\nhttpd 78268 [001] 3461630.850950:      probe:tcp_sendmsg_locked:\n        ffffffff91461d91 tcp_sendmsg_locked+0x1\n        ffffffff91462b57 tcp_sendmsg+0x27\n        ffffffff9139814e sock_sendmsg+0x3e\n        ffffffffc06dfe1d smb_send_kvec+0x28\n        [...]\n        ffffffffc06cfaf8 cifs_readpages+0x213\n        ffffffff90e83c4b read_pages+0x6b\n        ffffffff90e83f31 __do_page_cache_readahead+0x1c1\n        ffffffff90e79e98 filemap_fault+0x788\n        ffffffff90eb0458 __do_fault+0x38\n        ffffffff90eb5280 do_fault+0x1a0\n        ffffffff90eb7c84 __handle_mm_fault+0x4d4\n        ffffffff90eb8093 handle_mm_fault+0xc3\n        ffffffff90c74f6d __do_page_fault+0x1ed\n        ffffffff90c75277 do_page_fault+0x37\n        ffffffff9160111e page_fault+0x1e\n        ffffffff9109e7b5 copyin+0x25\n        ffffffff9109eb40 _copy_from_iter_full+0xe0\n        ffffffff91462370 tcp_sendmsg_locked+0x5e0\n        ffffffff91462370 tcp_sendmsg_locked+0x5e0\n        ffffffff91462b57 tcp_sendmsg+0x27\n        ffffffff9139815c sock_sendmsg+0x4c\n        ffffffff913981f7 sock_write_iter+0x97\n        ffffffff90f2cc56 do_iter_readv_writev+0x156\n        ffffffff90f2dff0 do_iter_write+0x80\n        ffffffff90f2e1c3 vfs_writev+0xa3\n        ffffffff90f2e27c do_writev+0x5c\n        ffffffff90c042bb do_syscall_64+0x5b\n        ffffffff916000ad entry_SYSCALL_64_after_hwframe+0x65\n\nThe cifs filesystem rightfully sets sk_allocations to GFP_NOFS,\nwe can avoid the nesting using the sk page frag for allocation\nlacking the __GFP_FS flag. Do not define an additional mm-helper\nfor that, as this is strictly tied to the sk page frag usage.\n\nv1 -> v2:\n - use a stricted sk_page_frag() check instead of reordering the\n   code (Eric)",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c6f340a331fb72e5ac23a083de9c780e132ca3ae",
      "https://git.kernel.org/stable/c/5a9afcd827cafe14a95c9fcbded2c2d104f18dfc",
      "https://git.kernel.org/stable/c/dacb5d8875cc6cd3a553363b4d6f06760fcbe70c"
    ],
    "受影响版本": [
      "5640f7685831e088fe6c2e1f863a6805962f8e81",
      "5640f7685831e088fe6c2e1f863a6805962f8e81",
      "5640f7685831e088fe6c2e1f863a6805962f8e81"
    ],
    "公开日期": "2024年05月24日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47536",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/smc: fix wrong list_del in smc_lgr_cleanup_early\n\nsmc_lgr_cleanup_early() meant to delete the link\ngroup from the link group list, but it deleted\nthe list head by mistake.\n\nThis may cause memory corruption since we didn't\nremove the real link group from the list and later\nmemseted the link group structure.\nWe got a list corruption panic when testing:\n\n[  231.277259] list_del corruption. prev->next should be ffff8881398a8000, but was 0000000000000000\n[  231.278222] ------------[ cut here ]------------\n[  231.278726] kernel BUG at lib/list_debug.c:53!\n[  231.279326] invalid opcode: 0000 [#1] SMP NOPTI\n[  231.279803] CPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.10.46+ #435\n[  231.280466] Hardware name: Alibaba Cloud ECS, BIOS 8c24b4c 04/01/2014\n[  231.281248] Workqueue: events smc_link_down_work\n[  231.281732] RIP: 0010:__list_del_entry_valid+0x70/0x90\n[  231.282258] Code: 4c 60 82 e8 7d cc 6a 00 0f 0b 48 89 fe 48 c7 c7 88 4c\n60 82 e8 6c cc 6a 00 0f 0b 48 89 fe 48 c7 c7 c0 4c 60 82 e8 5b cc 6a 00 <0f>\n0b 48 89 fe 48 c7 c7 00 4d 60 82 e8 4a cc 6a 00 0f 0b cc cc cc\n[  231.284146] RSP: 0018:ffffc90000033d58 EFLAGS: 00010292\n[  231.284685] RAX: 0000000000000054 RBX: ffff8881398a8000 RCX: 0000000000000000\n[  231.285415] RDX: 0000000000000001 RSI: ffff88813bc18040 RDI: ffff88813bc18040\n[  231.286141] RBP: ffffffff8305ad40 R08: 0000000000000003 R09: 0000000000000001\n[  231.286873] R10: ffffffff82803da0 R11: ffffc90000033b90 R12: 0000000000000001\n[  231.287606] R13: 0000000000000000 R14: ffff8881398a8000 R15: 0000000000000003\n[  231.288337] FS:  0000000000000000(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000\n[  231.289160] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  231.289754] CR2: 0000000000e72058 CR3: 000000010fa96006 CR4: 00000000003706f0\n[  231.290485] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  231.291211] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  231.291940] Call Trace:\n[  231.292211]  smc_lgr_terminate_sched+0x53/0xa0\n[  231.292677]  smc_switch_conns+0x75/0x6b0\n[  231.293085]  ? update_load_avg+0x1a6/0x590\n[  231.293517]  ? ttwu_do_wakeup+0x17/0x150\n[  231.293907]  ? update_load_avg+0x1a6/0x590\n[  231.294317]  ? newidle_balance+0xca/0x3d0\n[  231.294716]  smcr_link_down+0x50/0x1a0\n[  231.295090]  ? __wake_up_common_lock+0x77/0x90\n[  231.295534]  smc_link_down_work+0x46/0x60\n[  231.295933]  process_one_work+0x18b/0x350",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/77731fede297a23d26f2d169b4269466b2c82529",
      "https://git.kernel.org/stable/c/95518fe354d712dca6f431cf2a11b8f63bc9a66c",
      "https://git.kernel.org/stable/c/789b6cc2a5f9123b9c549b886fdc47c865cfe0ba"
    ],
    "受影响版本": [
      "a0a62ee15a829ebf8aeec55a4f1688230439b3e0",
      "a0a62ee15a829ebf8aeec55a4f1688230439b3e0",
      "a0a62ee15a829ebf8aeec55a4f1688230439b3e0"
    ],
    "公开日期": "2024年05月24日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47531",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/msm: Fix mmap to include VM_IO and VM_DONTDUMP\n\nIn commit 510410bfc034 (\"drm/msm: Implement mmap as GEM object\nfunction\") we switched to a new/cleaner method of doing things. That's\ngood, but we missed a little bit.\n\nBefore that commit, we used to _first_ run through the\ndrm_gem_mmap_obj() case where `obj->funcs->mmap()` was NULL. That meant\nthat we ran:\n\n  vma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\n  vma->vm_page_prot = pgprot_writecombine(vm_get_page_prot(vma->vm_flags));\n  vma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);\n\n...and _then_ we modified those mappings with our own. Now that\n`obj->funcs->mmap()` is no longer NULL we don't run the default\ncode. It looks like the fact that the vm_flags got VM_IO / VM_DONTDUMP\nwas important because we're now getting crashes on Chromebooks that\nuse ARC++ while logging out. Specifically a crash that looks like this\n(this is on a 5.10 kernel w/ relevant backports but also seen on a\n5.15 kernel):\n\n  Unable to handle kernel paging request at virtual address ffffffc008000000\n  Mem abort info:\n    ESR = 0x96000006\n    EC = 0x25: DABT (current EL), IL = 32 bits\n    SET = 0, FnV = 0\n    EA = 0, S1PTW = 0\n  Data abort info:\n    ISV = 0, ISS = 0x00000006\n    CM = 0, WnR = 0\n  swapper pgtable: 4k pages, 39-bit VAs, pgdp=000000008293d000\n  [ffffffc008000000] pgd=00000001002b3003, p4d=00000001002b3003,\n                     pud=00000001002b3003, pmd=0000000000000000\n  Internal error: Oops: 96000006 [#1] PREEMPT SMP\n  [...]\n  CPU: 7 PID: 15734 Comm: crash_dump64 Tainted: G W 5.10.67 #1 [...]\n  Hardware name: Qualcomm Technologies, Inc. sc7280 IDP SKU2 platform (DT)\n  pstate: 80400009 (Nzcv daif +PAN -UAO -TCO BTYPE=--)\n  pc : __arch_copy_to_user+0xc0/0x30c\n  lr : copyout+0xac/0x14c\n  [...]\n  Call trace:\n   __arch_copy_to_user+0xc0/0x30c\n   copy_page_to_iter+0x1a0/0x294\n   process_vm_rw_core+0x240/0x408\n   process_vm_rw+0x110/0x16c\n   __arm64_sys_process_vm_readv+0x30/0x3c\n   el0_svc_common+0xf8/0x250\n   do_el0_svc+0x30/0x80\n   el0_svc+0x10/0x1c\n   el0_sync_handler+0x78/0x108\n   el0_sync+0x184/0x1c0\n  Code: f8408423 f80008c3 910020c6 36100082 (b8404423)\n\nLet's add the two flags back in.\n\nWhile we're at it, the fact that we aren't running the default means\nthat we _don't_ need to clear out VM_PFNMAP, so remove that and save\nan instruction.\n\nNOTE: it was confirmed that VM_IO was the important flag to fix the\nproblem I was seeing, but adding back VM_DONTDUMP seems like a sane\nthing to do so I'm doing that too.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/8e2b7fe5e8a4be5e571561d9afcfbd92097288ba",
      "https://git.kernel.org/stable/c/3466d9e217b337bf473ee629c608e53f9f3ab786"
    ],
    "受影响版本": [
      "510410bfc034c57cc3caf1572aa47c1017bab2f9",
      "510410bfc034c57cc3caf1572aa47c1017bab2f9"
    ],
    "公开日期": "2024年05月24日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47510",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix re-dirty process of tree-log nodes\n\nThere is a report of a transaction abort of -EAGAIN with the following\nscript.\n\n  #!/bin/sh\n\n  for d in sda sdb; do\n          mkfs.btrfs -d single -m single -f /dev/\\${d}\n  done\n\n  mount /dev/sda /mnt/test\n  mount /dev/sdb /mnt/scratch\n\n  for dir in test scratch; do\n          echo 3 >/proc/sys/vm/drop_caches\n          fio --directory=/mnt/\\${dir} --name=fio.\\${dir} --rw=read --size=50G --bs=64m \\\n                  --numjobs=$(nproc) --time_based --ramp_time=5 --runtime=480 \\\n                  --group_reporting |& tee /dev/shm/fio.\\${dir}\n          echo 3 >/proc/sys/vm/drop_caches\n  done\n\n  for d in sda sdb; do\n          umount /dev/\\${d}\n  done\n\nThe stack trace is shown in below.\n\n  [3310.967991] BTRFS: error (device sda) in btrfs_commit_transaction:2341: errno=-11 unknown (Error while writing out transaction)\n  [3310.968060] BTRFS info (device sda): forced readonly\n  [3310.968064] BTRFS warning (device sda): Skipping commit of aborted transaction.\n  [3310.968065] ------------[ cut here ]------------\n  [3310.968066] BTRFS: Transaction aborted (error -11)\n  [3310.968074] WARNING: CPU: 14 PID: 1684 at fs/btrfs/transaction.c:1946 btrfs_commit_transaction.cold+0x209/0x2c8\n  [3310.968131] CPU: 14 PID: 1684 Comm: fio Not tainted 5.14.10-300.fc35.x86_64 #1\n  [3310.968135] Hardware name: DIAWAY Tartu/Tartu, BIOS V2.01.B10 04/08/2021\n  [3310.968137] RIP: 0010:btrfs_commit_transaction.cold+0x209/0x2c8\n  [3310.968144] RSP: 0018:ffffb284ce393e10 EFLAGS: 00010282\n  [3310.968147] RAX: 0000000000000026 RBX: ffff973f147b0f60 RCX: 0000000000000027\n  [3310.968149] RDX: ffff974ecf098a08 RSI: 0000000000000001 RDI: ffff974ecf098a00\n  [3310.968150] RBP: ffff973f147b0f08 R08: 0000000000000000 R09: ffffb284ce393c48\n  [3310.968151] R10: ffffb284ce393c40 R11: ffffffff84f47468 R12: ffff973f101bfc00\n  [3310.968153] R13: ffff971f20cf2000 R14: 00000000fffffff5 R15: ffff973f147b0e58\n  [3310.968154] FS:  00007efe65468740(0000) GS:ffff974ecf080000(0000) knlGS:0000000000000000\n  [3310.968157] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [3310.968158] CR2: 000055691bcbe260 CR3: 000000105cfa4001 CR4: 0000000000770ee0\n  [3310.968160] PKRU: 55555554\n  [3310.968161] Call Trace:\n  [3310.968167]  ? dput+0xd4/0x300\n  [3310.968174]  btrfs_sync_file+0x3f1/0x490\n  [3310.968180]  __x64_sys_fsync+0x33/0x60\n  [3310.968185]  do_syscall_64+0x3b/0x90\n  [3310.968190]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n  [3310.968194] RIP: 0033:0x7efe6557329b\n  [3310.968200] RSP: 002b:00007ffe0236ebc0 EFLAGS: 00000293 ORIG_RAX: 000000000000004a\n  [3310.968203] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007efe6557329b\n  [3310.968204] RDX: 0000000000000000 RSI: 00007efe58d77010 RDI: 0000000000000006\n  [3310.968205] RBP: 0000000004000000 R08: 0000000000000000 R09: 00007efe58d77010\n  [3310.968207] R10: 0000000016cacc0c R11: 0000000000000293 R12: 00007efe5ce95980\n  [3310.968208] R13: 0000000000000000 R14: 00007efe6447c790 R15: 0000000c80000000\n  [3310.968212] ---[ end trace 1a346f4d3c0d96ba ]---\n  [3310.968214] BTRFS: error (device sda) in cleanup_transaction:1946: errno=-11 unknown\n\nThe abort occurs because of a write hole while writing out freeing tree\nnodes of a tree-log tree. For zoned btrfs, we re-dirty a freed tree\nnode to ensure btrfs can write the region and does not leave a hole on\nwrite on a zoned device. The current code fails to re-dirty a node\nwhen the tree-log tree's depth is greater or equal to 2. That leads to\na transaction abort with -EAGAIN.\n\nFix the issue by properly re-dirtying a node on walking up the tree.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/477675049ca803aa95ff77468ffbddd966b415b0",
      "https://git.kernel.org/stable/c/84c25448929942edacba905cecc0474e91114e7a"
    ],
    "受影响版本": [
      "d3575156f6623eecf086a20bcf99a63f1598109c",
      "d3575156f6623eecf086a20bcf99a63f1598109c"
    ],
    "公开日期": "2024年05月24日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47492",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm, thp: bail out early in collapse_file for writeback page\n\nCurrently collapse_file does not explicitly check PG_writeback, instead,\npage_has_private and try_to_release_page are used to filter writeback\npages.  This does not work for xfs with blocksize equal to or larger\nthan pagesize, because in such case xfs has no page->private.\n\nThis makes collapse_file bail out early for writeback page.  Otherwise,\nxfs end_page_writeback will panic as follows.\n\n  page:fffffe00201bcc80 refcount:0 mapcount:0 mapping:ffff0003f88c86a8 index:0x0 pfn:0x84ef32\n  aops:xfs_address_space_operations [xfs] ino:30000b7 dentry name:\"libtest.so\"\n  flags: 0x57fffe0000008027(locked|referenced|uptodate|active|writeback)\n  raw: 57fffe0000008027 ffff80001b48bc28 ffff80001b48bc28 ffff0003f88c86a8\n  raw: 0000000000000000 0000000000000000 00000000ffffffff ffff0000c3e9a000\n  page dumped because: VM_BUG_ON_PAGE(((unsigned int) page_ref_count(page) + 127u <= 127u))\n  page->mem_cgroup:ffff0000c3e9a000\n  ------------[ cut here ]------------\n  kernel BUG at include/linux/mm.h:1212!\n  Internal error: Oops - BUG: 0 [#1] SMP\n  Modules linked in:\n  BUG: Bad page state in process khugepaged  pfn:84ef32\n   xfs(E)\n  page:fffffe00201bcc80 refcount:0 mapcount:0 mapping:0 index:0x0 pfn:0x84ef32\n   libcrc32c(E) rfkill(E) aes_ce_blk(E) crypto_simd(E) ...\n  CPU: 25 PID: 0 Comm: swapper/25 Kdump: loaded Tainted: ...\n  pstate: 60400005 (nZCv daif +PAN -UAO -TCO BTYPE=--)\n  Call trace:\n    end_page_writeback+0x1c0/0x214\n    iomap_finish_page_writeback+0x13c/0x204\n    iomap_finish_ioend+0xe8/0x19c\n    iomap_writepage_end_bio+0x38/0x50\n    bio_endio+0x168/0x1ec\n    blk_update_request+0x278/0x3f0\n    blk_mq_end_request+0x34/0x15c\n    virtblk_request_done+0x38/0x74 [virtio_blk]\n    blk_done_softirq+0xc4/0x110\n    __do_softirq+0x128/0x38c\n    __irq_exit_rcu+0x118/0x150\n    irq_exit+0x1c/0x30\n    __handle_domain_irq+0x8c/0xf0\n    gic_handle_irq+0x84/0x108\n    el1_irq+0xcc/0x180\n    arch_cpu_idle+0x18/0x40\n    default_idle_call+0x4c/0x1a0\n    cpuidle_idle_call+0x168/0x1e0\n    do_idle+0xb4/0x104\n    cpu_startup_entry+0x30/0x9c\n    secondary_start_kernel+0x104/0x180\n  Code: d4210000 b0006161 910c8021 94013f4d (d4210000)\n  ---[ end trace 4a88c6a074082f8c ]---\n  Kernel panic - not syncing: Oops - BUG: Fatal exception in interrupt",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/69a7fa5cb0de06c8956b040f19a7248c8c8308ca",
      "https://git.kernel.org/stable/c/5e669d8ab30ab61dec3c36e27b4711f07611e6fc",
      "https://git.kernel.org/stable/c/74c42e1baacf206338b1dd6b6199ac964512b5bb"
    ],
    "受影响版本": [
      "99cb0dbd47a15d395bf3faa78dc122bc5efe3fc0",
      "99cb0dbd47a15d395bf3faa78dc122bc5efe3fc0",
      "99cb0dbd47a15d395bf3faa78dc122bc5efe3fc0"
    ],
    "公开日期": "2024年05月22日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47458",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: mount fails with buffer overflow in strlen\n\nStarting with kernel 5.11 built with CONFIG_FORTIFY_SOURCE mouting an\nocfs2 filesystem with either o2cb or pcmk cluster stack fails with the\ntrace below.  Problem seems to be that strings for cluster stack and\ncluster name are not guaranteed to be null terminated in the disk\nrepresentation, while strlcpy assumes that the source string is always\nnull terminated.  This causes a read outside of the source string\ntriggering the buffer overflow detection.\n\n  detected buffer overflow in strlen\n  ------------[ cut here ]------------\n  kernel BUG at lib/string.c:1149!\n  invalid opcode: 0000 [#1] SMP PTI\n  CPU: 1 PID: 910 Comm: mount.ocfs2 Not tainted 5.14.0-1-amd64 #1\n    Debian 5.14.6-2\n  RIP: 0010:fortify_panic+0xf/0x11\n  ...\n  Call Trace:\n   ocfs2_initialize_super.isra.0.cold+0xc/0x18 [ocfs2]\n   ocfs2_fill_super+0x359/0x19b0 [ocfs2]\n   mount_bdev+0x185/0x1b0\n   legacy_get_tree+0x27/0x40\n   vfs_get_tree+0x25/0xb0\n   path_mount+0x454/0xa20\n   __x64_sys_mount+0x103/0x140\n   do_syscall_64+0x3b/0xc0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ac011cb3ff7a76b3e0e6e77158ee4ba2f929e1fb",
      "https://git.kernel.org/stable/c/4b74ddcc22ee6455946e80a9c4808801f8f8561e",
      "https://git.kernel.org/stable/c/232ed9752510de4436468b653d145565669c8498",
      "https://git.kernel.org/stable/c/7623b1035ca2d17bde0f6a086ad6844a34648df1",
      "https://git.kernel.org/stable/c/d3a83576378b4c904f711598dde2c5e881c4295c",
      "https://git.kernel.org/stable/c/93be0eeea14cf39235e585c8f56df3b3859deaad",
      "https://git.kernel.org/stable/c/0e677ea5b7396f715a76b6b0ef441430e4c4b57f",
      "https://git.kernel.org/stable/c/b15fa9224e6e1239414525d8d556d824701849fc"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年05月22日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47441",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: thermal: Fix out-of-bounds memory accesses\n\nCurrently, mlxsw allows cooling states to be set above the maximum\ncooling state supported by the driver:\n\n # cat /sys/class/thermal/thermal_zone2/cdev0/type\n mlxsw_fan\n # cat /sys/class/thermal/thermal_zone2/cdev0/max_state\n 10\n # echo 18 > /sys/class/thermal/thermal_zone2/cdev0/cur_state\n # echo $?\n 0\n\nThis results in out-of-bounds memory accesses when thermal state\ntransition statistics are enabled (CONFIG_THERMAL_STATISTICS=y), as the\ntransition table is accessed with a too large index (state) [1].\n\nAccording to the thermal maintainer, it is the responsibility of the\ndriver to reject such operations [2].\n\nTherefore, return an error when the state to be set exceeds the maximum\ncooling state supported by the driver.\n\nTo avoid dead code, as suggested by the thermal maintainer [3],\npartially revert commit a421ce088ac8 (\"mlxsw: core: Extend cooling\ndevice with cooling levels\") that tried to interpret these invalid\ncooling states (above the maximum) in a special way. The cooling levels\narray is not removed in order to prevent the fans going below 20% PWM,\nwhich would cause them to get stuck at 0% PWM.\n\n[1]\nBUG: KASAN: slab-out-of-bounds in thermal_cooling_device_stats_update+0x271/0x290\nRead of size 4 at addr ffff8881052f7bf8 by task kworker/0:0/5\n\nCPU: 0 PID: 5 Comm: kworker/0:0 Not tainted 5.15.0-rc3-custom-45935-gce1adf704b14 #122\nHardware name: Mellanox Technologies Ltd. \"MSN2410-CB2FO\"/\"SA000874\", BIOS 4.6.5 03/08/2016\nWorkqueue: events_freezable_power_ thermal_zone_device_check\nCall Trace:\n dump_stack_lvl+0x8b/0xb3\n print_address_description.constprop.0+0x1f/0x140\n kasan_report.cold+0x7f/0x11b\n thermal_cooling_device_stats_update+0x271/0x290\n __thermal_cdev_update+0x15e/0x4e0\n thermal_cdev_update+0x9f/0xe0\n step_wise_throttle+0x770/0xee0\n thermal_zone_device_update+0x3f6/0xdf0\n process_one_work+0xa42/0x1770\n worker_thread+0x62f/0x13e0\n kthread+0x3ee/0x4e0\n ret_from_fork+0x1f/0x30\n\nAllocated by task 1:\n kasan_save_stack+0x1b/0x40\n __kasan_kmalloc+0x7c/0x90\n thermal_cooling_device_setup_sysfs+0x153/0x2c0\n __thermal_cooling_device_register.part.0+0x25b/0x9c0\n thermal_cooling_device_register+0xb3/0x100\n mlxsw_thermal_init+0x5c5/0x7e0\n __mlxsw_core_bus_device_register+0xcb3/0x19c0\n mlxsw_core_bus_device_register+0x56/0xb0\n mlxsw_pci_probe+0x54f/0x710\n local_pci_probe+0xc6/0x170\n pci_device_probe+0x2b2/0x4d0\n really_probe+0x293/0xd10\n __driver_probe_device+0x2af/0x440\n driver_probe_device+0x51/0x1e0\n __driver_attach+0x21b/0x530\n bus_for_each_dev+0x14c/0x1d0\n bus_add_driver+0x3ac/0x650\n driver_register+0x241/0x3d0\n mlxsw_sp_module_init+0xa2/0x174\n do_one_initcall+0xee/0x5f0\n kernel_init_freeable+0x45a/0x4de\n kernel_init+0x1f/0x210\n ret_from_fork+0x1f/0x30\n\nThe buggy address belongs to the object at ffff8881052f7800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 1016 bytes inside of\n 1024-byte region [ffff8881052f7800, ffff8881052f7c00)\nThe buggy address belongs to the page:\npage:0000000052355272 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1052f0\nhead:0000000052355272 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0x200000000010200(slab|head|node=0|zone=2)\nraw: 0200000000010200 ffffea0005034800 0000000300000003 ffff888100041dc0\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff8881052f7a80: 00 00 00 00 00 00 04 fc fc fc fc fc fc fc fc fc\n ffff8881052f7b00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff8881052f7b80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                                                                ^\n ffff8881052f7c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff8881052f7c80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n\n[2] https://lore.kernel.org/linux-pm/9aca37cb-1629-5c67-\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ae0993739e14a102d506aa09e11b0065f3144f10",
      "https://git.kernel.org/stable/c/e59d839743b50cb1d3f42a786bea48cc5621d254",
      "https://git.kernel.org/stable/c/df8e58716afb3bee2b59de66b1ba1033f2e26303",
      "https://git.kernel.org/stable/c/332fdf951df8b870e3da86b122ae304e2aabe88c"
    ],
    "受影响版本": [
      "a50c1e35650b929500bd89be61c89d95a267ce56",
      "a50c1e35650b929500bd89be61c89d95a267ce56",
      "a50c1e35650b929500bd89be61c89d95a267ce56",
      "a50c1e35650b929500bd89be61c89d95a267ce56"
    ],
    "公开日期": "2024年05月22日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47430",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/entry: Clear X86_FEATURE_SMAP when CONFIG_X86_SMAP=n\n\nCommit\n\n  3c73b81a9164 (\"x86/entry, selftests: Further improve user entry sanity checks\")\n\nadded a warning if AC is set when in the kernel.\n\nCommit\n\n  662a0221893a3d (\"x86/entry: Fix AC assertion\")\n\nchanged the warning to only fire if the CPU supports SMAP.\n\nHowever, the warning can still trigger on a machine that supports SMAP\nbut where it's disabled in the kernel config and when running the\nsyscall_nt selftest, for example:\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 49 at irqentry_enter_from_user_mode\n  CPU: 0 PID: 49 Comm: init Tainted: G                T 5.15.0-rc4+ #98 e6202628ee053b4f310759978284bd8bb0ce6905\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n  RIP: 0010:irqentry_enter_from_user_mode\n  ...\n  Call Trace:\n   ? irqentry_enter\n   ? exc_general_protection\n   ? asm_exc_general_protection\n   ? asm_exc_general_protectio\n\nIS_ENABLED(CONFIG_X86_SMAP) could be added to the warning condition, but\neven this would not be enough in case SMAP is disabled at boot time with\nthe \"nosmap\" parameter.\n\nTo be consistent with \"nosmap\" behaviour, clear X86_FEATURE_SMAP when\n!CONFIG_X86_SMAP.\n\nFound using entry-fuzz + satrandconfig.\n\n [ bp: Massage commit message. ]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f2447f6587b8ffe42ba04d14ce67d429a1163e5e",
      "https://git.kernel.org/stable/c/4e9ec1c65da98c293f75d83755dfa5e03075a6d0",
      "https://git.kernel.org/stable/c/3958b9c34c2729597e182cc606cc43942fd19f7c"
    ],
    "受影响版本": [
      "3c73b81a9164d0c1b6379d6672d2772a9e95168e",
      "3c73b81a9164d0c1b6379d6672d2772a9e95168e",
      "3c73b81a9164d0c1b6379d6672d2772a9e95168e"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47428",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/64s: fix program check interrupt emergency stack path\n\nEmergency stack path was jumping into a 3: label inside the\n__GEN_COMMON_BODY macro for the normal path after it had finished,\nrather than jumping over it. By a small miracle this is the correct\nplace to build up a new interrupt frame with the existing stack\npointer, so things basically worked okay with an added weird looking\n700 trap frame on top (which had the wrong ->nip so it didn't decode\nbug messages either).\n\nFix this by avoiding using numeric labels when jumping over non-trivial\nmacros.\n\nBefore:\n\n LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA PowerNV\n Modules linked in:\n CPU: 0 PID: 88 Comm: sh Not tainted 5.15.0-rc2-00034-ge057cdade6e5 #2637\n NIP:  7265677368657265 LR: c00000000006c0c8 CTR: c0000000000097f0\n REGS: c0000000fffb3a50 TRAP: 0700   Not tainted\n MSR:  9000000000021031 <SF,HV,ME,IR,DR,LE>  CR: 00000700  XER: 20040000\n CFAR: c0000000000098b0 IRQMASK: 0\n GPR00: c00000000006c964 c0000000fffb3cf0 c000000001513800 0000000000000000\n GPR04: 0000000048ab0778 0000000042000000 0000000000000000 0000000000001299\n GPR08: 000001e447c718ec 0000000022424282 0000000000002710 c00000000006bee8\n GPR12: 9000000000009033 c0000000016b0000 00000000000000b0 0000000000000001\n GPR16: 0000000000000000 0000000000000002 0000000000000000 0000000000000ff8\n GPR20: 0000000000001fff 0000000000000007 0000000000000080 00007fff89d90158\n GPR24: 0000000002000000 0000000002000000 0000000000000255 0000000000000300\n GPR28: c000000001270000 0000000042000000 0000000048ab0778 c000000080647e80\n NIP [7265677368657265] 0x7265677368657265\n LR [c00000000006c0c8] ___do_page_fault+0x3f8/0xb10\n Call Trace:\n [c0000000fffb3cf0] [c00000000000bdac] soft_nmi_common+0x13c/0x1d0 (unreliable)\n --- interrupt: 700 at decrementer_common_virt+0xb8/0x230\n NIP:  c0000000000098b8 LR: c00000000006c0c8 CTR: c0000000000097f0\n REGS: c0000000fffb3d60 TRAP: 0700   Not tainted\n MSR:  9000000000021031 <SF,HV,ME,IR,DR,LE>  CR: 22424282  XER: 20040000\n CFAR: c0000000000098b0 IRQMASK: 0\n GPR00: c00000000006c964 0000000000002400 c000000001513800 0000000000000000\n GPR04: 0000000048ab0778 0000000042000000 0000000000000000 0000000000001299\n GPR08: 000001e447c718ec 0000000022424282 0000000000002710 c00000000006bee8\n GPR12: 9000000000009033 c0000000016b0000 00000000000000b0 0000000000000001\n GPR16: 0000000000000000 0000000000000002 0000000000000000 0000000000000ff8\n GPR20: 0000000000001fff 0000000000000007 0000000000000080 00007fff89d90158\n GPR24: 0000000002000000 0000000002000000 0000000000000255 0000000000000300\n GPR28: c000000001270000 0000000042000000 0000000048ab0778 c000000080647e80\n NIP [c0000000000098b8] decrementer_common_virt+0xb8/0x230\n LR [c00000000006c0c8] ___do_page_fault+0x3f8/0xb10\n --- interrupt: 700\n Instruction dump:\n XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX\n ---[ end trace 6d28218e0cc3c949 ]---\n\nAfter:\n\n ------------[ cut here ]------------\n kernel BUG at arch/powerpc/kernel/exceptions-64s.S:491!\n Oops: Exception in kernel mode, sig: 5 [#1]\n LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA PowerNV\n Modules linked in:\n CPU: 0 PID: 88 Comm: login Not tainted 5.15.0-rc2-00034-ge057cdade6e5-dirty #2638\n NIP:  c0000000000098b8 LR: c00000000006bf04 CTR: c0000000000097f0\n REGS: c0000000fffb3d60 TRAP: 0700   Not tainted\n MSR:  9000000000021031 <SF,HV,ME,IR,DR,LE>  CR: 24482227  XER: 00040000\n CFAR: c0000000000098b0 IRQMASK: 0\n GPR00: c00000000006bf04 0000000000002400 c000000001513800 c000000001271868\n GPR04: 00000000100f0d29 0000000042000000 0000000000000007 0000000000000009\n GPR08: 00000000100f0d29 0000000024482227 0000000000002710 c000000000181b3c\n GPR12: 9000000000009033 c0000000016b0000 00000000100f0d29 c000000005b22f00\n GPR16: 00000000ffff0000 0000000000000001 0000000000000009 00000000100eed90\n GPR20: 00000000100eed90 00000\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/411b38fe68ba20a8bbe724b0939762c3f16e16ca",
      "https://git.kernel.org/stable/c/c835b3d1d6362b4a4ebb192da7e7fd27a0a45d01",
      "https://git.kernel.org/stable/c/3e607dc4df180b72a38e75030cb0f94d12808712"
    ],
    "受影响版本": [
      "0a882e28468f48ab3d9a36dde0a5723ea29ed1ed",
      "0a882e28468f48ab3d9a36dde0a5723ea29ed1ed",
      "0a882e28468f48ab3d9a36dde0a5723ea29ed1ed"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47419",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: sch_taprio: properly cancel timer from taprio_destroy()\n\nThere is a comment in qdisc_create() about us not calling ops->reset()\nin some cases.\n\nerr_out4:\n\t/*\n\t * Any broken qdiscs that would require a ops->reset() here?\n\t * The qdisc was never in action so it shouldn't be necessary.\n\t */\n\nAs taprio sets a timer before actually receiving a packet, we need\nto cancel it from ops->destroy, just in case ops->reset has not\nbeen called.\n\nsyzbot reported:\n\nODEBUG: free active (active state 0) object type: hrtimer hint: advance_sched+0x0/0x9a0 arch/x86/include/asm/atomic64_64.h:22\nWARNING: CPU: 0 PID: 8441 at lib/debugobjects.c:505 debug_print_object+0x16e/0x250 lib/debugobjects.c:505\nModules linked in:\nCPU: 0 PID: 8441 Comm: syz-executor813 Not tainted 5.14.0-rc6-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:debug_print_object+0x16e/0x250 lib/debugobjects.c:505\nCode: ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 af 00 00 00 48 8b 14 dd e0 d3 e3 89 4c 89 ee 48 c7 c7 e0 c7 e3 89 e8 5b 86 11 05 <0f> 0b 83 05 85 03 92 09 01 48 83 c4 18 5b 5d 41 5c 41 5d 41 5e c3\nRSP: 0018:ffffc9000130f330 EFLAGS: 00010282\nRAX: 0000000000000000 RBX: 0000000000000003 RCX: 0000000000000000\nRDX: ffff88802baeb880 RSI: ffffffff815d87b5 RDI: fffff52000261e58\nRBP: 0000000000000001 R08: 0000000000000000 R09: 0000000000000000\nR10: ffffffff815d25ee R11: 0000000000000000 R12: ffffffff898dd020\nR13: ffffffff89e3ce20 R14: ffffffff81653630 R15: dffffc0000000000\nFS:  0000000000f0d300(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffb64b3e000 CR3: 0000000036557000 CR4: 00000000001506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n __debug_check_no_obj_freed lib/debugobjects.c:987 [inline]\n debug_check_no_obj_freed+0x301/0x420 lib/debugobjects.c:1018\n slab_free_hook mm/slub.c:1603 [inline]\n slab_free_freelist_hook+0x171/0x240 mm/slub.c:1653\n slab_free mm/slub.c:3213 [inline]\n kfree+0xe4/0x540 mm/slub.c:4267\n qdisc_create+0xbcf/0x1320 net/sched/sch_api.c:1299\n tc_modify_qdisc+0x4c8/0x1a60 net/sched/sch_api.c:1663\n rtnetlink_rcv_msg+0x413/0xb80 net/core/rtnetlink.c:5571\n netlink_rcv_skb+0x153/0x420 net/netlink/af_netlink.c:2504\n netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]\n netlink_unicast+0x533/0x7d0 net/netlink/af_netlink.c:1340\n netlink_sendmsg+0x86d/0xdb0 net/netlink/af_netlink.c:1929\n sock_sendmsg_nosec net/socket.c:704 [inline]\n sock_sendmsg+0xcf/0x120 net/socket.c:724\n ____sys_sendmsg+0x6e8/0x810 net/socket.c:2403\n ___sys_sendmsg+0xf3/0x170 net/socket.c:2457\n __sys_sendmsg+0xe5/0x1b0 net/socket.c:2486\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c951c08a5996365aecbc5f1a9bddec3905e1ddfc",
      "https://git.kernel.org/stable/c/3ec73ffeef54596c32aff0e73fe60971b9c8b866",
      "https://git.kernel.org/stable/c/7a1c1af341041221b3acb9d7036cc2b43e0efa75",
      "https://git.kernel.org/stable/c/a56d447f196fa9973c568f54c0d76d5391c3b0c0"
    ],
    "受影响版本": [
      "c71c512f4a65267e6a18163f4df729c489a51035",
      "a969a632cbe7165d448a5528806ad120c2599397",
      "44d4775ca51805b376a8db5b34f650434a08e556",
      "44d4775ca51805b376a8db5b34f650434a08e556"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47406",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: add error checking to ext4_ext_replay_set_iblocks()\n\nIf the call to ext4_map_blocks() fails due to an corrupted file\nsystem, ext4_ext_replay_set_iblocks() can get stuck in an infinite\nloop.  This could be reproduced by running generic/526 with a file\nsystem that has inline_data and fast_commit enabled.  The system will\nrepeatedly log to the console:\n\nEXT4-fs warning (device dm-3): ext4_block_to_path:105: block 1074800922 > max in inode 131076\n\nand the stack that it gets stuck in is:\n\n   ext4_block_to_path+0xe3/0x130\n   ext4_ind_map_blocks+0x93/0x690\n   ext4_map_blocks+0x100/0x660\n   skip_hole+0x47/0x70\n   ext4_ext_replay_set_iblocks+0x223/0x440\n   ext4_fc_replay_inode+0x29e/0x3b0\n   ext4_fc_replay+0x278/0x550\n   do_one_pass+0x646/0xc10\n   jbd2_journal_recover+0x14a/0x270\n   jbd2_journal_load+0xc4/0x150\n   ext4_load_journal+0x1f3/0x490\n   ext4_fill_super+0x22d4/0x2c00\n\nWith this patch, generic/526 still fails, but system is no longer\nlocking up in a tight loop.  It's likely the root casue is that\nfast_commit replay is corrupting file systems with inline_data, and we\nprobably need to add better error handling in the fast commit replay\ncode path beyond what is done here, which essentially just breaks the\ninfinite loop without reporting the to the higher levels of the code.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a63474dbf692dd09b50fed592bc41f6de5f102fc",
      "https://git.kernel.org/stable/c/27e10c5d31ff1d222c7f797f1ee96d422859ba67",
      "https://git.kernel.org/stable/c/1fd95c05d8f742abfe906620780aee4dbe1a2db0"
    ],
    "受影响版本": [
      "8016e29f4362e285f0f7e38fadc61a5b7bdfdfa2",
      "8016e29f4362e285f0f7e38fadc61a5b7bdfdfa2",
      "8016e29f4362e285f0f7e38fadc61a5b7bdfdfa2"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47400",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hns3: do not allow call hns3_nic_net_open repeatedly\n\nhns3_nic_net_open() is not allowed to called repeatly, but there\nis no checking for this. When doing device reset and setup tc\nconcurrently, there is a small oppotunity to call hns3_nic_net_open\nrepeatedly, and cause kernel bug by calling napi_enable twice.\n\nThe calltrace information is like below:\n[ 3078.222780] ------------[ cut here ]------------\n[ 3078.230255] kernel BUG at net/core/dev.c:6991!\n[ 3078.236224] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP\n[ 3078.243431] Modules linked in: hns3 hclgevf hclge hnae3 vfio_iommu_type1 vfio_pci vfio_virqfd vfio pv680_mii(O)\n[ 3078.258880] CPU: 0 PID: 295 Comm: kworker/u8:5 Tainted: G           O      5.14.0-rc4+ #1\n[ 3078.269102] Hardware name:  , BIOS KpxxxFPGA 1P B600 V181 08/12/2021\n[ 3078.276801] Workqueue: hclge hclge_service_task [hclge]\n[ 3078.288774] pstate: 60400009 (nZCv daif +PAN -UAO -TCO BTYPE=--)\n[ 3078.296168] pc : napi_enable+0x80/0x84\ntc qdisc sho[w  3d0e7v8 .e3t0h218 79] lr : hns3_nic_net_open+0x138/0x510 [hns3]\n\n[ 3078.314771] sp : ffff8000108abb20\n[ 3078.319099] x29: ffff8000108abb20 x28: 0000000000000000 x27: ffff0820a8490300\n[ 3078.329121] x26: 0000000000000001 x25: ffff08209cfc6200 x24: 0000000000000000\n[ 3078.339044] x23: ffff0820a8490300 x22: ffff08209cd76000 x21: ffff0820abfe3880\n[ 3078.349018] x20: 0000000000000000 x19: ffff08209cd76900 x18: 0000000000000000\n[ 3078.358620] x17: 0000000000000000 x16: ffffc816e1727a50 x15: 0000ffff8f4ff930\n[ 3078.368895] x14: 0000000000000000 x13: 0000000000000000 x12: 0000259e9dbeb6b4\n[ 3078.377987] x11: 0096a8f7e764eb40 x10: 634615ad28d3eab5 x9 : ffffc816ad8885b8\n[ 3078.387091] x8 : ffff08209cfc6fb8 x7 : ffff0820ac0da058 x6 : ffff0820a8490344\n[ 3078.396356] x5 : 0000000000000140 x4 : 0000000000000003 x3 : ffff08209cd76938\n[ 3078.405365] x2 : 0000000000000000 x1 : 0000000000000010 x0 : ffff0820abfe38a0\n[ 3078.414657] Call trace:\n[ 3078.418517]  napi_enable+0x80/0x84\n[ 3078.424626]  hns3_reset_notify_up_enet+0x78/0xd0 [hns3]\n[ 3078.433469]  hns3_reset_notify+0x64/0x80 [hns3]\n[ 3078.441430]  hclge_notify_client+0x68/0xb0 [hclge]\n[ 3078.450511]  hclge_reset_rebuild+0x524/0x884 [hclge]\n[ 3078.458879]  hclge_reset_service_task+0x3c4/0x680 [hclge]\n[ 3078.467470]  hclge_service_task+0xb0/0xb54 [hclge]\n[ 3078.475675]  process_one_work+0x1dc/0x48c\n[ 3078.481888]  worker_thread+0x15c/0x464\n[ 3078.487104]  kthread+0x160/0x170\n[ 3078.492479]  ret_from_fork+0x10/0x18\n[ 3078.498785] Code: c8027c81 35ffffa2 d50323bf d65f03c0 (d4210000)\n[ 3078.506889] ---[ end trace 8ebe0340a1b0fb44 ]---\n\nOnce hns3_nic_net_open() is excute success, the flag\nHNS3_NIC_STATE_DOWN will be cleared. So add checking for this\nflag, directly return when HNS3_NIC_STATE_DOWN is no set.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5a31d4e73ada8022427b69b10fd1f01a6a8d4b3d",
      "https://git.kernel.org/stable/c/f8ba689cb69523144d10606096ef686002dd7285",
      "https://git.kernel.org/stable/c/3dac38bdce7932901b9f0b71c62331852c809e61",
      "https://git.kernel.org/stable/c/5b09e88e1bf7fe86540fab4b5f3eece8abead39e"
    ],
    "受影响版本": [
      "e888402789b9db5de4fcda361331d66dbf0cd9fd",
      "e888402789b9db5de4fcda361331d66dbf0cd9fd",
      "e888402789b9db5de4fcda361331d66dbf0cd9fd",
      "e888402789b9db5de4fcda361331d66dbf0cd9fd"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47399",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nixgbe: Fix NULL pointer dereference in ixgbe_xdp_setup\n\nThe ixgbe driver currently generates a NULL pointer dereference with\nsome machine (online cpus < 63). This is due to the fact that the\nmaximum value of num_xdp_queues is nr_cpu_ids. Code is in\n\"ixgbe_set_rss_queues\"\".\n\nHere's how the problem repeats itself:\nSome machine (online cpus < 63), And user set num_queues to 63 through\nethtool. Code is in the \"ixgbe_set_channels\",\n\tadapter->ring_feature[RING_F_FDIR].limit = count;\n\nIt becomes 63.\n\nWhen user use xdp, \"ixgbe_set_rss_queues\" will set queues num.\n\tadapter->num_rx_queues = rss_i;\n\tadapter->num_tx_queues = rss_i;\n\tadapter->num_xdp_queues = ixgbe_xdp_queues(adapter);\n\nAnd rss_i's value is from\n\tf = &adapter->ring_feature[RING_F_FDIR];\n\trss_i = f->indices = f->limit;\n\nSo \"num_rx_queues\" > \"num_xdp_queues\", when run to \"ixgbe_xdp_setup\",\n\tfor (i = 0; i < adapter->num_rx_queues; i++)\n\t\tif (adapter->xdp_ring[i]->xsk_umem)\n\nIt leads to panic.\n\nCall trace:\n[exception RIP: ixgbe_xdp+368]\nRIP: ffffffffc02a76a0  RSP: ffff9fe16202f8d0  RFLAGS: 00010297\nRAX: 0000000000000000  RBX: 0000000000000020  RCX: 0000000000000000\nRDX: 0000000000000000  RSI: 000000000000001c  RDI: ffffffffa94ead90\nRBP: ffff92f8f24c0c18   R8: 0000000000000000   R9: 0000000000000000\nR10: ffff9fe16202f830  R11: 0000000000000000  R12: ffff92f8f24c0000\nR13: ffff9fe16202fc01  R14: 000000000000000a  R15: ffffffffc02a7530\nORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n 7 [ffff9fe16202f8f0] dev_xdp_install at ffffffffa89fbbcc\n 8 [ffff9fe16202f920] dev_change_xdp_fd at ffffffffa8a08808\n 9 [ffff9fe16202f960] do_setlink at ffffffffa8a20235\n10 [ffff9fe16202fa88] rtnl_setlink at ffffffffa8a20384\n11 [ffff9fe16202fc78] rtnetlink_rcv_msg at ffffffffa8a1a8dd\n12 [ffff9fe16202fcf0] netlink_rcv_skb at ffffffffa8a717eb\n13 [ffff9fe16202fd40] netlink_unicast at ffffffffa8a70f88\n14 [ffff9fe16202fd80] netlink_sendmsg at ffffffffa8a71319\n15 [ffff9fe16202fdf0] sock_sendmsg at ffffffffa89df290\n16 [ffff9fe16202fe08] __sys_sendto at ffffffffa89e19c8\n17 [ffff9fe16202ff30] __x64_sys_sendto at ffffffffa89e1a64\n18 [ffff9fe16202ff38] do_syscall_64 at ffffffffa84042b9\n19 [ffff9fe16202ff50] entry_SYSCALL_64_after_hwframe at ffffffffa8c0008c\n\nSo I fix ixgbe_max_channels so that it will not allow a setting of queues\nto be higher than the num_online_cpus(). And when run to ixgbe_xdp_setup,\ntake the smaller value of num_rx_queues and num_xdp_queues.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/20f6c4a31a525edd9ea6243712b868ba0e4e331e",
      "https://git.kernel.org/stable/c/2744341dd52e935344ca1b4bf189ba0d182a3e8e",
      "https://git.kernel.org/stable/c/513e605d7a9ce136886cb42ebb2c40e9a6eb6333"
    ],
    "受影响版本": [
      "4a9b32f30f805ca596d76605903a48eab58e0b88",
      "4a9b32f30f805ca596d76605903a48eab58e0b88",
      "4a9b32f30f805ca596d76605903a48eab58e0b88"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47396",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211-hwsim: fix late beacon hrtimer handling\n\nThomas explained in https://lore.kernel.org/r/87mtoeb4hb.ffs@tglx\nthat our handling of the hrtimer here is wrong: If the timer fires\nlate (e.g. due to vCPU scheduling, as reported by Dmitry/syzbot)\nthen it tries to actually rearm the timer at the next deadline,\nwhich might be in the past already:\n\n 1          2          3          N          N+1\n |          |          |   ...    |          |\n\n ^ intended to fire here (1)\n            ^ next deadline here (2)\n                                      ^ actually fired here\n\nThe next time it fires, it's later, but will still try to schedule\nfor the next deadline (now 3), etc. until it catches up with N,\nbut that might take a long time, causing stalls etc.\n\nNow, all of this is simulation, so we just have to fix it, but\nnote that the behaviour is wrong even per spec, since there's no\nvalue then in sending all those beacons unaligned - they should be\naligned to the TBTT (1, 2, 3, ... in the picture), and if we're a\nbit (or a lot) late, then just resume at that point.\n\nTherefore, change the code to use hrtimer_forward_now() which will\nensure that the next firing of the timer would be at N+1 (in the\npicture), i.e. the next interval point after the current time.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/9bee85de2c8155388c09a2e1530a243ec1c96f05",
      "https://git.kernel.org/stable/c/2c204cf594df3b9468368dc9d0b24d482d93cda7",
      "https://git.kernel.org/stable/c/ed2adf69e29848d1eb9df99633dde655421c92ed",
      "https://git.kernel.org/stable/c/313bbd1990b6ddfdaa7da098d0c56b098a833572"
    ],
    "受影响版本": [
      "01e59e467ecf976c782eecd4dc99644802cc60e2",
      "01e59e467ecf976c782eecd4dc99644802cc60e2",
      "01e59e467ecf976c782eecd4dc99644802cc60e2",
      "01e59e467ecf976c782eecd4dc99644802cc60e2"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47393",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (mlxreg-fan) Return non-zero value when fan current state is enforced from sysfs\n\nFan speed minimum can be enforced from sysfs. For example, setting\ncurrent fan speed to 20 is used to enforce fan speed to be at 100%\nspeed, 19 - to be not below 90% speed, etcetera. This feature provides\nability to limit fan speed according to some system wise\nconsiderations, like absence of some replaceable units or high system\nambient temperature.\n\nRequest for changing fan minimum speed is configuration request and can\nbe set only through 'sysfs' write procedure. In this situation value of\nargument 'state' is above nominal fan speed maximum.\n\nReturn non-zero code in this case to avoid\nthermal_cooling_device_stats_update() call, because in this case\nstatistics update violates thermal statistics table range.\nThe issues is observed in case kernel is configured with option\nCONFIG_THERMAL_STATISTICS.\n\nHere is the trace from KASAN:\n[  159.506659] BUG: KASAN: slab-out-of-bounds in thermal_cooling_device_stats_update+0x7d/0xb0\n[  159.516016] Read of size 4 at addr ffff888116163840 by task hw-management.s/7444\n[  159.545625] Call Trace:\n[  159.548366]  dump_stack+0x92/0xc1\n[  159.552084]  ? thermal_cooling_device_stats_update+0x7d/0xb0\n[  159.635869]  thermal_zone_device_update+0x345/0x780\n[  159.688711]  thermal_zone_device_set_mode+0x7d/0xc0\n[  159.694174]  mlxsw_thermal_modules_init+0x48f/0x590 [mlxsw_core]\n[  159.700972]  ? mlxsw_thermal_set_cur_state+0x5a0/0x5a0 [mlxsw_core]\n[  159.731827]  mlxsw_thermal_init+0x763/0x880 [mlxsw_core]\n[  160.070233] RIP: 0033:0x7fd995909970\n[  160.074239] Code: 73 01 c3 48 8b 0d 28 d5 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 99 2d 2c 00 00 75 10 b8 01 00 00 00 0f 05 <48> 3d 01 f0 ff ..\n[  160.095242] RSP: 002b:00007fff54f5d938 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[  160.103722] RAX: ffffffffffffffda RBX: 0000000000000013 RCX: 00007fd995909970\n[  160.111710] RDX: 0000000000000013 RSI: 0000000001906008 RDI: 0000000000000001\n[  160.119699] RBP: 0000000001906008 R08: 00007fd995bc9760 R09: 00007fd996210700\n[  160.127687] R10: 0000000000000073 R11: 0000000000000246 R12: 0000000000000013\n[  160.135673] R13: 0000000000000001 R14: 00007fd995bc8600 R15: 0000000000000013\n[  160.143671]\n[  160.145338] Allocated by task 2924:\n[  160.149242]  kasan_save_stack+0x19/0x40\n[  160.153541]  __kasan_kmalloc+0x7f/0xa0\n[  160.157743]  __kmalloc+0x1a2/0x2b0\n[  160.161552]  thermal_cooling_device_setup_sysfs+0xf9/0x1a0\n[  160.167687]  __thermal_cooling_device_register+0x1b5/0x500\n[  160.173833]  devm_thermal_of_cooling_device_register+0x60/0xa0\n[  160.180356]  mlxreg_fan_probe+0x474/0x5e0 [mlxreg_fan]\n[  160.248140]\n[  160.249807] The buggy address belongs to the object at ffff888116163400\n[  160.249807]  which belongs to the cache kmalloc-1k of size 1024\n[  160.263814] The buggy address is located 64 bytes to the right of\n[  160.263814]  1024-byte region [ffff888116163400, ffff888116163800)\n[  160.277536] The buggy address belongs to the page:\n[  160.282898] page:0000000012275840 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888116167000 pfn:0x116160\n[  160.294872] head:0000000012275840 order:3 compound_mapcount:0 compound_pincount:0\n[  160.303251] flags: 0x200000000010200(slab|head|node=0|zone=2)\n[  160.309694] raw: 0200000000010200 ffffea00046f7208 ffffea0004928208 ffff88810004dbc0\n[  160.318367] raw: ffff888116167000 00000000000a0006 00000001ffffffff 0000000000000000\n[  160.327033] page dumped because: kasan: bad access detected\n[  160.333270]\n[  160.334937] Memory state around the buggy address:\n[  160.356469] >ffff888116163800: fc ..",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5c6e0bce647d9cb32a17d58ffa669b3421fcc6ca",
      "https://git.kernel.org/stable/c/a6c42ae1530f94724d3c42cf91fe3d3c5e394f8a",
      "https://git.kernel.org/stable/c/76bbb482d33bfcd7e9070ecf594c9ec73e01c930",
      "https://git.kernel.org/stable/c/aa85fb7bde558bb2e364e85976b14b259c8b6fe8",
      "https://git.kernel.org/stable/c/e6fab7af6ba1bc77c78713a83876f60ca7a4a064"
    ],
    "受影响版本": [
      "65afb4c8e7e4e7e74b28efa1df62da503ca3e7a6",
      "65afb4c8e7e4e7e74b28efa1df62da503ca3e7a6",
      "65afb4c8e7e4e7e74b28efa1df62da503ca3e7a6",
      "65afb4c8e7e4e7e74b28efa1df62da503ca3e7a6",
      "65afb4c8e7e4e7e74b28efa1df62da503ca3e7a6"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47374",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ndma-debug: prevent an error message from causing runtime problems\n\nFor some drivers, that use the DMA API. This error message can be reached\nseveral millions of times per second, causing spam to the kernel's printk\nbuffer and bringing the CPU usage up to 100% (so, it should be rate\nlimited). However, since there is at least one driver that is in the\nmainline and suffers from the error condition, it is more useful to\nerr_printk() here instead of just rate limiting the error message (in hopes\nthat it will make it easier for other drivers that suffer from this issue\nto be spotted).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/de4afec2d2946c92c62a15ab341c70b287289e6a",
      "https://git.kernel.org/stable/c/510e1a724ab1bf38150be2c1acabb303f98d0047"
    ],
    "受影响版本": [
      "2b4bbc6231d789f58676d2ccc42177df163e1c4a",
      "2b4bbc6231d789f58676d2ccc42177df163e1c4a"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47350",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/mm: Fix lockup on kernel exec fault\n\nThe powerpc kernel is not prepared to handle exec faults from kernel.\nEspecially, the function is_exec_fault() will return 'false' when an\nexec fault is taken by kernel, because the check is based on reading\ncurrent->thread.regs->trap which contains the trap from user.\n\nFor instance, when provoking a LKDTM EXEC_USERSPACE test,\ncurrent->thread.regs->trap is set to SYSCALL trap (0xc00), and\nthe fault taken by the kernel is not seen as an exec fault by\nset_access_flags_filter().\n\nCommit d7df2443cd5f (\"powerpc/mm: Fix spurious segfaults on radix\nwith autonuma\") made it clear and handled it properly. But later on\ncommit d3ca587404b3 (\"powerpc/mm: Fix reporting of kernel execute\nfaults\") removed that handling, introducing test based on error_code.\nAnd here is the problem, because on the 603 all upper bits of SRR1\nget cleared when the TLB instruction miss handler bails out to ISI.\n\nUntil commit cbd7e6ca0210 (\"powerpc/fault: Avoid heavy\nsearch_exception_tables() verification\"), an exec fault from kernel\nat a userspace address was indirectly caught by the lack of entry for\nthat address in the exception tables. But after that commit the\nkernel mainly relies on KUAP or on core mm handling to catch wrong\nuser accesses. Here the access is not wrong, so mm handles it.\nIt is a minor fault because PAGE_EXEC is not set,\nset_access_flags_filter() should set PAGE_EXEC and voila.\nBut as is_exec_fault() returns false as explained in the beginning,\nset_access_flags_filter() bails out without setting PAGE_EXEC flag,\nwhich leads to a forever minor exec fault.\n\nAs the kernel is not prepared to handle such exec faults, the thing to\ndo is to fire in bad_kernel_fault() for any exec fault taken by the\nkernel, as it was prior to commit d3ca587404b3.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a82471a14aad90f79d1608d2bcbb019f0ffb53f0",
      "https://git.kernel.org/stable/c/d2e52d4664097a6c1f591d869ec594bd7a0d4925",
      "https://git.kernel.org/stable/c/500f81cec9f1bfa5210aa9dd5ba9a06e22f62a35",
      "https://git.kernel.org/stable/c/8a96ec5ebf96ad8e2ba7b1b34103a0be5140fc70",
      "https://git.kernel.org/stable/c/cd5d5e602f502895e47e18cd46804d6d7014e65c"
    ],
    "受影响版本": [
      "d3ca587404b36943b02df87406054ce73cc49500",
      "d3ca587404b36943b02df87406054ce73cc49500",
      "d3ca587404b36943b02df87406054ce73cc49500",
      "d3ca587404b36943b02df87406054ce73cc49500",
      "d3ca587404b36943b02df87406054ce73cc49500"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47349",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmwifiex: bring down link before deleting interface\n\nWe can deadlock when rmmod'ing the driver or going through firmware\nreset, because the cfg80211_unregister_wdev() has to bring down the link\nfor us, ... which then grab the same wiphy lock.\n\nnl80211_del_interface() already handles a very similar case, with a nice\ndescription:\n\n        /*\n         * We hold RTNL, so this is safe, without RTNL opencount cannot\n         * reach 0, and thus the rdev cannot be deleted.\n         *\n         * We need to do it for the dev_close(), since that will call\n         * the netdev notifiers, and we need to acquire the mutex there\n         * but don't know if we get there from here or from some other\n         * place (e.g. \"ip link set ... down\").\n         */\n        mutex_unlock(&rdev->wiphy.mtx);\n...\n\nDo similarly for mwifiex teardown, by ensuring we bring the link down\nfirst.\n\nSample deadlock trace:\n\n[  247.103516] INFO: task rmmod:2119 blocked for more than 123 seconds.\n[  247.110630]       Not tainted 5.12.4 #5\n[  247.115796] \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n[  247.124557] task:rmmod           state:D stack:    0 pid: 2119 ppid:  2114 flags:0x00400208\n[  247.133905] Call trace:\n[  247.136644]  __switch_to+0x130/0x170\n[  247.140643]  __schedule+0x714/0xa0c\n[  247.144548]  schedule_preempt_disabled+0x88/0xf4\n[  247.149714]  __mutex_lock_common+0x43c/0x750\n[  247.154496]  mutex_lock_nested+0x5c/0x68\n[  247.158884]  cfg80211_netdev_notifier_call+0x280/0x4e0 [cfg80211]\n[  247.165769]  raw_notifier_call_chain+0x4c/0x78\n[  247.170742]  call_netdevice_notifiers_info+0x68/0xa4\n[  247.176305]  __dev_close_many+0x7c/0x138\n[  247.180693]  dev_close_many+0x7c/0x10c\n[  247.184893]  unregister_netdevice_many+0xfc/0x654\n[  247.190158]  unregister_netdevice_queue+0xb4/0xe0\n[  247.195424]  _cfg80211_unregister_wdev+0xa4/0x204 [cfg80211]\n[  247.201816]  cfg80211_unregister_wdev+0x20/0x2c [cfg80211]\n[  247.208016]  mwifiex_del_virtual_intf+0xc8/0x188 [mwifiex]\n[  247.214174]  mwifiex_uninit_sw+0x158/0x1b0 [mwifiex]\n[  247.219747]  mwifiex_remove_card+0x38/0xa0 [mwifiex]\n[  247.225316]  mwifiex_pcie_remove+0xd0/0xe0 [mwifiex_pcie]\n[  247.231451]  pci_device_remove+0x50/0xe0\n[  247.235849]  device_release_driver_internal+0x110/0x1b0\n[  247.241701]  driver_detach+0x5c/0x9c\n[  247.245704]  bus_remove_driver+0x84/0xb8\n[  247.250095]  driver_unregister+0x3c/0x60\n[  247.254486]  pci_unregister_driver+0x2c/0x90\n[  247.259267]  cleanup_module+0x18/0xcdc [mwifiex_pcie]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a3041d39d3c14da97fa3476835aba043ba810cf0",
      "https://git.kernel.org/stable/c/35af69c7c0490fdccfc159c6a87e4d1dc070838a",
      "https://git.kernel.org/stable/c/1f9482aa8d412b4ba06ce6ab8e333fb8ca29a06e"
    ],
    "受影响版本": [
      "a05829a7222e9d10c416dd2dbbf3929fe6646b89",
      "a05829a7222e9d10c416dd2dbbf3929fe6646b89",
      "a05829a7222e9d10c416dd2dbbf3929fe6646b89"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47333",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: alcor_pci: fix null-ptr-deref when there is no PCI bridge\n\nThere is an issue with the ASPM(optional) capability checking function.\nA device might be attached to root complex directly, in this case,\nbus->self(bridge) will be NULL, thus priv->parent_pdev is NULL.\nSince alcor_pci_init_check_aspm(priv->parent_pdev) checks the PCI link's\nASPM capability and populate parent_cap_off, which will be used later by\nalcor_pci_aspm_ctrl() to dynamically turn on/off device, what we can do\nhere is to avoid checking the capability if we are on the root complex.\nThis will make pdev_cap_off 0 and alcor_pci_aspm_ctrl() will simply\nreturn when bring called, effectively disable ASPM for the device.\n\n[    1.246492] BUG: kernel NULL pointer dereference, address: 00000000000000c0\n[    1.248731] RIP: 0010:pci_read_config_byte+0x5/0x40\n[    1.253998] Call Trace:\n[    1.254131]  ? alcor_pci_find_cap_offset.isra.0+0x3a/0x100 [alcor_pci]\n[    1.254476]  alcor_pci_probe+0x169/0x2d5 [alcor_pci]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/d2639ffdcad463b358b6bef8645ff81715daffcb",
      "https://git.kernel.org/stable/c/58f69684ba03e5b0e0a3ae844a845280c0f06309",
      "https://git.kernel.org/stable/c/717cf5ae52322ddbdf3ac2c584b34c5970b0d174",
      "https://git.kernel.org/stable/c/09d154990ca82d14aed2b72796f6c8845e2e605d",
      "https://git.kernel.org/stable/c/3ce3e45cc333da707d4d6eb433574b990bcc26f5"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47318",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\narch_topology: Avoid use-after-free for scale_freq_data\n\nCurrently topology_scale_freq_tick() (which gets called from\nscheduler_tick()) may end up using a pointer to \"struct\nscale_freq_data\", which was previously cleared by\ntopology_clear_scale_freq_source(), as there is no protection in place\nhere. The users of topology_clear_scale_freq_source() though needs a\nguarantee that the previously cleared scale_freq_data isn't used\nanymore, so they can free the related resources.\n\nSince topology_scale_freq_tick() is called from scheduler tick, we don't\nwant to add locking in there. Use the RCU update mechanism instead\n(which is already used by the scheduler's utilization update path) to\nguarantee race free updates here.\n\nsynchronize_rcu() makes sure that all RCU critical sections that started\nbefore it is called, will finish before it returns. And so the callers\nof topology_clear_scale_freq_source() don't need to worry about their\ncallback getting called anymore.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ccdf7e073170886bc370c613e269de610a794c4a",
      "https://git.kernel.org/stable/c/83150f5d05f065fb5c12c612f119015cabdcc124"
    ],
    "受影响版本": [
      "01e055c120a46e78650b5f903088badbbdaae9ad",
      "01e055c120a46e78650b5f903088badbbdaae9ad"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47303",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Track subprog poke descriptors correctly and fix use-after-free\n\nSubprograms are calling map_poke_track(), but on program release there is no\nhook to call map_poke_untrack(). However, on program release, the aux memory\n(and poke descriptor table) is freed even though we still have a reference to\nit in the element list of the map aux data. When we run map_poke_run(), we then\nend up accessing free'd memory, triggering KASAN in prog_array_map_poke_run():\n\n  [...]\n  [  402.824689] BUG: KASAN: use-after-free in prog_array_map_poke_run+0xc2/0x34e\n  [  402.824698] Read of size 4 at addr ffff8881905a7940 by task hubble-fgs/4337\n  [  402.824705] CPU: 1 PID: 4337 Comm: hubble-fgs Tainted: G          I       5.12.0+ #399\n  [  402.824715] Call Trace:\n  [  402.824719]  dump_stack+0x93/0xc2\n  [  402.824727]  print_address_description.constprop.0+0x1a/0x140\n  [  402.824736]  ? prog_array_map_poke_run+0xc2/0x34e\n  [  402.824740]  ? prog_array_map_poke_run+0xc2/0x34e\n  [  402.824744]  kasan_report.cold+0x7c/0xd8\n  [  402.824752]  ? prog_array_map_poke_run+0xc2/0x34e\n  [  402.824757]  prog_array_map_poke_run+0xc2/0x34e\n  [  402.824765]  bpf_fd_array_map_update_elem+0x124/0x1a0\n  [...]\n\nThe elements concerned are walked as follows:\n\n    for (i = 0; i < elem->aux->size_poke_tab; i++) {\n           poke = &elem->aux->poke_tab[i];\n    [...]\n\nThe access to size_poke_tab is a 4 byte read, verified by checking offsets\nin the KASAN dump:\n\n  [  402.825004] The buggy address belongs to the object at ffff8881905a7800\n                 which belongs to the cache kmalloc-1k of size 1024\n  [  402.825008] The buggy address is located 320 bytes inside of\n                 1024-byte region [ffff8881905a7800, ffff8881905a7c00)\n\nThe pahole output of bpf_prog_aux:\n\n  struct bpf_prog_aux {\n    [...]\n    /* --- cacheline 5 boundary (320 bytes) --- */\n    u32                        size_poke_tab;        /*   320     4 */\n    [...]\n\nIn general, subprograms do not necessarily manage their own data structures.\nFor example, BTF func_info and linfo are just pointers to the main program\nstructure. This allows reference counting and cleanup to be done on the latter\nwhich simplifies their management a bit. The aux->poke_tab struct, however,\ndid not follow this logic. The initial proposed fix for this use-after-free\nbug further embedded poke data tracking into the subprogram with proper\nreference counting. However, Daniel and Alexei questioned why we were treating\nthese objects special; I agree, its unnecessary. The fix here removes the per\nsubprogram poke table allocation and map tracking and instead simply points\nthe aux->poke_tab pointer at the main programs poke table. This way, map\ntracking is simplified to the main program and we do not need to manage them\nper subprogram.\n\nThis also means, bpf_prog_free_deferred(), which unwinds the program reference\ncounting and kfrees objects, needs to ensure that we don't try to double free\nthe poke_tab when free'ing the subprog structures. This is easily solved by\nNULL'ing the poke_tab pointer. The second detail is to ensure that per\nsubprogram JIT logic only does fixups on poke_tab[] entries it owns. To do\nthis, we add a pointer in the poke structure to point at the subprogram value\nso JITs can easily check while walking the poke_tab structure if the current\nentry belongs to the current program. The aux pointer is stable and therefore\nsuitable for such comparison. On the jit_subprogs() error path, we omit\ncleaning up the poke->aux field because these are only ever referenced from\nthe JIT side, but on error we will never make it to the JIT, so its fine to\nleave them dangling. Removing these pointers would complicate the error path\nfor no reason. However, we do need to untrack all poke descriptors from the\nmain program as otherwise they could race with the freeing of JIT memory from\nthe subprograms. Lastly, a748c6975dea3 (\"bpf: propagate poke des\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a9f36bf3613c65cb587c70fac655c775d911409b",
      "https://git.kernel.org/stable/c/599148d40366bd5d1d504a3a8fcd65e21107e500",
      "https://git.kernel.org/stable/c/f263a81451c12da5a342d90572e317e611846f2c"
    ],
    "受影响版本": [
      "a748c6975dea325da540610c2ba9b5f332c603e6",
      "a748c6975dea325da540610c2ba9b5f332c603e6",
      "a748c6975dea325da540610c2ba9b5f332c603e6"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47275",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbcache: avoid oversized read request in cache missing code path\n\nIn the cache missing code path of cached device, if a proper location\nfrom the internal B+ tree is matched for a cache miss range, function\ncached_dev_cache_miss() will be called in cache_lookup_fn() in the\nfollowing code block,\n[code block 1]\n  526         unsigned int sectors = KEY_INODE(k) == s->iop.inode\n  527                 ? min_t(uint64_t, INT_MAX,\n  528                         KEY_START(k) - bio->bi_iter.bi_sector)\n  529                 : INT_MAX;\n  530         int ret = s->d->cache_miss(b, s, bio, sectors);\n\nHere s->d->cache_miss() is the call backfunction pointer initialized as\ncached_dev_cache_miss(), the last parameter 'sectors' is an important\nhint to calculate the size of read request to backing device of the\nmissing cache data.\n\nCurrent calculation in above code block may generate oversized value of\n'sectors', which consequently may trigger 2 different potential kernel\npanics by BUG() or BUG_ON() as listed below,\n\n1) BUG_ON() inside bch_btree_insert_key(),\n[code block 2]\n   886         BUG_ON(b->ops->is_extents && !KEY_SIZE(k));\n2) BUG() inside biovec_slab(),\n[code block 3]\n   51         default:\n   52                 BUG();\n   53                 return NULL;\n\nAll the above panics are original from cached_dev_cache_miss() by the\noversized parameter 'sectors'.\n\nInside cached_dev_cache_miss(), parameter 'sectors' is used to calculate\nthe size of data read from backing device for the cache missing. This\nsize is stored in s->insert_bio_sectors by the following lines of code,\n[code block 4]\n  909    s->insert_bio_sectors = min(sectors, bio_sectors(bio) + reada);\n\nThen the actual key inserting to the internal B+ tree is generated and\nstored in s->iop.replace_key by the following lines of code,\n[code block 5]\n  911   s->iop.replace_key = KEY(s->iop.inode,\n  912                    bio->bi_iter.bi_sector + s->insert_bio_sectors,\n  913                    s->insert_bio_sectors);\nThe oversized parameter 'sectors' may trigger panic 1) by BUG_ON() from\nthe above code block.\n\nAnd the bio sending to backing device for the missing data is allocated\nwith hint from s->insert_bio_sectors by the following lines of code,\n[code block 6]\n  926    cache_bio = bio_alloc_bioset(GFP_NOWAIT,\n  927                 DIV_ROUND_UP(s->insert_bio_sectors, PAGE_SECTORS),\n  928                 &dc->disk.bio_split);\nThe oversized parameter 'sectors' may trigger panic 2) by BUG() from the\nagove code block.\n\nNow let me explain how the panics happen with the oversized 'sectors'.\nIn code block 5, replace_key is generated by macro KEY(). From the\ndefinition of macro KEY(),\n[code block 7]\n  71 #define KEY(inode, offset, size)                                  \\\n  72 ((struct bkey) {                                                  \\\n  73      .high = (1ULL << 63) | ((__u64) (size) << 20) | (inode),     \\\n  74      .low = (offset)                                              \\\n  75 })\n\nHere 'size' is 16bits width embedded in 64bits member 'high' of struct\nbkey. But in code block 1, if \"KEY_START(k) - bio->bi_iter.bi_sector\" is\nvery probably to be larger than (1<<16) - 1, which makes the bkey size\ncalculation in code block 5 is overflowed. In one bug report the value\nof parameter 'sectors' is 131072 (= 1 << 17), the overflowed 'sectors'\nresults the overflowed s->insert_bio_sectors in code block 4, then makes\nsize field of s->iop.replace_key to be 0 in code block 5. Then the 0-\nsized s->iop.replace_key is inserted into the internal B+ tree as cache\nmissing check key (a special key to detect and avoid a racing between\nnormal write request and cache missing read request) as,\n[code block 8]\n  915   ret = bch_btree_insert_check_key(b, &s->op, &s->iop.replace_key);\n\nThen the 0-sized s->iop.replace_key as 3rd parameter triggers the bkey\nsize check BUG_ON() in code block 2, and causes the kernel panic 1).\n\nAnother ke\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/555002a840ab88468e252b0eedf0b05e2ce7099c",
      "https://git.kernel.org/stable/c/41fe8d088e96472f63164e213de44ec77be69478"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47246",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Fix page reclaim for dead peer hairpin\n\nWhen adding a hairpin flow, a firmware-side send queue is created for\nthe peer net device, which claims some host memory pages for its\ninternal ring buffer. If the peer net device is removed/unbound before\nthe hairpin flow is deleted, then the send queue is not destroyed which\nleads to a stack trace on pci device remove:\n\n[ 748.005230] mlx5_core 0000:08:00.2: wait_func:1094:(pid 12985): MANAGE_PAGES(0x108) timeout. Will cause a leak of a command resource\n[ 748.005231] mlx5_core 0000:08:00.2: reclaim_pages:514:(pid 12985): failed reclaiming pages: err -110\n[ 748.001835] mlx5_core 0000:08:00.2: mlx5_reclaim_root_pages:653:(pid 12985): failed reclaiming pages (-110) for func id 0x0\n[ 748.002171] ------------[ cut here ]------------\n[ 748.001177] FW pages counter is 4 after reclaiming all pages\n[ 748.001186] WARNING: CPU: 1 PID: 12985 at drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c:685 mlx5_reclaim_startup_pages+0x34b/0x460 [mlx5_core]                      [  +0.002771] Modules linked in: cls_flower mlx5_ib mlx5_core ptp pps_core act_mirred sch_ingress openvswitch nsh xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi rdma_cm ib_umad ib_ipoib iw_cm ib_cm ib_uverbs ib_core overlay fuse [last unloaded: pps_core]\n[ 748.007225] CPU: 1 PID: 12985 Comm: tee Not tainted 5.12.0+ #1\n[ 748.001376] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n[ 748.002315] RIP: 0010:mlx5_reclaim_startup_pages+0x34b/0x460 [mlx5_core]\n[ 748.001679] Code: 28 00 00 00 0f 85 22 01 00 00 48 81 c4 b0 00 00 00 31 c0 5b 5d 41 5c 41 5d 41 5e 41 5f c3 48 c7 c7 40 cc 19 a1 e8 9f 71 0e e2 <0f> 0b e9 30 ff ff ff 48 c7 c7 a0 cc 19 a1 e8 8c 71 0e e2 0f 0b e9\n[ 748.003781] RSP: 0018:ffff88815220faf8 EFLAGS: 00010286\n[ 748.001149] RAX: 0000000000000000 RBX: ffff8881b4900280 RCX: 0000000000000000\n[ 748.001445] RDX: 0000000000000027 RSI: 0000000000000004 RDI: ffffed102a441f51\n[ 748.001614] RBP: 00000000000032b9 R08: 0000000000000001 R09: ffffed1054a15ee8\n[ 748.001446] R10: ffff8882a50af73b R11: ffffed1054a15ee7 R12: fffffbfff07c1e30\n[ 748.001447] R13: dffffc0000000000 R14: ffff8881b492cba8 R15: 0000000000000000\n[ 748.001429] FS:  00007f58bd08b580(0000) GS:ffff8882a5080000(0000) knlGS:0000000000000000\n[ 748.001695] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 748.001309] CR2: 000055a026351740 CR3: 00000001d3b48006 CR4: 0000000000370ea0\n[ 748.001506] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 748.001483] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ 748.001654] Call Trace:\n[ 748.000576]  ? mlx5_satisfy_startup_pages+0x290/0x290 [mlx5_core]\n[ 748.001416]  ? mlx5_cmd_teardown_hca+0xa2/0xd0 [mlx5_core]\n[ 748.001354]  ? mlx5_cmd_init_hca+0x280/0x280 [mlx5_core]\n[ 748.001203]  mlx5_function_teardown+0x30/0x60 [mlx5_core]\n[ 748.001275]  mlx5_uninit_one+0xa7/0xc0 [mlx5_core]\n[ 748.001200]  remove_one+0x5f/0xc0 [mlx5_core]\n[ 748.001075]  pci_device_remove+0x9f/0x1d0\n[ 748.000833]  device_release_driver_internal+0x1e0/0x490\n[ 748.001207]  unbind_store+0x19f/0x200\n[ 748.000942]  ? sysfs_file_ops+0x170/0x170\n[ 748.001000]  kernfs_fop_write_iter+0x2bc/0x450\n[ 748.000970]  new_sync_write+0x373/0x610\n[ 748.001124]  ? new_sync_read+0x600/0x600\n[ 748.001057]  ? lock_acquire+0x4d6/0x700\n[ 748.000908]  ? lockdep_hardirqs_on_prepare+0x400/0x400\n[ 748.001126]  ? fd_install+0x1c9/0x4d0\n[ 748.000951]  vfs_write+0x4d0/0x800\n[ 748.000804]  ksys_write+0xf9/0x1d0\n[ 748.000868]  ? __x64_sys_read+0xb0/0xb0\n[ 748.000811]  ? filp_open+0x50/0x50\n[ 748.000919]  ? syscall_enter_from_user_mode+0x1d/0x50\n[ 748.001223]  do_syscall_64+0x3f/0x80\n[ 748.000892]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[ 748.00\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4b16118665e94c90a3e84a5190486fd0e4eedd74",
      "https://git.kernel.org/stable/c/be7f3f401d224e1efe8112b2fa8b837eeb8c5e52",
      "https://git.kernel.org/stable/c/b374c1304f6d3d4752ad1412427b7bf02bb1fd61",
      "https://git.kernel.org/stable/c/a3e5fd9314dfc4314a9567cde96e1aef83a7458a"
    ],
    "受影响版本": [
      "4d8fcf216c90bc25e34ae2200aa8985ee3158898",
      "4d8fcf216c90bc25e34ae2200aa8985ee3158898",
      "4d8fcf216c90bc25e34ae2200aa8985ee3158898",
      "4d8fcf216c90bc25e34ae2200aa8985ee3158898"
    ],
    "公开日期": "2024年05月21日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47215",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: kTLS, Fix crash in RX resync flow\n\nFor the TLS RX resync flow, we maintain a list of TLS contexts\nthat require some attention, to communicate their resync information\nto the HW.\nHere we fix list corruptions, by protecting the entries against\nmovements coming from resync_handle_seq_match(), until their resync\nhandling in napi is fully completed.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ebeda7a9528ae690e6bf12791a868f0cca8391f2",
      "https://git.kernel.org/stable/c/cc4a9cc03faa6d8db1a6954bb536f2c1e63bdff6"
    ],
    "受影响版本": [
      "e9ce991bce5bacf71641bd0f72f4b7c589529f40",
      "e9ce991bce5bacf71641bd0f72f4b7c589529f40"
    ],
    "公开日期": "2024年04月10日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47179",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSv4: Fix a NULL pointer dereference in pnfs_mark_matching_lsegs_return()\n\nCommit de144ff4234f changes _pnfs_return_layout() to call\npnfs_mark_matching_lsegs_return() passing NULL as the struct\npnfs_layout_range argument. Unfortunately,\npnfs_mark_matching_lsegs_return() doesn't check if we have a value here\nbefore dereferencing it, causing an oops.\n\nI'm able to hit this crash consistently when running connectathon basic\ntests on NFS v4.1/v4.2 against Ontap.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4e1ba532dbc1a0e19fc2458d74ab8d98680c4e42",
      "https://git.kernel.org/stable/c/42637ca25c7d7b5a92804a679af5192e8c1a9f48",
      "https://git.kernel.org/stable/c/39785761feadf261bc5101372b0b0bbaf6a94494",
      "https://git.kernel.org/stable/c/aba3c7795f51717ae316f3566442dee7cc3eeccb",
      "https://git.kernel.org/stable/c/f9890652185b72b8de9ebeb4406037640b6e1b53",
      "https://git.kernel.org/stable/c/b090d110e66636bca473fd8b98d5c97b555a965a",
      "https://git.kernel.org/stable/c/a421d218603ffa822a0b8045055c03eae394a7eb"
    ],
    "受影响版本": [
      "80e34f4957ec3010c85f9bb0b568a8d46acdf535",
      "7b7b9774643220e53eef58c15bb29bd4182fe053",
      "9ffa7967f9379a0a1b924e9ffeda709d72237da7",
      "6be0e4b59314e4a836495f6ffdc5d2c5b079deeb",
      "2fafe7d5047f98791afd9a1d90d2afb70debc590",
      "7e65ea887d0c0997f3053acd91a027af45e71c5b",
      "de144ff4234f935bd2150108019b5d87a90a8a96",
      "96260bde1ea8ae31a5402fe506abbb8951d5a42c"
    ],
    "公开日期": "2024年03月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47172",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niio: adc: ad7124: Fix potential overflow due to non sequential channel numbers\n\nChannel numbering must start at 0 and then not have any holes, or\nit is possible to overflow the available storage.  Note this bug was\nintroduced as part of a fix to ensure we didn't rely on the ordering\nof child nodes.  So we need to support arbitrary ordering but they all\nneed to be there somewhere.\n\nNote I hit this when using qemu to test the rest of this series.\nArguably this isn't the best fix, but it is probably the most minimal\noption for backporting etc.\n\nAlexandru's sign-off is here because he carried this patch in a larger\nset that Jonathan then applied.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/f49149964d2423fb618fb6b755bb1eaa431cca2c",
      "https://git.kernel.org/stable/c/f70122825076117787b91e7f219e21c09f11a5b9",
      "https://git.kernel.org/stable/c/26da8040eccc6c6b0e415e9a3baf72fd39eb2fdc",
      "https://git.kernel.org/stable/c/f2a772c51206b0c3f262e4f6a3812c89a650191b"
    ],
    "受影响版本": [
      "5408cbc6337300d6f1a87c797273c535ed96305a",
      "d7857e4ee1ba69732b16c73b2f2dde83ecd78ee4",
      "d7857e4ee1ba69732b16c73b2f2dde83ecd78ee4",
      "d7857e4ee1ba69732b16c73b2f2dde83ecd78ee4"
    ],
    "公开日期": "2024年03月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47145",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: do not BUG_ON in link_to_fixup_dir\n\nWhile doing error injection testing I got the following panic\n\n  kernel BUG at fs/btrfs/tree-log.c:1862!\n  invalid opcode: 0000 [#1] SMP NOPTI\n  CPU: 1 PID: 7836 Comm: mount Not tainted 5.13.0-rc1+ #305\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014\n  RIP: 0010:link_to_fixup_dir+0xd5/0xe0\n  RSP: 0018:ffffb5800180fa30 EFLAGS: 00010216\n  RAX: fffffffffffffffb RBX: 00000000fffffffb RCX: ffff8f595287faf0\n  RDX: ffffb5800180fa37 RSI: ffff8f5954978800 RDI: 0000000000000000\n  RBP: ffff8f5953af9450 R08: 0000000000000019 R09: 0000000000000001\n  R10: 000151f408682970 R11: 0000000120021001 R12: ffff8f5954978800\n  R13: ffff8f595287faf0 R14: ffff8f5953c77dd0 R15: 0000000000000065\n  FS:  00007fc5284c8c40(0000) GS:ffff8f59bbd00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007fc5287f47c0 CR3: 000000011275e002 CR4: 0000000000370ee0\n  Call Trace:\n   replay_one_buffer+0x409/0x470\n   ? btree_read_extent_buffer_pages+0xd0/0x110\n   walk_up_log_tree+0x157/0x1e0\n   walk_log_tree+0xa6/0x1d0\n   btrfs_recover_log_trees+0x1da/0x360\n   ? replay_one_extent+0x7b0/0x7b0\n   open_ctree+0x1486/0x1720\n   btrfs_mount_root.cold+0x12/0xea\n   ? __kmalloc_track_caller+0x12f/0x240\n   legacy_get_tree+0x24/0x40\n   vfs_get_tree+0x22/0xb0\n   vfs_kern_mount.part.0+0x71/0xb0\n   btrfs_mount+0x10d/0x380\n   ? vfs_parse_fs_string+0x4d/0x90\n   legacy_get_tree+0x24/0x40\n   vfs_get_tree+0x22/0xb0\n   path_mount+0x433/0xa10\n   __x64_sys_mount+0xe3/0x120\n   do_syscall_64+0x3d/0x80\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nWe can get -EIO or any number of legitimate errors from\nbtrfs_search_slot(), panicing here is not the appropriate response.  The\nerror path for this code handles errors properly, simply return the\nerror.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/76bfd8ac20bebeae599452a03dfc5724c0475dcf",
      "https://git.kernel.org/stable/c/e934c4ee17b33bafb0444f2f9766cda7166d3c40",
      "https://git.kernel.org/stable/c/0eaf383c6a4a83c09f60fd07a1bea9f1a9181611",
      "https://git.kernel.org/stable/c/6eccfb28f8dca70c9b1b3bb3194ca54cbe73a9fa",
      "https://git.kernel.org/stable/c/0ed102453aa1cd12fefde8f6b60b9519b0b1f003",
      "https://git.kernel.org/stable/c/7e13db503918820e6333811cdc6f151dcea5090a",
      "https://git.kernel.org/stable/c/b545442133580dcb2f2496133bf850824d41255c",
      "https://git.kernel.org/stable/c/91df99a6eb50d5a1bc70fff4a09a0b7ae6aab96d"
    ],
    "受影响版本": [
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2",
      "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2"
    ],
    "公开日期": "2024年03月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47139",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hns3: put off calling register_netdev() until client initialize complete\n\nCurrently, the netdevice is registered before client initializing\ncomplete. So there is a timewindow between netdevice available\nand usable. In this case, if user try to change the channel number\nor ring param, it may cause the hns3_set_rx_cpu_rmap() being called\ntwice, and report bug.\n\n[47199.416502] hns3 0000:35:00.0 eth1: set channels: tqp_num=1, rxfh=0\n[47199.430340] hns3 0000:35:00.0 eth1: already uninitialized\n[47199.438554] hns3 0000:35:00.0: rss changes from 4 to 1\n[47199.511854] hns3 0000:35:00.0: Channels changed, rss_size from 4 to 1, tqps from 4 to 1\n[47200.163524] ------------[ cut here ]------------\n[47200.171674] kernel BUG at lib/cpu_rmap.c:142!\n[47200.177847] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP\n[47200.185259] Modules linked in: hclge(+) hns3(-) hns3_cae(O) hns_roce_hw_v2 hnae3 vfio_iommu_type1 vfio_pci vfio_virqfd vfio pv680_mii(O) [last unloaded: hclge]\n[47200.205912] CPU: 1 PID: 8260 Comm: ethtool Tainted: G           O      5.11.0-rc3+ #1\n[47200.215601] Hardware name:  , xxxxxx 02/04/2021\n[47200.223052] pstate: 60400009 (nZCv daif +PAN -UAO -TCO BTYPE=--)\n[47200.230188] pc : cpu_rmap_add+0x38/0x40\n[47200.237472] lr : irq_cpu_rmap_add+0x84/0x140\n[47200.243291] sp : ffff800010e93a30\n[47200.247295] x29: ffff800010e93a30 x28: ffff082100584880\n[47200.254155] x27: 0000000000000000 x26: 0000000000000000\n[47200.260712] x25: 0000000000000000 x24: 0000000000000004\n[47200.267241] x23: ffff08209ba03000 x22: ffff08209ba038c0\n[47200.273789] x21: 000000000000003f x20: ffff0820e2bc1680\n[47200.280400] x19: ffff0820c970ec80 x18: 00000000000000c0\n[47200.286944] x17: 0000000000000000 x16: ffffb43debe4a0d0\n[47200.293456] x15: fffffc2082990600 x14: dead000000000122\n[47200.300059] x13: ffffffffffffffff x12: 000000000000003e\n[47200.306606] x11: ffff0820815b8080 x10: ffff53e411988000\n[47200.313171] x9 : 0000000000000000 x8 : ffff0820e2bc1700\n[47200.319682] x7 : 0000000000000000 x6 : 000000000000003f\n[47200.326170] x5 : 0000000000000040 x4 : ffff800010e93a20\n[47200.332656] x3 : 0000000000000004 x2 : ffff0820c970ec80\n[47200.339168] x1 : ffff0820e2bc1680 x0 : 0000000000000004\n[47200.346058] Call trace:\n[47200.349324]  cpu_rmap_add+0x38/0x40\n[47200.354300]  hns3_set_rx_cpu_rmap+0x6c/0xe0 [hns3]\n[47200.362294]  hns3_reset_notify_init_enet+0x1cc/0x340 [hns3]\n[47200.370049]  hns3_change_channels+0x40/0xb0 [hns3]\n[47200.376770]  hns3_set_channels+0x12c/0x2a0 [hns3]\n[47200.383353]  ethtool_set_channels+0x140/0x250\n[47200.389772]  dev_ethtool+0x714/0x23d0\n[47200.394440]  dev_ioctl+0x4cc/0x640\n[47200.399277]  sock_do_ioctl+0x100/0x2a0\n[47200.404574]  sock_ioctl+0x28c/0x470\n[47200.409079]  __arm64_sys_ioctl+0xb4/0x100\n[47200.415217]  el0_svc_common.constprop.0+0x84/0x210\n[47200.422088]  do_el0_svc+0x28/0x34\n[47200.426387]  el0_svc+0x28/0x70\n[47200.431308]  el0_sync_handler+0x1a4/0x1b0\n[47200.436477]  el0_sync+0x174/0x180\n[47200.441562] Code: 11000405 79000c45 f8247861 d65f03c0 (d4210000)\n[47200.448869] ---[ end trace a01efe4ce42e5f34 ]---\n\nThe process is like below:\nexcuting hns3_client_init\n|\nregister_netdev()\n|                           hns3_set_channels()\n|                           |\nhns3_set_rx_cpu_rmap()      hns3_reset_notify_uninit_enet()\n|                               |\n|                            quit without calling function\n|                            hns3_free_rx_cpu_rmap for flag\n|                            HNS3_NIC_STATE_INITED is unset.\n|                           |\n|                           hns3_reset_notify_init_enet()\n|                               |\nset HNS3_NIC_STATE_INITED    call hns3_set_rx_cpu_rmap()-- crash\n\nFix it by calling register_netdev() at the end of function\nhns3_client_init().",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a663c1e418a3b5b8e8edfad4bc8e7278c312d6fc",
      "https://git.kernel.org/stable/c/0921a0620b5077796fddffb22a8e6bc635a4bb50",
      "https://git.kernel.org/stable/c/a289a7e5c1d49b7d47df9913c1cc81fb48fab613"
    ],
    "受影响版本": [
      "08a100689d4baf296d6898c687ea8d005da8d234",
      "08a100689d4baf296d6898c687ea8d005da8d234",
      "08a100689d4baf296d6898c687ea8d005da8d234"
    ],
    "公开日期": "2024年03月25日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47134",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nefi/fdt: fix panic when no valid fdt found\n\nsetup_arch() would invoke efi_init()->efi_get_fdt_params(). If no\nvalid fdt found then initial_boot_params will be null. So we\nshould stop further fdt processing here. I encountered this\nissue on risc-v.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5148066edbdc89c6fe5bc419c31a5c22e5f83bdb",
      "https://git.kernel.org/stable/c/8a7e8b4e5631a03ea2fee27957857a56612108ca",
      "https://git.kernel.org/stable/c/668a84c1bfb2b3fd5a10847825a854d63fac7baa"
    ],
    "受影响版本": [
      "b91540d52a08b65eb6a2b09132e1bd54fa82754c",
      "b91540d52a08b65eb6a2b09132e1bd54fa82754c",
      "b91540d52a08b65eb6a2b09132e1bd54fa82754c"
    ],
    "公开日期": "2024年03月15日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47130",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvmet: fix freeing unallocated p2pmem\n\nIn case p2p device was found but the p2p pool is empty, the nvme target\nis still trying to free the sgl from the p2p pool instead of the\nregular sgl pool and causing a crash (BUG() is called). Instead, assign\nthe p2p_dev for the request only if it was allocated from p2p pool.\n\nThis is the crash that was caused:\n\n[Sun May 30 19:13:53 2021] ------------[ cut here ]------------\n[Sun May 30 19:13:53 2021] kernel BUG at lib/genalloc.c:518!\n[Sun May 30 19:13:53 2021] invalid opcode: 0000 [#1] SMP PTI\n...\n[Sun May 30 19:13:53 2021] kernel BUG at lib/genalloc.c:518!\n...\n[Sun May 30 19:13:53 2021] RIP: 0010:gen_pool_free_owner+0xa8/0xb0\n...\n[Sun May 30 19:13:53 2021] Call Trace:\n[Sun May 30 19:13:53 2021] ------------[ cut here ]------------\n[Sun May 30 19:13:53 2021]  pci_free_p2pmem+0x2b/0x70\n[Sun May 30 19:13:53 2021]  pci_p2pmem_free_sgl+0x4f/0x80\n[Sun May 30 19:13:53 2021]  nvmet_req_free_sgls+0x1e/0x80 [nvmet]\n[Sun May 30 19:13:53 2021] kernel BUG at lib/genalloc.c:518!\n[Sun May 30 19:13:53 2021]  nvmet_rdma_release_rsp+0x4e/0x1f0 [nvmet_rdma]\n[Sun May 30 19:13:53 2021]  nvmet_rdma_send_done+0x1c/0x60 [nvmet_rdma]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c440cd080761b18a52cac20f2a42e5da1e3995af",
      "https://git.kernel.org/stable/c/8a452d62e7cea3c8a2676a3b89a9118755a1a271",
      "https://git.kernel.org/stable/c/bcd9a0797d73eeff659582f23277e7ab6e5f18f3"
    ],
    "受影响版本": [
      "c6e3f13398123a008cd2ee28f93510b113a32791",
      "c6e3f13398123a008cd2ee28f93510b113a32791",
      "c6e3f13398123a008cd2ee28f93510b113a32791"
    ],
    "公开日期": "2024年03月15日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47128",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, lockdown, audit: Fix buggy SELinux lockdown permission checks\n\nCommit 59438b46471a (\"security,lockdown,selinux: implement SELinux lockdown\")\nadded an implementation of the locked_down LSM hook to SELinux, with the aim\nto restrict which domains are allowed to perform operations that would breach\nlockdown. This is indirectly also getting audit subsystem involved to report\nevents. The latter is problematic, as reported by Ondrej and Serhei, since it\ncan bring down the whole system via audit:\n\n  1) The audit events that are triggered due to calls to security_locked_down()\n     can OOM kill a machine, see below details [0].\n\n  2) It also seems to be causing a deadlock via avc_has_perm()/slow_avc_audit()\n     when trying to wake up kauditd, for example, when using trace_sched_switch()\n     tracepoint, see details in [1]. Triggering this was not via some hypothetical\n     corner case, but with existing tools like runqlat & runqslower from bcc, for\n     example, which make use of this tracepoint. Rough call sequence goes like:\n\n     rq_lock(rq) -> -------------------------+\n       trace_sched_switch() ->               |\n         bpf_prog_xyz() ->                   +-> deadlock\n           selinux_lockdown() ->             |\n             audit_log_end() ->              |\n               wake_up_interruptible() ->    |\n                 try_to_wake_up() ->         |\n                   rq_lock(rq) --------------+\n\nWhat's worse is that the intention of 59438b46471a to further restrict lockdown\nsettings for specific applications in respect to the global lockdown policy is\ncompletely broken for BPF. The SELinux policy rule for the current lockdown check\nlooks something like this:\n\n  allow <who> <who> : lockdown { <reason> };\n\nHowever, this doesn't match with the 'current' task where the security_locked_down()\nis executed, example: httpd does a syscall. There is a tracing program attached\nto the syscall which triggers a BPF program to run, which ends up doing a\nbpf_probe_read_kernel{,_str}() helper call. The selinux_lockdown() hook does\nthe permission check against 'current', that is, httpd in this example. httpd\nhas literally zero relation to this tracing program, and it would be nonsensical\nhaving to write an SELinux policy rule against httpd to let the tracing helper\npass. The policy in this case needs to be against the entity that is installing\nthe BPF program. For example, if bpftrace would generate a histogram of syscall\ncounts by user space application:\n\n  bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'\n\nbpftrace would then go and generate a BPF program from this internally. One way\nof doing it [for the sake of the example] could be to call bpf_get_current_task()\nhelper and then access current->comm via one of bpf_probe_read_kernel{,_str}()\nhelpers. So the program itself has nothing to do with httpd or any other random\napp doing a syscall here. The BPF program _explicitly initiated_ the lockdown\ncheck. The allow/deny policy belongs in the context of bpftrace: meaning, you\nwant to grant bpftrace access to use these helpers, but other tracers on the\nsystem like my_random_tracer _not_.\n\nTherefore fix all three issues at the same time by taking a completely different\napproach for the security_locked_down() hook, that is, move the check into the\nprogram verification phase where we actually retrieve the BPF func proto. This\nalso reliably gets the task (current) that is trying to install the BPF tracing\nprogram, e.g. bpftrace/bcc/perf/systemtap/etc, and it also fixes the OOM since\nwe're moving this out of the BPF helper's fast-path which can be called several\nmillions of times per second.\n\nThe check is then also in line with other security_locked_down() hooks in the\nsystem where the enforcement is performed at open/load time, for example,\nopen_kcore() for /proc/kcore access or module_sig_check() for module signatures\njust to pick f\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/ff5039ec75c83d2ed5b781dc7733420ee8c985fc",
      "https://git.kernel.org/stable/c/acc43fc6cf0d50612193813c5906a1ab9d433e1e",
      "https://git.kernel.org/stable/c/ff40e51043af63715ab413995ff46996ecf9583f"
    ],
    "受影响版本": [
      "59438b46471ae6cdfb761afc8c9beaf1e428a331",
      "59438b46471ae6cdfb761afc8c9beaf1e428a331",
      "59438b46471ae6cdfb761afc8c9beaf1e428a331"
    ],
    "公开日期": "2024年03月15日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47097",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nInput: elantech - fix stack out of bound access in elantech_change_report_id()\n\nThe array param[] in elantech_change_report_id() must be at least 3\nbytes, because elantech_read_reg_params() is calling ps2_command() with\nPSMOUSE_CMD_GETINFO, that is going to access 3 bytes from param[], but\nit's defined in the stack as an array of 2 bytes, therefore we have a\npotential stack out-of-bounds access here, also confirmed by KASAN:\n\n[    6.512374] BUG: KASAN: stack-out-of-bounds in __ps2_command+0x372/0x7e0\n[    6.512397] Read of size 1 at addr ffff8881024d77c2 by task kworker/2:1/118\n\n[    6.512416] CPU: 2 PID: 118 Comm: kworker/2:1 Not tainted 5.13.0-22-generic #22+arighi20211110\n[    6.512428] Hardware name: LENOVO 20T8000QGE/20T8000QGE, BIOS R1AET32W (1.08 ) 08/14/2020\n[    6.512436] Workqueue: events_long serio_handle_event\n[    6.512453] Call Trace:\n[    6.512462]  show_stack+0x52/0x58\n[    6.512474]  dump_stack+0xa1/0xd3\n[    6.512487]  print_address_description.constprop.0+0x1d/0x140\n[    6.512502]  ? __ps2_command+0x372/0x7e0\n[    6.512516]  __kasan_report.cold+0x7d/0x112\n[    6.512527]  ? _raw_write_lock_irq+0x20/0xd0\n[    6.512539]  ? __ps2_command+0x372/0x7e0\n[    6.512552]  kasan_report+0x3c/0x50\n[    6.512564]  __asan_load1+0x6a/0x70\n[    6.512575]  __ps2_command+0x372/0x7e0\n[    6.512589]  ? ps2_drain+0x240/0x240\n[    6.512601]  ? dev_printk_emit+0xa2/0xd3\n[    6.512612]  ? dev_vprintk_emit+0xc5/0xc5\n[    6.512621]  ? __kasan_check_write+0x14/0x20\n[    6.512634]  ? mutex_lock+0x8f/0xe0\n[    6.512643]  ? __mutex_lock_slowpath+0x20/0x20\n[    6.512655]  ps2_command+0x52/0x90\n[    6.512670]  elantech_ps2_command+0x4f/0xc0 [psmouse]\n[    6.512734]  elantech_change_report_id+0x1e6/0x256 [psmouse]\n[    6.512799]  ? elantech_report_trackpoint.constprop.0.cold+0xd/0xd [psmouse]\n[    6.512863]  ? ps2_command+0x7f/0x90\n[    6.512877]  elantech_query_info.cold+0x6bd/0x9ed [psmouse]\n[    6.512943]  ? elantech_setup_ps2+0x460/0x460 [psmouse]\n[    6.513005]  ? psmouse_reset+0x69/0xb0 [psmouse]\n[    6.513064]  ? psmouse_attr_set_helper+0x2a0/0x2a0 [psmouse]\n[    6.513122]  ? phys_pmd_init+0x30e/0x521\n[    6.513137]  elantech_init+0x8a/0x200 [psmouse]\n[    6.513200]  ? elantech_init_ps2+0xf0/0xf0 [psmouse]\n[    6.513249]  ? elantech_query_info+0x440/0x440 [psmouse]\n[    6.513296]  ? synaptics_send_cmd+0x60/0x60 [psmouse]\n[    6.513342]  ? elantech_query_info+0x440/0x440 [psmouse]\n[    6.513388]  ? psmouse_try_protocol+0x11e/0x170 [psmouse]\n[    6.513432]  psmouse_extensions+0x65d/0x6e0 [psmouse]\n[    6.513476]  ? psmouse_try_protocol+0x170/0x170 [psmouse]\n[    6.513519]  ? mutex_unlock+0x22/0x40\n[    6.513526]  ? ps2_command+0x7f/0x90\n[    6.513536]  ? psmouse_probe+0xa3/0xf0 [psmouse]\n[    6.513580]  psmouse_switch_protocol+0x27d/0x2e0 [psmouse]\n[    6.513624]  psmouse_connect+0x272/0x530 [psmouse]\n[    6.513669]  serio_driver_probe+0x55/0x70\n[    6.513679]  really_probe+0x190/0x720\n[    6.513689]  driver_probe_device+0x160/0x1f0\n[    6.513697]  device_driver_attach+0x119/0x130\n[    6.513705]  ? device_driver_attach+0x130/0x130\n[    6.513713]  __driver_attach+0xe7/0x1a0\n[    6.513720]  ? device_driver_attach+0x130/0x130\n[    6.513728]  bus_for_each_dev+0xfb/0x150\n[    6.513738]  ? subsys_dev_iter_exit+0x10/0x10\n[    6.513748]  ? _raw_write_unlock_bh+0x30/0x30\n[    6.513757]  driver_attach+0x2d/0x40\n[    6.513764]  serio_handle_event+0x199/0x3d0\n[    6.513775]  process_one_work+0x471/0x740\n[    6.513785]  worker_thread+0x2d2/0x790\n[    6.513794]  ? process_one_work+0x740/0x740\n[    6.513802]  kthread+0x1b4/0x1e0\n[    6.513809]  ? set_kthread_struct+0x80/0x80\n[    6.513816]  ret_from_fork+0x22/0x30\n\n[    6.513832] The buggy address belongs to the page:\n[    6.513838] page:00000000bc35e189 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1024d7\n[    6.513847] flags: 0x17ffffc0000000(node=0|zone=2|lastcpupid=0x1fffff)\n[    6.513860] raw: 0\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a7f95328c6f0afffdc4555f16e3bbab8bbf0d9be",
      "https://git.kernel.org/stable/c/676c572439e58b7ee6b7ca3f1e5595382921045c",
      "https://git.kernel.org/stable/c/dfd5b60b5342b6b505a104e48f08ad9b9bdbbd7b",
      "https://git.kernel.org/stable/c/1d72d9f960ccf1052a0630a68c3d358791dbdaaa"
    ],
    "受影响版本": [
      "9e4815cf178561104881e5d687ef69396aca1c8d",
      "dde807b4a44273fa5f62c0cb308295e6d6642550",
      "e4c9062717feda88900b566463228d1c4910af6d",
      "e4c9062717feda88900b566463228d1c4910af6d"
    ],
    "公开日期": "2024年03月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47092",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: VMX: Always clear vmx->fail on emulation_required\n\nRevert a relatively recent change that set vmx->fail if the vCPU is in L2\nand emulation_required is true, as that behavior is completely bogus.\nSetting vmx->fail and synthesizing a VM-Exit is contradictory and wrong:\n\n  (a) it's impossible to have both a VM-Fail and VM-Exit\n  (b) vmcs.EXIT_REASON is not modified on VM-Fail\n  (c) emulation_required refers to guest state and guest state checks are\n      always VM-Exits, not VM-Fails.\n\nFor KVM specifically, emulation_required is handled before nested exits\nin __vmx_handle_exit(), thus setting vmx->fail has no immediate effect,\ni.e. KVM calls into handle_invalid_guest_state() and vmx->fail is ignored.\nSetting vmx->fail can ultimately result in a WARN in nested_vmx_vmexit()\nfiring when tearing down the VM as KVM never expects vmx->fail to be set\nwhen L2 is active, KVM always reflects those errors into L1.\n\n  ------------[ cut here ]------------\n  WARNING: CPU: 0 PID: 21158 at arch/x86/kvm/vmx/nested.c:4548\n                                nested_vmx_vmexit+0x16bd/0x17e0\n                                arch/x86/kvm/vmx/nested.c:4547\n  Modules linked in:\n  CPU: 0 PID: 21158 Comm: syz-executor.1 Not tainted 5.16.0-rc3-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n  RIP: 0010:nested_vmx_vmexit+0x16bd/0x17e0 arch/x86/kvm/vmx/nested.c:4547\n  Code: <0f> 0b e9 2e f8 ff ff e8 57 b3 5d 00 0f 0b e9 00 f1 ff ff 89 e9 80\n  Call Trace:\n   vmx_leave_nested arch/x86/kvm/vmx/nested.c:6220 [inline]\n   nested_vmx_free_vcpu+0x83/0xc0 arch/x86/kvm/vmx/nested.c:330\n   vmx_free_vcpu+0x11f/0x2a0 arch/x86/kvm/vmx/vmx.c:6799\n   kvm_arch_vcpu_destroy+0x6b/0x240 arch/x86/kvm/x86.c:10989\n   kvm_vcpu_destroy+0x29/0x90 arch/x86/kvm/../../../virt/kvm/kvm_main.c:441\n   kvm_free_vcpus arch/x86/kvm/x86.c:11426 [inline]\n   kvm_arch_destroy_vm+0x3ef/0x6b0 arch/x86/kvm/x86.c:11545\n   kvm_destroy_vm arch/x86/kvm/../../../virt/kvm/kvm_main.c:1189 [inline]\n   kvm_put_kvm+0x751/0xe40 arch/x86/kvm/../../../virt/kvm/kvm_main.c:1220\n   kvm_vcpu_release+0x53/0x60 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3489\n   __fput+0x3fc/0x870 fs/file_table.c:280\n   task_work_run+0x146/0x1c0 kernel/task_work.c:164\n   exit_task_work include/linux/task_work.h:32 [inline]\n   do_exit+0x705/0x24f0 kernel/exit.c:832\n   do_group_exit+0x168/0x2d0 kernel/exit.c:929\n   get_signal+0x1740/0x2120 kernel/signal.c:2852\n   arch_do_signal_or_restart+0x9c/0x730 arch/x86/kernel/signal.c:868\n   handle_signal_work kernel/entry/common.c:148 [inline]\n   exit_to_user_mode_loop kernel/entry/common.c:172 [inline]\n   exit_to_user_mode_prepare+0x191/0x220 kernel/entry/common.c:207\n   __syscall_exit_to_user_mode_work kernel/entry/common.c:289 [inline]\n   syscall_exit_to_user_mode+0x2e/0x70 kernel/entry/common.c:300\n   do_syscall_64+0x53/0xd0 arch/x86/entry/common.c:86\n   entry_SYSCALL_64_after_hwframe+0x44/0xae",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e4e4e7cb229821cd215031abc47efdab5486a67c",
      "https://git.kernel.org/stable/c/a80dfc025924024d2c61a4c1b8ef62b2fce76a04"
    ],
    "受影响版本": [
      "c8607e4a086fae05efe5bffb47c5199c65e7216e",
      "c8607e4a086fae05efe5bffb47c5199c65e7216e"
    ],
    "公开日期": "2024年03月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47090",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/hwpoison: clear MF_COUNT_INCREASED before retrying get_any_page()\n\nHulk Robot reported a panic in put_page_testzero() when testing\nmadvise() with MADV_SOFT_OFFLINE.  The BUG() is triggered when retrying\nget_any_page().  This is because we keep MF_COUNT_INCREASED flag in\nsecond try but the refcnt is not increased.\n\n    page dumped because: VM_BUG_ON_PAGE(page_ref_count(page) == 0)\n    ------------[ cut here ]------------\n    kernel BUG at include/linux/mm.h:737!\n    invalid opcode: 0000 [#1] PREEMPT SMP\n    CPU: 5 PID: 2135 Comm: sshd Tainted: G    B             5.16.0-rc6-dirty #373\n    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\n    RIP: release_pages+0x53f/0x840\n    Call Trace:\n      free_pages_and_swap_cache+0x64/0x80\n      tlb_flush_mmu+0x6f/0x220\n      unmap_page_range+0xe6c/0x12c0\n      unmap_single_vma+0x90/0x170\n      unmap_vmas+0xc4/0x180\n      exit_mmap+0xde/0x3a0\n      mmput+0xa3/0x250\n      do_exit+0x564/0x1470\n      do_group_exit+0x3b/0x100\n      __do_sys_exit_group+0x13/0x20\n      __x64_sys_exit_group+0x16/0x20\n      do_syscall_64+0x34/0x80\n      entry_SYSCALL_64_after_hwframe+0x44/0xae\n    Modules linked in:\n    ---[ end trace e99579b570fe0649 ]---\n    RIP: 0010:release_pages+0x53f/0x840",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/1f207076740101fed87074a6bc924dbe806f08a5",
      "https://git.kernel.org/stable/c/c691e7575eff76e563b0199c23ec46bd454f43e3",
      "https://git.kernel.org/stable/c/2a57d83c78f889bf3f54eede908d0643c40d5418"
    ],
    "受影响版本": [
      "b94e02822debdf0cc473556aad7dcc859f216653",
      "b94e02822debdf0cc473556aad7dcc859f216653",
      "b94e02822debdf0cc473556aad7dcc859f216653"
    ],
    "公开日期": "2024年03月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47089",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nkfence: fix memory leak when cat kfence objects\n\nHulk robot reported a kmemleak problem:\n\n    unreferenced object 0xffff93d1d8cc02e8 (size 248):\n      comm \"cat\", pid 23327, jiffies 4624670141 (age 495992.217s)\n      hex dump (first 32 bytes):\n        00 40 85 19 d4 93 ff ff 00 10 00 00 00 00 00 00  .@..............\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n      backtrace:\n         seq_open+0x2a/0x80\n         full_proxy_open+0x167/0x1e0\n         do_dentry_open+0x1e1/0x3a0\n         path_openat+0x961/0xa20\n         do_filp_open+0xae/0x120\n         do_sys_openat2+0x216/0x2f0\n         do_sys_open+0x57/0x80\n         do_syscall_64+0x33/0x40\n         entry_SYSCALL_64_after_hwframe+0x44/0xa9\n    unreferenced object 0xffff93d419854000 (size 4096):\n      comm \"cat\", pid 23327, jiffies 4624670141 (age 495992.217s)\n      hex dump (first 32 bytes):\n        6b 66 65 6e 63 65 2d 23 32 35 30 3a 20 30 78 30  kfence-#250: 0x0\n        30 30 30 30 30 30 30 37 35 34 62 64 61 31 32 2d  0000000754bda12-\n      backtrace:\n         seq_read_iter+0x313/0x440\n         seq_read+0x14b/0x1a0\n         full_proxy_read+0x56/0x80\n         vfs_read+0xa5/0x1b0\n         ksys_read+0xa0/0xf0\n         do_syscall_64+0x33/0x40\n         entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nI find that we can easily reproduce this problem with the following\ncommands:\n\n\tcat /sys/kernel/debug/kfence/objects\n\techo scan > /sys/kernel/debug/kmemleak\n\tcat /sys/kernel/debug/kmemleak\n\nThe leaked memory is allocated in the stack below:\n\n    do_syscall_64\n      do_sys_open\n        do_dentry_open\n          full_proxy_open\n            seq_open            ---> alloc seq_file\n      vfs_read\n        full_proxy_read\n          seq_read\n            seq_read_iter\n              traverse          ---> alloc seq_buf\n\nAnd it should have been released in the following process:\n\n    do_syscall_64\n      syscall_exit_to_user_mode\n        exit_to_user_mode_prepare\n          task_work_run\n            ____fput\n              __fput\n                full_proxy_release  ---> free here\n\nHowever, the release function corresponding to file_operations is not\nimplemented in kfence.  As a result, a memory leak occurs.  Therefore,\nthe solution to this problem is to implement the corresponding release\nfunction.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2f06c8293d27f6337f907042c602c9c953988c48",
      "https://git.kernel.org/stable/c/0129ab1f268b6cf88825eae819b9b84aa0a85634"
    ],
    "受影响版本": [
      "0ce20dd840897b12ae70869c69f1ba34d6d16965",
      "0ce20dd840897b12ae70869c69f1ba34d6d16965"
    ],
    "公开日期": "2024年03月04日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47072",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix removed dentries still existing after log is synced\n\nWhen we move one inode from one directory to another and both the inode\nand its previous parent directory were logged before, we are not supposed\nto have the dentry for the old parent if we have a power failure after the\nlog is synced. Only the new dentry is supposed to exist.\n\nGenerally this works correctly, however there is a scenario where this is\nnot currently working, because the old parent of the file/directory that\nwas moved is not authoritative for a range that includes the dir index and\ndir item keys of the old dentry. This case is better explained with the\nfollowing example and reproducer:\n\n  # The test requires a very specific layout of keys and items in the\n  # fs/subvolume btree to trigger the bug. So we want to make sure that\n  # on whatever platform we are, we have the same leaf/node size.\n  #\n  # Currently in btrfs the node/leaf size can not be smaller than the page\n  # size (but it can be greater than the page size). So use the largest\n  # supported node/leaf size (64K).\n\n  $ mkfs.btrfs -f -n 65536 /dev/sdc\n  $ mount /dev/sdc /mnt\n\n  # \"testdir\" is inode 257.\n  $ mkdir /mnt/testdir\n  $ chmod 755 /mnt/testdir\n\n  # Create several empty files to have the directory \"testdir\" with its\n  # items spread over several leaves (7 in this case).\n  $ for ((i = 1; i <= 1200; i++)); do\n       echo -n > /mnt/testdir/file$i\n    done\n\n  # Create our test directory \"dira\", inode number 1458, which gets all\n  # its items in leaf 7.\n  #\n  # The BTRFS_DIR_ITEM_KEY item for inode 257 (\"testdir\") that points to\n  # the entry named \"dira\" is in leaf 2, while the BTRFS_DIR_INDEX_KEY\n  # item that points to that entry is in leaf 3.\n  #\n  # For this particular filesystem node size (64K), file count and file\n  # names, we endup with the directory entry items from inode 257 in\n  # leaves 2 and 3, as previously mentioned - what matters for triggering\n  # the bug exercised by this test case is that those items are not placed\n  # in leaf 1, they must be placed in a leaf different from the one\n  # containing the inode item for inode 257.\n  #\n  # The corresponding BTRFS_DIR_ITEM_KEY and BTRFS_DIR_INDEX_KEY items for\n  # the parent inode (257) are the following:\n  #\n  #    item 460 key (257 DIR_ITEM 3724298081) itemoff 48344 itemsize 34\n  #         location key (1458 INODE_ITEM 0) type DIR\n  #         transid 6 data_len 0 name_len 4\n  #         name: dira\n  #\n  # and:\n  #\n  #    item 771 key (257 DIR_INDEX 1202) itemoff 36673 itemsize 34\n  #         location key (1458 INODE_ITEM 0) type DIR\n  #         transid 6 data_len 0 name_len 4\n  #         name: dira\n\n  $ mkdir /mnt/testdir/dira\n\n  # Make sure everything done so far is durably persisted.\n  $ sync\n\n  # Now do a change to inode 257 (\"testdir\") that does not result in\n  # COWing leaves 2 and 3 - the leaves that contain the directory items\n  # pointing to inode 1458 (directory \"dira\").\n  #\n  # Changing permissions, the owner/group, updating or adding a xattr,\n  # etc, will not change (COW) leaves 2 and 3. So for the sake of\n  # simplicity change the permissions of inode 257, which results in\n  # updating its inode item and therefore change (COW) only leaf 1.\n\n  $ chmod 700 /mnt/testdir\n\n  # Now fsync directory inode 257.\n  #\n  # Since only the first leaf was changed/COWed, we log the inode item of\n  # inode 257 and only the dentries found in the first leaf, all have a\n  # key type of BTRFS_DIR_ITEM_KEY, and no keys of type\n  # BTRFS_DIR_INDEX_KEY, because they sort after the former type and none\n  # exist in the first leaf.\n  #\n  # We also log 3 items that represent ranges for dir items and dir\n  # indexes for which the log is authoritative:\n  #\n  # 1) a key of type BTRFS_DIR_LOG_ITEM_KEY, which indicates the log is\n  #    authoritative for all BTRFS_DIR_ITEM_KEY keys that have an offset\n  #    in the range [0, 2285968570] (the offset here is th\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6d0924c5b742036b4f20a0ffdf2b6cf3f963f5f6",
      "https://git.kernel.org/stable/c/54a40fc3a1da21b52dbf19f72fdc27a2ec740760"
    ],
    "受影响版本": [
      "64d6b281ba4db044c946158387c74e1149b9487e",
      "64d6b281ba4db044c946158387c74e1149b9487e"
    ],
    "公开日期": "2024年03月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47069",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nipc/mqueue, msg, sem: avoid relying on a stack reference past its expiry\n\ndo_mq_timedreceive calls wq_sleep with a stack local address.  The\nsender (do_mq_timedsend) uses this address to later call pipelined_send.\n\nThis leads to a very hard to trigger race where a do_mq_timedreceive\ncall might return and leave do_mq_timedsend to rely on an invalid\naddress, causing the following crash:\n\n  RIP: 0010:wake_q_add_safe+0x13/0x60\n  Call Trace:\n   __x64_sys_mq_timedsend+0x2a9/0x490\n   do_syscall_64+0x80/0x680\n   entry_SYSCALL_64_after_hwframe+0x44/0xa9\n  RIP: 0033:0x7f5928e40343\n\nThe race occurs as:\n\n1. do_mq_timedreceive calls wq_sleep with the address of `struct\n   ext_wait_queue` on function stack (aliased as `ewq_addr` here) - it\n   holds a valid `struct ext_wait_queue *` as long as the stack has not\n   been overwritten.\n\n2. `ewq_addr` gets added to info->e_wait_q[RECV].list in wq_add, and\n   do_mq_timedsend receives it via wq_get_first_waiter(info, RECV) to call\n   __pipelined_op.\n\n3. Sender calls __pipelined_op::smp_store_release(&this->state,\n   STATE_READY).  Here is where the race window begins.  (`this` is\n   `ewq_addr`.)\n\n4. If the receiver wakes up now in do_mq_timedreceive::wq_sleep, it\n   will see `state == STATE_READY` and break.\n\n5. do_mq_timedreceive returns, and `ewq_addr` is no longer guaranteed\n   to be a `struct ext_wait_queue *` since it was on do_mq_timedreceive's\n   stack.  (Although the address may not get overwritten until another\n   function happens to touch it, which means it can persist around for an\n   indefinite time.)\n\n6. do_mq_timedsend::__pipelined_op() still believes `ewq_addr` is a\n   `struct ext_wait_queue *`, and uses it to find a task_struct to pass to\n   the wake_q_add_safe call.  In the lucky case where nothing has\n   overwritten `ewq_addr` yet, `ewq_addr->task` is the right task_struct.\n   In the unlucky case, __pipelined_op::wake_q_add_safe gets handed a\n   bogus address as the receiver's task_struct causing the crash.\n\ndo_mq_timedsend::__pipelined_op() should not dereference `this` after\nsetting STATE_READY, as the receiver counterpart is now free to return.\nChange __pipelined_op to call wake_q_add_safe on the receiver's\ntask_struct returned by get_task_struct, instead of dereferencing `this`\nwhich sits on the receiver's stack.\n\nAs Manfred pointed out, the race potentially also exists in\nipc/msg.c::expunge_all and ipc/sem.c::wake_up_sem_queue_prepare.  Fix\nthose in the same way.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4528c0c323085e645b8765913b4a7fd42cf49b65",
      "https://git.kernel.org/stable/c/807fa14536b26803b858da878b643be72952a097",
      "https://git.kernel.org/stable/c/a11ddb37bf367e6b5239b95ca759e5389bb46048"
    ],
    "受影响版本": [
      "c5b2cbdbdac563f46ecd5e187253ab1abbd6fc04",
      "c5b2cbdbdac563f46ecd5e187253ab1abbd6fc04",
      "c5b2cbdbdac563f46ecd5e187253ab1abbd6fc04"
    ],
    "公开日期": "2024年03月01日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47051",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: fsl-lpspi: Fix PM reference leak in lpspi_prepare_xfer_hardware()\n\npm_runtime_get_sync will increment pm usage counter even it failed.\nForgetting to putting operation will result in reference leak here.\nFix it by replacing it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4a01ad002d2e03c399af536562693752af7c81b1",
      "https://git.kernel.org/stable/c/ce02e58ddf8658a4c3bed2296f32a5873b3f7cce",
      "https://git.kernel.org/stable/c/b8207bfc539cd07d15e753ff2d179c5b61c673b1",
      "https://git.kernel.org/stable/c/6a2b5cee0d31ab6cc51030c441135b0e31217282",
      "https://git.kernel.org/stable/c/a03675497970a93fcf25d81d9d92a59c2d7377a7"
    ],
    "受影响版本": [
      "944c01a889d97dc08e1b71f4ed868f4023fd6034",
      "944c01a889d97dc08e1b71f4ed868f4023fd6034",
      "944c01a889d97dc08e1b71f4ed868f4023fd6034",
      "944c01a889d97dc08e1b71f4ed868f4023fd6034",
      "944c01a889d97dc08e1b71f4ed868f4023fd6034"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47044",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nsched/fair: Fix shift-out-of-bounds in load_balance()\n\nSyzbot reported a handful of occurrences where an sd->nr_balance_failed can\ngrow to much higher values than one would expect.\n\nA successful load_balance() resets it to 0; a failed one increments\nit. Once it gets to sd->cache_nice_tries + 3, this *should* trigger an\nactive balance, which will either set it to sd->cache_nice_tries+1 or reset\nit to 0. However, in case the to-be-active-balanced task is not allowed to\nrun on env->dst_cpu, then the increment is done without any further\nmodification.\n\nThis could then be repeated ad nauseam, and would explain the absurdly high\nvalues reported by syzbot (86, 149). VincentG noted there is value in\nletting sd->cache_nice_tries grow, so the shift itself should be\nfixed. That means preventing:\n\n  \"\"\"\n  If the value of the right operand is negative or is greater than or equal\n  to the width of the promoted left operand, the behavior is undefined.\n  \"\"\"\n\nThus we need to cap the shift exponent to\n  BITS_PER_TYPE(typeof(lefthand)) - 1.\n\nI had a look around for other similar cases via coccinelle:\n\n  @expr@\n  position pos;\n  expression E1;\n  expression E2;\n  @@\n  (\n  E1 >> E2@pos\n  |\n  E1 >> E2@pos\n  )\n\n  @cst depends on expr@\n  position pos;\n  expression expr.E1;\n  constant cst;\n  @@\n  (\n  E1 >> cst@pos\n  |\n  E1 << cst@pos\n  )\n\n  @script:python depends on !cst@\n  pos << expr.pos;\n  exp << expr.E2;\n  @@\n  # Dirty hack to ignore constexpr\n  if exp.upper() != exp:\n     coccilib.report.print_report(pos[0], \"Possible UB shift here\")\n\nThe only other match in kernel/sched is rq_clock_thermal() which employs\nsched_thermal_decay_shift, and that exponent is already capped to 10, so\nthat one is fine.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/80862cbf76c2646f709a57c4517aefe0b094c774",
      "https://git.kernel.org/stable/c/2f3eab368e313dba35fc2f51ede778bf7b030b54",
      "https://git.kernel.org/stable/c/805cea93e66ca7deaaf6ad3b67224ce47c104c2f",
      "https://git.kernel.org/stable/c/39a2a6eb5c9b66ea7c8055026303b3aa681b49a5"
    ],
    "受影响版本": [
      "5a7f555904671c0737819fe4d19bd6143de3f6c0",
      "5a7f555904671c0737819fe4d19bd6143de3f6c0",
      "5a7f555904671c0737819fe4d19bd6143de3f6c0",
      "5a7f555904671c0737819fe4d19bd6143de3f6c0"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47034",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/64s: Fix pte update for kernel memory on radix\n\nWhen adding a PTE a ptesync is needed to order the update of the PTE\nwith subsequent accesses otherwise a spurious fault may be raised.\n\nradix__set_pte_at() does not do this for performance gains. For\nnon-kernel memory this is not an issue as any faults of this kind are\ncorrected by the page fault handler. For kernel memory these faults\nare not handled. The current solution is that there is a ptesync in\nflush_cache_vmap() which should be called when mapping from the\nvmalloc region.\n\nHowever, map_kernel_page() does not call flush_cache_vmap(). This is\ntroublesome in particular for code patching with Strict RWX on radix.\nIn do_patch_instruction() the page frame that contains the instruction\nto be patched is mapped and then immediately patched. With no ordering\nor synchronization between setting up the PTE and writing to the page\nit is possible for faults.\n\nAs the code patching is done using __put_user_asm_goto() the resulting\nfault is obscured - but using a normal store instead it can be seen:\n\n  BUG: Unable to handle kernel data access on write at 0xc008000008f24a3c\n  Faulting instruction address: 0xc00000000008bd74\n  Oops: Kernel access of bad area, sig: 11 [#1]\n  LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA PowerNV\n  Modules linked in: nop_module(PO+) [last unloaded: nop_module]\n  CPU: 4 PID: 757 Comm: sh Tainted: P           O      5.10.0-rc5-01361-ge3c1b78c8440-dirty #43\n  NIP:  c00000000008bd74 LR: c00000000008bd50 CTR: c000000000025810\n  REGS: c000000016f634a0 TRAP: 0300   Tainted: P           O       (5.10.0-rc5-01361-ge3c1b78c8440-dirty)\n  MSR:  9000000000009033 <SF,HV,EE,ME,IR,DR,RI,LE>  CR: 44002884  XER: 00000000\n  CFAR: c00000000007c68c DAR: c008000008f24a3c DSISR: 42000000 IRQMASK: 1\n\nThis results in the kind of issue reported here:\n  https://lore.kernel.org/linuxppc-dev/15AC5B0E-A221-4B8C-9039-FA96B8EF7C88@lca.pw/\n\nChris Riedl suggested a reliable way to reproduce the issue:\n  $ mount -t debugfs none /sys/kernel/debug\n  $ (while true; do echo function > /sys/kernel/debug/tracing/current_tracer ; echo nop > /sys/kernel/debug/tracing/current_tracer ; done) &\n\nTurning ftrace on and off does a large amount of code patching which\nin usually less then 5min will crash giving a trace like:\n\n   ftrace-powerpc: (____ptrval____): replaced (4b473b11) != old (60000000)\n   ------------[ ftrace bug ]------------\n   ftrace failed to modify\n   [<c000000000bf8e5c>] napi_busy_loop+0xc/0x390\n    actual:   11:3b:47:4b\n   Setting ftrace call site to call ftrace function\n   ftrace record flags: 80000001\n    (1)\n    expected tramp: c00000000006c96c\n   ------------[ cut here ]------------\n   WARNING: CPU: 4 PID: 809 at kernel/trace/ftrace.c:2065 ftrace_bug+0x28c/0x2e8\n   Modules linked in: nop_module(PO-) [last unloaded: nop_module]\n   CPU: 4 PID: 809 Comm: sh Tainted: P           O      5.10.0-rc5-01360-gf878ccaf250a #1\n   NIP:  c00000000024f334 LR: c00000000024f330 CTR: c0000000001a5af0\n   REGS: c000000004c8b760 TRAP: 0700   Tainted: P           O       (5.10.0-rc5-01360-gf878ccaf250a)\n   MSR:  900000000282b033 <SF,HV,VEC,VSX,EE,FP,ME,IR,DR,RI,LE>  CR: 28008848  XER: 20040000\n   CFAR: c0000000001a9c98 IRQMASK: 0\n   GPR00: c00000000024f330 c000000004c8b9f0 c000000002770600 0000000000000022\n   GPR04: 00000000ffff7fff c000000004c8b6d0 0000000000000027 c0000007fe9bcdd8\n   GPR08: 0000000000000023 ffffffffffffffd8 0000000000000027 c000000002613118\n   GPR12: 0000000000008000 c0000007fffdca00 0000000000000000 0000000000000000\n   GPR16: 0000000023ec37c5 0000000000000000 0000000000000000 0000000000000008\n   GPR20: c000000004c8bc90 c0000000027a2d20 c000000004c8bcd0 c000000002612fe8\n   GPR24: 0000000000000038 0000000000000030 0000000000000028 0000000000000020\n   GPR28: c000000000ff1b68 c000000000bf8e5c c00000000312f700 c000000000fbb9b0\n   NIP ftrace_bug+0x28c/0x2e8\n   LR  ftrace_bug+0x288/0x2e8\n   Call T\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/b3d5d0983388d6c4fb35f7d722556d5595f167a7",
      "https://git.kernel.org/stable/c/73f9dccb29e4f82574bec2765c0090cdb0404301",
      "https://git.kernel.org/stable/c/84c0762633f2a7ac8399e6b97d3b9bb8e6e1d50f",
      "https://git.kernel.org/stable/c/01ac203e2119d8922126886ddea309fb676f955f",
      "https://git.kernel.org/stable/c/e40c52ee67b155ad59f59e73ea136d02685f0e0d",
      "https://git.kernel.org/stable/c/b8b2f37cf632434456182e9002d63cbc4cccc50c"
    ],
    "受影响版本": [
      "f1cb8f9beba8699dd1b4518418191499e53f7b17",
      "f1cb8f9beba8699dd1b4518418191499e53f7b17",
      "f1cb8f9beba8699dd1b4518418191499e53f7b17",
      "f1cb8f9beba8699dd1b4518418191499e53f7b17",
      "f1cb8f9beba8699dd1b4518418191499e53f7b17",
      "f1cb8f9beba8699dd1b4518418191499e53f7b17"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47029",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nmt76: connac: fix kernel warning adding monitor interface\n\nFix the following kernel warning adding a monitor interface in\nmt76_connac_mcu_uni_add_dev routine.\n\n[  507.984882] ------------[ cut here ]------------\n[  507.989515] WARNING: CPU: 1 PID: 3017 at mt76_connac_mcu_uni_add_dev+0x178/0x190 [mt76_connac_lib]\n[  508.059379] CPU: 1 PID: 3017 Comm: ifconfig Not tainted 5.4.98 #0\n[  508.065461] Hardware name: MT7622_MT7531 RFB (DT)\n[  508.070156] pstate: 80000005 (Nzcv daif -PAN -UAO)\n[  508.074939] pc : mt76_connac_mcu_uni_add_dev+0x178/0x190 [mt76_connac_lib]\n[  508.081806] lr : mt7921_eeprom_init+0x1288/0x1cb8 [mt7921e]\n[  508.087367] sp : ffffffc013a33930\n[  508.090671] x29: ffffffc013a33930 x28: ffffff801e628ac0\n[  508.095973] x27: ffffff801c7f1200 x26: ffffff801c7eb008\n[  508.101275] x25: ffffff801c7eaef0 x24: ffffff801d025610\n[  508.106577] x23: ffffff801d022990 x22: ffffff801d024de8\n[  508.111879] x21: ffffff801d0226a0 x20: ffffff801c7eaee8\n[  508.117181] x19: ffffff801d0226a0 x18: 000000005d00b000\n[  508.122482] x17: 00000000ffffffff x16: 0000000000000000\n[  508.127785] x15: 0000000000000080 x14: ffffff801d704000\n[  508.133087] x13: 0000000000000040 x12: 0000000000000002\n[  508.138389] x11: 000000000000000c x10: 0000000000000000\n[  508.143691] x9 : 0000000000000020 x8 : 0000000000000001\n[  508.148992] x7 : 0000000000000000 x6 : 0000000000000000\n[  508.154294] x5 : ffffff801c7eaee8 x4 : 0000000000000006\n[  508.159596] x3 : 0000000000000001 x2 : 0000000000000000\n[  508.164898] x1 : ffffff801c7eac08 x0 : ffffff801d0226a0\n[  508.170200] Call trace:\n[  508.172640]  mt76_connac_mcu_uni_add_dev+0x178/0x190 [mt76_connac_lib]\n[  508.179159]  mt7921_eeprom_init+0x1288/0x1cb8 [mt7921e]\n[  508.184394]  drv_add_interface+0x34/0x88 [mac80211]\n[  508.189271]  ieee80211_add_virtual_monitor+0xe0/0xb48 [mac80211]\n[  508.195277]  ieee80211_do_open+0x86c/0x918 [mac80211]\n[  508.200328]  ieee80211_do_open+0x900/0x918 [mac80211]\n[  508.205372]  __dev_open+0xcc/0x150\n[  508.208763]  __dev_change_flags+0x134/0x198\n[  508.212937]  dev_change_flags+0x20/0x60\n[  508.216764]  devinet_ioctl+0x3e8/0x748\n[  508.220503]  inet_ioctl+0x1e4/0x350\n[  508.223983]  sock_do_ioctl+0x48/0x2a0\n[  508.227635]  sock_ioctl+0x310/0x4f8\n[  508.231116]  do_vfs_ioctl+0xa4/0xac0\n[  508.234681]  ksys_ioctl+0x44/0x90\n[  508.237985]  __arm64_sys_ioctl+0x1c/0x48\n[  508.241901]  el0_svc_common.constprop.1+0x7c/0x100\n[  508.246681]  el0_svc_handler+0x18/0x20\n[  508.250421]  el0_svc+0x8/0x1c8\n[  508.253465] ---[ end trace c7b90fee13d72c39 ]---\n[  508.261278] ------------[ cut here ]------------",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/2554b9cb4b5e097c6071ec3ed5bc7c665c477ca7",
      "https://git.kernel.org/stable/c/c996f0346e40e3b1ac2ebaf0681df898fb157f60"
    ],
    "受影响版本": [
      "d0e274af2f2e44b9d496f5d2c0431fdd2ea76fb8",
      "d0e274af2f2e44b9d496f5d2c0431fdd2ea76fb8"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47025",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/mediatek: Always enable the clk on resume\n\nIn mtk_iommu_runtime_resume always enable the clk, even\nif m4u_dom is null. Otherwise the 'suspend' cb might\ndisable the clk which is already disabled causing the warning:\n\n[    1.586104] infra_m4u already disabled\n[    1.586133] WARNING: CPU: 0 PID: 121 at drivers/clk/clk.c:952 clk_core_disable+0xb0/0xb8\n[    1.594391] mtk-iommu 10205000.iommu: bound 18001000.larb (ops mtk_smi_larb_component_ops)\n[    1.598108] Modules linked in:\n[    1.598114] CPU: 0 PID: 121 Comm: kworker/0:2 Not tainted 5.12.0-rc5 #69\n[    1.609246] mtk-iommu 10205000.iommu: bound 14027000.larb (ops mtk_smi_larb_component_ops)\n[    1.617487] Hardware name: Google Elm (DT)\n[    1.617491] Workqueue: pm pm_runtime_work\n[    1.620545] mtk-iommu 10205000.iommu: bound 19001000.larb (ops mtk_smi_larb_component_ops)\n\n[    1.627229] pstate: 60000085 (nZCv daIf -PAN -UAO -TCO BTYPE=--)\n[    1.659297] pc : clk_core_disable+0xb0/0xb8\n[    1.663475] lr : clk_core_disable+0xb0/0xb8\n[    1.667652] sp : ffff800011b9bbe0\n[    1.670959] x29: ffff800011b9bbe0 x28: 0000000000000000\n[    1.676267] x27: ffff800011448000 x26: ffff8000100cfd98\n[    1.681574] x25: ffff800011b9bd48 x24: 0000000000000000\n[    1.686882] x23: 0000000000000000 x22: ffff8000106fad90\n[    1.692189] x21: 000000000000000a x20: ffff0000c0048500\n[    1.697496] x19: ffff0000c0048500 x18: ffffffffffffffff\n[    1.702804] x17: 0000000000000000 x16: 0000000000000000\n[    1.708112] x15: ffff800011460300 x14: fffffffffffe0000\n[    1.713420] x13: ffff8000114602d8 x12: 0720072007200720\n[    1.718727] x11: 0720072007200720 x10: 0720072007200720\n[    1.724035] x9 : ffff800011b9bbe0 x8 : ffff800011b9bbe0\n[    1.729342] x7 : 0000000000000009 x6 : ffff8000114b8328\n[    1.734649] x5 : 0000000000000000 x4 : 0000000000000000\n[    1.739956] x3 : 00000000ffffffff x2 : ffff800011460298\n[    1.745263] x1 : 1af1d7de276f4500 x0 : 0000000000000000\n[    1.750572] Call trace:\n[    1.753010]  clk_core_disable+0xb0/0xb8\n[    1.756840]  clk_core_disable_lock+0x24/0x40\n[    1.761105]  clk_disable+0x20/0x30\n[    1.764501]  mtk_iommu_runtime_suspend+0x88/0xa8\n[    1.769114]  pm_generic_runtime_suspend+0x2c/0x48\n[    1.773815]  __rpm_callback+0xe0/0x178\n[    1.777559]  rpm_callback+0x24/0x88\n[    1.781041]  rpm_suspend+0xdc/0x470\n[    1.784523]  rpm_idle+0x12c/0x170\n[    1.787831]  pm_runtime_work+0xa8/0xc0\n[    1.791573]  process_one_work+0x1e8/0x360\n[    1.795580]  worker_thread+0x44/0x478\n[    1.799237]  kthread+0x150/0x158\n[    1.802460]  ret_from_fork+0x10/0x30\n[    1.806034] ---[ end trace 82402920ef64573b ]---\n[    1.810728] ------------[ cut here ]------------\n\nIn addition, we now don't need to enable the clock from the\nfunction mtk_iommu_hw_init since it is already enabled by the resume.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5cad9e2caa9613fdcd246bd4ebf0ffbec1cba2ca",
      "https://git.kernel.org/stable/c/b34ea31fe013569d42b7e8681ef3f717f77c5b72"
    ],
    "受影响版本": [
      "c0b57581b73be7b43f39e0dff201c93413f6a668",
      "c0b57581b73be7b43f39e0dff201c93413f6a668"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47012",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/siw: Fix a use after free in siw_alloc_mr\n\nOur code analyzer reported a UAF.\n\nIn siw_alloc_mr(), it calls siw_mr_add_mem(mr,..). In the implementation of\nsiw_mr_add_mem(), mem is assigned to mr->mem and then mem is freed via\nkfree(mem) if xa_alloc_cyclic() failed. Here, mr->mem still point to a\nfreed object. After, the execution continue up to the err_out branch of\nsiw_alloc_mr, and the freed mr->mem is used in siw_mr_drop_mem(mr).\n\nMy patch moves \"mr->mem = mem\" behind the if (xa_alloc_cyclic(..)<0) {}\nsection, to avoid the uaf.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/30b9e92d0b5e5d5dc1101ab856c17009537cbca4",
      "https://git.kernel.org/stable/c/608a4b90ece039940e9425ee2b39c8beff27e00c",
      "https://git.kernel.org/stable/c/3e22b88e02c194f6c80867abfef5cc09383461f4",
      "https://git.kernel.org/stable/c/ad9ce7188432650469a6c7625bf479f5ed0b6155",
      "https://git.kernel.org/stable/c/3093ee182f01689b89e9f8797b321603e5de4f63"
    ],
    "受影响版本": [
      "2251334dcac9eb337575d8767e2a6a7e81848f7f",
      "2251334dcac9eb337575d8767e2a6a7e81848f7f",
      "2251334dcac9eb337575d8767e2a6a7e81848f7f",
      "2251334dcac9eb337575d8767e2a6a7e81848f7f",
      "2251334dcac9eb337575d8767e2a6a7e81848f7f"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-46982",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: compress: fix race condition of overwrite vs truncate\n\npos_fsstress testcase complains a panic as belew:\n\n------------[ cut here ]------------\nkernel BUG at fs/f2fs/compress.c:1082!\ninvalid opcode: 0000 [#1] SMP PTI\nCPU: 4 PID: 2753477 Comm: kworker/u16:2 Tainted: G           OE     5.12.0-rc1-custom #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014\nWorkqueue: writeback wb_workfn (flush-252:16)\nRIP: 0010:prepare_compress_overwrite+0x4c0/0x760 [f2fs]\nCall Trace:\n f2fs_prepare_compress_overwrite+0x5f/0x80 [f2fs]\n f2fs_write_cache_pages+0x468/0x8a0 [f2fs]\n f2fs_write_data_pages+0x2a4/0x2f0 [f2fs]\n do_writepages+0x38/0xc0\n __writeback_single_inode+0x44/0x2a0\n writeback_sb_inodes+0x223/0x4d0\n __writeback_inodes_wb+0x56/0xf0\n wb_writeback+0x1dd/0x290\n wb_workfn+0x309/0x500\n process_one_work+0x220/0x3c0\n worker_thread+0x53/0x420\n kthread+0x12f/0x150\n ret_from_fork+0x22/0x30\n\nThe root cause is truncate() may race with overwrite as below,\nso that one reference count left in page can not guarantee the\npage attaching in mapping tree all the time, after truncation,\nlater find_lock_page() may return NULL pointer.\n\n- prepare_compress_overwrite\n - f2fs_pagecache_get_page\n - unlock_page\n\t\t\t\t\t- f2fs_setattr\n\t\t\t\t\t - truncate_setsize\n\t\t\t\t\t  - truncate_inode_page\n\t\t\t\t\t   - delete_from_page_cache\n - find_lock_page\n\nFix this by avoiding referencing updated page.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5639b73fd3bc6fc8ca72e3a9ac15aacaabd7ebff",
      "https://git.kernel.org/stable/c/64acb100fe3beb5d20184d0ae3307235bd3555c4",
      "https://git.kernel.org/stable/c/936158b15e2648253afb824d252c910c496d34b5",
      "https://git.kernel.org/stable/c/a949dc5f2c5cfe0c910b664650f45371254c0744"
    ],
    "受影响版本": [
      "4c8ff7095bef64fc47e996a938f7d57f9e077da3",
      "4c8ff7095bef64fc47e996a938f7d57f9e077da3",
      "4c8ff7095bef64fc47e996a938f7d57f9e077da3",
      "4c8ff7095bef64fc47e996a938f7d57f9e077da3"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-46964",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: qla2xxx: Reserve extra IRQ vectors\n\nCommit a6dcfe08487e (\"scsi: qla2xxx: Limit interrupt vectors to number of\nCPUs\") lowers the number of allocated MSI-X vectors to the number of CPUs.\n\nThat breaks vector allocation assumptions in qla83xx_iospace_config(),\nqla24xx_enable_msix() and qla2x00_iospace_config(). Either of the functions\ncomputes maximum number of qpairs as:\n\n  ha->max_qpairs = ha->msix_count - 1 (MB interrupt) - 1 (default\n                   response queue) - 1 (ATIO, in dual or pure target mode)\n\nmax_qpairs is set to zero in case of two CPUs and initiator mode. The\nnumber is then used to allocate ha->queue_pair_map inside\nqla2x00_alloc_queues(). No allocation happens and ha->queue_pair_map is\nleft NULL but the driver thinks there are queue pairs available.\n\nqla2xxx_queuecommand() tries to find a qpair in the map and crashes:\n\n  if (ha->mqenable) {\n          uint32_t tag;\n          uint16_t hwq;\n          struct qla_qpair *qpair = NULL;\n\n          tag = blk_mq_unique_tag(cmd->request);\n          hwq = blk_mq_unique_tag_to_hwq(tag);\n          qpair = ha->queue_pair_map[hwq]; # <- HERE\n\n          if (qpair)\n                  return qla2xxx_mqueuecommand(host, cmd, qpair);\n  }\n\n  BUG: kernel NULL pointer dereference, address: 0000000000000000\n  #PF: supervisor read access in kernel mode\n  #PF: error_code(0x0000) - not-present page\n  PGD 0 P4D 0\n  Oops: 0000 [#1] SMP PTI\n  CPU: 0 PID: 72 Comm: kworker/u4:3 Tainted: G        W         5.10.0-rc1+ #25\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.0.0-prebuilt.qemu-project.org 04/01/2014\n  Workqueue: scsi_wq_7 fc_scsi_scan_rport [scsi_transport_fc]\n  RIP: 0010:qla2xxx_queuecommand+0x16b/0x3f0 [qla2xxx]\n  Call Trace:\n   scsi_queue_rq+0x58c/0xa60\n   blk_mq_dispatch_rq_list+0x2b7/0x6f0\n   ? __sbitmap_get_word+0x2a/0x80\n   __blk_mq_sched_dispatch_requests+0xb8/0x170\n   blk_mq_sched_dispatch_requests+0x2b/0x50\n   __blk_mq_run_hw_queue+0x49/0xb0\n   __blk_mq_delay_run_hw_queue+0xfb/0x150\n   blk_mq_sched_insert_request+0xbe/0x110\n   blk_execute_rq+0x45/0x70\n   __scsi_execute+0x10e/0x250\n   scsi_probe_and_add_lun+0x228/0xda0\n   __scsi_scan_target+0xf4/0x620\n   ? __pm_runtime_resume+0x4f/0x70\n   scsi_scan_target+0x100/0x110\n   fc_scsi_scan_rport+0xa1/0xb0 [scsi_transport_fc]\n   process_one_work+0x1ea/0x3b0\n   worker_thread+0x28/0x3b0\n   ? process_one_work+0x3b0/0x3b0\n   kthread+0x112/0x130\n   ? kthread_park+0x80/0x80\n   ret_from_fork+0x22/0x30\n\nThe driver should allocate enough vectors to provide every CPU it's own HW\nqueue and still handle reserved (MB, RSP, ATIO) interrupts.\n\nThe change fixes the crash on dual core VM and prevents unbalanced QP\nallocation where nr_hw_queues is two less than the number of CPUs.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4ecd42dec858b6632c5f024fe13e9ad6c30f2734",
      "https://git.kernel.org/stable/c/0f86d66b38501e3ac66cf2d9f9f8ad6838bad0e6",
      "https://git.kernel.org/stable/c/f02d4086a8f36a0e1aaebf559b54cf24a177a486"
    ],
    "受影响版本": [
      "a6dcfe08487e5e83b6b4214c959a9577a9ed2d9f",
      "a6dcfe08487e5e83b6b4214c959a9577a9ed2d9f",
      "a6dcfe08487e5e83b6b4214c959a9577a9ed2d9f"
    ],
    "公开日期": "2024年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-46961",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nirqchip/gic-v3: Do not enable irqs when handling spurious interrups\n\nWe triggered the following error while running our 4.19 kernel\nwith the pseudo-NMI patches backported to it:\n\n[   14.816231] ------------[ cut here ]------------\n[   14.816231] kernel BUG at irq.c:99!\n[   14.816232] Internal error: Oops - BUG: 0 [#1] SMP\n[   14.816232] Process swapper/0 (pid: 0, stack limit = 0x(____ptrval____))\n[   14.816233] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O      4.19.95.aarch64 #14\n[   14.816233] Hardware name: evb (DT)\n[   14.816234] pstate: 80400085 (Nzcv daIf +PAN -UAO)\n[   14.816234] pc : asm_nmi_enter+0x94/0x98\n[   14.816235] lr : asm_nmi_enter+0x18/0x98\n[   14.816235] sp : ffff000008003c50\n[   14.816235] pmr_save: 00000070\n[   14.816237] x29: ffff000008003c50 x28: ffff0000095f56c0\n[   14.816238] x27: 0000000000000000 x26: ffff000008004000\n[   14.816239] x25: 00000000015e0000 x24: ffff8008fb916000\n[   14.816240] x23: 0000000020400005 x22: ffff0000080817cc\n[   14.816241] x21: ffff000008003da0 x20: 0000000000000060\n[   14.816242] x19: 00000000000003ff x18: ffffffffffffffff\n[   14.816243] x17: 0000000000000008 x16: 003d090000000000\n[   14.816244] x15: ffff0000095ea6c8 x14: ffff8008fff5ab40\n[   14.816244] x13: ffff8008fff58b9d x12: 0000000000000000\n[   14.816245] x11: ffff000008c8a200 x10: 000000008e31fca5\n[   14.816246] x9 : ffff000008c8a208 x8 : 000000000000000f\n[   14.816247] x7 : 0000000000000004 x6 : ffff8008fff58b9e\n[   14.816248] x5 : 0000000000000000 x4 : 0000000080000000\n[   14.816249] x3 : 0000000000000000 x2 : 0000000080000000\n[   14.816250] x1 : 0000000000120000 x0 : ffff0000095f56c0\n[   14.816251] Call trace:\n[   14.816251]  asm_nmi_enter+0x94/0x98\n[   14.816251]  el1_irq+0x8c/0x180                    (IRQ C)\n[   14.816252]  gic_handle_irq+0xbc/0x2e4\n[   14.816252]  el1_irq+0xcc/0x180                    (IRQ B)\n[   14.816253]  arch_timer_handler_virt+0x38/0x58\n[   14.816253]  handle_percpu_devid_irq+0x90/0x240\n[   14.816253]  generic_handle_irq+0x34/0x50\n[   14.816254]  __handle_domain_irq+0x68/0xc0\n[   14.816254]  gic_handle_irq+0xf8/0x2e4\n[   14.816255]  el1_irq+0xcc/0x180                    (IRQ A)\n[   14.816255]  arch_cpu_idle+0x34/0x1c8\n[   14.816255]  default_idle_call+0x24/0x44\n[   14.816256]  do_idle+0x1d0/0x2c8\n[   14.816256]  cpu_startup_entry+0x28/0x30\n[   14.816256]  rest_init+0xb8/0xc8\n[   14.816257]  start_kernel+0x4c8/0x4f4\n[   14.816257] Code: 940587f1 d5384100 b9401001 36a7fd01 (d4210000)\n[   14.816258] Modules linked in: start_dp(O) smeth(O)\n[   15.103092] ---[ end trace 701753956cb14aa8 ]---\n[   15.103093] Kernel panic - not syncing: Fatal exception in interrupt\n[   15.103099] SMP: stopping secondary CPUs\n[   15.103100] Kernel Offset: disabled\n[   15.103100] CPU features: 0x36,a2400218\n[   15.103100] Memory Limit: none\n\nwhich is cause by a 'BUG_ON(in_nmi())' in nmi_enter().\n\nFrom the call trace, we can find three interrupts (noted A, B, C above):\ninterrupt (A) is preempted by (B), which is further interrupted by (C).\n\nSubsequent investigations show that (B) results in nmi_enter() being\ncalled, but that it actually is a spurious interrupt. Furthermore,\ninterrupts are reenabled in the context of (B), and (C) fires with\nNMI priority. We end-up with a nested NMI situation, something\nwe definitely do not want to (and cannot) handle.\n\nThe bug here is that spurious interrupts should never result in any\nstate change, and we should just return to the interrupted context.\nMoving the handling of spurious interrupts as early as possible in\nthe GICv3 handler fixes this issue.\n\n[maz: rewrote commit message, corrected Fixes: tag]",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e7ea8e46e3b777be26aa855fe07778c415f24926",
      "https://git.kernel.org/stable/c/7be4db5c2b59fa77071c93ca4329876fb9777202",
      "https://git.kernel.org/stable/c/ea817ac1014c04f47885532b55f5d0898deadfba",
      "https://git.kernel.org/stable/c/3f72d3709f53af72835af7dc8b15ba61611a0e36",
      "https://git.kernel.org/stable/c/a97709f563a078e259bf0861cd259aa60332890a"
    ],
    "受影响版本": [
      "3f1f3234bc2db1c16b9818b9a15a5d58ad45251c",
      "3f1f3234bc2db1c16b9818b9a15a5d58ad45251c",
      "3f1f3234bc2db1c16b9818b9a15a5d58ad45251c",
      "3f1f3234bc2db1c16b9818b9a15a5d58ad45251c",
      "3f1f3234bc2db1c16b9818b9a15a5d58ad45251c"
    ],
    "公开日期": "2024年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-46960",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Return correct error code from smb2_get_enc_key\n\nAvoid a warning if the error percolates back up:\n\n[440700.376476] CIFS VFS: \\\\otters.example.com crypt_message: Could not get encryption key\n[440700.386947] ------------[ cut here ]------------\n[440700.386948] err = 1\n[440700.386977] WARNING: CPU: 11 PID: 2733 at /build/linux-hwe-5.4-p6lk6L/linux-hwe-5.4-5.4.0/lib/errseq.c:74 errseq_set+0x5c/0x70\n...\n[440700.397304] CPU: 11 PID: 2733 Comm: tar Tainted: G           OE     5.4.0-70-generic #78~18.04.1-Ubuntu\n...\n[440700.397334] Call Trace:\n[440700.397346]  __filemap_set_wb_err+0x1a/0x70\n[440700.397419]  cifs_writepages+0x9c7/0xb30 [cifs]\n[440700.397426]  do_writepages+0x4b/0xe0\n[440700.397444]  __filemap_fdatawrite_range+0xcb/0x100\n[440700.397455]  filemap_write_and_wait+0x42/0xa0\n[440700.397486]  cifs_setattr+0x68b/0xf30 [cifs]\n[440700.397493]  notify_change+0x358/0x4a0\n[440700.397500]  utimes_common+0xe9/0x1c0\n[440700.397510]  do_utimes+0xc5/0x150\n[440700.397520]  __x64_sys_utimensat+0x88/0xd0",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/e94851629c49c65b4fbb29a5725ddfd7988f8f20",
      "https://git.kernel.org/stable/c/e486f8397f3f14a7cadc166138141fdb14379a54",
      "https://git.kernel.org/stable/c/93f3339b22ba17e66f0808737467b70ba087eaec",
      "https://git.kernel.org/stable/c/aaa0faa5c28a91c362352d6b35dc3ed10df56fb0",
      "https://git.kernel.org/stable/c/f59a9242942fef0de7b926e438ba4eae65d4b4dd",
      "https://git.kernel.org/stable/c/b399c1a3ea0b9d10047ff266d65533df7f15532f",
      "https://git.kernel.org/stable/c/83728cbf366e334301091d5b808add468ab46b27"
    ],
    "受影响版本": [
      "61cfac6f267dabcf2740a7ec8a0295833b28b5f5",
      "61cfac6f267dabcf2740a7ec8a0295833b28b5f5",
      "61cfac6f267dabcf2740a7ec8a0295833b28b5f5",
      "61cfac6f267dabcf2740a7ec8a0295833b28b5f5",
      "61cfac6f267dabcf2740a7ec8a0295833b28b5f5",
      "61cfac6f267dabcf2740a7ec8a0295833b28b5f5",
      "61cfac6f267dabcf2740a7ec8a0295833b28b5f5"
    ],
    "公开日期": "2024年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-46959",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: Fix use-after-free with devm_spi_alloc_*\n\nWe can't rely on the contents of the devres list during\nspi_unregister_controller(), as the list is already torn down at the\ntime we perform devres_find() for devm_spi_release_controller. This\ncauses devices registered with devm_spi_alloc_{master,slave}() to be\nmistakenly identified as legacy, non-devm managed devices and have their\nreference counters decremented below 0.\n\n------------[ cut here ]------------\nWARNING: CPU: 1 PID: 660 at lib/refcount.c:28 refcount_warn_saturate+0x108/0x174\n[<b0396f04>] (refcount_warn_saturate) from [<b03c56a4>] (kobject_put+0x90/0x98)\n[<b03c5614>] (kobject_put) from [<b0447b4c>] (put_device+0x20/0x24)\n r4:b6700140\n[<b0447b2c>] (put_device) from [<b07515e8>] (devm_spi_release_controller+0x3c/0x40)\n[<b07515ac>] (devm_spi_release_controller) from [<b045343c>] (release_nodes+0x84/0xc4)\n r5:b6700180 r4:b6700100\n[<b04533b8>] (release_nodes) from [<b0454160>] (devres_release_all+0x5c/0x60)\n r8:b1638c54 r7:b117ad94 r6:b1638c10 r5:b117ad94 r4:b163dc10\n[<b0454104>] (devres_release_all) from [<b044e41c>] (__device_release_driver+0x144/0x1ec)\n r5:b117ad94 r4:b163dc10\n[<b044e2d8>] (__device_release_driver) from [<b044f70c>] (device_driver_detach+0x84/0xa0)\n r9:00000000 r8:00000000 r7:b117ad94 r6:b163dc54 r5:b1638c10 r4:b163dc10\n[<b044f688>] (device_driver_detach) from [<b044d274>] (unbind_store+0xe4/0xf8)\n\nInstead, determine the devm allocation state as a flag on the\ncontroller which is guaranteed to be stable during cleanup.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/62bb2c7f2411a0045c24831f11ecacfc35610815",
      "https://git.kernel.org/stable/c/8bf96425c90f5c1dcf3b7b9df568019a1d4b8a0e",
      "https://git.kernel.org/stable/c/8e029707f50a82c53172359c686b2536ab54e58c",
      "https://git.kernel.org/stable/c/28a5529068c51cdf0295ab1e11a99a3a909a03e4",
      "https://git.kernel.org/stable/c/001c8e83646ad3b847b18f6ac55a54367d917d74",
      "https://git.kernel.org/stable/c/c7fabe372a9031acd00498bc718ce27c253abfd1",
      "https://git.kernel.org/stable/c/cee78aa24578edac8cf00513dca618c0acc17cd7",
      "https://git.kernel.org/stable/c/8735248ebb918d25427965f0db07939ed0473ec6",
      "https://git.kernel.org/stable/c/794aaf01444d4e765e2b067cba01cc69c1c68ed9"
    ],
    "受影响版本": [
      "a4add022c1552b0d51a0b89a4781919d6ebac4f9",
      "0870525cf94bc27907e94ce99afb6d7239ffd2f5",
      "8c45a1c6c951bbe7f95db78fcab46f7337364468",
      "234b432c7b6184b2d6c5ba2c55f0dd5023c0edf0",
      "3e04a4976addbedcad326f47b0dd4efc570a1fac",
      "5e844cc37a5cbaa460e68f9a989d321d63088a89",
      "5e844cc37a5cbaa460e68f9a989d321d63088a89",
      "5e844cc37a5cbaa460e68f9a989d321d63088a89",
      "5e844cc37a5cbaa460e68f9a989d321d63088a89",
      "bd1a5b2307279029faaddbecf2f2ac25eaef8dc6"
    ],
    "公开日期": "2024年02月29日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-46957",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv/kprobe: fix kernel panic when invoking sys_read traced by kprobe\n\nThe execution of sys_read end up hitting a BUG_ON() in __find_get_block\nafter installing kprobe at sys_read, the BUG message like the following:\n\n[   65.708663] ------------[ cut here ]------------\n[   65.709987] kernel BUG at fs/buffer.c:1251!\n[   65.711283] Kernel BUG [#1]\n[   65.712032] Modules linked in:\n[   65.712925] CPU: 0 PID: 51 Comm: sh Not tainted 5.12.0-rc4 #1\n[   65.714407] Hardware name: riscv-virtio,qemu (DT)\n[   65.715696] epc : __find_get_block+0x218/0x2c8\n[   65.716835]  ra : __getblk_gfp+0x1c/0x4a\n[   65.717831] epc : ffffffe00019f11e ra : ffffffe00019f56a sp : ffffffe002437930\n[   65.719553]  gp : ffffffe000f06030 tp : ffffffe0015abc00 t0 : ffffffe00191e038\n[   65.721290]  t1 : ffffffe00191e038 t2 : 000000000000000a s0 : ffffffe002437960\n[   65.723051]  s1 : ffffffe00160ad00 a0 : ffffffe00160ad00 a1 : 000000000000012a\n[   65.724772]  a2 : 0000000000000400 a3 : 0000000000000008 a4 : 0000000000000040\n[   65.726545]  a5 : 0000000000000000 a6 : ffffffe00191e000 a7 : 0000000000000000\n[   65.728308]  s2 : 000000000000012a s3 : 0000000000000400 s4 : 0000000000000008\n[   65.730049]  s5 : 000000000000006c s6 : ffffffe00240f800 s7 : ffffffe000f080a8\n[   65.731802]  s8 : 0000000000000001 s9 : 000000000000012a s10: 0000000000000008\n[   65.733516]  s11: 0000000000000008 t3 : 00000000000003ff t4 : 000000000000000f\n[   65.734434]  t5 : 00000000000003ff t6 : 0000000000040000\n[   65.734613] status: 0000000000000100 badaddr: 0000000000000000 cause: 0000000000000003\n[   65.734901] Call Trace:\n[   65.735076] [<ffffffe00019f11e>] __find_get_block+0x218/0x2c8\n[   65.735417] [<ffffffe00020017a>] __ext4_get_inode_loc+0xb2/0x2f6\n[   65.735618] [<ffffffe000201b6c>] ext4_get_inode_loc+0x3a/0x8a\n[   65.735802] [<ffffffe000203380>] ext4_reserve_inode_write+0x2e/0x8c\n[   65.735999] [<ffffffe00020357a>] __ext4_mark_inode_dirty+0x4c/0x18e\n[   65.736208] [<ffffffe000206bb0>] ext4_dirty_inode+0x46/0x66\n[   65.736387] [<ffffffe000192914>] __mark_inode_dirty+0x12c/0x3da\n[   65.736576] [<ffffffe000180dd2>] touch_atime+0x146/0x150\n[   65.736748] [<ffffffe00010d762>] filemap_read+0x234/0x246\n[   65.736920] [<ffffffe00010d834>] generic_file_read_iter+0xc0/0x114\n[   65.737114] [<ffffffe0001f5d7a>] ext4_file_read_iter+0x42/0xea\n[   65.737310] [<ffffffe000163f2c>] new_sync_read+0xe2/0x15a\n[   65.737483] [<ffffffe000165814>] vfs_read+0xca/0xf2\n[   65.737641] [<ffffffe000165bae>] ksys_read+0x5e/0xc8\n[   65.737816] [<ffffffe000165c26>] sys_read+0xe/0x16\n[   65.737973] [<ffffffe000003972>] ret_from_syscall+0x0/0x2\n[   65.738858] ---[ end trace fe93f985456c935d ]---\n\nA simple reproducer looks like:\n\techo 'p:myprobe sys_read fd=%a0 buf=%a1 count=%a2' > /sys/kernel/debug/tracing/kprobe_events\n\techo 1 > /sys/kernel/debug/tracing/events/kprobes/myprobe/enable\n\tcat /sys/kernel/debug/tracing/trace\n\nHere's what happens to hit that BUG_ON():\n\n1) After installing kprobe at entry of sys_read, the first instruction\n   is replaced by 'ebreak' instruction on riscv64 platform.\n\n2) Once kernel reach the 'ebreak' instruction at the entry of sys_read,\n   it trap into the riscv breakpoint handler, where it do something to\n   setup for coming single-step of origin instruction, including backup\n   the 'sstatus' in pt_regs, followed by disable interrupt during single\n   stepping via clear 'SIE' bit of 'sstatus' in pt_regs.\n\n3) Then kernel restore to the instruction slot contains two instructions,\n   one is original instruction at entry of sys_read, the other is 'ebreak'.\n   Here it trigger a 'Instruction page fault' exception (value at 'scause'\n   is '0xc'), if PF is not filled into PageTabe for that slot yet.\n\n4) Again kernel trap into page fault exception handler, where it choose\n   different policy according to the state of running kprobe. Because\n   afte 2) the state is KPROBE_HIT_SS, so kernel reset the current kp\n---truncated---",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/fd0f06590d35c99f98d12c7984897ec4201a6263",
      "https://git.kernel.org/stable/c/b1ebaa0e1318494a7637099a26add50509e37964"
    ],
    "受影响版本": [
      "c22b0bcb1dd024cb9caad9230e3a387d8b061df5",
      "c22b0bcb1dd024cb9caad9230e3a387d8b061df5"
    ],
    "公开日期": "2024年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-46956",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtiofs: fix memory leak in virtio_fs_probe()\n\nWhen accidentally passing twice the same tag to qemu, kmemleak ended up\nreporting a memory leak in virtiofs.  Also, looking at the log I saw the\nfollowing error (that's when I realised the duplicated tag):\n\n  virtiofs: probe of virtio5 failed with error -17\n\nHere's the kmemleak log for reference:\n\nunreferenced object 0xffff888103d47800 (size 1024):\n  comm \"systemd-udevd\", pid 118, jiffies 4294893780 (age 18.340s)\n  hex dump (first 32 bytes):\n    00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00  .....N..........\n    ff ff ff ff ff ff ff ff 80 90 02 a0 ff ff ff ff  ................\n  backtrace:\n    [<000000000ebb87c1>] virtio_fs_probe+0x171/0x7ae [virtiofs]\n    [<00000000f8aca419>] virtio_dev_probe+0x15f/0x210\n    [<000000004d6baf3c>] really_probe+0xea/0x430\n    [<00000000a6ceeac8>] device_driver_attach+0xa8/0xb0\n    [<00000000196f47a7>] __driver_attach+0x98/0x140\n    [<000000000b20601d>] bus_for_each_dev+0x7b/0xc0\n    [<00000000399c7b7f>] bus_add_driver+0x11b/0x1f0\n    [<0000000032b09ba7>] driver_register+0x8f/0xe0\n    [<00000000cdd55998>] 0xffffffffa002c013\n    [<000000000ea196a2>] do_one_initcall+0x64/0x2e0\n    [<0000000008f727ce>] do_init_module+0x5c/0x260\n    [<000000003cdedab6>] __do_sys_finit_module+0xb5/0x120\n    [<00000000ad2f48c6>] do_syscall_64+0x33/0x40\n    [<00000000809526b5>] entry_SYSCALL_64_after_hwframe+0x44/0xae",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/310efc95c72c13faf855c692d19cd4d054d827c8",
      "https://git.kernel.org/stable/c/d19555ff225d0896a33246a49279e6d578095f15",
      "https://git.kernel.org/stable/c/9b9d60c0eb8ada99cce2a9ab5c15dffc523b01ae",
      "https://git.kernel.org/stable/c/5116e79fc6e6725b8acdad8b7e928a83ab7b47e6",
      "https://git.kernel.org/stable/c/c79c5e0178922a9e092ec8fed026750f39dcaef4"
    ],
    "受影响版本": [
      "a62a8ef9d97da23762a588592c8b8eb50a8deb6a",
      "a62a8ef9d97da23762a588592c8b8eb50a8deb6a",
      "a62a8ef9d97da23762a588592c8b8eb50a8deb6a",
      "a62a8ef9d97da23762a588592c8b8eb50a8deb6a",
      "a62a8ef9d97da23762a588592c8b8eb50a8deb6a"
    ],
    "公开日期": "2024年02月27日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-46910",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nARM: 9063/1: mm: reduce maximum number of CPUs if DEBUG_KMAP_LOCAL is enabled\n\nThe debugging code for kmap_local() doubles the number of per-CPU fixmap\nslots allocated for kmap_local(), in order to use half of them as guard\nregions. This causes the fixmap region to grow downwards beyond the start\nof its reserved window if the supported number of CPUs is large, and collide\nwith the newly added virtual DT mapping right below it, which is obviously\nnot good.\n\nOne manifestation of this is EFI boot on a kernel built with NR_CPUS=32\nand CONFIG_DEBUG_KMAP_LOCAL=y, which may pass the FDT in highmem, resulting\nin block entries below the fixmap region that the fixmap code misidentifies\nas fixmap table entries, and subsequently tries to dereference using a\nphys-to-virt translation that is only valid for lowmem. This results in a\ncryptic splat such as the one below.\n\n  ftrace: allocating 45548 entries in 89 pages\n  8<--- cut here ---\n  Unable to handle kernel paging request at virtual address fc6006f0\n  pgd = (ptrval)\n  [fc6006f0] *pgd=80000040207003, *pmd=00000000\n  Internal error: Oops: a06 [#1] SMP ARM\n  Modules linked in:\n  CPU: 0 PID: 0 Comm: swapper Not tainted 5.11.0+ #382\n  Hardware name: Generic DT based system\n  PC is at cpu_ca15_set_pte_ext+0x24/0x30\n  LR is at __set_fixmap+0xe4/0x118\n  pc : [<c041ac9c>]    lr : [<c04189d8>]    psr: 400000d3\n  sp : c1601ed8  ip : 00400000  fp : 00800000\n  r10: 0000071f  r9 : 00421000  r8 : 00c00000\n  r7 : 00c00000  r6 : 0000071f  r5 : ffade000  r4 : 4040171f\n  r3 : 00c00000  r2 : 4040171f  r1 : c041ac78  r0 : fc6006f0\n  Flags: nZcv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment none\n  Control: 30c5387d  Table: 40203000  DAC: 00000001\n  Process swapper (pid: 0, stack limit = 0x(ptrval))\n\nSo let's limit CONFIG_NR_CPUS to 16 when CONFIG_DEBUG_KMAP_LOCAL=y. Also,\nfix the BUILD_BUG_ON() check that was supposed to catch this, by checking\nwhether the region grows below the start address rather than above the end\naddress.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/5965ac11b1d5fcb38464728931649cd9df79c7c9",
      "https://git.kernel.org/stable/c/d624833f5984d484c5e3196f34b926f9e71dafee"
    ],
    "受影响版本": [
      "2a15ba82fa6ca3f35502b3060f22118a938d2889",
      "2a15ba82fa6ca3f35502b3060f22118a938d2889"
    ],
    "公开日期": "2024年02月27日"
  },
  {
    "设备品牌": "Yordam Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Library Automation System",
    "CVE编号": "CVE-2021-45479",
    "漏洞描述": "Improper Neutralization of Input During Web Page Generation vulnerability in Yordam Information Technologies Library Automation System allows Stored XSS.This issue affects Library Automation System: before 19.2.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0119"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年03月02日"
  },
  {
    "设备品牌": "Yordam Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Library Automation System",
    "CVE编号": "CVE-2021-45478",
    "漏洞描述": "Improper Handling of Parameters vulnerability in Bordam Information Technologies Library Automation System allows Collect Data as Provided by Users.This issue affects Library Automation System: before 19.2.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0119"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年03月02日"
  },
  {
    "设备品牌": "Yordam Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Library Automation System",
    "CVE编号": "CVE-2021-45477",
    "漏洞描述": "Improper Handling of Parameters vulnerability in Bordam Information Technologies Library Automation System allows Collect Data as Provided by Users.This issue affects Library Automation System: before 19.2.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0119"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年03月02日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-45310",
    "漏洞描述": "Sangoma Technologies Corporation Switchvox Version 102409 is affected by an information disclosure vulnerability due to an improper access restriction. Users information such as first name, last name, acount id, server uuid, email address, profile image, number, timestamps, etc can be extracted by sending an unauthenticated HTTP GET request to the https://Switchvox-IP/main?cmd=invalid_browser.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/IthacaLabs/Sangoma/tree/main/Switchvox_Version%20102409"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年02月14日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-45026",
    "漏洞描述": "ASG technologies ASG-Zena Cross Platform Server Enterprise Edition 4.2.1 is vulnerable to Cross Site Scripting (XSS).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "http://asg-zena.com",
      "http://asg.com",
      "https://docs.rocketsoftware.com/bundle/ven1649700711249/page/ayk1652945111726.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年06月17日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-45025",
    "漏洞描述": "ASG technologies ( A Rocket Software Company) ASG-Zena Cross Platform Server Enterprise Edition 4.2.1 is vulnerable to Cleartext Storage of Sensitive Information in a Cookie.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "http://asg-zena.com",
      "http://asg.com",
      "https://docs.rocketsoftware.com/bundle/ven1649700711249/page/ayk1652945111726.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年06月17日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-45024",
    "漏洞描述": "ASG technologies ( A Rocket Software Company) ASG-Zena Cross Platform Server Enterprise Edition 4.2.1 is vulnerable to XML External Entity (XXE).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "http://asg-zena.com",
      "http://asg.com",
      "https://docs.rocketsoftware.com/bundle/ven1649700711249/page/ayk1652945111726.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年06月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-4454",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: j1939: fix errant WARN_ON_ONCE in j1939_session_deactivate\n\nThe conclusion \"j1939_session_deactivate() should be called with a\nsession ref-count of at least 2\" is incorrect. In some concurrent\nscenarios, j1939_session_deactivate can be called with the session\nref-count less than 2. But there is not any problem because it\nwill check the session active state before session putting in\nj1939_session_deactivate_locked().\n\nHere is the concurrent scenario of the problem reported by syzbot\nand my reproduction log.\n\n        cpu0                            cpu1\n                                j1939_xtp_rx_eoma\nj1939_xtp_rx_abort_one\n                                j1939_session_get_by_addr [kref == 2]\nj1939_session_get_by_addr [kref == 3]\nj1939_session_deactivate [kref == 2]\nj1939_session_put [kref == 1]\n\t\t\t\tj1939_session_completed\n\t\t\t\tj1939_session_deactivate\n\t\t\t\tWARN_ON_ONCE(kref < 2)\n\n=====================================================\nWARNING: CPU: 1 PID: 21 at net/can/j1939/transport.c:1088 j1939_session_deactivate+0x5f/0x70\nCPU: 1 PID: 21 Comm: ksoftirqd/1 Not tainted 5.14.0-rc7+ #32\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1 04/01/2014\nRIP: 0010:j1939_session_deactivate+0x5f/0x70\nCall Trace:\n j1939_session_deactivate_activate_next+0x11/0x28\n j1939_xtp_rx_eoma+0x12a/0x180\n j1939_tp_recv+0x4a2/0x510\n j1939_can_recv+0x226/0x380\n can_rcv_filter+0xf8/0x220\n can_receive+0x102/0x220\n ? process_backlog+0xf0/0x2c0\n can_rcv+0x53/0xf0\n __netif_receive_skb_one_core+0x67/0x90\n ? process_backlog+0x97/0x2c0\n __netif_receive_skb+0x22/0x80",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/6950df42a03c9ac9290503ced3f371199cb68fa9",
      "https://git.kernel.org/stable/c/b6d44072117bba057d50f7a2f96e5d070c65926d",
      "https://git.kernel.org/stable/c/9ab896775f98ff54b68512f345eed178bf961084",
      "https://git.kernel.org/stable/c/1740a1e45eee65099a92fb502e1e67e63aad277d",
      "https://git.kernel.org/stable/c/d0553680f94c49bbe0e39eb50d033ba563b4212d"
    ],
    "受影响版本": [
      "7eef18c0479ba5d9f54fba30cd77c233ebca3eb1",
      "55dd22c5d029423f513fd849e633adf0e9c10d0c",
      "0c71437dd50dd687c15d8ca80b3b68f10bb21d63",
      "0c71437dd50dd687c15d8ca80b3b68f10bb21d63",
      "0c71437dd50dd687c15d8ca80b3b68f10bb21d63",
      "5e1fc537c1be332aef9621ca9146aeb3ba59522f"
    ],
    "公开日期": "2025年03月27日"
  },
  {
    "设备品牌": "UBIT Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Student Information Management System",
    "CVE编号": "CVE-2021-44197",
    "漏洞描述": "Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS) vulnerability in UBIT Information Technologies Student Information Management System.This issue affects Student Information Management System: before 20211126.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0131"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年03月07日"
  },
  {
    "设备品牌": "UBIT Information Technologies",
    "设备类型": "OTA",
    "产品型号": "Student Information Management System",
    "CVE编号": "CVE-2021-44196",
    "漏洞描述": "Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS) vulnerability in UBIT Information Technologies Student Information Management System.This issue affects Student Information Management System: before 20211126.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-23-0131"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2023年03月07日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-41497",
    "漏洞描述": "Null pointer reference in CMS_Conservative_increment_obj in RaRe-Technologies bounter version 1.01 and 1.10, allows attackers to conduct Denial of Service attacks by inputting a huge width of hash bucket.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/RaRe-Technologies/bounter/issues/47"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年12月17日"
  },
  {
    "设备品牌": "nextcloud",
    "设备类型": "OTA",
    "产品型号": "security-advisories",
    "CVE编号": "CVE-2021-41178",
    "漏洞描述": "Nextcloud is an open-source, self-hosted productivity platform. Prior to versions 20.0.13, 21.0.5, and 22.2.0, a file traversal vulnerability makes an attacker able to download arbitrary SVG images from the host system, including user provided files. This could also be leveraged into a XSS/phishing attack, an attacker could upload a malicious SVG file that mimics the Nextcloud login form and send a specially crafted link to victims. The XSS risk here is mitigated due to the fact that Nextcloud employs a strict Content-Security-Policy disallowing execution of arbitrary JavaScript. It is recommended that the Nextcloud Server be upgraded to 20.0.13, 21.0.5 or 22.2.0. There are no known workarounds aside from upgrading.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/nextcloud/security-advisories/security/advisories/GHSA-jp9c-vpr3-m5rf",
      "https://github.com/nextcloud/server/pull/28726",
      "https://hackerone.com/reports/1302155",
      "https://security.gentoo.org/glsa/202208-17"
    ],
    "受影响版本": [
      "20.0.13",
      ">= 21.0.0, < 21.0.5",
      "< 22.2.0"
    ],
    "公开日期": "2021年10月25日"
  },
  {
    "设备品牌": "caronc",
    "设备类型": "OTA",
    "产品型号": "apprise",
    "CVE编号": "CVE-2021-39229",
    "漏洞描述": "Apprise is an open source library which allows you to send a notification to almost all of the most popular notification services available. In affected versions users who use Apprise granting them access to the IFTTT plugin (which just comes out of the box) are subject to a denial of service attack on an inefficient regular expression. The vulnerable regular expression is [here](https://github.com/caronc/apprise/blob/0007eade20934ddef0aba38b8f1aad980cfff253/apprise/plugins/NotifyIFTTT.py#L356-L359). The problem has been patched in release version 0.9.5.1. Users who are unable to upgrade are advised to remove `apprise/plugins/NotifyIFTTT.py` to eliminate the service.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/caronc/apprise/security/advisories/GHSA-qhmp-h54x-38qr",
      "https://github.com/caronc/apprise/pull/436",
      "https://github.com/caronc/apprise/blob/0007eade20934ddef0aba38b8f1aad980cfff253/apprise/plugins/NotifyIFTTT.py#L356-L359"
    ],
    "受影响版本": [
      "< 0.9.5.1"
    ],
    "公开日期": "2021年09月20日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "samba",
    "CVE编号": "CVE-2021-3738",
    "漏洞描述": "In DCE/RPC it is possible to share the handles (cookies for resource state) between multiple connections via a mechanism called 'association groups'. These handles can reference connections to our sam.ldb database. However while the database was correctly shared, the user credentials state was only pointed at, and when one connection within that association group ended, the database would be left pointing at an invalid 'struct session_info'. The most likely outcome here is a crash, but it is possible that the use-after-free could instead allow different user state to be pointed at and this might allow more privileged access.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.samba.org/samba/security/CVE-2021-3738.html",
      "https://bugzilla.samba.org/show_bug.cgi?id=14468",
      "https://bugzilla.redhat.com/show_bug.cgi?id=2021726",
      "https://security.gentoo.org/glsa/202309-06"
    ],
    "受影响版本": [
      "Affects all versions since samba 4.0 | Fixedin samba v4.15.2, v4.14.10 and v4.13.14"
    ],
    "公开日期": "2022年03月02日"
  },
  {
    "设备品牌": "xwiki",
    "设备类型": "OTA",
    "产品型号": "xwiki-platform",
    "CVE编号": "CVE-2021-32732",
    "漏洞描述": "### Impact It's possible to know if a user has or not an account in a wiki related to an email address, and which username(s) is actually tied to that email by forging a request to the Forgot username page. Note that since this page does not have a CSRF check it's quite easy to perform a lot of those requests. ### Patches This issue has been patched in XWiki 12.10.5 and 13.2RC1. Two different patches are provided: - a first one to fix the CSRF problem - a more complex one that now relies on sending an email for the Forgot username process. ### Workarounds It's possible to fix the problem without uprading by editing the ForgotUsername page in version below 13.x, to use the following code: https://github.com/xwiki/xwiki-platform/blob/69548c0320cbd772540cf4668743e69f879812cf/xwiki-platform-core/xwiki-platform-administration/xwiki-platform-administration-ui/src/main/resources/XWiki/ForgotUsername.xml#L39-L123 In version after 13.x it's also possible to edit manually the forgotusername.vm file, but it's really encouraged to upgrade the version here. ### References * https://jira.xwiki.org/browse/XWIKI-18384 * https://jira.xwiki.org/browse/XWIKI-18408 ### For more information If you have any questions or comments about this advisory: * Open an issue in [Jira XWiki](https://jira.xwiki.org) * Email us at [security ML](mailto:security@xwiki.org)",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-vh5c-jqfg-mhrh",
      "https://github.com/xwiki/xwiki-platform/commit/69548c0320cbd772540cf4668743e69f879812cf",
      "https://github.com/xwiki/xwiki-platform/commit/f0440dfcbba705e03f7565cd88893dde57ca3fa8",
      "https://jira.xwiki.org/browse/XWIKI-18384",
      "https://jira.xwiki.org/browse/XWIKI-18408"
    ],
    "受影响版本": [
      "< 12.10.5 ",
      ">= 13.0, < 13.2RC1"
    ],
    "公开日期": "2022年02月04日"
  },
  {
    "设备品牌": "tensorflow",
    "设备类型": "OTA",
    "产品型号": "tensorflow",
    "CVE编号": "CVE-2021-29614",
    "漏洞描述": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.io.decode_raw` produces incorrect results and crashes the Python interpreter when combining `fixed_length` and wider datatypes. The implementation of the padded version(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) is buggy due to a confusion about pointer arithmetic rules. First, the code computes(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) the width of each output element by dividing the `fixed_length` value to the size of the type argument. The `fixed_length` argument is also used to determine the size needed for the output tensor(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79). This is followed by reencoding code(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94). The erroneous code is the last line above: it is moving the `out_data` pointer by `fixed_length * sizeof(T)` bytes whereas it only copied at most `fixed_length` bytes from the input. This results in parts of the input not being decoded into the output. Furthermore, because the pointer advance is far wider than desired, this quickly leads to writing to outside the bounds of the backing data. This OOB write leads to interpreter crash in the reproducer mentioned here, but more severe attacks can be mounted too, given that this gadget allows writing to periodically placed locations in memory. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-8pmx-p244-g88h",
      "https://github.com/tensorflow/tensorflow/commit/698e01511f62a3c185754db78ebce0eee1f0184d"
    ],
    "受影响版本": [
      "< 2.1.4",
      ">= 2.2.0, < 2.2.3",
      ">= 2.3.0, < 2.3.3",
      ">= 2.4.0, < 2.4.2"
    ],
    "公开日期": "2021年05月14日"
  },
  {
    "设备品牌": "tensorflow",
    "设备类型": "OTA",
    "产品型号": "tensorflow",
    "CVE编号": "CVE-2021-29540",
    "漏洞描述": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow to occur in `Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/1b0296c3b8dd9bd948f924aa8cd62f87dbb7c3da/tensorflow/core/kernels/conv_grad_filter_ops.cc#L495-L497) computes the size of the filter tensor but does not validate that it matches the number of elements in `filter_sizes`. Later, when reading/writing to this buffer, code uses the value computed here, instead of the number of elements in the tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
    "攻击向量": "LOCAL",
    "厂商补丁链接": [
      "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-xgc3-m89p-vr3x",
      "https://github.com/tensorflow/tensorflow/commit/c570e2ecfc822941335ad48f6e10df4e21f11c96"
    ],
    "受影响版本": [
      "< 2.1.4",
      ">= 2.2.0, < 2.2.3",
      ">= 2.3.0, < 2.3.3",
      ">= 2.4.0, < 2.4.2"
    ],
    "公开日期": "2021年05月14日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-29398",
    "漏洞描述": "Directory traversal in /northstar/Common/NorthFileManager/fileManagerObjects.jsp Northstar Technologies Inc NorthStar Club Management 6.3 allows remote unauthenticated users to browse and list the directories across the entire filesystem of the host of the web application.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://Ardent-Security.com",
      "https://ardent-security.com/en/advisory/asa-2021-06/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年02月04日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-29397",
    "漏洞描述": "Cleartext Transmission of Sensitive Information in /northstar/Admin/login.jsp in Northstar Technologies Inc NorthStar Club Management 6.3 allows remote local user to intercept users credentials transmitted in cleartext over HTTP.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://Ardent-Security.com",
      "https://ardent-security.com/en/advisory/asa-2021-05/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年02月04日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-29396",
    "漏洞描述": "Systemic Insecure Permissions in Northstar Technologies Inc NorthStar Club Management 6.3 allows remote unauthenticated users to use various functionalities without authentication.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://Ardent-Security.com",
      "https://ardent-security.com/en/advisory/asa-2021-04/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年02月04日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-29395",
    "漏洞描述": "Directory travesal in /northstar/filemanager/download.jsp in Northstar Technologies Inc NorthStar Club Management 6.3 allows remote unauthenticated users to download arbitrary files, including JSP source code, across the filesystem of the host of the web application.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://Ardent-Security.com",
      "https://ardent-security.com/en/advisory/asa-2021-03/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年02月04日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-29394",
    "漏洞描述": "Account Hijacking in /northstar/Admin/changePassword.jsp in Northstar Technologies Inc NorthStar Club Management 6.3 allows remote authenticated users to change the password of any targeted user accounts via lack of proper authorization in the user-controlled \"userID\" parameter of the HTTP POST request.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://ardent-security.com",
      "https://ardent-security.com/en/advisory/asa-2021-02/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年02月04日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-29393",
    "漏洞描述": "Remote Code Execution in cominput.jsp and comoutput.jsp in Northstar Technologies Inc NorthStar Club Management 6.3 allows remote unauthenticated users to inject and execute arbitrary system commands via the unsanitized user-controlled \"command\" and \"commandvalues\" parameters.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://ardent-security.com",
      "https://ardent-security.com/en/advisory/asa-2021-01/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年02月04日"
  },
  {
    "设备品牌": "Xen",
    "设备类型": "OTA",
    "产品型号": "xen",
    "CVE编号": "CVE-2021-28698",
    "漏洞描述": "long running loops in grant table handling In order to properly monitor resource use, Xen maintains information on the grant mappings a domain may create to map grants offered by other domains. In the process of carrying out certain actions, Xen would iterate over all such entries, including ones which aren't in use anymore and some which may have been created but never used. If the number of entries for a given domain is large enough, this iterating of the entire table may tie up a CPU for too long, starving other domains or causing issues in the hypervisor itself. Note that a domain may map its own grants, i.e. there is no need for multiple domains to be involved here. A pair of \"cooperating\" guests may, however, cause the effects to be more severe.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://xenbits.xenproject.org/xsa/advisory-380.txt",
      "http://www.openwall.com/lists/oss-security/2021/09/01/2",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LPRVHW4J4ZCPPOHZEWP5MOJT7XDGFFPJ/",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/FZCNPSRPGFCQRYE2BI4D4Q4SCE56ANV2/",
      "https://www.debian.org/security/2021/dsa-4977",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/2VQCFAPBNGBBAOMJZG6QBREOG5IIDZID/",
      "https://security.gentoo.org/glsa/202208-23"
    ],
    "受影响版本": [
      "4.14.x"
    ],
    "公开日期": "2021年08月27日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-28271",
    "漏洞描述": "Soyal Technologies SOYAL 701Server 9.0.1 suffers from an elevation of privileges vulnerability which can be used by an authenticated user to change the executable file with a binary choice. The vulnerability is due to improper permissions with the 'F' flag (Full) for 'Everyone'and 'Authenticated Users' group.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.zeroscience.mk/en/vulnerabilities",
      "https://www.exploit-db.com/exploits/49678",
      "https://www.zeroscience.mk/en/vulnerabilities/ZSL-2021-5633.php"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年04月27日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-26758",
    "漏洞描述": "Privilege Escalation in LiteSpeed Technologies OpenLiteSpeed web server version 1.7.8 allows attackers to gain root terminal access and execute commands on the host system.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/litespeedtech/openlitespeed/issues/217",
      "https://www.exploit-db.com/exploits/49556",
      "https://docs.unsafe-inline.com/0day/openlitespeed-web-server-1.7.8-command-injection-to-privilege-escalation-cve-2021-26758"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年04月07日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-26596",
    "漏洞描述": "An issue was discovered in Nokia NetAct 18A. A malicious user can change a filename of an uploaded file to include JavaScript code, which is then stored and executed by a victim's web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. Here, the /netact/sct filename parameter is used.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.gruppotim.it/redteam",
      "https://www.trusted-introducer.org/directory/teams/nokia-psirt.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年03月25日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-26540",
    "漏洞描述": "Apostrophe Technologies sanitize-html before 2.3.2 does not properly validate the hostnames set by the \"allowedIframeHostnames\" option when the \"allowIframeRelativeUrls\" is set to true, which allows attackers to bypass hostname whitelist for iframe element, related using an src value that starts with \"/\\\\example.com\".",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/apostrophecms/sanitize-html/blob/main/CHANGELOG.md#232-2021-01-26",
      "https://github.com/apostrophecms/sanitize-html/pull/460",
      "https://advisory.checkmarx.net/advisory/CX-2021-4309"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年02月08日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2021-26539",
    "漏洞描述": "Apostrophe Technologies sanitize-html before 2.3.1 does not properly handle internationalized domain name (IDN) which could allow an attacker to bypass hostname whitelist validation set by the \"allowedIframeHostnames\" option.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/apostrophecms/sanitize-html/blob/main/CHANGELOG.md#231-2021-01-22",
      "https://github.com/apostrophecms/sanitize-html/pull/458",
      "https://advisory.checkmarx.net/advisory/CX-2021-4308"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年02月08日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "unisharp/laravel-filemanager",
    "CVE编号": "CVE-2021-23814",
    "漏洞描述": "This affects versions of the package unisharp/laravel-filemanager before 2.6.2. The upload() function does not sufficiently validate the file type when uploading.\r\rAn attacker may be able to reproduce the following steps:\r\r1. Install a package with a web Laravel application.\r2. Navigate to the Upload window\r3. Upload an image file, then capture the request\r4. Edit the request contents with a malicious file (webshell)\r5. Enter the path of file uploaded on URL - Remote Code Execution\r\r\r**Note:** Prevention for bad extensions can be done by using a whitelist in the config file(lfm.php). Corresponding document can be found in [here](https://unisharp.github.io/laravel-filemanager/configfolder-categories).",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://security.snyk.io/vuln/SNYK-PHP-UNISHARPLARAVELFILEMANAGER-1567199",
      "https://github.com/UniSharp/laravel-filemanager/blob/master/src/Controllers/UploadController.php%23L26",
      "https://github.com/UniSharp/laravel-filemanager/releases/tag/v2.5.1",
      "https://github.com/UniSharp/laravel-filemanager/issues/1113",
      "https://github.com/UniSharp/laravel-filemanager/releases/tag/v2.6.2"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2021年12月17日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "github.com/pires/go-proxyproto",
    "CVE编号": "CVE-2021-23351",
    "漏洞描述": "The package github.com/pires/go-proxyproto before 0.5.0 are vulnerable to Denial of Service (DoS) via the parseVersion1() function. The reader in this package is a default bufio.Reader wrapping a net.Conn. It will read from the connection until it finds a newline. Since no limits are implemented in the code, a deliberately malformed V1 header could be used to exhaust memory in a server process using this code - and create a DoS. This can be exploited by sending a stream starting with PROXY and continuing to send data (which does not contain a newline) until the target stops acknowledging. The risk here is small, because only trusted sources should be allowed to send proxy protocol headers.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMPIRESGOPROXYPROTO-1081577",
      "https://github.com/pires/go-proxyproto/pull/71",
      "https://github.com/pires/go-proxyproto/issues/69",
      "https://github.com/pires/go-proxyproto/commit/7f48261db810703d173f27f3309a808cc2b49b8b",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/4BNVGJMVI3ZTZ675EFPUHPGXCKCGSX46/",
      "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/C36IBVOZXRTWM7MGTRUTOM56P5RR74VU/"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2021年03月08日"
  },
  {
    "设备品牌": "Oracle Corporation",
    "设备类型": "OTA",
    "产品型号": "Cloud Infrastructure",
    "CVE编号": "CVE-2021-2320",
    "漏洞描述": "Vulnerability in the Oracle Cloud Infrastructure Storage Gateway product of Oracle Storage Gateway (component: Management Console). The supported version that is affected is Prior to 1.4. Easily exploitable vulnerability allows high privileged attacker with network access via HTTP to compromise Oracle Cloud Infrastructure Storage Gateway. While the vulnerability is in Oracle Cloud Infrastructure Storage Gateway, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in takeover of Oracle Cloud Infrastructure Storage Gateway. Note: Updating the Oracle Cloud Infrastructure Storage Gateway to version 1.4 or later will address these vulnerabilities. Download the latest version of Oracle Cloud Infrastructure Storage Gateway from <a href=\" https://www.oracle.com/downloads/cloud/oci-storage-gateway-downloads.html\">here. Refer to Document <a href=\"https://support.oracle.com/rs?type=doc&id=2768897.1\">2768897.1 for more details. CVSS 3.1 Base Score 9.1 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H).",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.oracle.com/security-alerts/cpuapr2021.html"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2021年04月22日"
  },
  {
    "设备品牌": "Oracle Corporation",
    "设备类型": "OTA",
    "产品型号": "Cloud Infrastructure",
    "CVE编号": "CVE-2021-2319",
    "漏洞描述": "Vulnerability in the Oracle Cloud Infrastructure Storage Gateway product of Oracle Storage Gateway (component: Management Console). The supported version that is affected is Prior to 1.4. Easily exploitable vulnerability allows high privileged attacker with network access via HTTP to compromise Oracle Cloud Infrastructure Storage Gateway. While the vulnerability is in Oracle Cloud Infrastructure Storage Gateway, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in takeover of Oracle Cloud Infrastructure Storage Gateway. Note: Updating the Oracle Cloud Infrastructure Storage Gateway to version 1.4 or later will address these vulnerabilities. Download the latest version of Oracle Cloud Infrastructure Storage Gateway from <a href=\" https://www.oracle.com/downloads/cloud/oci-storage-gateway-downloads.html\">here. Refer to Document <a href=\"https://support.oracle.com/rs?type=doc&id=2768897.1\">2768897.1 for more details. CVSS 3.1 Base Score 9.1 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H).",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.oracle.com/security-alerts/cpuapr2021.html"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2021年04月22日"
  },
  {
    "设备品牌": "Oracle Corporation",
    "设备类型": "OTA",
    "产品型号": "Cloud Infrastructure",
    "CVE编号": "CVE-2021-2318",
    "漏洞描述": "Vulnerability in the Oracle Cloud Infrastructure Storage Gateway product of Oracle Storage Gateway (component: Management Console). The supported version that is affected is Prior to 1.4. Easily exploitable vulnerability allows high privileged attacker with network access via HTTP to compromise Oracle Cloud Infrastructure Storage Gateway. While the vulnerability is in Oracle Cloud Infrastructure Storage Gateway, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in takeover of Oracle Cloud Infrastructure Storage Gateway. Note: Updating the Oracle Cloud Infrastructure Storage Gateway to version 1.4 or later will address these vulnerabilities. Download the latest version of Oracle Cloud Infrastructure Storage Gateway from <a href=\" https://www.oracle.com/downloads/cloud/oci-storage-gateway-downloads.html\">here. Refer to Document <a href=\"https://support.oracle.com/rs?type=doc&id=2768897.1\">2768897.1 for more details. CVSS 3.1 Base Score 9.1 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H).",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.oracle.com/security-alerts/cpuapr2021.html"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2021年04月22日"
  },
  {
    "设备品牌": "Oracle Corporation",
    "设备类型": "OTA",
    "产品型号": "Cloud Infrastructure",
    "CVE编号": "CVE-2021-2317",
    "漏洞描述": "Vulnerability in the Oracle Cloud Infrastructure Storage Gateway product of Oracle Storage Gateway (component: Management Console). The supported version that is affected is Prior to 1.4. Easily exploitable vulnerability allows unauthenticated attacker with network access via HTTP to compromise Oracle Cloud Infrastructure Storage Gateway. While the vulnerability is in Oracle Cloud Infrastructure Storage Gateway, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in takeover of Oracle Cloud Infrastructure Storage Gateway. Note: Updating the Oracle Cloud Infrastructure Storage Gateway to version 1.4 or later will address these vulnerabilities. Download the latest version of Oracle Cloud Infrastructure Storage Gateway from <a href=\" https://www.oracle.com/downloads/cloud/oci-storage-gateway-downloads.html\">here. Refer to Document <a href=\"https://support.oracle.com/rs?type=doc&id=2768897.1\">2768897.1 for more details. CVSS 3.1 Base Score 10.0 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H).",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.oracle.com/security-alerts/cpuapr2021.html"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2021年04月22日"
  },
  {
    "设备品牌": "Oracle Corporation",
    "设备类型": "OTA",
    "产品型号": "Cloud Infrastructure",
    "CVE编号": "CVE-2021-2257",
    "漏洞描述": "Vulnerability in the Oracle Storage Cloud Software Appliance product of Oracle Storage Gateway (component: Management Console). The supported version that is affected is Prior to 16.3.1.4.2. Easily exploitable vulnerability allows high privileged attacker with network access via HTTP to compromise Oracle Storage Cloud Software Appliance. While the vulnerability is in Oracle Storage Cloud Software Appliance, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in unauthorized read access to a subset of Oracle Storage Cloud Software Appliance accessible data. Note: Updating the Oracle Storage Cloud Software Appliance to version 16.3.1.4.2 or later will address these vulnerabilities. Download the latest version of Oracle Storage Cloud Software Appliance from <a href=\" https://www.oracle.com/downloads/cloud/oscsa-downloads.html\">here. Refer to Document <a href=\"https://support.oracle.com/rstype=doc&id=2768897.1\">2768897.1 for more details. CVSS 3.1 Base Score 4.1 (Confidentiality impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:L/I:N/A:N).",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.oracle.com/security-alerts/cpuapr2021.html"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2021年04月22日"
  },
  {
    "设备品牌": "Oracle Corporation",
    "设备类型": "OTA",
    "产品型号": "Cloud Infrastructure",
    "CVE编号": "CVE-2021-2256",
    "漏洞描述": "Vulnerability in the Oracle Storage Cloud Software Appliance product of Oracle Storage Gateway (component: Management Console). The supported version that is affected is Prior to 16.3.1.4.2. Easily exploitable vulnerability allows unauthenticated attacker with network access via HTTP to compromise Oracle Storage Cloud Software Appliance. While the vulnerability is in Oracle Storage Cloud Software Appliance, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in takeover of Oracle Storage Cloud Software Appliance. Note: Updating the Oracle Storage Cloud Software Appliance to version 16.3.1.4.2 or later will address these vulnerabilities. Download the latest version of Oracle Storage Cloud Software Appliance from <a href=\" https://www.oracle.com/downloads/cloud/oscsa-downloads.html\">here. Refer to Document <a href=\"https://support.oracle.com/rstype=doc&id=2768897.1\">2768897.1 for more details. CVSS 3.1 Base Score 10.0 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H).",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.oracle.com/security-alerts/cpuapr2021.html"
    ],
    "受影响版本": [
      "unspecified"
    ],
    "公开日期": "2021年04月22日"
  },
  {
    "设备品牌": "glpi-project",
    "设备类型": "OTA",
    "产品型号": "glpi",
    "CVE编号": "CVE-2021-21313",
    "漏洞描述": "GLPI is open source software which stands for Gestionnaire Libre de Parc Informatique and it is a Free Asset and IT Management Software package. In GLPI before verison 9.5.4, there is a vulnerability in the /ajax/common.tabs.php endpoint, indeed, at least two parameters _target and id are not properly sanitized. Here are two payloads (due to two different exploitations depending on which parameter you act) to exploit the vulnerability:/ajax/common.tabs.php?_target=javascript:alert(document.cookie)&_itemtype=DisplayPreference&_glpi_tab=DisplayPreference$2&id=258&displaytype=Ticket (Payload triggered if you click on the button). /ajax/common.tabs.php?_target=/front/ticket.form.php&_itemtype=Ticket&_glpi_tab=Ticket$1&id=(){};(function%20(){alert(document.cookie);})();function%20a&#.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/glpi-project/glpi/security/advisories/GHSA-h4hj-mrpg-xfgx",
      "https://github.com/glpi-project/glpi/releases/tag/9.5.4"
    ],
    "受影响版本": [
      "< 9.5.4"
    ],
    "公开日期": "2021年03月03日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "docsify",
    "CVE编号": "CVE-2020-7680",
    "漏洞描述": "docsify prior to 4.11.4 is susceptible to Cross-site Scripting (XSS). Docsify.js uses fragment identifiers (parameters after # sign) to load resources from server-side .md files. Due to lack of validation here, it is possible to provide external URLs after the /#/ (domain.com/#//attacker.com) and render arbitrary JavaScript/HTML inside docsify page.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/docsifyjs/docsify/issues/1126",
      "https://github.com/docsifyjs/docsify/pull/1128",
      "https://snyk.io/vuln/SNYK-JS-DOCSIFY-567099",
      "http://packetstormsecurity.com/files/158515/Docsify.js-4.11.4-Cross-Site-Scripting.html",
      "http://seclists.org/fulldisclosure/2021/Feb/71",
      "http://packetstormsecurity.com/files/161495/docsify-4.11.6-Cross-Site-Scripting.html"
    ],
    "受影响版本": [
      "All versions prior to 4.11.4"
    ],
    "公开日期": "2020年07月20日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "node-prompt-here",
    "CVE编号": "CVE-2020-7602",
    "漏洞描述": "node-prompt-here through 1.0.1 allows execution of arbitrary commands. The \"runCommand()\" is called by \"getDevices()\" function in file \"linux/manager.js\", which is required by the \"index. process.env.NM_CLI\" in the file \"linux/manager.js\". This function is used to construct the argument of function \"execSync()\", which can be controlled by users without any sanitization.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://snyk.io/vuln/SNYK-JS-NODEPROMPTHERE-560115"
    ],
    "受影响版本": [
      "All versions including 1.0.1"
    ],
    "公开日期": "2020年03月15日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "Check Point Endpoint Security Client for Windows",
    "CVE编号": "CVE-2020-6014",
    "漏洞描述": "Check Point Endpoint Security Client for Windows, with Anti-Bot or Threat Emulation blades installed, before version E83.20, tries to load a non-existent DLL during a query for the Domain Name. An attacker with administrator privileges can leverage this to gain code execution within a Check Point Software Technologies signed binary, where under certain circumstances may cause the client to terminate.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://supportcontent.checkpoint.com/solutions?id=sk168081"
    ],
    "受影响版本": [
      "before E83.20"
    ],
    "公开日期": "2020年10月30日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "Trading Technologies Messaging",
    "CVE编号": "CVE-2020-5779",
    "漏洞描述": "A flaw in Trading Technologies Messaging 7.1.28.3 (ttmd.exe) relates to invalid parameter handling when calling strcpy_s() with an invalid parameter (i.e., a long src string parameter) as a part of processing a type 4 message sent to default TCP RequestPort 10200. It's been observed that ttmd.exe terminates as a result.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.tenable.com/security/research/tra-2020-52"
    ],
    "受影响版本": [
      "Trading Technologies Messaging 7.1.28.3"
    ],
    "公开日期": "2020年09月02日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "Trading Technologies Messaging",
    "CVE编号": "CVE-2020-5778",
    "漏洞描述": "A flaw exists in Trading Technologies Messaging 7.1.28.3 (ttmd.exe) due to improper validation of user-supplied data when processing a type 8 message sent to default TCP RequestPort 10200. An unauthenticated, remote attacker can exploit this issue, via a specially crafted message, to terminate ttmd.exe.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.tenable.com/security/research/tra-2020-52"
    ],
    "受影响版本": [
      "Trading Technologies Messaging 7.1.28.3"
    ],
    "公开日期": "2020年09月02日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2020-36789",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: dev: can_get_echo_skb(): prevent call to kfree_skb() in hard IRQ context\n\nIf a driver calls can_get_echo_skb() during a hardware IRQ (which is often, but\nnot always, the case), the 'WARN_ON(in_irq)' in\nnet/core/skbuff.c#skb_release_head_state() might be triggered, under network\ncongestion circumstances, together with the potential risk of a NULL pointer\ndereference.\n\nThe root cause of this issue is the call to kfree_skb() instead of\ndev_kfree_skb_irq() in net/core/dev.c#enqueue_to_backlog().\n\nThis patch prevents the skb to be freed within the call to netif_rx() by\nincrementing its reference count with skb_get(). The skb is finally freed by\none of the in-irq-context safe functions: dev_consume_skb_any() or\ndev_kfree_skb_any(). The \"any\" version is used because some drivers might call\ncan_get_echo_skb() in a normal context.\n\nThe reason for this issue to occur is that initially, in the core network\nstack, loopback skb were not supposed to be received in hardware IRQ context.\nThe CAN stack is an exeption.\n\nThis bug was previously reported back in 2017 in [1] but the proposed patch\nnever got accepted.\n\nWhile [1] directly modifies net/core/dev.c, we try to propose here a\nsmoother modification local to CAN network stack (the assumption\nbehind is that only CAN devices are affected by this issue).\n\n[1] http://lore.kernel.org/r/57a3ffb6-3309-3ad5-5a34-e93c3fe3614d@cetitec.com",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/248b71ce92d4f3a574b2537f9838f48e892618f4",
      "https://git.kernel.org/stable/c/451187b20431924d13fcfecc500d7cd2d9951bac",
      "https://git.kernel.org/stable/c/3a922a85701939624484e7f2fd07d32beed00d25",
      "https://git.kernel.org/stable/c/7e4cf2ec0ca236c3e5f904239cec6efe1f3baf22",
      "https://git.kernel.org/stable/c/ab46748bf98864f9c3f5559060bf8caf9df2b41e",
      "https://git.kernel.org/stable/c/87530b557affe01c764de32dbeb58cdf47234574",
      "https://git.kernel.org/stable/c/2283f79b22684d2812e5c76fc2280aae00390365"
    ],
    "受影响版本": [
      "39549eef3587f1c1e8c65c88a2400d10fd30ea17",
      "39549eef3587f1c1e8c65c88a2400d10fd30ea17",
      "39549eef3587f1c1e8c65c88a2400d10fd30ea17",
      "39549eef3587f1c1e8c65c88a2400d10fd30ea17",
      "39549eef3587f1c1e8c65c88a2400d10fd30ea17",
      "39549eef3587f1c1e8c65c88a2400d10fd30ea17",
      "39549eef3587f1c1e8c65c88a2400d10fd30ea17"
    ],
    "公开日期": "2025年04月17日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2020-36784",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: cadence: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in functions cdns_i2c_master_xfer and cdns_reg_slave.\n\nHowever, pm_runtime_get_sync will increment pm usage counter\neven failed. Forgetting to putting operation will result in a\nreference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/30410519328c94367e561fd878e5f0d3a0303585",
      "https://git.kernel.org/stable/c/d57ff04e0ed6f3be1682ae861ead33f879225e07",
      "https://git.kernel.org/stable/c/a45fc41beed8e0fe31864619c34aa00797fb60c1",
      "https://git.kernel.org/stable/c/23ceb8462dc6f4b4decdb5536a7e5fc477cdf0b6"
    ],
    "受影响版本": [
      "7fa32329ca03148fb2c07b4ef3247b8fc0488d6a",
      "7fa32329ca03148fb2c07b4ef3247b8fc0488d6a",
      "7fa32329ca03148fb2c07b4ef3247b8fc0488d6a",
      "7fa32329ca03148fb2c07b4ef3247b8fc0488d6a"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2020-36783",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: img-scb: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in functions img_i2c_xfer and img_i2c_init.\n\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/4734c4b1d9573c9d20bbc46cf37dde095ee011b8",
      "https://git.kernel.org/stable/c/e80ae8bde41266d3b8bf012460b6593851766006",
      "https://git.kernel.org/stable/c/96c4a03658d661666c360959aa80cdabfe2972ed",
      "https://git.kernel.org/stable/c/7ee35cde1e810ad6ca589980b9ec2b7b62946a5b",
      "https://git.kernel.org/stable/c/223125e37af8a641ea4a09747a6a52172fc4b903"
    ],
    "受影响版本": [
      "93222bd9b966105f43418fd336654ad10045783a",
      "93222bd9b966105f43418fd336654ad10045783a",
      "93222bd9b966105f43418fd336654ad10045783a",
      "93222bd9b966105f43418fd336654ad10045783a",
      "93222bd9b966105f43418fd336654ad10045783a"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2020-36782",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: imx-lpi2c: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in lpi2c_imx_master_enable.\n\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/815859cb1d2302e74f11bf6894bceace9ca9eb4a",
      "https://git.kernel.org/stable/c/cc49d206414240483bb93ffa3d80243e6a776916",
      "https://git.kernel.org/stable/c/bb300acc867e937edc2a6898e92b21f88e4e4e66",
      "https://git.kernel.org/stable/c/b100650d80cd2292f6c152f5f2943b5944b3e8ce",
      "https://git.kernel.org/stable/c/278e5bbdb9a94fa063c0f9bcde2479d0b8042462"
    ],
    "受影响版本": [
      "13d6eb20fc79a1e606307256dad4098375539a09",
      "13d6eb20fc79a1e606307256dad4098375539a09",
      "13d6eb20fc79a1e606307256dad4098375539a09",
      "13d6eb20fc79a1e606307256dad4098375539a09",
      "13d6eb20fc79a1e606307256dad4098375539a09"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2020-36781",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: imx: fix reference leak when pm_runtime_get_sync fails\n\nIn i2c_imx_xfer() and i2c_imx_remove(), the pm reference count\nis not expected to be incremented on return.\n\nHowever, pm_runtime_get_sync will increment pm reference count\neven failed. Forgetting to putting operation will result in a\nreference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/3a0cdd336d92c429b51a79bf4f64b17eafa0325d",
      "https://git.kernel.org/stable/c/1ecc0ebc2ebbad4a22a670a07d27a21fa0b59c77",
      "https://git.kernel.org/stable/c/ff406f6cd09c273337ab4854292e4aca48f8affd",
      "https://git.kernel.org/stable/c/47ff617217ca6a13194fcb35c6c3a0c57c080693"
    ],
    "受影响版本": [
      "3a5ee18d2a32bda6b9a1260136f6805848e3839d",
      "3a5ee18d2a32bda6b9a1260136f6805848e3839d",
      "3a5ee18d2a32bda6b9a1260136f6805848e3839d",
      "3a5ee18d2a32bda6b9a1260136f6805848e3839d"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2020-36780",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: sprd: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in sprd_i2c_master_xfer() and sprd_i2c_remove().\n\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/7e1764312440c5df9dfe6b436035a03673b0c1b9",
      "https://git.kernel.org/stable/c/e547640cee7981fd751d2c9cde3a61bdb678b755",
      "https://git.kernel.org/stable/c/9223505e938ba3db5907e058f4209770cff2f2a7",
      "https://git.kernel.org/stable/c/d3406ab52097328a3bc4cbe124bfd8f6d51fb86f",
      "https://git.kernel.org/stable/c/3a4f326463117cee3adcb72999ca34a9aaafda93"
    ],
    "受影响版本": [
      "8b9ec0719834fe66146d138d62ed66cef025c864",
      "8b9ec0719834fe66146d138d62ed66cef025c864",
      "8b9ec0719834fe66146d138d62ed66cef025c864",
      "8b9ec0719834fe66146d138d62ed66cef025c864",
      "8b9ec0719834fe66146d138d62ed66cef025c864"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2020-36779",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: stm32f7: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in these stm32f7_i2c_xx serious functions.\n\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c323b270a52a26aa8038a4d1fd9a850904a41166",
      "https://git.kernel.org/stable/c/d791b90f5c5e5aa8ccf9e33386c16bd2b7e333a4",
      "https://git.kernel.org/stable/c/c7ea772c9fcf711ed566814b92eecaffc0e2bfd0",
      "https://git.kernel.org/stable/c/2c662660ce2bd3b09dae21a9a9ac9395e1e6c00b"
    ],
    "受影响版本": [
      "ea6dd25deeb5b797a145be7f860e3085e7d104c3",
      "ea6dd25deeb5b797a145be7f860e3085e7d104c3",
      "ea6dd25deeb5b797a145be7f860e3085e7d104c3",
      "ea6dd25deeb5b797a145be7f860e3085e7d104c3"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2020-36778",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: xiic: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in xiic_xfer and xiic_i2c_remove.\n\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/c977426db644ba476938125597947979e8aba725",
      "https://git.kernel.org/stable/c/e2ba996577eaea423694dc69ae43d56f1410a22b",
      "https://git.kernel.org/stable/c/a42ac16e6573f19c78f556ea292f5b534fcc4514",
      "https://git.kernel.org/stable/c/a85c5c7a3aa8041777ff691400b4046e56149fd3"
    ],
    "受影响版本": [
      "10b17004a74c384c6f410af355b0d6d7a168f613",
      "10b17004a74c384c6f410af355b0d6d7a168f613",
      "10b17004a74c384c6f410af355b0d6d7a168f613",
      "10b17004a74c384c6f410af355b0d6d7a168f613"
    ],
    "公开日期": "2024年02月28日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-36489",
    "漏洞描述": "Dropouts Technologies LLP Air Share v1.2 was discovered to contain a cross-site scripting (XSS) vulnerability in the devicename parameter. This vulnerability allows attackers to execute arbitrary web scripts or HTML via a crafted payload in the devicename information.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.vulnerability-lab.com/get_content.php?id=2204"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年10月22日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-35766",
    "漏洞描述": "The test suite in libopendkim in OpenDKIM through 2.10.3 allows local users to gain privileges via a symlink attack against the /tmp/testkeys file (related to t-testdata.h, t-setup.c, and t-cleanup.c). NOTE: this is applicable to persons who choose to engage in the \"A number of self-test programs are included here for unit-testing the library\" situation.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/trusteddomainproject/OpenDKIM/issues/113"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2020年12月28日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-35677",
    "漏洞描述": "BigProf Online Invoicing System before 4.0 fails to adequately sanitize fields for HTML characters upon an administrator using admin/pageEditGroup.php to create a new group, resulting in Stored XSS. The caveat here is that an attacker would need administrative privileges in order to create the payload. One might think this completely mitigates the privilege-escalation impact as there is only one high-privileged role. However, it was discovered that the endpoint responsible for creating the group lacks CSRF protection.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://labs.ingredous.com/2020/07/13/ois-groupedit-xss/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2020年12月24日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-29050",
    "漏洞描述": "SphinxSearch in Sphinx Technologies Sphinx through 3.1.1 allows directory traversal (in conjunction with CVE-2019-14511) because the mysql client can be used for CALL SNIPPETS and load_file operations on a full pathname (e.g., a file in the /etc directory). NOTE: this is unrelated to CMUSphinx.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://blog.wirhabenstil.de/2019/08/19/sphinxsearch-0-0-0-09306-cve-2019-14511/",
      "https://security-tracker.debian.org/tracker/CVE-2020-29050",
      "https://lists.debian.org/debian-lts-announce/2022/01/msg00009.html"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2022年01月07日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-23061",
    "漏洞描述": "Dropouts Technologies LLP Super Backup v2.0.5 was discovered to contain an issue in the path parameter of the `list` and `download` module which allows attackers to perform a directory traversal via a change to the path variable to request the local list command.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.vulnerability-lab.com/get_content.php?id=2200"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年10月22日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-23042",
    "漏洞描述": "Dropouts Technologies LLP Super Backup v2.0.5 was discovered to contain a cross-site scripting (XSS) vulnerability in the path parameter of the `list` and `download` module. This vulnerability allows attackers to execute arbitrary web scripts or HTML via a crafted GET request.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.vulnerability-lab.com/get_content.php?id=2201"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年10月22日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-23041",
    "漏洞描述": "Dropouts Technologies LLP Air Share v1.2 was discovered to contain a cross-site scripting (XSS) vulnerability in the path parameter of the `list` and `download` exception-handling. This vulnerability allows attackers to execute arbitrary web scripts or HTML via a crafted GET request.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.vulnerability-lab.com/get_content.php?id=2204"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年10月22日"
  },
  {
    "设备品牌": "Juniper Networks",
    "设备类型": "OTA",
    "产品型号": "Junos OS",
    "CVE编号": "CVE-2020-1625",
    "漏洞描述": "The kernel memory usage represented as \"temp\" via 'show system virtual-memory' may constantly increase when Integrated Routing and Bridging (IRB) is configured with multiple underlay physical interfaces, and one interface flaps. This memory leak can affect running daemons (processes), leading to an extended Denial of Service (DoS) condition. Usage of \"temp\" virtual memory, shown here by a constantly increasing value of outstanding Requests, can be monitored by executing the 'show system virtual-memory' command as shown below: user@junos> show system virtual-memory |match \"fpc|type|temp\" fpc0: -------------------------------------------------------------------------- Type InUse MemUse HighUse Requests Size(s) temp 2023 431K - 10551 16,32,64,128,256,512,1024,2048,4096,65536,262144,1048576,2097152,4194304,8388608 fpc1: -------------------------------------------------------------------------- Type InUse MemUse HighUse Requests Size(s) temp 2020 431K - 6460 16,32,64,128,256,512,1024,2048,4096,65536,262144,1048576,2097152,4194304,8388608 user@junos> show system virtual-memory |match \"fpc|type|temp\" fpc0: -------------------------------------------------------------------------- Type InUse MemUse HighUse Requests Size(s) temp 2023 431K - 16101 16,32,64,128,256,512,1024,2048,4096,65536,262144,1048576,2097152,4194304,8388608 fpc1: -------------------------------------------------------------------------- Type InUse MemUse HighUse Requests Size(s) temp 2020 431K - 6665 16,32,64,128,256,512,1024,2048,4096,65536,262144,1048576,2097152,4194304,8388608 user@junos> show system virtual-memory |match \"fpc|type|temp\" fpc0: -------------------------------------------------------------------------- Type InUse MemUse HighUse Requests Size(s) temp 2023 431K - 21867 16,32,64,128,256,512,1024,2048,4096,65536,262144,1048576,2097152,4194304,8388608 fpc1: -------------------------------------------------------------------------- Type InUse MemUse HighUse Requests Size(s) temp 2020 431K - 6858 16,32,64,128,256,512,1024,2048,4096,65536,262144,1048576,2097152,4194304,8388608 This issue affects Juniper Networks Junos OS: 16.1 versions prior to 16.1R7-S6; 17.1 versions prior to 17.1R2-S11, 17.1R3-S1; 17.2 versions prior to 17.2R2-S8, 17.2R3-S3; 17.2X75 versions prior to 17.2X75-D44; 17.3 versions prior to 17.3R2-S5, 17.3R3-S6; 17.4 versions prior to 17.4R2-S5, 17.4R3; 18.1 versions prior to 18.1R3-S7; 18.2 versions prior to 18.2R2-S5, 18.2R3; 18.2X75 versions prior to 18.2X75-D33, 18.2X75-D411, 18.2X75-D420, 18.2X75-D60; 18.3 versions prior to 18.3R1-S5, 18.3R2-S3, 18.3R3; 18.4 versions prior to 18.4R2-S2, 18.4R3; 19.1 versions prior to 19.1R1-S3, 19.1R2; 19.2 versions prior to 19.2R1-S3, 19.2R2. This issue does not affect Juniper Networks Junos OS 12.3 and 15.1.",
    "攻击向量": "ADJACENT_NETWORK",
    "厂商补丁链接": [
      "https://kb.juniper.net/JSA11004"
    ],
    "受影响版本": [
      "16.1",
      "17.1",
      "17.2",
      "17.2X75",
      "17.3",
      "17.4",
      "18.1",
      "18.2",
      "18.2X75",
      "18.3",
      "18.4",
      "19.1",
      "19.2"
    ],
    "公开日期": "2020年04月08日"
  },
  {
    "设备品牌": "Gallagher",
    "设备类型": "OTA",
    "产品型号": "Command Centre",
    "CVE编号": "CVE-2020-16098",
    "漏洞描述": "It is possible to enumerate access card credentials via an unauthenticated network connection to the server in versions of Command Centre v8.20 prior to v8.20.1166(MR3), versions of 8.10 prior to v8.10.1211(MR5), versions of 8.00 prior to v8.00.1228(MR6), all versions of 7.90 and earlier. These credentials can then be used to encode low security cards to be used by the system where insecure card technologies are supported.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://security.gallagher.com/Security-Advisories/CVE-2020-16098"
    ],
    "受影响版本": [
      "unspecified",
      "8.20",
      "8.10",
      "8.00"
    ],
    "公开日期": "2020年09月15日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-15598",
    "漏洞描述": "Trustwave ModSecurity 3.x through 3.0.4 allows denial of service via a special request. NOTE: The discoverer reports \"Trustwave has signaled they are disputing our claims.\" The CVE suggests that there is a security issue with how ModSecurity handles regular expressions that can result in a Denial of Service condition. The vendor does not consider this as a security issue because1) there is no default configuration issue here. An attacker would need to know that a rule using a potentially problematic regular expression was in place, 2) the attacker would need to know the basic nature of the regular expression itself to exploit any resource issues. It's well known that regular expression usage can be taxing on system resources regardless of the use case. It is up to the administrator to decide on when it is appropriate to trade resources for potential security benefit",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.modsecurity.org",
      "http://packetstormsecurity.com/files/159185/ModSecurity-3.0.x-Denial-Of-Service.html",
      "http://seclists.org/fulldisclosure/2020/Sep/32",
      "https://www.debian.org/security/2020/dsa-4765",
      "https://coreruleset.org/20200914/cve-2020-15598/"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2020年10月06日"
  },
  {
    "设备品牌": "Sylius",
    "设备类型": "OTA",
    "产品型号": "Sylius",
    "CVE编号": "CVE-2020-15245",
    "漏洞描述": "In Sylius before versions 1.6.9, 1.7.9 and 1.8.3, the user may register in a shop by email mail@example.com, verify it, change it to the mail another@domain.com and stay verified and enabled. This may lead to having accounts addressed to totally different emails, that were verified. Note, that this way one is not able to take over any existing account (guest or normal one). The issue has been patched in Sylius 1.6.9, 1.7.9 and 1.8.3. As a workaround, you may resolve this issue on your own by creating a custom event listener, which will listen to the sylius.customer.pre_update event. You can determine that email has been changed if customer email and user username are different. They are synchronized later on. Pay attention, to email changing behavior for administrators. You may need to skip this logic for them. In order to achieve this, you should either check master request path info, if it does not contain /admin prefix or adjust event triggered during customer update in the shop. You can find more information on how to customize the event here.",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://github.com/Sylius/Sylius/security/advisories/GHSA-6gw4-x63h-5499",
      "https://github.com/Sylius/Sylius/commit/60636d711a4011e8694d10d201b53632c7e8ecaf"
    ],
    "受影响版本": [
      ">= 9.0.0, < 9.4.4"
    ],
    "公开日期": "2020年10月19日"
  },
  {
    "设备品牌": "Oracle Corporation",
    "设备类型": "OTA",
    "产品型号": "Help Technologies",
    "CVE编号": "CVE-2020-14723",
    "漏洞描述": "Vulnerability in the Oracle Help Technologies product of Oracle Fusion Middleware (component: Web UIX). Supported versions that are affected are 11.1.1.9.0 and 12.2.1.3.0. Easily exploitable vulnerability allows unauthenticated attacker with network access via HTTP to compromise Oracle Help Technologies. Successful attacks require human interaction from a person other than the attacker and while the vulnerability is in Oracle Help Technologies, attacks may significantly impact additional products. Successful attacks of this vulnerability can result in unauthorized access to critical data or complete access to all Oracle Help Technologies accessible data as well as unauthorized update, insert or delete access to some of Oracle Help Technologies accessible data. CVSS 3.1 Base Score 8.2 (Confidentiality and Integrity impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:L/A:N).",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.oracle.com/security-alerts/cpujul2020.html",
      "https://cybersecurityworks.com/zerodays/cve-2020-14723-oracle.html"
    ],
    "受影响版本": [
      "11.1.1.9.0",
      "12.2.1.3.0"
    ],
    "公开日期": "2020年07月15日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-11920",
    "漏洞描述": "An issue was discovered in Svakom Siime Eye 14.1.00000001.3.330.0.0.3.14. A command injection vulnerability resides in the HOST/IP section of the NFS settings menu in the webserver running on the device. By injecting Bash commands via shell metacharacters here, the device executes arbitrary code with root privileges (all of the device's services are running as root).",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://www.pentestpartners.com/security-blog/vulnerable-wi-fi-dildo-camera-endoscope-yes-really/",
      "http://seclists.org/fulldisclosure/2024/Jul/14"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2021年02月08日"
  },
  {
    "设备品牌": "n/a",
    "设备类型": "OTA",
    "产品型号": "n/a",
    "CVE编号": "CVE-2020-11710",
    "漏洞描述": "An issue was discovered in docker-kong (for Kong) through 2.0.3. The admin API port may be accessible on interfaces other than 127.0.0.1. NOTE: The vendor argue that this CVE is not a vulnerability because it has an inaccurate bug scope and patch links. “1) Inaccurate Bug Scope - The issue scope was on Kong's docker-compose template, and not Kong's docker image itself. In reality, this issue is not associated with any version of the Kong gateway. As such, the description stating ‘An issue was discovered in docker-kong (for Kong) through 2.0.3.’ is incorrect. This issue only occurs if a user decided to spin up Kong via docker-compose without following the security documentation. The docker-compose template is meant for users to quickly get started with Kong, and is meant for development purposes only. 2) Incorrect Patch Links - The CVE currently points to a documentation improvement as a “Patch” link: https://github.com/Kong/docs.konghq.com/commit/d693827c32144943a2f45abc017c1321b33ff611.This link actually points to an improvement Kong Inc made for fool-proofing. However, instructions for how to protect the admin API were already well-documented here: https://docs.konghq.com/2.0.x/secure-admin-api/#network-layer-access-restrictions , which was first published back in 2017 (as shown in this commit: https://github.com/Kong/docs.konghq.com/commit/e99cf875d875dd84fdb751079ac37882c9972949) Lastly, the hyperlink to https://github.com/Kong/kong (an unrelated Github Repo to this issue) on the Hyperlink list does not include any meaningful information on this topic.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://github.com/Kong/kong",
      "https://github.com/Kong/docs.konghq.com/commit/d693827c32144943a2f45abc017c1321b33ff611",
      "https://github.com/Kong/docker-kong/commit/dfa095cadf7e8309155be51982d8720daf32e31c",
      "https://github.com/Kong/docs.konghq.com/commit/e99cf875d875dd84fdb751079ac37882c9972949"
    ],
    "受影响版本": [
      "n/a"
    ],
    "公开日期": "2020年04月12日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2024-50060",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring: check if we need to reschedule during overflow flush\n\nIn terms of normal application usage, this list will always be empty.\nAnd if an application does overflow a bit, it'll have a few entries.\nHowever, nothing obviously prevents syzbot from running a test case\nthat generates a ton of overflow entries, and then flushing them can\ntake quite a while.\n\nCheck for needing to reschedule while flushing, and drop our locks and\ndo so if necessary. There's no state to maintain here as overflows\nalways prune from head-of-list, hence it's fine to drop and reacquire\nthe locks at the end of the loop.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/a2493904e95ce94bbec819d8f7f03b99976eb25c",
      "https://git.kernel.org/stable/c/f4ce3b5d26ce149e77e6b8e8f2058aa80e5b034e",
      "https://git.kernel.org/stable/c/c2eadeafce2d385b3f6d26a7f31fee5aba2bbbb0",
      "https://git.kernel.org/stable/c/eac2ca2d682f94f46b1973bdf5e77d85d77b8e53"
    ],
    "受影响版本": [
      "2b188cc1bb857a9d4701ae59aa7768b5124e262e",
      "2b188cc1bb857a9d4701ae59aa7768b5124e262e",
      "2b188cc1bb857a9d4701ae59aa7768b5124e262e",
      "2b188cc1bb857a9d4701ae59aa7768b5124e262e"
    ],
    "公开日期": "2024年10月21日"
  },
  {
    "设备品牌": "Utarit Information Technologies",
    "设备类型": "OTA",
    "产品型号": "SoliPay Mobile App",
    "CVE编号": "CVE-2023-6255",
    "漏洞描述": "Use of Hard-coded Credentials vulnerability in Utarit Information Technologies SoliPay Mobile App allows Read Sensitive Strings Within an Executable.This issue affects SoliPay Mobile App: before 5.0.8.\n\n",
    "攻击向量": "NETWORK",
    "厂商补丁链接": [
      "https://www.usom.gov.tr/bildirim/tr-24-0104"
    ],
    "受影响版本": [
      "0"
    ],
    "公开日期": "2024年02月15日"
  },
  {
    "设备品牌": "Linux",
    "设备类型": "OTA",
    "产品型号": "Linux",
    "CVE编号": "CVE-2021-47073",
    "漏洞描述": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/x86: dell-smbios-wmi: Fix oops on rmmod dell_smbios\n\ninit_dell_smbios_wmi() only registers the dell_smbios_wmi_driver on systems\nwhere the Dell WMI interface is supported. While exit_dell_smbios_wmi()\nunregisters it unconditionally, this leads to the following oops:\n\n[  175.722921] ------------[ cut here ]------------\n[  175.722925] Unexpected driver unregister!\n[  175.722939] WARNING: CPU: 1 PID: 3630 at drivers/base/driver.c:194 driver_unregister+0x38/0x40\n...\n[  175.723089] Call Trace:\n[  175.723094]  cleanup_module+0x5/0xedd [dell_smbios]\n...\n[  175.723148] ---[ end trace 064c34e1ad49509d ]---\n\nMake the unregister happen on the same condition the register happens\nto fix this.",
    "攻击向量": "N/A",
    "厂商补丁链接": [
      "https://git.kernel.org/stable/c/75cfc833da4a2111106d4c134e93e0c7f41e35e7",
      "https://git.kernel.org/stable/c/6fa78a6b9a3beb676a010dc489c1257f7e432525",
      "https://git.kernel.org/stable/c/0cf036a0d325200e6c27b90908e51195bbc557b1",
      "https://git.kernel.org/stable/c/8d746ea7c687bab060a2c05a35c449302406cd52",
      "https://git.kernel.org/stable/c/3a53587423d25c87af4b4126a806a0575104b45e"
    ],
    "受影响版本": [
      "1a258e670434f404a4500b65ba1afea2c2b29bba",
      "1a258e670434f404a4500b65ba1afea2c2b29bba",
      "1a258e670434f404a4500b65ba1afea2c2b29bba",
      "1a258e670434f404a4500b65ba1afea2c2b29bba",
      "1a258e670434f404a4500b65ba1afea2c2b29bba"
    ],
    "公开日期": "2024年03月01日"
  }
]